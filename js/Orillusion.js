(function(f,b){typeof exports=="object"&&typeof module<"u"?b(exports):typeof define=="function"&&define.amd?define(["exports"],b):(f=typeof globalThis<"u"?globalThis:f||self,b(f.Orillusion={}))})(this,function(f){var b,Gf=Object.defineProperty,Qf=(i,e,t)=>e in i?Gf(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,n=(i,e,t)=>(Qf(i,typeof e!="symbol"?e+"":e,t),t);let z=(b=class{constructor(i=1,e=1,t=1,r=1){n(this,"r",0),n(this,"g",0),n(this,"b",0),n(this,"a",0),this.setTo(i,e,t,r)}convertToHDRRGB(){return this.r=this.r*Math.pow(2.4,this.a),this.g=this.g*Math.pow(2.4,this.a),this.b=this.b*Math.pow(2.4,this.a),this}unSerialized(i){return this.r=i.r,this.g=i.g,this.b=i.b,this.a=i.a,this}hexToRGB(i){return this.r=(i>>16&255)/255,this.g=(i>>8&255)/255,this.b=(i&255)/255,this}hexToRGBA(i){return this.a=(i>>24&255)/255,this.r=(i>>16&255)/255,this.g=(i>>8&255)/255,this.b=(i&255)/255,this}static random(i=1){let e=new b;return e.a=i,e.r=i*Math.random(),e.g=i*Math.random(),e.b=i*Math.random(),e}setTo(i,e,t,r){this.r=Math.max(i,0),this.g=Math.max(e,0),this.b=Math.max(t,0),this.a=Math.max(r,0)}setHex(i){if(typeof i!="string"||b.NON_HEX_CHARS.test(i)||!b.VALID_HEX_SIZE.test(i))throw new TypeError("Expected a valid hex string");i=i.replace(/^#/,"");let e=1;i.length===8&&(e=Number.parseInt(i.slice(6,8),16)/255,i=i.slice(0,6)),i.length===4&&(e=Number.parseInt(i.slice(3,4).repeat(2),16)/255,i=i.slice(0,3)),i.length===3&&(i=i[0]+i[0]+i[1]+i[1]+i[2]+i[2]);const t=Number.parseInt(i,16),r=t>>16,a=t>>8&255,s=t&255,o=e;this.a=o,this.r=r/255,this.g=a/255,this.b=s/255}getHex(){let i=t=>{t*=255;let r=t.toString(16);return r.length===1&&(r="0"+r),r};return i(this.r)+i(this.g)+i(this.b)+i(this.a)}get rgb(){return[this.r*255>>>0,this.g*255>>>0,this.b*255>>>0]}set rgb(i){this.setTo(i[0]/255,i[1]/255,i[2]/255,this.a)}get rgba(){return[this.r*255>>>0,this.g*255>>>0,this.b*255>>>0,this.a*255>>>0]}set rgba(i){this.setTo(i[0]/255,i[1]/255,i[2]/255,i[3]/255)}clone(){return new b().copyFrom(this)}copyFrom(i){return this.r=i.r,this.g=i.g,this.b=i.b,this.a=i.a,this}copyFromArray(i,e=255){return this.r=i[0]/e,this.g=i[1]/e,this.b=i[2]/e,this.a=i[3]/e,this}copyFromVector(i){return this.r=i.x,this.g=i.y,this.b=i.z,this.a=i.w,this}static hexRGBColor(i,e=null){return e=e||new b,e.hexToRGB(i),e}},n(b,"COLOR_RED",new b(1,0,0,1)),n(b,"COLOR_GREEN",new b(0,1,0,1)),n(b,"COLOR_BLUE",new b(0,0,1,1)),n(b,"COLOR_WHITE",new b(1,1,1,1)),n(b,"COLOR_0",new b),n(b,"COLOR_1",new b),n(b,"COLOR_2",new b),n(b,"HEX_CHARACTERS","a-f\\d"),n(b,"MATCH_3OR4_HEX",`#?[${b.HEX_CHARACTERS}]{3}[${b.HEX_CHARACTERS}]?`),n(b,"MATCH_6OR8_HEX",`#?[${b.HEX_CHARACTERS}]{6}([${b.HEX_CHARACTERS}]{2})?`),n(b,"NON_HEX_CHARS",new RegExp(`[^#${b.HEX_CHARACTERS}]`,"gi")),n(b,"VALID_HEX_SIZE",new RegExp(`^${b.MATCH_3OR4_HEX}$|^${b.MATCH_6OR8_HEX}$`,"i")),n(b,"PRIMARY",4149685),n(b,"PRIMARYDARK",3162015),n(b,"ACCENT",16728193),n(b,"WHITE",16777215),n(b,"IVORY",16777200),n(b,"LIGHTYELLOW",16777184),n(b,"YELLOW",16776960),n(b,"SNOW",16775930),n(b,"FLORALWHITE",16775920),n(b,"LEMONCHIFFON",16775885),n(b,"CORNSILK",16775388),n(b,"SEASHELL",16774638),n(b,"LAVENDERBLUSH",16773365),n(b,"PAPAYAWHIP",16773077),n(b,"BLANCHEDALMOND",16772045),n(b,"MISTYROSE",16770273),n(b,"BISQUE",16770244),n(b,"MOCCASIN",16770229),n(b,"NAVAJOWHITE",16768685),n(b,"PEACHPUFF",16767673),n(b,"GOLD",16766720),n(b,"PINK",16761035),n(b,"LIGHTPINK",16758465),n(b,"ORANGE",16753920),n(b,"LIGHTSALMON",16752762),n(b,"DARKORANGE",16747520),n(b,"CORAL",16744272),n(b,"HOTPINK",16738740),n(b,"TOMATO",16737095),n(b,"ORANGERED",16729344),n(b,"DEEPPINK",16716947),n(b,"FUCHSIA",16711935),n(b,"MAGENTA",16711935),n(b,"RED",16711680),n(b,"OLDLACE",16643558),n(b,"LIGHTGOLDENRODYELLOW",16448210),n(b,"LINEN",16445670),n(b,"ANTIQUEWHITE",16444375),n(b,"SALMON",16416882),n(b,"GHOSTWHITE",16316671),n(b,"MINTCREAM",16121850),n(b,"WHITESMOKE",16119285),n(b,"BEIGE",16119260),n(b,"WHEAT",16113331),n(b,"SANDYBROWN",16032864),n(b,"AZURE",15794175),n(b,"HONEYDEW",15794160),n(b,"ALICEBLUE",15792383),n(b,"KHAKI",15787660),n(b,"LIGHTCORAL",15761536),n(b,"PALEGOLDENROD",15657130),n(b,"VIOLET",15631086),n(b,"DARKSALMON",15308410),n(b,"LAVENDER",15132410),n(b,"LIGHTCYAN",14745599),n(b,"BURLYWOOD",14596231),n(b,"PLUM",14524637),n(b,"GAINSBORO",14474460),n(b,"CRIMSON",14423100),n(b,"PALEVIOLETRED",14381203),n(b,"GOLDENROD",14329120),n(b,"ORCHID",14315734),n(b,"THISTLE",14204888),n(b,"LIGHTGREY",13882323),n(b,"TAN",13808780),n(b,"CHOCOLATE",13789470),n(b,"PERU",13468991),n(b,"INDIANRED",13458524),n(b,"MEDIUMVIOLETRED",13047173),n(b,"SILVER",12632256),n(b,"DARKKHAKI",12433259),n(b,"ROSYBROWN",12357519),n(b,"MEDIUMORCHID",12211667),n(b,"DARKGOLDENROD",12092939),n(b,"FIREBRICK",11674146),n(b,"POWDERBLUE",11591910),n(b,"LIGHTSTEELBLUE",11584734),n(b,"PALETURQUOISE",11529966),n(b,"GREENYELLOW",11403055),n(b,"LIGHTBLUE",11393254),n(b,"DARKGRAY",11119017),n(b,"BROWN",10824234),n(b,"SIENNA",10506797),n(b,"DARKORCHID",10040012),n(b,"PALEGREEN",10025880),n(b,"DARKVIOLET",9699539),n(b,"MEDIUMPURPLE",9662683),n(b,"LIGHTGREEN",9498256),n(b,"DARKSEAGREEN",9419919),n(b,"SADDLEBROWN",9127187),n(b,"DARKMAGENTA",9109643),n(b,"DARKRED",9109504),n(b,"BLUEVIOLET",9055202),n(b,"LIGHTSKYBLUE",8900346),n(b,"SKYBLUE",8900331),n(b,"GRAY",8421504),n(b,"OLIVE",8421376),n(b,"PURPLE",8388736),n(b,"MAROON",8388608),n(b,"AQUAMARINE",8388564),n(b,"CHARTREUSE",8388352),n(b,"LAWNGREEN",8190976),n(b,"MEDIUMSLATEBLUE",8087790),n(b,"LIGHTSLATEGRAY",7833753),n(b,"SLATEGRAY",7372944),n(b,"OLIVEDRAB",7048739),n(b,"SLATEBLUE",6970061),n(b,"DIMGRAY",6908265),n(b,"MEDIUMAQUAMARINE",6737322),n(b,"CORNFLOWERBLUE",6591981),n(b,"CADETBLUE",6266528),n(b,"DARKOLIVEGREEN",5597999),n(b,"INDIGO",4915330),n(b,"MEDIUMTURQUOISE",4772300),n(b,"DARKSLATEBLUE",4734347),n(b,"STEELBLUE",4620980),n(b,"ROYALBLUE",4286945),n(b,"TURQUOISE",4251856),n(b,"MEDIUMSEAGREEN",3978097),n(b,"LIMEGREEN",3329330),n(b,"DARKSLATEGRAY",3100495),n(b,"SEAGREEN",3050327),n(b,"FORESTGREEN",2263842),n(b,"LIGHTSEAGREEN",2142890),n(b,"DODGERBLUE",2003199),n(b,"MIDNIGHTBLUE",1644912),n(b,"AQUA",65535),n(b,"CYAN",65535),n(b,"SPRINGGREEN",65407),n(b,"LIME",65280),n(b,"MEDIUMSPRINGGREEN",64154),n(b,"DARKTURQUOISE",52945),n(b,"DEEPSKYBLUE",49151),n(b,"DARKCYAN",35723),n(b,"TEAL",32896),n(b,"GREEN",32768),n(b,"DARKGREEN",25600),n(b,"BLUE",255),n(b,"MEDIUMBLUE",205),n(b,"DARKBLUE",139),n(b,"NAVY",128),n(b,"BLACK",0),b);class he{static start(e){this._startTime=performance.now(),this._timeLabel=e}static end(){console.log(this._timeLabel,performance.now()-this._startTime)}}n(he,"time",0),n(he,"frame",0),n(he,"delta",0),n(he,"_startTime",0),n(he,"_timeLabel","");class je{constructor(e=null,t=null){n(this,"target"),n(this,"currentTarget"),n(this,"type"),n(this,"data"),n(this,"param"),n(this,"time",0),n(this,"delay",0),n(this,"mouseCode",0),n(this,"ctrlKey"),n(this,"altKey"),n(this,"shiftKey"),n(this,"targetTouches"),n(this,"changedTouches"),n(this,"touches"),n(this,"_stopImmediatePropagation",!1),n(this,"view"),this.type=e,this.data=t}stopImmediatePropagation(){this._stopImmediatePropagation=!0}reset(){this._stopImmediatePropagation=!1}get isStopImmediatePropagation(){return this._stopImmediatePropagation}}class Sr{constructor(e=null,t=null,r=null,a=null,s=0){n(this,"id",0),n(this,"current"),this.type=e,this.thisObject=t,this.handler=r,this.param=a,this.priority=s}equalCurrentListener(e,t,r,a){return this.type==e&&this.thisObject==r&&this.handler==t&&this.param==a}dispose(){this.handler=null,this.thisObject=null,this.param=null,this.priority=0}}n(Sr,"event_id_count",0);class hi{constructor(){n(this,"listeners",{}),n(this,"data")}dispatchEvent(e){var t=this.listeners[e.type];if(t!=null){t=t.slice();for(var r=0;r<t.length;r++){var a=t[r];if(a.handler){try{e.param=a.param,e.currentTarget=a,a.thisObject,a.handler.call(a.thisObject,e)}catch{}if(e.isStopImmediatePropagation)break}}}}destroy(){for(var e in this.listeners)for(var t=this.listeners[e];t.length>0;){var r=t[0];r.handler=null,r.thisObject=null,t.splice(0,1)}}addEventListener(e,t,r,a=null,s=0){if(this.listeners[e]==null&&(this.listeners[e]=[]),!this.hasEventListener(e,t,r)){var o=new Sr(e,r,t,a,s);return o.id=++Sr.event_id_count,o.current=this,this.listeners[e].push(o),this.listeners[e].sort(function(l,h){return h.priority-l.priority}),o.id}for(let l=0;l<this.listeners[e].length;l++){let h=this.listeners[e][l];if(h.equalCurrentListener(e,t,r,a))return h.id}return 0}removeEventListener(e,t,r){if(this.hasEventListener(e,t,r))for(var a=0;a<this.listeners[e].length;a++){var s=this.listeners[e][a];if(s.equalCurrentListener(e,t,r,s.param)){s.handler=null,s.thisObject=null,this.listeners[e].splice(a,1);return}}}removeEventListenerAt(e){for(var t in this.listeners)for(var r=0;r<this.listeners[t].length;r++){var a=this.listeners[t][r];if(a.id==e)return a.handler=null,a.thisObject=null,this.listeners[t].splice(r,1),!0}return!1}removeAllEventListener(e=null){let t;if(e){if(this.listeners[e]){for(var r=0;r<this.listeners[e].length;r++)t=this.listeners[e][r],t.dispose(),this.listeners[e].splice(r,1);delete this.listeners[e]}}else for(let a in this.listeners){for(var r=0;r<this.listeners[a].length;r++)t=this.listeners[a][r],t.dispose(),this.listeners[a].splice(r,1);delete this.listeners[a]}}containEventListener(e){return this.listeners[e]==null?!1:this.listeners[e].length>0}hasEventListener(e,t=null,r=null){if(this.listeners[e]==null)return!1;if(r&&t)for(var a=0;a<this.listeners[e].length;a++){var s=this.listeners[e][a];if(s.equalCurrentListener(e,t,r,s.param))return!0}return!1}}class Qt extends je{constructor(){super(...arguments),n(this,"keyCode",0)}}n(Qt,"KEY_DOWN","onKeyDown"),n(Qt,"KEY_UP","onKeyUp");class L extends je{constructor(){super(...arguments),n(this,"pointerId"),n(this,"pointerType"),n(this,"isPrimary"),n(this,"pressure"),n(this,"mouseX"),n(this,"mouseY"),n(this,"movementX"),n(this,"movementY"),n(this,"deltaX"),n(this,"deltaY"),n(this,"deltaZ")}reset(){super.reset(),this.mouseX=0,this.mouseY=0,this.movementX=0,this.movementY=0,this.deltaX=0,this.deltaY=0,this.deltaZ=0}}n(L,"PICK_OVER","onPickOver"),n(L,"PICK_OVER_GUI","onPickOverGUI"),n(L,"PICK_CLICK","onPickClick"),n(L,"PICK_CLICK_GUI","onPickClickGUI"),n(L,"PICK_OUT","onPickOut"),n(L,"PICK_OUT_GUI","onPickOutGUI"),n(L,"PICK_MOVE","onPickMove"),n(L,"PICK_UP","onPickUp"),n(L,"PICK_UP_GUI","onPickUpGUI"),n(L,"PICK_DOWN","onPickDown"),n(L,"PICK_DOWN_GUI","onPickDownGUI"),n(L,"POINTER_RIGHT_CLICK","onPointerRightClick"),n(L,"POINTER_MID_UP","onPointerMidUp"),n(L,"POINTER_MID_DOWN","onPointerMidDown"),n(L,"POINTER_CLICK","onPointerClick"),n(L,"POINTER_MOVE","onPointerMove"),n(L,"POINTER_DOWN","onPointerDown"),n(L,"POINTER_UP","onPointerUp"),n(L,"POINTER_OUT","onPointerOut"),n(L,"POINTER_OVER","onPointerOver"),n(L,"POINTER_WHEEL","onPointerWheel");const W=class{constructor(i=0,e=0,t=0,r=0){n(this,"x",0),n(this,"y",0),n(this,"z",0),n(this,"w",1),n(this,"index",0),this.set(i,e,t,r),this.index=W._index++}static get ZERO(){return new W(0,0,0)}static get ONE(){return new W(1,1,1)}static get LEFT(){return new W(-1,0,0)}static get RIGHT(){return new W(1,0,0)}static get UP(){return new W(0,1,0)}static get DOWN(){return new W(0,-1,0)}static get BACK(){return new W(0,0,-1)}static get FORWARD(){return new W(0,0,1)}set a(i){this.w=i}set r(i){this.x=i}set g(i){this.y=i}set b(i){this.z=i}get a(){return this.w}get r(){return this.x}get g(){return this.y}get b(){return this.z}get length(){return Math.sqrt(this.lengthSquared)}get lengthSquared(){return this.x*this.x+this.y*this.y+this.z*this.z}get position(){return this}static getTowPointbyDir(i,e,t,r,a){a==W.Z_AXIS?(e.x=i.y,e.y=-i.x,t.x=-i.y,t.y=i.x,e.scaleBy(r*.5),t.scaleBy(r*.5)):a==W.Y_AXIS&&(e.x=i.z,e.z=-i.x,t.x=-i.z,t.z=i.x,e.scaleBy(r*.5),t.scaleBy(r*.5))}static pointToLine(i,e,t){let r=0,a,s,o;if(a=W.distance(i,e),s=W.distance(i,t),o=W.distance(e,t),o<=1e-6||s<=1e-6)return r=0,r;if(a<=1e-6||o*o>=a*a+s*s)return r=s,r;if(s*s>=a*a+o*o)return r=o,r;let l=(a+s+o)/2;return r=2*Math.sqrt(l*(l-a)*(l-s)*(l-o))/a,r}static dot(i,e){return i.x*e.x+i.y*e.y+i.z*e.z}static getPoints(i,e){let t=[];for(let r=0;r<i;r++){const a=new W(Math.random()*e-e*.5,Math.random()*e-e*.5,Math.random()*e-e*.5);t.push(a)}return t}static getPointNumbers(i,e){let t=[];for(let r=0;r<i;r++)t.push(Math.random()*e-e*.5,Math.random()*e-e*.5,Math.random()*e-e*.5);return t}static getAngle(i,e){let t=i.dotProduct(e)/(i.length*e.length);return Math.acos(t)*180/Math.PI}static sqrMagnitude(i){return i.x*i.x+i.y*i.y+i.z*i.z}static getZYAngle(i,e){return this.calAngle(i.y,i.z,e.y,e.z)}static sub(i,e,t=null){return t=t||new W,t.x=i.x-e.x,t.y=i.y-e.y,t.z=i.z-e.z,t}static add(i,e,t=null){return t=t||new W,t.x=i.x+e.x,t.y=i.y+e.y,t.z=i.z+e.z,t}static smoothDamp(i,e,t,r,a,s){return null}static distance(i,e){var t=i.x-e.x,r=i.y-e.y,a=i.z-e.z;return Math.sqrt(t*t+r*r+a*a)}static squareDistance(i,e){var t=i.x-e.x,r=i.y-e.y,a=i.z-e.z;return t*t+r*r+a*a}static distanceXZ(i,e){var t=i.x-e.x,r=0,a=i.z-e.z;return Math.sqrt(t*t+r*r+a*a)}set(i,e,t,r=1){return this.x=i,this.y=e,this.z=t,this.w=r,this}add(i,e=null){e||(e=new W);var t=this.x,r=this.y,a=this.z,s=this.w,o=i.x,l=i.y,h=i.z,u=i.w;return e.setTo(t+o,r+l,a+h,s+u),e}subVectors(i,e){return this.x=i.x-e.x,this.y=i.y-e.y,this.z=i.z-e.z,this}distanceToSquared(i){let e=this.x-i.x,t=this.y-i.y,r=this.z-i.z;return e*e+t*t+r*r}addXYZW(i,e,t,r,a=null){a||(a=new W);var s=this.x,o=this.y,l=this.z,h=this.w,u=i,c=e,d=t,g=r;return a.setTo(s+u,o+c,l+d,h+g),a}clone(){return new W(this.x,this.y,this.z,this.w)}copyFrom(i){var e=this;return e.x=i.x,e.y=i.y,e.z=i.z,e.w=i.w,e}decrementBy(i){this.x-=i.x,this.y-=i.y,this.z-=i.z}dotProduct(i){return this.x*i.x+this.y*i.y+this.z*i.z}equals(i,e=!1){return this.x==i.x&&this.y==i.y&&this.z==i.z&&(!e||this.w==i.w)}incrementBy(i){this.x+=i.x,this.y+=i.y,this.z+=i.z}divide(i){return i instanceof W?new W(this.x/i.x,this.y/i.y,this.z/i.z):(this.x=this.x/i,this.y=this.y/i,this.z=this.z/i,this)}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}normalize(i=1){let e=this;if(this.length!=0){var t=i/this.length;return this.x*=t,this.y*=t,this.z*=t,e}return e}applyQuaternion(i){const e=this.x,t=this.y,r=this.z,a=i.x,s=i.y,o=i.z,l=i.w,h=l*e+s*r-o*t,u=l*t+o*e-a*r,c=l*r+a*t-s*e,d=-a*e-s*t-o*r;return this.x=h*l+d*-a+u*-o-c*-s,this.y=u*l+d*-s+c*-a-h*-o,this.z=c*l+d*-o+h*-s-u*-a,this}scaleBy(i){return this.x*=i,this.y*=i,this.z*=i,this}mul(i){let e=new W;return e.x=this.x*i,e.y=this.y*i,e.z=this.z*i,e}scale(i){return this.x*=i.x,this.y*=i.y,this.z*=i.z,this}scaleToRef(i,e){return e||(e=new W),e.x=this.x*i,e.y=this.y*i,e.z=this.z*i,e}setTo(i,e,t,r=1){this.x=i,this.y=e,this.z=t,this.w=r}copy(i){return this.x=i.x,this.y=i.y,this.z=i.z,this.w=i.w,this}subtract(i,e=null){return e||(e=new W),e.setTo(this.x-i.x,this.y-i.y,this.z-i.z),e}multiply(i,e=null){e||(e=new W);var t=this.x,r=this.y,a=this.z,s=i.x,o=i.y,l=i.z;return e.setTo(t*s,r*o,a*l),e}divided(i,e=null){e||(e=new W);var t=this.x,r=this.y,a=this.z,s=i.x,o=i.y,l=i.z;return e.setTo(t/s,r/o,a/l),e}div(i,e){e||(e=new W);var t=this.x,r=this.y,a=this.z,s=this.w;return e.setTo(t/i,r/i,a/i,s/i),e}lerp(i,e,t){var r=i.x,a=i.y,s=i.z,o=i.w,l=e.x,h=e.y,u=e.z,c=e.w;this.x=(l-r)*t+r,this.y=(h-a)*t+a,this.z=(u-s)*t+s,this.w=(c-o)*t+o}clamp(i,e){return this.x=Math.max(i.x,Math.min(e.x,this.x)),this.y=Math.max(i.y,Math.min(e.y,this.y)),this.z=Math.max(i.z,Math.min(e.z,this.z)),this}toString(){return"<"+this.x+", "+this.y+", "+this.z+">"}normalizeToWay2D_XY(){let i=Math.abs(this.x),e=Math.abs(this.y);i>e?this.x>0?this.copyFrom(W.RIGHT):this.copyFrom(W.LEFT):this.y>0?this.copyFrom(W.DOWN):this.copyFrom(W.UP)}toArray(){return[this.x,this.y,this.z]}copyToBytes(i){i.setFloat32(0*Float32Array.BYTES_PER_ELEMENT,this.x,!0),i.setFloat32(1*Float32Array.BYTES_PER_ELEMENT,this.y,!0),i.setFloat32(2*Float32Array.BYTES_PER_ELEMENT,this.z,!0)}crossProduct(i,e=null){return e=e||new W,e.x=this.y*i.z-this.z*i.y,e.y=this.z*i.x-this.x*i.z,e.z=this.x*i.y-this.y*i.x,e.w=1,e}crossVectors(i,e){return i.crossProduct(e,this),this}multiplyScalar(i){return this.x*=i,this.y*=i,this.z*=i,this}setFromArray(i,e=0){this.x=i[e],this.y=i[e+1],this.z=i[e+2]}divideScalar(i){return this.multiplyScalar(1/i)}clampLength(i,e){let t=this.length;return this.divideScalar(t||1).multiplyScalar(Math.max(i,Math.min(e,t)))}setScalar(i){return this.x=i,this.y=i,this.z=i,this}static calAngle(i,e,t,r){const a=o(t,r,i,e);let s=Math.acos(a)*180/Math.PI;return t<i&&(s=-s),s;function o(h,u,c,d){let g=[h-c,u-d];return l(g,[0,-1])}function l(h,u){let c=h[0]*u[0]+h[1]*u[1],d=Math.sqrt(h[0]*h[0]+h[1]*h[1])*Math.sqrt(u[0]*u[0]+u[1]*u[1]);return c/d}}};let p=W;n(p,"MAX",new W(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE)),n(p,"MIN",new W(Number.MIN_VALUE,Number.MIN_VALUE,Number.MIN_VALUE)),n(p,"SAFE_MAX",new W(Number.MAX_SAFE_INTEGER,Number.MAX_SAFE_INTEGER,Number.MAX_SAFE_INTEGER,Number.MAX_SAFE_INTEGER)),n(p,"SAFE_MIN",new W(Number.MIN_SAFE_INTEGER,Number.MIN_SAFE_INTEGER,Number.MIN_SAFE_INTEGER,Number.MIN_SAFE_INTEGER)),n(p,"X_AXIS",new W(1,0,0)),n(p,"neg_X_AXIS",new W(-1,0,0)),n(p,"Y_AXIS",new W(0,1,0)),n(p,"Z_AXIS",new W(0,0,1)),n(p,"HELP_0",new W),n(p,"HELP_1",new W),n(p,"HELP_2",new W),n(p,"EPSILON",1e-5),n(p,"HELP_3",new W),n(p,"HELP_4",new W),n(p,"HELP_5",new W),n(p,"HELP_6",new W),n(p,"_index",0);class So{constructor(e){n(this,"canvasX"),n(this,"canvasY"),n(this,"identifier"),n(this,"clientX"),n(this,"clientY"),n(this,"pageX"),n(this,"pageY"),n(this,"screenX"),n(this,"screenY"),this.canvasX=e.clientX,this.canvasY=e.clientY,this.identifier=e.identifier,this.clientX=e.clientX,this.clientY=e.clientY,this.pageX=e.pageX,this.pageY=e.pageY,this.screenX=e.screenX,this.screenY=e.screenY}}class Io extends hi{constructor(){super(...arguments),n(this,"canvasX",0),n(this,"canvasY",0),n(this,"isMouseDown",!1),n(this,"isRightMouseDown",!1),n(this,"canvas"),n(this,"mouseX",0),n(this,"mouseY",0),n(this,"wheelDelta",0),n(this,"mouseOffsetX",0),n(this,"mouseOffsetY",0),n(this,"mouseLastX",0),n(this,"mouseLastY",0),n(this,"_time",0),n(this,"_keyStatus"),n(this,"_mouseStatus"),n(this,"_isTouchStart"),n(this,"_keyEvent3d"),n(this,"_pointerEvent3D"),n(this,"_windowsEvent3d"),n(this,"_gp",!1),n(this,"_oldPosition1",null),n(this,"_oldPosition2",null),n(this,"_downTime",0)}initCanvas(e){this.canvas=e,e.onpointerdown=r=>{r.button==0?this.mouseStart(r):r.button==1?this.middleDown(r):r.button==2&&this.mouseStart(r)},e.onpointerup=r=>{r.button==0?this.mouseEnd(r):r.button==1?this.middleUp(r):r.button==2&&this.mouseEnd(r)},e.onpointerenter=r=>{this.mouseOver(r)},e.onpointermove=r=>{this.mouseMove(r)},e.onpointercancel=r=>{this.mouseEnd(r)},e.onpointerleave=r=>{this.mouseEnd(r)},e.onpointerout=r=>{this.mouseEnd(r)},e.addEventListener("click",r=>{r.button==2?(this.isRightMouseDown=!1,this.rightClick(r)):r.button==0&&(this.isMouseDown=!1,this.mouseClick(r))},!0),e.addEventListener("wheel",r=>this.mouseWheel(r),{passive:!1}),window.addEventListener("keydown",r=>this.keyDown(r),!0),window.addEventListener("keyup",r=>this.keyUp(r),!0),e.oncontextmenu=function(){return!1};let t=this.canvas.getBoundingClientRect();this.canvasX=t.left,this.canvasY=t.top,this._keyStatus={},this._mouseStatus={},this._isTouchStart=!1,this._keyEvent3d=new Qt,this._pointerEvent3D=new L,this._windowsEvent3d=new je}onPinch(e,t,r,a){this._oldPosition1=new p(e,t),this._oldPosition2=new p(r,a)}onSwipe(e,t){this.mouseX=e,this.mouseY=t,this._oldPosition1=null,this._oldPosition2=null,this._time=new Date().getTime()}GetTargetTouches(e){for(var t=new Array,r=0;r<e.length;r++){var a=new So(e[r]);t.push(a)}return t}rightClick(e){this._pointerEvent3D.reset(),this._pointerEvent3D.mouseCode=e.button,this._pointerEvent3D.mouseX=e.clientX-this.canvasX,this._pointerEvent3D.mouseY=e.clientY-this.canvasY,this._pointerEvent3D.type=L.POINTER_RIGHT_CLICK,this._pointerEvent3D.ctrlKey=e.ctrlKey,this._pointerEvent3D.altKey=e.altKey,this._pointerEvent3D.shiftKey=e.shiftKey,this.dispatchEvent(this._pointerEvent3D)}middleDown(e){this._pointerEvent3D.reset(),this._pointerEvent3D.mouseCode=e.button,this._pointerEvent3D.mouseX=e.clientX-this.canvasX,this._pointerEvent3D.mouseY=e.clientY-this.canvasY,this._pointerEvent3D.type=L.POINTER_MID_DOWN,this._pointerEvent3D.ctrlKey=e.ctrlKey,this._pointerEvent3D.altKey=e.altKey,this._pointerEvent3D.shiftKey=e.shiftKey,this._pointerEvent3D.pointerId=e.pointerId,this._pointerEvent3D.pointerType=e.pointerType,this._pointerEvent3D.isPrimary=e.isPrimary,this._pointerEvent3D.pressure=e.pressure,this.dispatchEvent(this._pointerEvent3D)}middleUp(e){this._pointerEvent3D.reset(),this._pointerEvent3D.mouseCode=e.button,this._pointerEvent3D.mouseX=e.clientX-this.canvasX,this._pointerEvent3D.mouseY=e.clientY-this.canvasY,this._pointerEvent3D.type=L.POINTER_MID_UP,this._pointerEvent3D.ctrlKey=e.ctrlKey,this._pointerEvent3D.altKey=e.altKey,this._pointerEvent3D.shiftKey=e.shiftKey,this._pointerEvent3D.pointerId=e.pointerId,this._pointerEvent3D.pointerType=e.pointerType,this._pointerEvent3D.isPrimary=e.isPrimary,this._pointerEvent3D.pressure=e.pressure,this.dispatchEvent(this._pointerEvent3D)}mouseClick(e){this._pointerEvent3D.reset(),this._pointerEvent3D.mouseCode=e.button,this._pointerEvent3D.mouseX=e.clientX-this.canvasX,this._pointerEvent3D.mouseY=e.clientY-this.canvasY,this._pointerEvent3D.type=L.POINTER_CLICK,this._pointerEvent3D.ctrlKey=e.ctrlKey,this._pointerEvent3D.altKey=e.altKey,this._pointerEvent3D.shiftKey=e.shiftKey,this.dispatchEvent(this._pointerEvent3D)}mouseEnd(e){this.isMouseDown=!1,this.mouseLastX=this.mouseX,this.mouseLastY=this.mouseY,this.mouseX=e.clientX-this.canvasX,this.mouseY=e.clientY-this.canvasY,this.mouseOffsetX=this.mouseX-this.mouseLastX,this.mouseOffsetY=this.mouseY-this.mouseLastY,this._pointerEvent3D.reset(),this._pointerEvent3D.mouseCode=e.button,this._mouseStatus[this._pointerEvent3D.mouseCode]=!1,this._pointerEvent3D.type=L.POINTER_UP,this._pointerEvent3D.ctrlKey=e.ctrlKey,this._pointerEvent3D.altKey=e.altKey,this._pointerEvent3D.shiftKey=e.shiftKey,this._pointerEvent3D.pointerId=e.pointerId,this._pointerEvent3D.pointerType=e.pointerType,this._pointerEvent3D.isPrimary=e.isPrimary,this._pointerEvent3D.pressure=e.pressure,this._pointerEvent3D.mouseX=this.mouseX,this._pointerEvent3D.mouseY=this.mouseY,this.dispatchEvent(this._pointerEvent3D)}mouseStart(e){this.isMouseDown=!0,this.mouseLastX=this.mouseX,this.mouseLastY=this.mouseY,this.mouseX=e.clientX-this.canvasX,this.mouseY=e.clientY-this.canvasY,this.mouseOffsetX=this.mouseX-this.mouseLastX,this.mouseOffsetY=this.mouseY-this.mouseLastY,this._pointerEvent3D.reset(),this._pointerEvent3D.mouseCode=e.button,this._pointerEvent3D.ctrlKey=e.ctrlKey,this._pointerEvent3D.altKey=e.altKey,this._pointerEvent3D.shiftKey=e.shiftKey,this._pointerEvent3D.pointerId=e.pointerId,this._pointerEvent3D.pointerType=e.pointerType,this._pointerEvent3D.isPrimary=e.isPrimary,this._pointerEvent3D.pressure=e.pressure,this._pointerEvent3D.mouseX=this.mouseX,this._pointerEvent3D.mouseY=this.mouseY,this._pointerEvent3D.type=L.POINTER_DOWN,this.dispatchEvent(this._pointerEvent3D)}mouseMove(e){this.mouseLastX=this.mouseX,this.mouseLastY=this.mouseY,this.mouseX=e.clientX-this.canvasX,this.mouseY=e.clientY-this.canvasY,this.mouseOffsetX=this.mouseX-this.mouseLastX,this.mouseOffsetY=this.mouseY-this.mouseLastY,this._pointerEvent3D.reset(),this._pointerEvent3D.type=L.POINTER_MOVE,this._pointerEvent3D.ctrlKey=e.ctrlKey,this._pointerEvent3D.altKey=e.altKey,this._pointerEvent3D.shiftKey=e.shiftKey,this._pointerEvent3D.pointerId=e.pointerId,this._pointerEvent3D.pointerType=e.pointerType,this._pointerEvent3D.isPrimary=e.isPrimary,this._pointerEvent3D.pressure=e.pressure,this._pointerEvent3D.mouseX=this.mouseX,this._pointerEvent3D.mouseY=this.mouseY,this._pointerEvent3D.movementX=e.movementX,this._pointerEvent3D.movementY=e.movementY,this.dispatchEvent(this._pointerEvent3D)}mouseOver(e){this.isMouseDown=!1,this.mouseLastX=this.mouseX,this.mouseLastY=this.mouseY,this.mouseX=e.clientX-this.canvasX,this.mouseY=e.clientY-this.canvasY,this.mouseOffsetX=this.mouseX-this.mouseLastX,this.mouseOffsetY=this.mouseY-this.mouseLastY,this._pointerEvent3D.reset(),this._pointerEvent3D.type=L.POINTER_OVER,this._pointerEvent3D.ctrlKey=e.ctrlKey,this._pointerEvent3D.altKey=e.altKey,this._pointerEvent3D.shiftKey=e.shiftKey,this._pointerEvent3D.pointerId=e.pointerId,this._pointerEvent3D.pointerType=e.pointerType,this._pointerEvent3D.isPrimary=e.isPrimary,this._pointerEvent3D.pressure=e.pressure,this._pointerEvent3D.mouseX=this.mouseX,this._pointerEvent3D.mouseY=this.mouseY,this.dispatchEvent(this._pointerEvent3D)}mouseWheel(e){e.preventDefault(),this.mouseLastX=this.mouseX,this.mouseLastY=this.mouseY,this.mouseX=e.clientX-this.canvasX,this.mouseY=e.clientY-this.canvasY,this.mouseOffsetX=this.mouseX-this.mouseLastX,this.mouseOffsetY=this.mouseY-this.mouseLastY,"wheelDelta"in e?(this._pointerEvent3D.delay=e.wheelDelta,this.wheelDelta=e.wheelDelta):"delta"in e&&(this.wheelDelta=e.delta),this._pointerEvent3D.reset(),this._pointerEvent3D.type=L.POINTER_WHEEL,this._pointerEvent3D.ctrlKey=e.ctrlKey,this._pointerEvent3D.altKey=e.altKey,this._pointerEvent3D.shiftKey=e.shiftKey,this._pointerEvent3D.mouseX=this.mouseX,this._pointerEvent3D.mouseY=this.mouseY,this._pointerEvent3D.deltaX=e.deltaX,this._pointerEvent3D.deltaY=e.deltaY,this._pointerEvent3D.deltaZ=e.deltaZ,this.dispatchEvent(this._pointerEvent3D)}keyDown(e){this._keyEvent3d.reset(),this._keyEvent3d.keyCode=e.keyCode,this._keyEvent3d.ctrlKey=e.ctrlKey,this._keyEvent3d.altKey=e.altKey,this._keyEvent3d.shiftKey=e.shiftKey,this._keyStatus[e.keyCode]||(this._keyStatus[e.keyCode]=!0,this._keyEvent3d.type=Qt.KEY_DOWN,this.dispatchEvent(this._keyEvent3d))}keyUp(e){this._keyEvent3d.reset(),this._keyEvent3d.keyCode=e.keyCode,this._keyStatus[e.keyCode]=!1,this._keyEvent3d.type=Qt.KEY_UP,this.dispatchEvent(this._keyEvent3d)}GetSlideAngle(e,t){return Math.atan2(t,e)*180/Math.PI}GetSlideDirection(e,t,r,a){var s=t-a,o=r-e,l=0;if(Math.abs(o)<2&&Math.abs(s)<2)return l;var h=this.GetSlideAngle(o,s);return h>=-45&&h<45?l=4:h>=45&&h<135?l=1:h>=-135&&h<-45?l=2:(h>=135&&h<=180||h>=-180&&h<-135)&&(l=3),l}}const Vf="0.6.9";class Hf{constructor(){n(this,"adapter"),n(this,"device"),n(this,"context"),n(this,"aspect"),n(this,"presentationSize",[0,0]),n(this,"presentationFormat"),n(this,"canvas"),n(this,"windowWidth"),n(this,"windowHeight"),n(this,"canvasConfig"),n(this,"super",1),n(this,"_pixelRatio",1)}get pixelRatio(){return this._pixelRatio}async init(e){var t;if(this.canvasConfig=e,e&&e.canvas){if(this.canvas=e.canvas,this.canvas===null)throw new Error("no Canvas");const s=this.canvas.clientWidth,o=this.canvas.clientHeight;this.resize(this.canvas.clientWidth,this.canvas.clientHeight),s!=this.canvas.clientWidth&&(this.canvas.style.width=s+"px"),o!=this.canvas.clientHeight&&(this.canvas.style.height=o+"px")}else this.canvas=document.createElement("canvas"),this.canvas.style.position="absolute",this.canvas.style.top="0px",this.canvas.style.left="0px",this.canvas.style.width="100%",this.canvas.style.height="100%",this.canvas.style.zIndex=e?.zIndex?e.zIndex.toString():"0",document.body.appendChild(this.canvas);if(e&&e.backgroundImage?(this.canvas.style.background=`url(${e.backgroundImage})`,this.canvas.style["background-size"]="cover",this.canvas.style["background-position"]="center"):this.canvas.style.background="transparent",this.canvas.style["touch-action"]="none",this.canvas.style["object-fit"]="cover",navigator.gpu===void 0)throw new Error("Your browser does not support WebGPU!");if(this.adapter=await navigator.gpu.requestAdapter({powerPreference:"high-performance"}),this.adapter==null)throw new Error("Your browser does not support WebGPU!");if(this.device=await this.adapter.requestDevice({requiredFeatures:["bgra8unorm-storage","depth-clip-control","depth32float-stencil8","indirect-first-instance","rg11b10ufloat-renderable"],requiredLimits:{minUniformBufferOffsetAlignment:256,maxStorageBufferBindingSize:this.adapter.limits.maxStorageBufferBindingSize}}),this.device==null)throw new Error("Your browser does not support WebGPU!");this._pixelRatio=((t=this.canvasConfig)==null?void 0:t.devicePixelRatio)||window.devicePixelRatio||1,this._pixelRatio=Math.min(this._pixelRatio,2),this.device.label="device",this.presentationFormat=navigator.gpu.getPreferredCanvasFormat(),this.context=this.canvas.getContext("webgpu"),this.context.configure({device:this.device,format:this.presentationFormat,usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT,alphaMode:"premultiplied",colorSpace:"display-p3"}),this.resize(this.canvas.clientWidth,this.canvas.clientHeight);let r;return new ResizeObserver(()=>{clearTimeout(r),r=setTimeout(()=>{this.resize(this.canvas.clientWidth,this.canvas.clientHeight)},50)}).observe(this.canvas),!0}resize(e,t){this.canvas.width=this.windowWidth=Math.floor(e*this.pixelRatio*this.super),this.canvas.height=this.windowHeight=Math.floor(t*this.pixelRatio*this.super),this.presentationSize[0]=this.windowWidth,this.presentationSize[1]=this.windowHeight,this.aspect=this.windowWidth/this.windowHeight}}let I=new Hf;class Ci{}n(Ci,"Bloom_Brightness_frag_wgsl",`
    struct uniformData {
        luminosityThreshold: f32
    };

    struct FragmentOutput {
        @location(0) o_Target: vec4<f32>
    };

    var<private> fragUV1: vec2<f32>;
    var<private> o_Target: vec4<f32>;
    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_2d<f32>;
    @group(2) @binding(0)
    var<uniform> global: uniformData;

    fn Brightness(c: vec3<f32>) -> f32 {
        var c1: vec3<f32>;

        c1 = c;
        let e8: vec3<f32> = c1;
        let e10: vec3<f32> = c1;
        let e12: vec3<f32> = c1;
        let e14: vec3<f32> = c1;
        let e17: vec3<f32> = c1;
        let e19: vec3<f32> = c1;
        let e21: vec3<f32> = c1;
        let e23: vec3<f32> = c1;
        let e25: vec3<f32> = c1;
        let e28: vec3<f32> = c1;
        return max(max(e23.x, e25.y), e28.z);
    }

    fn main1() {
        var uv: vec2<f32>;
        var LinearColor: vec4<f32>;
        var TotalLuminance: f32;
        var BloomLuminance: f32;
        var BloomAmount: f32;

        let e6: vec2<f32> = fragUV1;
        uv = e6.xy;
        let e11: vec2<f32> = uv;
        uv.y = (1.0 - e11.y);
        let e15: vec2<f32> = uv;
        let e16: vec4<f32> = textureSample(baseMap, baseMapSampler, e15);
        LinearColor = e16;
        let e18: vec4<f32> = LinearColor;
        let e27: vec4<f32> = LinearColor;
        let e36: vec4<f32> = LinearColor;
        let e38: vec3<f32> = min(vec3<f32>(f32(65000), f32(65000), f32(65000)), e36.xyz);
        LinearColor.x = e38.x;
        LinearColor.y = e38.y;
        LinearColor.z = e38.z;
        let e45: vec4<f32> = LinearColor;
        let e47: vec4<f32> = LinearColor;
        let e49: f32 = Brightness(e47.xyz);
        TotalLuminance = e49;
        let e51: f32 = TotalLuminance;
        let e52: f32 = global.luminosityThreshold;
        BloomLuminance = (e51 - e52);
        let e55: f32 = BloomLuminance;
        let e60: f32 = BloomLuminance;
        BloomAmount = clamp((e60 * 0.5), 0.0, 1.0);
        let e67: f32 = BloomAmount;
        let e68: vec4<f32> = LinearColor;
        o_Target = vec4<f32>((e67 * e68.xyz), f32(0));
        return;
    }

    @fragment
    fn main(@location(0) fragUV: vec2<f32>) -> FragmentOutput {
        fragUV1 = fragUV;
        main1();
        let e13: vec4<f32> = o_Target;
        return FragmentOutput(e13);
    }
    `),n(Ci,"Bloom_blur_frag_wgsl",`
      struct uniformData {
          texSize: vec2<f32>,
          hScale: f32,
          vScale: f32,
          horizontal: f32
      };

      struct FragmentOutput {
          @location(0) o_Target: vec4<f32>
      };

      var<private> fragUV1: vec2<f32>;
      var<private> o_Target: vec4<f32>;
      @group(1) @binding(0)
      var baseMapSampler: sampler;
      @group(1) @binding(1)
      var baseMap: texture_2d<f32>;
      @group(2) @binding(0)
      var<uniform> global: uniformData;

      fn main1() {
       
          return;
      }

      const buffer1: array<f32,5> = array<f32,5>(0.22702699899673462, 0.194594606757164, 0.12162160128355026, 0.05405399948358536, 0.01621600054204464);

      @fragment
      fn main(@location(0) fragUV: vec2<f32>) -> FragmentOutput {
          var result: vec3<f32>;
          var i: i32 = 1;
          var j: i32 = 1;
          var uv: vec2<f32> = fragUV;
          uv.y = (1.0 - uv.y);
          var tex_offset: vec2<f32> = (vec2<f32>(1.0) / vec2<f32>(global.texSize));
          let color: vec4<f32> = textureSample(baseMap, baseMapSampler, uv);
          result = (color.xyz * buffer1[0]);
        
          if ((global.horizontal > 1.0)) {
              {
                  loop {
                      if (!((i < 5))) {
                          break;
                      }
                      {
                          let c1: vec4<f32> = textureSample(baseMap, baseMapSampler, (uv + vec2<f32>(((tex_offset.x * f32(i)) * global.hScale), 0.0)));
                          result = (result + (c1.xyz * buffer1[i]));
                          let e101: vec4<f32> = textureSample(baseMap, baseMapSampler, (uv - vec2<f32>(((tex_offset.x * f32(i)) * global.hScale), 0.0)));
                          result = (result + (e101.xyz * buffer1[i]));
                      }
                      continuing {
                          i = (i + 1);
                      }
                  }
              }
          }
          if ((global.horizontal < 1.0)) {
              {
                  loop {
                      let e114: i32 = j;
                      if (!((e114 < 5))) {
                          break;
                      }
                      {
                          let e144: vec4<f32> = textureSample(baseMap, baseMapSampler, (uv + vec2<f32>(0.0, ((tex_offset.y * f32(j)) * global.vScale))));
                          result = (result + (e144.xyz * buffer1[j]));
                          let e175: vec4<f32> = textureSample(baseMap, baseMapSampler, (uv - vec2<f32>(0.0, ((tex_offset.y * f32(j)) * global.vScale))));
                          result = (result + (e175.xyz *  buffer1[j]));
                      }
                      continuing {
                          j = (j + 1);
                      }
                  }
              }
          }
          o_Target = vec4<f32>(result, 1.0);
          return FragmentOutput(o_Target);
      }
    `),n(Ci,"Bloom_composite_frag_wgsl",`
    #include "ColorUtil"
      struct UniformData {
          tintColor:vec4<f32>,
          bloomStrength: f32,
          exposure: f32,
          bloomRadius: f32,
      };

      struct FragmentOutput {
          @location(0) o_Target: vec4<f32>
      };

      var<private> fragUV1: vec2<f32>;
      var<private> o_Target: vec4<f32>;
      @group(1) @binding(0)
      var baseMapSampler: sampler;
      @group(1) @binding(1)
      var baseMap: texture_2d<f32>;
      @group(1) @binding(2)
      var blurTex1Sampler: sampler;
      @group(1) @binding(3)
      var blurTex1: texture_2d<f32>;
      @group(1) @binding(4)
      var blurTex2Sampler: sampler;
      @group(1) @binding(5)
      var blurTex2: texture_2d<f32>;
      @group(1) @binding(6)
      var blurTex3Sampler: sampler;
      @group(1) @binding(7)
      var blurTex3: texture_2d<f32>;
      @group(1) @binding(8)
      var blurTex4Sampler: sampler;
      @group(1) @binding(9)
      var blurTex4: texture_2d<f32>;
      @group(1) @binding(10)
      var blurTex5Sampler: sampler;
      @group(1) @binding(11)
      var blurTex5: texture_2d<f32>;
      @group(2) @binding(0)
      var<uniform> global: UniformData;

      const bloomFactors = array<f32,5>(1.0, 0.800000011920929, 0.6000000238418579, 0.4000000059604645, 0.20000000298023224);
     
      fn lerpBloomFactor(factor: f32) -> f32 {
          var mirrorFactor: f32 = (1.2000000476837158 - factor);
          return mix(factor, mirrorFactor, global.bloomRadius);
      }

      fn main1() {
    
          return;
      } 

      @fragment
      fn main(@location(0) fragUV: vec2<f32>) -> FragmentOutput {
          var uv: vec2<f32> = fragUV;
          uv.y = (1.0 - uv.y);
        
          let e38: f32 = lerpBloomFactor(bloomFactors[0]);
          let e46: vec4<f32> = textureSample(blurTex1, blurTex1Sampler, uv);
          let e52: f32 = lerpBloomFactor(bloomFactors[1]);
          let e60: vec4<f32> = textureSample(blurTex2, blurTex2Sampler, uv);
          let e67: f32 = lerpBloomFactor(bloomFactors[2]);
          let e75: vec4<f32> = textureSample(blurTex3, blurTex3Sampler, uv);
          let e82: f32 = lerpBloomFactor(bloomFactors[3]);
          let e90: vec4<f32> = textureSample(blurTex4, blurTex4Sampler, uv);
          let e97: f32 = lerpBloomFactor(bloomFactors[4]);
          let e105: vec4<f32> = textureSample(blurTex5, blurTex5Sampler, uv);
          o_Target = ((((((((e38 * vec4<f32>(array<vec3<f32>,5>(vec3<f32>(1.0, 1.0, 1.0), vec3<f32>(1.0, 1.0, 1.0), vec3<f32>(1.0, 1.0, 1.0), vec3<f32>(1.0, 1.0, 1.0), vec3<f32>(1.0, 1.0, 1.0))[0], 1.0)) * e46) + ((e52 * vec4<f32>(array<vec3<f32>,5>(vec3<f32>(1.0, 1.0, 1.0), vec3<f32>(1.0, 1.0, 1.0), vec3<f32>(1.0, 1.0, 1.0), vec3<f32>(1.0, 1.0, 1.0), vec3<f32>(1.0, 1.0, 1.0))[1], 1.0)) * e60)) + ((e67 * vec4<f32>(array<vec3<f32>,5>(vec3<f32>(1.0, 1.0, 1.0), vec3<f32>(1.0, 1.0, 1.0), vec3<f32>(1.0, 1.0, 1.0), vec3<f32>(1.0, 1.0, 1.0), vec3<f32>(1.0, 1.0, 1.0))[2], 1.0)) * e75)) + ((e82 * vec4<f32>(array<vec3<f32>,5>(vec3<f32>(1.0, 1.0, 1.0), vec3<f32>(1.0, 1.0, 1.0), vec3<f32>(1.0, 1.0, 1.0), vec3<f32>(1.0, 1.0, 1.0), vec3<f32>(1.0, 1.0, 1.0))[3], 1.0)) * e90)) + ((e97 * vec4<f32>(array<vec3<f32>,5>(vec3<f32>(1.0, 1.0, 1.0), vec3<f32>(1.0, 1.0, 1.0), vec3<f32>(1.0, 1.0, 1.0), vec3<f32>(1.0, 1.0, 1.0), vec3<f32>(1.0, 1.0, 1.0))[4], 1.0)) * e105))));
          
          let baseColor: vec4<f32> = textureSample(baseMap, baseMapSampler, uv);
          
          var bloomLight = global.bloomStrength * o_Target.rgb;

          bloomLight = getHDRColor(bloomLight.rgb,global.exposure);
          bloomLight = LinearToGammaSpace(bloomLight);

          o_Target =  baseColor + vec4<f32>(bloomLight * global.tintColor.rgb, baseColor.a) ;
          o_Target.a = min(o_Target.a,1.0);
          return FragmentOutput(o_Target);
      }
  `);let Eo=`
        var<private> colorSet : array<vec3<f32>, 9> = array<vec3<f32>, 9>(
            vec3<f32>(1.0, 0.0, 0.0),
            vec3<f32>(1.0, 0.5, 0.0),
            vec3<f32>(0.5, 1.0, 0.0),
            vec3<f32>(0.0, 1.0, 0.0),
            vec3<f32>(0.0, 1.0, 0.5),
            vec3<f32>(0.0, 0.5, 1.0),
            vec3<f32>(0.0, 0.0, 1.0),
            vec3<f32>(0.5, 0.0, 1.0),
            vec3<f32>(1.0, 0.0, 0.5)
        );

        #if DEBUG_CLUSTER
        fn debugCluster(fragCoord:vec4<f32>) {
            #if USE_LIGHT
              var tileID : u32 = getClusterId3().z;
              let clusterDebug = vec4<f32>(colorSet[tileID % 9u], 1.0);
              ORI_FragmentOutput.color = clusterDebug ;
            #endif
          }
      
          fn debugClusterBox(fragCoord:vec4<f32>) {
            #if USE_LIGHT
              let clusterId3 : vec3<u32> = getClusterId3();
              let px = f32(clusterId3.x) / clustersUniform.clusterTileX ;
              let py = f32(clusterId3.y) / clustersUniform.clusterTileY ;
              let pz = f32(clusterId3.z) / clustersUniform.clusterTileZ ;
              ORI_FragmentOutput.color = vec4<f32>(px,py,pz, 1.0);

              var screenUV = ORI_VertexVarying.fragCoord.xy / vec2<f32>( globalUniform.windowWidth , globalUniform.windowHeight );
              ORI_FragmentOutput.color = vec4<f32>(screenUV.x,screenUV.y,0.0, 1.0);

              // let clusterId : u32 = getClusterIndex();
              // let cluster = clusterBuffer[clusterId];
        
              // let midPoint : vec3<f32> = (cluster.maxPoint.xyz - cluster.minPoint.xyz) * vec3<f32>(0.5);
              // let center : vec3<f32> = cluster.minPoint.xyz + midPoint;
              // let radius : f32 = length(midPoint) ;
        
              // let fragToBoundsCenter : vec3<f32> = ORI_VertexVarying.viewPosition.xyz - center;
              // let distToBoundsCenter : f32 = length(fragToBoundsCenter);
              // let normDist : f32 = distToBoundsCenter / radius;
              // ORI_FragmentOutput.color = vec4<f32>(normDist,normDist,normDist, 1.0);
            #endif
          }
      
          fn debugClusterLightCount(fragCoord:vec4<f32>){
            #if USE_LIGHT
            //LightIndex
              let cluster : LightIndex = getCluster();
              let lightCount : u32 = u32(cluster.count);
              let lightFactor : f32 = f32(lightCount) / f32(clustersUniform.maxNumLightsPerCluster);
              ORI_FragmentOutput.color =  mix(vec4<f32>(0.0, 0.0,0.0, 1.0), vec4<f32>(1.0, 1.0, 1.0, 1.0), vec4<f32>(lightFactor, lightFactor, lightFactor, lightFactor));
            #endif
          }
          #endif
    `;class Ir{}n(Ir,"sky_vs_frag_wgsl",`
    #include "WorldMatrixUniform"
    #include "GlobalUniform"

    struct VertexOutput {
      @location(0) fragUV: vec2<f32>,
      @location(1) vWorldPos: vec4<f32>,
      @location(2) vWorldNormal: vec3<f32>,
      @builtin(position) member: vec4<f32>
    };

    var<private> ORI_VertexOut: VertexOutput ;

    @vertex
    fn main( 
      @builtin(instance_index) index : u32,
      @location(0) position: vec3<f32>,
      @location(1) normal: vec3<f32>,
      @location(2) uv: vec2<f32>
    ) -> VertexOutput {
      ORI_VertexOut.fragUV = uv;
      let modelMat = models.matrix[u32(index)];
      let vm = globalUniform.viewMat * modelMat;
      let normalMatrix = mat3x3<f32>(vm[0].xyz,vm[1].xyz,vm[2].xyz);
	    ORI_VertexOut.vWorldNormal = normalize( normalMatrix * normal );
      ORI_VertexOut.vWorldPos = modelMat * vec4<f32>(position.xyz,1.0) ;

      var fixProjMat = globalUniform.projMat ;
      fixProjMat[2].z = 1.0 ;//99999.0 / (99999.0 - 1.0) ;
      fixProjMat[3].z = -1.0 ;//(-1.0 * 99999.0) / (99999.0 - 1.0) ;

      var fixViewMat = globalUniform.viewMat ;
      fixViewMat[3].x = 0.0 ;
      fixViewMat[3].y = 0.0 ;
      fixViewMat[3].z = 0.0 ;

      var clipPos = fixProjMat * fixViewMat * ORI_VertexOut.vWorldPos;
      ORI_VertexOut.member = clipPos;
      return ORI_VertexOut;
    }
  `),n(Ir,"sky_fs_frag_wgsl",`
    #include "GlobalUniform"

    struct uniformData {
        exposure: f32,
        roughness: f32
    };

    struct FragmentOutput {
        @location(0) o_Target: vec4<f32>,
        #if USE_WORLDPOS
          @location(1) o_Position: vec4<f32>,
        #endif
        #if USEGBUFFER
          @location(2) o_Normal: vec4<f32>,
          @location(3) o_Material: vec4<f32>
        #endif
    };

    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_cube<f32>;

    @group(2) @binding(0)
    var<uniform> global: uniformData;

    fn LinearToGammaSpace(linRGB: vec3<f32>) -> vec3<f32> {
      var linRGB1 = max(linRGB, vec3<f32>(0.0));
      linRGB1 = pow(linRGB1, vec3<f32>(0.4166666567325592));
      return max(((1.0549999475479126 * linRGB1) - vec3<f32>(0.054999999701976776)), vec3<f32>(0.0));
    }

    @fragment
    fn main(@location(0) fragUV: vec2<f32>, @location(1) vWorldPos: vec4<f32>, @location(2) vWorldNormal: vec3<f32>) -> FragmentOutput {
        let maxLevel: u32 = textureNumLevels(baseMap);
        var textureColor:vec3<f32> = textureSampleLevel(baseMap, baseMapSampler, normalize(vWorldPos.xyz), global.roughness * f32(maxLevel) ).xyz;
        #if IS_HDR_SKY
        textureColor = LinearToGammaSpace(textureColor);
        #endif
        let o_Target: vec4<f32> =vec4<f32>(textureColor, 1.0) * globalUniform.skyExposure ;
        var normal_rgba8unorm = (vWorldNormal + 1.0) * 0.5;
        normal_rgba8unorm = clamp(normal_rgba8unorm, vec3<f32>(0.0), vec3<f32>(1.0));

        return FragmentOutput(
          o_Target,
          #if USE_WORLDPOS
              vWorldPos,
          #endif
          #if USEGBUFFER
              vec4<f32>(normal_rgba8unorm,0.0),
              vec4<f32>(0.0,1.0,0.0,0.0)
          #endif
        );
    }
    `);let Bo=`
#include "BRDF_frag"
#include "ClusterLight"
#include "ShadowMapping_frag"

#if USE_IES_PROFILE
  #include "IESProfiles_frag"
#endif



const LUMEN = 10.764;



fn calcAttenuation( d : f32 ,  falloffStart : f32 ,  falloffEnd : f32)-> f32
{
    // Linear falloff.
    return saturate((falloffEnd-d) / (falloffEnd - falloffStart));
}

fn directLighting( albedo:vec3<f32>, N:vec3<f32>, V:vec3<f32>,  roughness:f32 , metallic:f32 , light:LightData , shadowBias:f32 ) -> vec3<f32> {
    var color = vec3<f32>(0.0) ;
    #if USE_LIGHT
      var L = -normalize(light.direction.xyz) ;
      let lightCC = pow( light.lightColor.rgb,vec3<f32>(2.2));
      var lightColor = getHDRColor( lightCC.rgb , light.linear )  ;
      var att = light.intensity / LUMEN ;
      if(light.castShadow>=0){
          #if USE_SHADOWMAPING
            for (var j: i32 = 0; j < 8; j += 1) {
                if(j == light.castShadow){
                  att *= shadowStrut.directShadowVisibility[j] ; 
                }
            }
          #endif
      }

      #if USE_LAMBERT
        color = vec3<f32>(1.0,1.0,1.0) ;
      #endif 

      #if USE_BRDF
        color = simpleBRDF(albedo,N,V,L,att,lightColor,roughness,metallic) ;
      #endif 
    #endif 
    return color;
}

fn pointLighting( albedo:vec3<f32>,WP:vec3<f32>, N:vec3<f32>, V:vec3<f32>, roughness:f32 , metallic:f32 ,light:LightData ) -> vec3<f32> {
    var color = vec3<f32>(0.0) ;
    let lightPos = light.position.xyz;
    var dir = lightPos.xyz - WP ;
    let dist = length(dir);
    if(dist != 0.0){
      dir *= 1.0 / dist ;
    }
    if( abs(dist) < light.range ){
        var L = dir ;
        var atten = 1.0 ;
        atten = 1.0 - smoothstep(0.0,light.range,dist) ;
        atten *= 1.0 / max(light.radius,0.001) * light.intensity / LUMEN;
        if( light.castShadow >= 0 )
        {
            #if USE_SHADOWMAPING
              // atten *= shadowStrut.pointShadows[light.castShadow] ; 
              for (var j: i32 = 0; j < 8; j += 1) {
                  if(j == light.castShadow){
                    atten *= shadowStrut.pointShadows[j] ; 
                  }
              }
            #endif
        }

        #if USE_IES_PROFILE
          atten *= getLightIESProfileAtt(WP,light);
        #endif

        var lightColor = light.lightColor.rgb  ;
        lightColor = getHDRColor(lightColor , light.linear )  ;

        #if USE_LAMBERT
          color = vec3<f32>(1.0,1.0,1.0) ;
        #endif 

        #if USE_BRDF
          color = (simpleBRDF(albedo,N,V,L,atten,lightColor,roughness,metallic))  ;
        #endif 
    } 
    return color ;
}

fn getDistanceAtten(  light:LightData , dist : f32 ) -> f32 {
  return 1.0 - smoothstep(0.0,light.range,dist) ;
}

fn spotLighting( albedo:vec3<f32>,WP:vec3<f32>, N:vec3<f32>, V:vec3<f32>, roughness:f32 , metallic:f32 ,light:LightData ) -> vec3<f32> {
    let lightPos = light.position.xyz;
    var dir = lightPos.xyz - WP ;
    let dist = length(dir) ;
    if(dist != 0.0){
      dir *= 1.0 / dist ;
    }
    var color = vec3<f32>(0.0) ;
    if( abs(dist) < light.range * 2.0 ){
        var L = dir ;
        let theta = dot(-L, normalize(light.direction));
        let angle = acos(theta) ;
        var atten = 1.0 ;
        var lightColor = light.lightColor.rgb  ;

        atten = 1.0 - smoothstep(0.0,light.range,dist) ;
        atten *= 1.0 / max(light.radius,0.1) * light.intensity / LUMEN;
        if(angle < light.outerCutOff){
          if(angle > light.innerCutOff){
            atten *= 1.0 - smoothstep(light.innerCutOff, light.outerCutOff, angle) ;
          }
        }else{
            atten = 0.0 ;
        }

        if( light.castShadow >= 0 )
        {
            #if USE_SHADOWMAPING
            for (var j: i32 = 0; j < 8; j += 1) {
                if(j == light.castShadow){
                  atten *= shadowStrut.pointShadows[j] ; 
                }
            }
          #endif
        }

        #if USE_IES_PROFILE
            atten *= getLightIESProfileAtt(WP,light);
        #endif

        lightColor = getHDRColor(lightColor , light.linear ) ;

        #if USE_LAMBERT
          color = vec3<f32>(1.0,0.5,1.0) ;
        #endif 

        #if USE_BRDF
          color = (simpleBRDF(albedo,N,V,L,atten,lightColor,roughness,metallic)) ;
        #endif 
    }
    return  color ;
}
`,Ba=`
var<private> PI: f32 = 3.14159265359;


fn applyQuaternion(position:vec3<f32>, q:vec4<f32>) -> vec3<f32>{
  let x:f32 = position.x;
  let y:f32 = position.y;
  let z:f32 = position.z;

  let qx:f32 = q.x;
  let qy:f32 = q.y;
  let qz:f32 = q.z;
  let qw:f32 = q.w;

  let ix:f32 = qw * x + qy * z - qz * y;
  let iy:f32 = qw * y + qz * x - qx * z;
  let iz:f32 = qw * z + qx * y - qy * x;
  let iw:f32 = -qx * x - qy * y - qz * z;

  var ret: vec3<f32>;
  ret.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  ret.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  ret.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;

  return ret;
}

fn inverse( m:mat3x3<f32>) -> mat3x3<f32>{
  var a00 = m[0][0];
  var a01 = m[0][1];
  var a02 = m[0][2];
  var a10 = m[1][0];
  var a11 = m[1][1];
  var a12 = m[1][2];
  var a20 = m[2][0];
  var a21 = m[2][1];
  var a22 = m[2][2];

  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20;

  var det = a00 * b01 + a01 * b11 + a02 * b21 ;
  return mat3x3<f32>(
      vec3<f32>(b01/ det, (-a22 * a01 + a02 * a21)/ det, (a12 * a01 - a02 * a11)/ det),
      vec3<f32>(b11/ det, (a22 * a00 - a02 * a20)/ det, (-a12 * a00 + a02 * a10)/ det),
      vec3<f32>(b21/ det, (-a21 * a00 + a01 * a20)/ det, (a11 * a00 - a01 * a10)/ det)
  );
}

fn dir_to_faceId(pt:vec3<f32>) -> i32 {
    //**** nx px ny py nz pz
    var abs_x = abs(pt.x);
    var abs_y = abs(pt.y);
    var abs_z = abs(pt.z);
    var coord = max(max(abs_x, abs_y), abs_z);
    if(coord == -pt.x){  return 0;}
    if(coord == pt.x) { return 1;}

    if(coord == -pt.y){  return 2;}
    if(coord == pt.y) { return 3;}

    if(coord == -pt.z) { return 4;}
    return 5;
  }

  fn convert_xyz_to_cube_uv(x:f32, y:f32, z:f32 ) -> vec2<f32>
  {
    var dir = vec3<f32>(x, y, z);
    var absX = abs(dir.x);
    var absY = abs(dir.y);
    var absZ = abs(dir.z);

    var isXPositive = 0;
    if(dir.x > 0.0){isXPositive = 1;}
    var isYPositive = 0;
    if(dir.y > 0.0){isYPositive = 1;}
    var isZPositive = 0;
    if(dir.z > 0.0){isZPositive = 1;}

    var maxAxis:f32 = 0.0;
    var uc:f32 = 0.0;
    var vc:f32 = 0.0;

    // POSITIVE X
    if (isXPositive == 1 && absX >= absY && absX >= absZ) {
      // u (0 to 1) goes from +z to -z
      // v (0 to 1) goes from -y to +y
      maxAxis = absX;
      uc = -z;
      vc = y;
    }
    // NEGATIVE X
    if (isXPositive ==0 && absX >= absY && absX >= absZ) {
      // u (0 to 1) goes from -z to +z
      // v (0 to 1) goes from -y to +y
      maxAxis = absX;
      uc = z;
      vc = y;
    }
    // POSITIVE Y
    if (isYPositive==1 && absY >= absX && absY >= absZ) {
      // u (0 to 1) goes from -x to +x
      // v (0 to 1) goes from +z to -z
      maxAxis = absY;
      uc = x;
      vc = -z;
    }
    // NEGATIVE Y
    if (isYPositive ==0 && absY >= absX && absY >= absZ) {
      // u (0 to 1) goes from -x to +x
      // v (0 to 1) goes from -z to +z
      maxAxis = absY;
      uc = x;
      vc = z;
    }
    // POSITIVE Z
    if (isZPositive == 1&& absZ >= absX && absZ >= absY) {
      // u (0 to 1) goes from -x to +x
      // v (0 to 1) goes from -y to +y
      maxAxis = absZ;
      uc = x;
      vc = y;
    }
    // NEGATIVE Z
    if (isZPositive ==0 && absZ >= absX && absZ >= absY) {
      // u (0 to 1) goes from +x to -x
      // v (0 to 1) goes from -y to +y
      maxAxis = absZ;
      uc = -x;
      vc = y;
    }

    // Convert range from -1 to 1 to 0 to 1
    var u = 0.5f * (uc / maxAxis + 1.0f);
    var v = 0.5f * (vc / maxAxis + 1.0f);

    return vec2(u, v);
  }

    // Returns \xB11
    fn signNotZero( v1:vec2<f32>) -> vec2<f32> {
        var v:vec2<f32> = v1;
        if(v.x >= 0.0){
            v.x = 1.0;
        }else{
            v.x = -1.0;
        }
        if(v.y >= 0.0){
            v.y = 1.0;
        }else{
            v.y= -1.0;
        }
        return v;
    }

    fn octEncode( v:vec3<f32> ) -> vec2<f32> {
        var l1norm = abs(v.x) + abs(v.y) + abs(v.z);
        var result = v.xy * (1.0 / l1norm);
        if (v.z < 0.0) {
            result = (1.0 - abs(result.yx)) * signNotZero(result.xy);
        }
        return result;
    }

    // Returns a unit vector. Argument o is an octahedral vector packed via octEncode,on the [-1, +1] square*/
    fn octDecode( o:vec2<f32> ) -> vec3<f32> {
        var v = vec3<f32>(o.x, o.y, 1.0 - abs(o.x) - abs(o.y));
        if (v.z < 0.0) {
            var tmp = (1.0 - abs(v.yx)) * signNotZero(v.xy);
            v.x = tmp.x;
            v.y = tmp.y;
        }
        return normalize(v);
    }

    fn Linear01Depth(z:f32,near:f32,far:f32)-> f32{
        let ZBufferZ = (-1.0+(far/near)) / far;
        let ZBufferW = near /far ;
        return 1.0 / (ZBufferZ * z + ZBufferW) ;
    }

    
    fn LinearizeDepth( depth:f32 , nearPlane:f32 , farPlane:f32 )-> f32 {
      var z = depth * 2.0 - 1.0;
      return (2.0 * nearPlane * farPlane) / (farPlane + nearPlane - z * (farPlane - nearPlane));
    }

    fn logDepth(depth : f32, far:f32) -> f32 {
      return log2(depth + 1.0) * 2.0 / (log(far + 1.0) / 0.6931471805599453) * 0.5;
    }

    fn log2Depth(depth : f32, near:f32, far:f32) -> f32 {
      let pt = pow((far / near),depth);
      return near * pt / (far / near);
    }

   


    fn QuaternionToMatrix(q: vec4<f32>) -> mat4x4<f32> {
      // If q is guaranteed to be a unit quaternion, s will always
      // be 1.  In that case, this calculation can be optimized out.
      //float norm = GetNorm (q);
      //float s = (norm > 0.0) ? 2.0/norm : 0;

      var result: mat4x4<f32>;
  
      // Precalculate coordinate products
      let x = q.x * 2.0;
      let y = q.y * 2.0;
      let z = q.z * 2.0;
      let xx = q.x * x;
      let yy = q.y * y;
      let zz = q.z * z;
      let xy = q.x * y;
      let xz = q.x * z;
      let yz = q.y * z;
      let wx = q.w * x;
      let wy = q.w * y;
      let wz = q.w * z;
  
      // Calculate 3x3 matrix from orthonormal basis
      result[0][0] = 1.0 - (yy + zz);
      result[0][1] = xy + wz;
      result[0][2] = xz - wy;
      result[0][3] = 0.0;
  
      result[1][0] = xy - wz;
      result[1][1] = 1.0 - (xx + zz);
      result[1][2] = yz + wx;
      result[1][3] = 0.0;
  
      result[2][0] = xz + wy;
      result[2][1] = yz - wx;
      result[2][2] = 1.0 - (xx + yy);
      result[2][3] = 0.0;
  
      result[3][0] = 0.0;
      result[3][1] = 0.0;
      result[3][2] = 0.0;
      result[3][3] = 1.0;

      return result;
    }

    fn MakeScaleMatrix(scale: vec3<f32>) -> mat4x4<f32> {
        return mat4x4<f32>(
          scale.x, 0.0, 0.0, 0.0,
          0.0, scale.y, 0.0, 0.0,
          0.0, 0.0, scale.z, 0.0,
          0.0, 0.0, 0.0, 1.0,
        );
    }

    fn MakeRotationMatrix(rotationQuaternion: vec4<f32>) -> mat4x4<f32> {
        return QuaternionToMatrix(rotationQuaternion);
    }

    fn MakeTranslationMatrix(translation: vec3<f32>) -> mat4x4<f32> {
        return mat4x4<f32>(
          1.0, 0.0, 0.0, 0.0,
          0.0, 1.0, 0.0, 0.0,
          0.0, 0.0, 1.0, 0.0,
          translation.x, translation.y, translation.z, 1.0,
        );
    }

    fn MakeMatrix4x4(scale: vec3<f32>, rotationQuaternion: vec4<f32>, translation: vec3<f32>) -> mat4x4<f32> {
        var scaleMat: mat4x4<f32> = MakeScaleMatrix(scale);
        var rotationMat: mat4x4<f32> = MakeRotationMatrix(rotationQuaternion);
        var translationMat: mat4x4<f32> = MakeTranslationMatrix(translation);
        return translationMat * scaleMat * rotationMat;
    }

    fn mixMatrix4x4(a: mat4x4<f32>, b: mat4x4<f32>, t:f32) -> mat4x4<f32> {
      return a * (1.0 - t) + b * t;
      // return mat4x4<f32>(
      //   mix(a[0], b[0], t),
      //   mix(a[1], b[1], t),
      //   mix(a[2], b[2], t),
      //   mix(a[3], b[3], t)
      // );
    }

    fn decodeDepth( color:vec4<f32> ) -> f32{
      var depth = 0.0 ;
      const bitShifts = vec4<f32>(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0); 
      depth = dot(color, bitShifts);
      return depth;
    }

    fn encodeDepth( depth:f32 ) -> vec4<f32>{
      const bitSh  = vec4<f32>(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);
      const bitMsk = vec4<f32>(0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);
      var comp:vec4<f32>;
      comp  = depth * bitSh;
      comp  = fract(comp);
      comp -= comp.xxyz * bitMsk;
      return comp;
    }
`,To=`
        struct MaterialUniform {
          transformUV1:vec4<f32>,
          transformUV2:vec4<f32>,

          baseColor: vec4<f32>,
          emissiveColor: vec4<f32>,
          materialF0: vec4<f32>,
          envIntensity: f32,
          normalScale: f32,
          roughness: f32,
          metallic: f32,
          ao: f32,

          roughness_min: f32,
          roughness_max: f32,
          metallic_min: f32,
          metallic_max: f32,
          emissiveIntensity: f32,
          alphaCutoff: f32,
          ior: f32,
          clearcoatColor: vec4<f32>,
          clearcoatWeight: f32,
          clearcoatFactor: f32,
          clearcoatRoughnessFactor: f32,
        };
      
        @group(2) @binding(0)
        var<uniform> materialUniform: MaterialUniform;
      `,Do=`
struct MaterialUniform {
  transformUV1:vec4<f32>,
  transformUV2:vec4<f32>,
  baseColor: vec4<f32>,
  alphaCutoff: f32,
};

@group(2) @binding(0)
var<uniform> materialUniform: MaterialUniform;
`,Mo=`
    #include "Common_frag"
    #include "GlobalUniform"

    fn UnLit(){
        let alpha = ORI_ShadingInput.BaseColor.a ;
        ORI_FragmentOutput.color = vec4<f32>(ORI_ShadingInput.BaseColor.rgb * alpha , alpha) ;

        #if USE_WORLDPOS
            ORI_FragmentOutput.worldPos = vec4<f32>(ORI_VertexVarying.vWorldPos.xyzw);
        #endif

        #if USEGBUFFER
            var normal_rgba8unorm = (ORI_VertexVarying.vWorldNormal + 1.0) * 0.5;
            normal_rgba8unorm = clamp(normal_rgba8unorm, vec3<f32>(0.0), vec3<f32>(1.0));
            ORI_FragmentOutput.worldNormal = vec4<f32>(normal_rgba8unorm,1.0);
            ORI_FragmentOutput.material = vec4<f32>(1.0,1.0,0.0,1.0);
        #endif
    }

    fn debugFragmentOut(){

    }
`;class Er{static groupBindingAndFunctions(e,t){return`
            struct JointsMatrix {
                matrix : array<mat4x4<f32>>
            };

            @group(${e}) @binding(${t})
            var<storage, read> jointsMatrixIndexTable: array<f32>;

            @group(${e}) @binding(${t+1})
            var<storage, read> jointsInverseMatrix: JointsMatrix;

            @group(${e}) @binding(${t+2})
            var<storage, read> jointsIndexMapingTable: array<f32>;

            const MAX_JOINT_NUM = 8;
            fn getSkeletonWorldMatrix(joints: array<f32, MAX_JOINT_NUM>, weights: array<f32, MAX_JOINT_NUM>, num: u32) -> mat4x4<f32> {
                var result: mat4x4<f32>;
                for(var i: u32 = 0; i < num; i = i + 1) {
                    let jointId = i32(joints[i]);
                    let jointIndex = u32(jointsIndexMapingTable[jointId]);
                    let jointMatrixIndex = u32(jointsMatrixIndexTable[jointIndex]);
                    let joint = models.matrix[jointMatrixIndex] * jointsInverseMatrix.matrix[jointId] * weights[i];
                    result += joint;
                }
                return result;
            }

            fn getSkeletonWorldMatrix_4(joints: vec4<f32>, weights: vec4<f32>) -> mat4x4<f32> {
                return getSkeletonWorldMatrix(array<f32, MAX_JOINT_NUM>(
                    joints.x, joints.y, joints.z, joints.w,
                    0, 0, 0, 0,
                ), array<f32, MAX_JOINT_NUM>(
                    weights.x, weights.y, weights.z, weights.w,
                    0, 0, 0, 0,
                ), 4);
            }
    
            fn getSkeletonWorldMatrix_8(joints0: vec4<f32>, weights0: vec4<f32>, joints1: vec4<f32>, weights1: vec4<f32>) -> mat4x4<f32> {
                return getSkeletonWorldMatrix(array<f32, MAX_JOINT_NUM>(
                    joints0.x, joints0.y, joints0.z, joints0.w,
                    joints1.x, joints1.y, joints1.z, joints1.w,
                ), array<f32, MAX_JOINT_NUM>(
                    weights0.x, weights0.y, weights0.z, weights0.w,
                    weights1.x, weights1.y, weights1.z, weights1.w,
                ), 8);
            }
        `}}class Re{static getMorphTargetShaderBinding(e,t){return`
            fn blendMorphTargetPosition(vertexID:i32, posIn:vec3<f32>) -> vec3<f32>{
                let offset:i32 = vertexID * 3;
                var pos = posIn * morphTargetConfig.morphBaseInfluence;
                pos += vec3<f32>(morphTargetOpPositions[offset], morphTargetOpPositions[offset + 1], morphTargetOpPositions[offset + 2]);
                return pos;
            }

            #if USE_MORPHNORMALS
                fn blendMorphTargetNormal(vertexID:i32, normalIn:vec3<f32>) -> vec3<f32>{
                    let offset:i32 = vertexID * 3;
                    var normal = normalIn * morphTargetConfig.morphBaseInfluence;
                    normal += vec3<f32>(morphTargetOpNormals[offset], morphTargetOpNormals[offset + 1], morphTargetOpNormals[offset + 2]);
                    return normal;
                }
            #endif

            struct MorphTargetConfigData {
                morphBaseInfluence:f32,
                morphTargetCount:f32,
                totalVertexCount:f32,
                computeWorkGroupXY:f32,
            };
            
            @group(${e}) @binding(${t})
            var<uniform> morphTargetConfig: MorphTargetConfigData;
            
            @group(${e}) @binding(${t+1})
            var<storage,read> morphTargetOpPositions: array<f32>;

            #if USE_MORPHNORMALS
                @group(${e}) @binding(${t+2})
                var<storage,read> morphTargetOpNormals: array<f32>;
            #endif
`}static getMorphTargetAttr(e){return`@location(${e}) vIndex: f32,`}static getMorphTargetCalcVertex(){return`
            vertexPosition = blendMorphTargetPosition(i32(vertex.vIndex), vertexPosition);

            #if USE_MORPHNORMALS
                vertexNormal = blendMorphTargetNormal(i32(vertex.vIndex), vertexNormal);
            #endif
        `}}n(Re,"CsMain",`
        struct MorphTargetConfigData {
            morphBaseInfluence:f32,
            morphTargetCount:f32,
            totalVertexCount:f32,
            computeWorkGroupXY:f32,
        };

        @group(0) @binding(0) var<uniform> morphTargetConfig: MorphTargetConfigData;
        @group(0) @binding(1) var<storage, read> morphTargetInfluence : array<f32>;
        @group(0) @binding(2) var<storage, read> morphTargetPositions : array<f32>;
        @group(0) @binding(3) var<storage, read_write> morphTargetOpPositions : array<f32>;
        
        #if USE_MORPHNORMALS
            @group(0) @binding(4) var<storage, read> morphTargetNormals : array<f32>;
            @group(0) @binding(5) var<storage, read_write> morphTargetOpNormals : array<f32>;
        #endif
        
        @compute @workgroup_size( 8 , 8 , 1 )
        fn CsMain(@builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
        {
            let vertexIndex:i32 = i32(globalInvocation_id.y) * i32(morphTargetConfig.computeWorkGroupXY) + i32(globalInvocation_id.x);
        
            let morphTargetCount:i32 = i32(morphTargetConfig.morphTargetCount);
            let totalVertexCount:i32 = i32(morphTargetConfig.totalVertexCount);
            var vertexPosition:vec3<f32> = vec3<f32>(0.0);
            var vertexNormal:vec3<f32> = vec3<f32>(0.0);
            if(vertexIndex < totalVertexCount)
            {
                for(var i:i32 = 0; i < morphTargetCount; i ++){
                    let offset:i32 = (i * totalVertexCount + vertexIndex) * 3;
                    let morphPosition = vec3<f32>(morphTargetPositions[offset], morphTargetPositions[offset + 1], morphTargetPositions[offset + 2]);
                    vertexPosition += morphTargetInfluence[i] * morphPosition;
                }

                var writeOffset = vertexIndex * 3;
                //op position
                morphTargetOpPositions[writeOffset] = vertexPosition.x;
                morphTargetOpPositions[writeOffset + 1] = vertexPosition.y;
                morphTargetOpPositions[writeOffset + 2] = vertexPosition.z;

                #if USE_MORPHNORMALS
                    for(var i:i32 = 0; i < morphTargetCount; i ++){
                        let offset:i32 = (i * totalVertexCount + vertexIndex) * 3;
                        let morphNormal = vec3<f32>(morphTargetNormals[offset], morphTargetNormals[offset + 1], morphTargetNormals[offset + 2]);
                        vertexNormal += morphTargetInfluence[i] * morphNormal;
                    }

                    //op normal
                    morphTargetOpNormals[writeOffset] = vertexNormal.x;
                    morphTargetOpNormals[writeOffset + 1] = vertexNormal.y;
                    morphTargetOpNormals[writeOffset + 2] = vertexNormal.z;
                #endif
            }
        }
`);let Po=`
    #if USE_MORPHTARGETS
    ${Re.getMorphTargetShaderBinding(3,0)}
    #endif

    #if USE_SKELETON
    ${Er.groupBindingAndFunctions(3,0)} 
    #endif

    struct VertexAttributes{
    @builtin(instance_index) index : u32,
    @location(0) position: vec3<f32>,
    @location(1) normal: vec3<f32>,
    @location(2) uv: vec2<f32>,
    @location(3) TEXCOORD_1: vec2<f32>,

    #if USE_TANGENT
        @location(4) TANGENT: vec4<f32>,
        #if USE_SKELETON
            @location(5) joints0: vec4<f32>,
            @location(6) weights0: vec4<f32>,
            #if USE_JOINT_VEC8
            @location(7) joints1: vec4<f32>,
            @location(8) weights1: vec4<f32>,
        #endif
        #elseif USE_MORPHTARGETS
            ${Re.getMorphTargetAttr(5)}
        #endif
    #elseif USE_SKELETON
        @location(4) joints0: vec4<f32>,
        @location(5) weights0: vec4<f32>,
        #if USE_JOINT_VEC8
        @location(6) joints1: vec4<f32>,
        @location(7) weights1: vec4<f32>,
        #endif
    #elseif USE_MORPHTARGETS
        ${Re.getMorphTargetAttr(4)}
    #endif
    }

    struct VertexOutput {
    @location(0) varying_UV0: vec2<f32>,
    @location(1) varying_UV1: vec2<f32>,
    @location(2) varying_ViewPos: vec4<f32>,
    @location(3) varying_Clip: vec4<f32>,
    @location(4) varying_WPos: vec4<f32>,
    @location(5) varying_WNormal: vec3<f32>,
    @location(6) varying_Color: vec4<f32>,

    #if USE_SHADOWMAPING
        @location(7) varying_ShadowPos: vec4<f32>,
    #endif

    #if USE_TANGENT
        @location(8) varying_Tangent: vec4<f32>,
    #endif

    @builtin(position) member: vec4<f32>
    };

    var<private> ORI_VertexOut: VertexOutput ;

    fn ORI_Vert(vertex:VertexAttributes){
    var vertexPosition = vertex.position;
    var vertexNormal = vertex.normal;

    #if USE_MORPHTARGETS
    ${Re.getMorphTargetCalcVertex()}    
    #endif

    #if USE_SKELETON
        #if USE_JOINT_VEC8
            let skeletonNormal = getSkeletonWorldMatrix_8(vertex.joints0, vertex.weights0, vertex.joints1, vertex.weights1);
            ORI_MATRIX_M *= skeletonNormal ;
        #else
            let skeletonNormal = getSkeletonWorldMatrix_4(vertex.joints0, vertex.weights0);
            ORI_MATRIX_M *= skeletonNormal ;
        #endif
    #endif

    #if USE_TANGENT
        ORI_VertexOut.varying_Tangent = vertex.TANGENT ;
    #endif

    ORI_NORMALMATRIX = transpose(inverse( mat3x3<f32>(ORI_MATRIX_M[0].xyz,ORI_MATRIX_M[1].xyz,ORI_MATRIX_M[2].xyz) ));

    var worldPos = (ORI_MATRIX_M * vec4<f32>(vertexPosition.xyz, 1.0));
    var viewPosition = ORI_MATRIX_V * worldPos;
    var clipPosition = ORI_MATRIX_P * viewPosition ;

    ORI_CameraWorldDir = normalize(ORI_CAMERAMATRIX[3].xyz - worldPos.xyz) ;

    ORI_VertexOut.varying_UV0 = vertex.uv.xy ;
    ORI_VertexOut.varying_UV1 = vertex.TEXCOORD_1.xy;
    ORI_VertexOut.varying_ViewPos = viewPosition ;
    ORI_VertexOut.varying_Clip = clipPosition ;
    ORI_VertexOut.varying_WPos = worldPos ;
    ORI_VertexOut.varying_WPos.w = f32(vertex.index);
    ORI_VertexOut.varying_WNormal = normalize(ORI_NORMALMATRIX * vertexNormal.xyz) ;

    ORI_VertexOut.member = clipPosition ;
    }
`,Ro=`
struct MaterialUniform {
  transformUV1:vec4<f32>,
  transformUV2:vec4<f32>,
  baseColor: vec4<f32>,
  rectClip: vec4<f32>,
  alphaCutoff: f32,
};

@group(2) @binding(0)
var<uniform> materialUniform: MaterialUniform;
`,Lo=`
    struct IrradianceVolumeData {
        //0
        orientationIndex:f32,
            hysteresis:f32,
            OctRTSideSize:f32,
            OctRTMaxSize:f32,

            //1
            startX:f32,
            startY:f32,
            startZ:f32,
            ProbeSpace:f32,

            //2
            gridXCount:f32,
            gridYCount:f32,
            gridZCount:f32,
            maxDistance:f32,

            //3
            depthSharpness:f32,
            ProbeSourceTextureSize:f32,
            ProbeSize:f32,
            bounceIntensity:f32,

            //4
            probeRoughness:f32,
            normalBias:f32,
            irradianceChebyshevBias:f32,
            rayNumber:f32,

            //5
            irradianceDistanceBias:f32,
            indirectIntensity:f32,
            ddgiGamma:f32,
            lerpHysteresis:f32,
            //6

            debugX:f32,
            debugY:f32,
            debugZ:f32,
            slot0:f32,

            //..
            v7:vec4<f32>,
    }
`,Uo=`
    #include "MathShader"
    #include "FastMathShader"
    #include "InstanceUniform"

    var<private> ORI_MATRIX_P: mat4x4<f32>;
    var<private> ORI_MATRIX_V: mat4x4<f32>;
    var<private> ORI_MATRIX_M: mat4x4<f32>;
    var<private> ORI_MATRIX_PV: mat4x4<f32>;
    var<private> ORI_MATRIX_PVInv: mat4x4<f32>;
    var<private> ORI_MATRIX_World: mat4x4<f32>;
    var<private> ORI_CAMERAMATRIX: mat4x4<f32>;
    var<private> ORI_NORMALMATRIX: mat3x3<f32>;
    var<private> ORI_CameraWorldDir: vec3<f32>;
    var<private> ORI_ViewDir: vec3<f32>;

    var<private> TIME: vec4<f32>;
    var<private> MOUSE: vec4<f32>;
    var<private> SCREEN: vec4<f32>;

    var<private> ProjectionParams: vec4<f32>;

    fn vertex_inline(vertex:VertexAttributes){
        TIME.x = globalUniform.frame;
        TIME.y = globalUniform.time;
        TIME.z = globalUniform.delta;

        MOUSE.x = globalUniform.mouseX;
        MOUSE.y = globalUniform.mouseY;

        SCREEN.x = globalUniform.windowWidth;
        SCREEN.y = globalUniform.windowHeight;

        ProjectionParams.x = globalUniform.near;
        ProjectionParams.y = globalUniform.far;
        ProjectionParams.z = 1.0 + 1.0 / globalUniform.far;

        ORI_MATRIX_P = globalUniform.projMat ;
        ORI_MATRIX_V = globalUniform.viewMat ;
        ORI_MATRIX_PV = ORI_MATRIX_P * ORI_MATRIX_V ;
        ORI_MATRIX_PVInv = globalUniform.pvMatrixInv ;
        ORI_CAMERAMATRIX = globalUniform.cameraWorldMatrix ;

        ORI_MATRIX_M = models.matrix[u32(vertex.index)];
            
        #if USE_INSTANCEDRAW
            let modelID = instanceDrawID.matrixIDs[vertex.index];
            ORI_MATRIX_M = models.matrix[modelID];
        #endif
    }
`,Oo=`
  #include "GlobalUniform"
  #include "FragmentVarying"
  #include "ColorPassFragmentOutput"
  #include "ShadingInput"

  var<private> ORI_FragmentOutput: FragmentOutput;
  var<private> ORI_VertexVarying: FragmentVarying;
  var<private> ORI_ShadingInput: ShadingInput;
  var<private> viewDir:vec3<f32>;
  @fragment
  fn FragMain( vertex_varying:FragmentVarying ) -> FragmentOutput {
    ORI_VertexVarying = vertex_varying;
    ORI_FragmentOutput.color = vec4<f32>(1.0, 0.0, 0.0, 1.0);
    viewDir = normalize(globalUniform.CameraPos.xyz - ORI_VertexVarying.vWorldPos.xyz) ;
    #if USE_WORLDPOS
      ORI_FragmentOutput.worldPos = ORI_VertexVarying.vWorldPos;
    #endif
    #if USEGBUFFER
      ORI_FragmentOutput.worldNormal = vec4<f32>(ORI_ShadingInput.Normal.rgb ,1.0); 
      ORI_FragmentOutput.material = vec4<f32>(0.0,1.0,0.0,0.0);
    #endif
    frag();
    
    #if USE_DEBUG
      debugFragmentOut();
    #endif

    // var d1 = logDepth( ORI_VertexVarying.fragCoord.w , globalUniform.far);
    // ORI_FragmentOutput.out_depth = d1 ;

    #if USE_OUTDEPTH
      #if USE_LOGDEPTH
        ORI_FragmentOutput.out_depth = log2Depth(ORI_VertexVarying.fragCoord.z,globalUniform.near,globalUniform.far) ;
      #else
        ORI_FragmentOutput.out_depth = ORI_ShadingInput.FragDepth ;
      #endif
    #endif

    // var d1 = log2(ORI_VertexVarying.fragCoord.w + 1.0) * 2.0 / (log(f + 1.0) / 0.6931471805599453) * 0.5 ;
    // 2.0 / (Math.log(camera.far + 1.0) / Math.LN2)
    // ORI_FragmentOutput.out_depth = d1 ;

    return ORI_FragmentOutput ;
  }


`,No=`
    #include "WorldMatrixUniform"
    #include "VertexAttributes_vert"
    #include "GlobalUniform"
    #include "Inline_vert"
    @vertex
    fn VertMain( vertex:VertexAttributes ) -> VertexOutput {
        vertex_inline(vertex);
        vert(vertex);
        return ORI_VertexOut ;
    }
`,Fo=`
    @group(1) @binding(auto)
    var brdflutMapSampler: sampler;
    @group(1) @binding(auto)
    var brdflutMap: texture_2d<f32>;
`,ko=`
    @group(1) @binding(auto)
    var prefilterMapSampler: sampler;
    @group(1) @binding(auto)
    var prefilterMap: texture_cube<f32>;
    @group(1) @binding(auto)
    var envMapSampler: sampler;
    @group(1) @binding(auto)
    var envMap: texture_cube<f32>;
`;class nt{}n(nt,"Cascades",4);let Ta=`

  struct GlobalUniform {
    projMat: mat4x4<f32>,
    viewMat: mat4x4<f32>,
    cameraWorldMatrix: mat4x4<f32>,
    pvMatrixInv : mat4x4<f32>,
    shadowMatrix: array<mat4x4<f32>, 8u>,
    csmShadowBias: vec4<f32>,
    csmMatrix: array<mat4x4<f32>,${nt.Cascades}>,

    CameraPos: vec3<f32>,
    frame: f32,

    time: f32,
    delta: f32,
    shadowBias: f32,
    skyExposure: f32,

    renderPassState:f32,
    quadScale: f32,
    hdrExposure: f32,
    renderState_left: i32,

    renderState_right: i32,
    renderState_split: f32,
    mouseX: f32,
    mouseY: f32,

    windowWidth: f32,
    windowHeight: f32,
    near: f32,
    far: f32,

    pointShadowBias: f32,
    shadowMapSize: f32,
    shadowSoft: f32,
    enableCSM:f32,

    csmMargin:f32,
    notUsed1:f32,
    notUsed2:f32,
    notUsed3:f32
    
  };

  @group(0) @binding(0)
  var<uniform> globalUniform: GlobalUniform;
`,zo=`
    #if USE_INSTANCEDRAW
        struct InstanceUniform {
            matrixIDs : array<i32>
        };
        @group(2) @binding(7)
        var<storage, read> instanceDrawID : InstanceUniform;
    #endif
`,Es=`
    struct Uniforms {
        matrix : array<mat4x4<f32>>
    };

    @group(0) @binding(1)
    var<storage, read> models : Uniforms;
`,Go=`
  fn Pow3(  x : f32 ) -> f32
  {
      var xx = x*x;
      return x * xx;
  }

  fn Pow4(  x : f32 ) -> f32
  {
      var xx = x*x;
      return xx * xx;
  }

  fn pow5(x: f32) -> f32 {
      var x2 = x * x;
      return x2 * x2 * x;
  }

  fn rcp( x:f32 ) -> f32
  {
      return 1.0 / x;
  }

  fn rsqrt3( a : vec3<f32> ) -> vec3<f32>
  {
    return pow(a, vec3<f32>(-0.5));
  }

  fn rsqrt( a : f32 ) -> f32
  {
    return pow(a, -0.5);
  }
`,Qo=`
    fn perturbNormal(  worldPos:vec3<f32>,  surf_norm:vec3<f32>,  mapN:vec3<f32> , normalScale:f32 , face:f32 ) -> vec3<f32> {
        var q0 = vec3<f32>( dpdx( worldPos.x ), dpdx( worldPos.y ), dpdx( worldPos.z ) );
        var q1 = vec3<f32>( dpdy( worldPos.x ), dpdy( worldPos.y ), dpdy( worldPos.z ) );
        var st0 = dpdx( ORI_VertexVarying.fragUV0.xy );
        var st1 = dpdy( ORI_VertexVarying.fragUV0.xy );
        var N = surf_norm;
        var q1perp = cross( q1, N );
        var q0perp = cross( N, q0 );

        #if USE_TANGENT
            var T = ORI_VertexVarying.TANGENT.xyz ;
        #else
            var T = q1perp * st0.x + q0perp * st1.x;
        #endif
        
        var B = q1perp * st0.y + q0perp * st1.y;

        var det = max( dot( T, T ), dot( B, B ) );
        var scale = 1.0 ;
        if( det != 0.0 ){
            scale = inverseSqrt( det ) ;
        }
        #if USE_TANGENT
            scale = scale * ORI_VertexVarying.TANGENT.w ;
        #endif

        scale *= normalScale;
        return normalize( (T * ( -mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z ) * face ) ;
    }

    fn unpackNormalMap( normal : vec3<f32> ) -> vec3<f32>
    {
        var normalTex = vec3<f32>( normal.xyz * 2.0 - 1.0 ) ;
        return (normalTex);
    }

    fn unPackNormal(normal : vec3<f32> , height:f32 ) -> vec3<f32>{
        var face = 1.0 ;
        if(ORI_VertexVarying.face){
            face = 1.0 ;
        }else{
            face = -1.0 ;
        }

        #if USE_RGNORMAL
            return unPackRGNormal(normal,height,face);
        #else
            var n = normal ;
            #if USE_NORMALFILPY
            n.y = 1.0 - n.y ; 
            #endif
            
            var mapNormal: vec3<f32> = unpackNormalMap(n) ;
            return perturbNormal(ORI_VertexVarying.vWorldPos.xyz , ORI_VertexVarying.vWorldNormal.xyz , mapNormal , height , face  ) ;
        #endif
    }

    fn unPackRGNormal(normal : vec3<f32> , height:f32 , face:f32) -> vec3<f32> {
        var d = normal.rg * 2.0 - 1.0 ;
        var l = 1.0 - saturate(dot(d,d));
        var s = sqrt(l);
        var rg = d * height ; 
        var mapNormal = vec3<f32>(rg,s);
        var outN = perturbNormal(ORI_VertexVarying.vWorldPos.xyz,ORI_VertexVarying.vWorldNormal,mapNormal,1.0,face) ;
        return outN ;
    }
`,Vo=`
    struct FragmentVarying {
        @location(0) fragUV0: vec2<f32>,
        @location(1) fragUV1: vec2<f32>,
        @location(2) viewPosition: vec4<f32>,
        @location(3) fragPosition: vec4<f32>,
        @location(4) vWorldPos: vec4<f32>,
        @location(5) vWorldNormal: vec3<f32>,
        @location(6) vColor: vec4<f32>,

        #if USE_SHADOWMAPING
            @location(7) vShadowPos: vec4<f32>,
        #endif

        #if USE_TANGENT
            @location(8) TANGENT: vec4<f32>,
        #endif
        
        @builtin(front_facing) face: bool,
        @builtin(position) fragCoord : vec4<f32>
    };
`,Bs=`
    struct FragmentOutput {
        @location(0) color: vec4<f32>,
        #if USE_WORLDPOS
            @location(1) worldPos: vec4<f32>,
        #endif
        #if USEGBUFFER
            @location(2) worldNormal: vec4<f32>,
            @location(3) material: vec4<f32>,
        #endif

        #if USE_OUTDEPTH
            @builtin(frag_depth) out_depth: f32
        #endif
    };
`,Ho=`
    struct ShadingInput{
        BaseColor:vec4<f32>,
        Roughness:f32,
        Metallic:f32,
        Specular:f32,
        EmissiveColor:vec4<f32>,
        SurfaceColor:vec4<f32>,
        Normal:vec3<f32>,
        Tangent:vec4<f32>,
        WorldPositionOffset:vec3<f32>,
        AmbientOcclusion:f32,
        PixelDepthOffset:f32,

        Opacity:f32,
        OpacityMask:f32,

        Refraction:f32,
        FragDepth:f32
    }
`,Yo=`
    #if USE_IES_PROFILE 
        @group(1) @binding(auto)
        var iesTextureArrayMapSampler : sampler;
        @group(1) @binding(auto)
        var iesTextureArrayMap: texture_2d_array<f32> ;
    #endif

    fn getLightIESProfileAtt( wPos : vec3<f32> , light:LightData ) -> f32
    {
        #if USE_IES_PROFILE 
            let tangent = vec3<f32>(1.0,0.0,0.0);
            let lightBitangent = normalize( cross( tangent, light.direction ) );
            let lightMatrix = mat4x4( vec4<f32>(light.direction.xyz, 0.0), vec4<f32>(lightBitangent.xyz, 0.0), vec4<f32>(tangent.xyz, 0.0), vec4<f32>(0.0, 0.0, 0.0, 1.0) );
            let lightMatrixInv = transpose(lightMatrix);
            let lightPos = light.position.xyz;
            let l = lightPos - wPos; 
            let toLight = normalize(l);
            let localToLight = (vec4<f32>(toLight.xyz, 0.0) * lightMatrixInv).xyz;
            let dotProd = dot(toLight, light.direction);
            let angle = asin(dotProd);
            let normAngle = (angle / PI) + 0.5 ;
            let tangentAngle = atan2( -localToLight.z, -localToLight.x ); 
            let normTangentAngle = tangentAngle / (PI * 2.0) + 0.5 ;
            if(light.ies >= 0.0){
                return textureSampleLevel(iesTextureArrayMap, iesTextureArrayMapSampler, vec2<f32>(normAngle , normTangentAngle) , i32(light.ies) , 0.0).r ;
            }else{
                return 1.0;
            }
        #else 
            return 1.0;
        #endif
    }

`,Xo=`
    #if USE_SHADOWMAPING
    @group(1) @binding(auto) var shadowMapSampler: sampler;
    @group(1) @binding(auto) var shadowMap: texture_depth_2d_array;
    #endif

    @group(1) @binding(auto) var pointShadowMapSampler: sampler;
    @group(1) @binding(auto) var pointShadowMap: texture_depth_cube_array;

    struct ShadowStruct{
      directShadowVisibility: array<f32, 8>,
      pointShadows: array<f32, 8>,
    }

    var<private>shadowStrut: ShadowStruct;

    struct ShadowBuffer{
      nDirShadowStart: i32,
      nDirShadowEnd: i32,
      nPointShadowStart: i32,
      nPointShadowEnd: i32,
      shadowLights:array<u32,16>
    }

    #if DEBUG_CLUSTER
        @group(2) @binding(6) var<storage,read> shadowBuffer: ShadowBuffer;
    #else
        @group(2) @binding(5) var<storage,read> shadowBuffer: ShadowBuffer;
    #endif

    fn useShadow(){
        shadowStrut.directShadowVisibility = array<f32, 8>( 1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0) ;
        shadowStrut.pointShadows = array<f32, 8>( 1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0) ;
        directShadowMaping(globalUniform.shadowBias);
        pointShadowMapCompare(globalUniform.pointShadowBias);
    }

    fn calcBasicBias(shadowWorldSize:f32, shadowDepthTexSize:f32, near:f32, far:f32) -> f32{
      var bias = shadowWorldSize / shadowDepthTexSize;
      bias = bias / (far - near);
      return bias * 2.0;
    }

    const dirCount:i32 = 8 ;
    const pointCount:i32 = 8 ;
    const csmCount:i32 = ${nt.Cascades} ;
    var<private> csmLevel:i32 = -1;
    fn directShadowMaping(shadowBias: f32)  {
      #if USE_SHADOWMAPING
        let enableCSM:bool = globalUniform.enableCSM > 0.5;
        for (var i: i32 = 0; i < dirCount ; i = i + 1) {
          if( i >= shadowBuffer.nDirShadowStart && i < shadowBuffer.nDirShadowEnd ){
            let ldx = shadowBuffer.shadowLights[i];
            var light = lightBuffer[ldx];
            var shadowIndex = i32(light.castShadow);
            var visibility = 1.0;
            var shadowMatrix:mat4x4<f32>;
            #if USE_CSM
              if(enableCSM && shadowIndex == 0){
                var totalWeight = 0.0;
                visibility = 0.0;
                var validCount = 0;
                for(var csm:i32 = 0; csm < csmCount; csm ++){
                  var csmShadowBias = globalUniform.csmShadowBias[csm];
                  shadowMatrix = globalUniform.csmMatrix[csm];
                  let csmShadowResult = directShadowMapingIndex(light, shadowMatrix, csm, csmShadowBias);
                  if(csmShadowResult.y < 0.5){
                    validCount ++;

                    var uv = 2.0 * csmShadowResult.zw - vec2<f32>(1.0);
                    uv = saturate(vec2<f32>(1.0) - abs(uv));
                    uv /= clamp(globalUniform.csmMargin, 0.01, 0.5);
                    var weight:f32 = min(uv.x, 1.0);
                    weight = min(weight, uv.y);

                    if(validCount == 1 && csm == csmCount - 1){
                      visibility = 1.0 - weight + csmShadowResult.x * weight;
                      totalWeight = 1.0;
                    }else{
                      weight *= 1.0 - totalWeight;
                      visibility += csmShadowResult.x * weight;
                      totalWeight += weight;
                    }
                    // if(weight < 1.0){
                    //   visibility += 0.1;
                    // }
                    if(validCount >= 2 || totalWeight >= 0.99){
                      csmLevel = csm;
                      break;
                    }
                  }
                }
                totalWeight += 0.0001;
                if(validCount == 0){
                  visibility = 1.0;
                }else{
                  visibility = visibility / totalWeight;
                }
              }else{
                shadowMatrix = globalUniform.shadowMatrix[shadowIndex];
                if(enableCSM) {
                  shadowIndex += csmCount - 1;
                }
                visibility = directShadowMapingIndex(light, shadowMatrix, shadowIndex, shadowBias).x;
              }
            #else
              shadowMatrix = globalUniform.shadowMatrix[shadowIndex];
              visibility = directShadowMapingIndex(light, shadowMatrix, shadowIndex, shadowBias).x;
            #endif 
            shadowStrut.directShadowVisibility[i] = visibility;
          }
        }
      #endif
    }

    fn directShadowMapingIndex(light:LightData, matrix:mat4x4<f32>, depthTexIndex:i32, shadowBias:f32) -> vec4<f32>
    {
      var visibility = 1.0;
      var isOutSideArea:f32 = 1.0;
      var varying_shadowUV:vec2<f32> = vec2<f32>(0.0);
      #if USE_SHADOWMAPING
        var shadowPosTmp = matrix * vec4<f32>(ORI_VertexVarying.vWorldPos.xyz, 1.0);
        var shadowPos = shadowPosTmp.xyz / shadowPosTmp.w;
        varying_shadowUV = shadowPos.xy * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5, 0.5);
        if (varying_shadowUV.x <= 1.0
          && varying_shadowUV.x >= 0.0
          && varying_shadowUV.y <= 1.0
          && varying_shadowUV.y >= 0.0
          && shadowPosTmp.z <= 1.0
          && shadowPosTmp.z >= 0.0)
        {
          visibility = 0.0;
          isOutSideArea = 0.0;
          var uvOnePixel = 1.0 / vec2<f32>(globalUniform.shadowMapSize);
          var totalWeight = 0.0;
          var NoL = abs(dot(normalize(ORI_VertexVarying.vWorldNormal), normalize(light.direction)));
          var bias = shadowBias / max(NoL, 0.000001);
          for (var y = -1; y <= 1; y++) {
            for (var x = -1; x <= 1; x++) {
              var offset = vec2<f32>(f32(x), f32(y)) * uvOnePixel;
              
              // visibility += textureSampleCompare(shadowMap, shadowMapSampler, varying_shadowUV + offset, depthTexIndex, shadowPos.z - bias);
              var depth = textureSampleLevel(shadowMap, shadowMapSampler, varying_shadowUV + offset, depthTexIndex, 0);
              if ((shadowPos.z - bias ) < depth) {
                visibility += 1.0 ;//* dot(offsetDir, dir.xyz);
              }
              totalWeight += 1.0;
            }
          }
          visibility /= totalWeight;
          visibility += 0.001;
        }
      #endif
      return vec4<f32>(visibility, isOutSideArea, varying_shadowUV);
    }

    fn pointShadowMapCompare(shadowBias: f32){
      let worldPos = ORI_VertexVarying.vWorldPos.xyz;
      let offset = 0.1;

      for (var i: i32 = 0; i < pointCount ; i = i + 1) {
        if( i >= shadowBuffer.nPointShadowStart && i < shadowBuffer.nPointShadowEnd ){
          let ldx = shadowBuffer.shadowLights[i];
          let light = lightBuffer[ldx] ;

          #if USE_SHADOWMAPING
          let lightPos = light.position.xyz;
          var shadow = 0.0;
          let frgToLight = worldPos - lightPos.xyz;
          var dir: vec3<f32> = normalize(frgToLight);
          var len = length(frgToLight);
          var bias = max(shadowBias * globalUniform.far * (1.0 - dot(ORI_ShadingInput.Normal, dir)), 0.005);
  
          #if USE_PCF_SHADOW
          let samples = 4.0;
          for (var x: f32 = -offset; x < offset; x += offset / (samples * 0.5)) {
            for (var y: f32 = -offset; y < offset; y += offset / (samples * 0.5)) {
              for (var z: f32 = -offset; z < offset; z += offset / (samples * 0.5)) {
                let offsetDir = normalize(dir.xyz + vec3<f32>(x, y, z));
                var depth = textureSampleLevel(pointShadowMap, pointShadowMapSampler, offsetDir, light.castShadow, 0);
                depth *= globalUniform.far;
                if ((len - bias) > depth) {
                  shadow += 1.0 * dot(offsetDir, dir.xyz);
                }
              }
            }
          }
          shadow = min(max(shadow / (samples * samples * samples), 0.0), 1.0);
          #endif
  
          #if USE_SOFT_SHADOW
          let vDis = length(globalUniform.CameraPos.xyz - worldPos.xyz);
          let sampleRadies = globalUniform.shadowSoft;
          let samples = 20;
          for (var j: i32 = 0; j < samples; j += 1) {
            let offsetDir = normalize(dir.xyz + sampleOffsetDir[j] * sampleRadies);
            var depth = textureSampleLevel(pointShadowMap, pointShadowMapSampler, offsetDir, light.castShadow, 0);
            depth *= globalUniform.far;
            if ((len - bias) > depth) {
              shadow += 1.0 * dot(offsetDir, dir.xyz);
            }
          }
          shadow = min(max(shadow / f32(samples), 0.0), 1.0);
          #endif
  
          #if USE_HARD_SHADOW
          var depth = textureSampleLevel(pointShadowMap, pointShadowMapSampler, dir.xyz, light.castShadow, 0);
          depth *= globalUniform.far;
          if ((len - bias) > depth) {
            shadow = 1.0;
          }
          #endif
  
          for (var j = 0; j < pointCount ; j+=1 ) {
              if(i32(light.castShadow) == j){
                shadowStrut.pointShadows[j] = 1.0 - shadow ;
              }
          }
          #endif
        }
        }
    }

    #if USE_SOFT_SHADOW
    var<private>sampleOffsetDir : array<vec3<f32>, 20> = array<vec3<f32>, 20>(
      vec3<f32>(1.0, 1.0, 1.0), vec3<f32>(1.0, -1.0, 1.0), vec3<f32>(-1.0, -1.0, 1.0), vec3<f32>(-1.0, 1.0, 1.0),
      vec3<f32>(1.0, 1.0, -1.0), vec3<f32>(1.0, -1.0, -1.0), vec3<f32>(-1.0, -1.0, -1.0), vec3<f32>(-1.0, 1.0, -1.0),
      vec3<f32>(1.0, 1.0, 0.0), vec3<f32>(1.0, -1.0, 0.0), vec3<f32>(-1.0, -1.0, 0.0), vec3<f32>(-1.0, 1.0, 0.0),
      vec3<f32>(1.0, 0.0, 1.0), vec3<f32>(-1.0, 0.0, 1.0), vec3<f32>(1.0, 0.0, -1.0), vec3<f32>(-1.0, 0.0, -1.0),
      vec3<f32>(0.0, 1.0, 1.0), vec3<f32>(0.0, -1.0, 1.0), vec3<f32>(0.0, -1.0, -1.0), vec3<f32>(0.0, 1.0, -1.0),
    );
    #endif
`,Wo=`
#include "IrradianceVolumeData_frag"
    fn pow3(  x : f32 ) -> f32
    {
        return x*x*x;
    }

    struct IrradianceField {
        probeStartPosition: vec4<f32>,
        probeCounts:vec4<f32>,
        probeStep:f32,
        irradianceTextureWidth:f32,
        irradianceTextureHeight:f32,
        irradianceProbeSideLength:f32,
    };

    @group(1) @binding(auto)
    var irradianceMapSampler: sampler;
    @group(1) @binding(auto)
    var irradianceMap: texture_2d<f32>;
    @group(1) @binding(auto)
    var irradianceDepthMapSampler: sampler;
    @group(1) @binding(auto)
    var irradianceDepthMap: texture_2d<f32>;
    @group(2) @binding(7)
    var<storage,read> irradianceData : IrradianceVolumeData ;

    var<private> irradianceFieldSurface: IrradianceField;
    var<private> energyPreservation: f32 = 0.85;
    var<private> quaternion:vec4<f32> = vec4<f32>(0.0, -0.7071067811865475, 0.7071067811865475, 0.0);

    fn getIrradianceFieldSurface() -> IrradianceField{
        let data = irradianceData ;
        irradianceFieldSurface.probeStartPosition = vec4<f32>(data.startX, data.startY, data.startZ, 0.0);
        irradianceFieldSurface.probeCounts = vec4<f32>(data.gridXCount, data.gridYCount, data.gridZCount, 0.0);
        irradianceFieldSurface.probeStep = data.ProbeSpace;
        irradianceFieldSurface.irradianceTextureWidth = data.OctRTMaxSize;
        irradianceFieldSurface.irradianceTextureHeight = data.OctRTMaxSize;
        irradianceFieldSurface.irradianceProbeSideLength = data.OctRTSideSize;
        return irradianceFieldSurface;
    }

    fn rotateDir(n:vec3<f32>) -> vec3<f32>{
       return normalize(applyQuaternion(-n, quaternion));
    }

    fn square1f(v:f32) -> f32 {
        return v * v ;
     }

   fn square(v:vec3<f32>) -> vec3<f32>{
      return v*v;
   }

    fn getIrradiance() -> vec4<f32>{
        var irradiance = sampleIrradianceField();
        var outerVolumeFactor:f32 = getOuterVolume(irradianceFieldSurface, ORI_VertexVarying.vWorldPos.xyz);
        irradiance *= outerVolumeFactor;
       return irradiance ;
    }
    
    fn debugProbe(id:i32) -> vec4<f32>{
        getIrradianceFieldSurface();
        var direction = normalize(ORI_VertexVarying.vWorldNormal);
        direction = applyQuaternion(-direction, quaternion);
        var probeTextureUV : vec2<f32> = textureCoordFromDirection(normalize(direction),
            id,
            irradianceFieldSurface.irradianceTextureWidth,
            irradianceFieldSurface.irradianceTextureHeight,
            irradianceFieldSurface.irradianceProbeSideLength);

        var probeIrradiance: vec4<f32> = textureSampleLevel(irradianceMap, irradianceMapSampler, probeTextureUV ,0.0);
        return probeIrradiance;
    }
    
    fn debugProbeDepth(id:i32) -> vec4<f32>{
        getIrradianceFieldSurface();
        var direction = normalize(ORI_VertexVarying.vWorldNormal);
        direction = applyQuaternion(-direction, quaternion);
        var probeTextureUV : vec2<f32> = textureCoordFromDirection(normalize(direction),
            id,
            irradianceFieldSurface.irradianceTextureWidth,
            irradianceFieldSurface.irradianceTextureHeight,
            irradianceFieldSurface.irradianceProbeSideLength);
        
        var probeIrradiance: vec4<f32> = textureSampleLevel(irradianceDepthMap, irradianceDepthMapSampler, probeTextureUV ,0.0);
        probeIrradiance.x = probeIrradiance.x / irradianceData.maxDistance;
        probeIrradiance.y = 0.0;
        probeIrradiance.z = 0.0;
        probeIrradiance.w = 1.0;
        return probeIrradiance;
    }
    
    fn getOuterVolume(L:IrradianceField, position:vec3<f32>) -> f32{
        let halfWidth:vec3<f32> = 0.5 * (L.probeCounts.xyz - 1.0) * L.probeStep;
        let edgeWidth:vec3<f32> = halfWidth + L.probeStep;
        let centerPosition:vec3<f32> = halfWidth + L.probeStartPosition.xyz;
        let clampPos = min(edgeWidth, abs(position - centerPosition));
        
        let factorX = getOuterAxis(clampPos.x, edgeWidth.x, L.probeStep);
        let factorY = getOuterAxis(clampPos.y, edgeWidth.y, L.probeStep);
        let factorZ = getOuterAxis(clampPos.z, edgeWidth.z, L.probeStep);
        return factorX * factorY * factorZ;
    }
    
    fn getOuterAxis(current:f32, edge:f32, space:f32) -> f32{
        return clamp((edge - current) / space, 0.0, 1.0);
    }

    fn getBaseGridCoord(L:IrradianceField, X:vec3<f32>) -> vec3<i32> {
        var offsetIndex = (X - L.probeStartPosition.xyz) / irradianceFieldSurface.probeStep;
        return clamp(vec3<i32>(offsetIndex.xyz), vec3<i32>(0), vec3<i32>(L.probeCounts.xyz) - 1);
    }

    fn gridCoordToProbeIndex(L:IrradianceField, grid:vec3<i32>) -> i32
    {
        return grid.x + i32(L.probeCounts.x) * grid.z + grid.y * i32(L.probeCounts.z * L.probeCounts.x);
    }

    fn gridCoordToPosition(L:IrradianceField, grid:vec3<i32>) -> vec3<f32>
    {
        var pos:vec3<f32> = vec3<f32>(grid.xyz) * L.probeStep + L.probeStartPosition.xyz;
        return pos;
    }

    fn textureCoordFromDirection(dir:vec3<f32>, probeIndex:i32, width:f32, height:f32, sideLength:f32) -> vec2<f32>
    {
        var uv = getWriteOctUVByID(dir, u32(probeIndex), sideLength) ;
        uv.x = uv.x / irradianceFieldSurface.irradianceTextureWidth;
        uv.y = uv.y / irradianceFieldSurface.irradianceTextureHeight;
        return uv ;
    }

    fn getWriteOctUVByID(dir:vec3<f32> , probeID:u32, size: f32) -> vec2<f32>
    {
        var blockCount = u32(irradianceFieldSurface.probeCounts.x * irradianceFieldSurface.probeCounts.z) ;
        var offsetX = (probeID % blockCount) % u32(irradianceFieldSurface.probeCounts.x) ;
        var offsetY = u32(irradianceFieldSurface.probeCounts.z - 1.0) - (probeID % blockCount) / u32(irradianceFieldSurface.probeCounts.x) ;
        var offsetZ = probeID / blockCount ;

        var pixelCoord = (( octEncode(dir) + 1.0 ) * 0.5) * vec2<f32>(size,size) ;

        var blockOffset = vec2<f32>(0.0);
        blockOffset.x = f32(offsetX) * size;
        blockOffset.y = f32(offsetY) * size + f32(offsetZ) * irradianceFieldSurface.probeCounts.z * size;

        let mapHeight = u32(irradianceFieldSurface.irradianceTextureHeight);
        var probeCounts:vec3<f32> = irradianceFieldSurface.probeCounts.xyz;

        var gridOffsetFrom = vec2<i32>(blockOffset) + 1;
        var gridOffsetTo = offsetByCol(gridOffsetFrom, size, mapHeight, probeCounts);

        pixelCoord = pixelCoord + vec2<f32>(gridOffsetTo - 1) + vec2<f32>(vec2<i32>(vec2<f32>(gridOffsetTo) / size) * 2);

        return pixelCoord + 1.0 ;
    }

    fn offsetByCol(pixelCoord0:vec2<i32>, octSideSize:f32, mapHeight:u32, counts:vec3<f32>) -> vec2<i32>
    {
      var pixelCoord = pixelCoord0;
      let blockSize:vec2<i32> = vec2<i32>(i32(octSideSize * counts.x),  i32(octSideSize * counts.z));
      let blockSizeYBorder:i32 = i32((octSideSize + 2.0) * counts.z);
      let blockMaxRowBorder:i32 = i32(mapHeight) / blockSizeYBorder;
      let pixelCountYMax:i32 = blockMaxRowBorder * i32(octSideSize * counts.z);
      let col:i32 = pixelCoord.y / pixelCountYMax;
      pixelCoord.x = col * i32(octSideSize * counts.x) + pixelCoord.x;
      pixelCoord.y = pixelCoord.y % pixelCountYMax;
      return pixelCoord;
    }

    var<private> wpNormal:vec3<f32> ;
    fn sampleIrradianceField() -> vec4<f32>{
        wpNormal = ORI_ShadingInput.Normal.xyz ;
        var wo:vec3<f32> = ORI_CameraWorldDir ;
        var wsN:vec3<f32> = normalize(wpNormal);
        var direction:vec3<f32> = wpNormal;
        var worldPosition: vec3<f32> = ORI_VertexVarying.vWorldPos.xyz;
   
        getIrradianceFieldSurface();

        let surfaceBias = (wsN + 3.0 * wo) * irradianceData.normalBias ;

        var irradiance = vec3<f32>(0.0, 0.0, 0.0);
        var accumulatedWeights = 0.0;
        var biasedWorldPosition = (worldPosition + surfaceBias);

        var baseProbeCoords: vec3<i32> = getBaseGridCoord(irradianceFieldSurface, worldPosition);
        
        var baseProbeWorldPosition: vec3<f32> = gridCoordToPosition(irradianceFieldSurface, baseProbeCoords) ;
        
        var gridSpaceDistance = (biasedWorldPosition - baseProbeWorldPosition);

        // alpha is how far from the floor(currentVertex) position. on [0, 1] for each axis.
        var alpha: vec3<f32> = clamp(gridSpaceDistance / (irradianceFieldSurface.probeStep), vec3<f32>(0.0), vec3<f32>(1.0));
        // let irradianceDir = rotateDir(wsN.xyz);
        // Iterate over adjacent probe cage
        for (var i:i32 = 0; i < 8; i = i + 1) {
            var adjacentProbeOffset : vec3<i32> = vec3<i32>(i, i32(f32(i) * 0.5), i32(f32(i) * 0.25)) & vec3<i32>(1);
            var adjacentProbeCoords: vec3<i32> = clamp(baseProbeCoords + adjacentProbeOffset, vec3<i32>(0),  vec3<i32>(irradianceFieldSurface.probeCounts.xyz) - 1) ;
            
            var adjacentProbeIndex :i32 = gridCoordToProbeIndex(irradianceFieldSurface, adjacentProbeCoords);
            var adjacentProbeWorldPosition :vec3<f32> = gridCoordToPosition(irradianceFieldSurface, adjacentProbeCoords) ;//+ (wsN + 3.0 * w_o) * globalUniform.normalBias;
         
            var worldPosToAdjProbe = normalize(adjacentProbeWorldPosition - worldPosition);
            var biasedPosToAdjProbe = normalize(adjacentProbeWorldPosition - biasedWorldPosition);
            var biasedPosToAdjProbeDist = length(adjacentProbeWorldPosition - biasedWorldPosition);

            let trilinear = max(vec3<f32>(0.001), mix(1.0 - alpha, alpha, vec3<f32>(adjacentProbeOffset)));
            let trilinearWeight = (trilinear.x * trilinear.y * trilinear.z);
            var weight = 1.0;

            var wrapShading = (dot(worldPosToAdjProbe, direction) + 1.0) * 0.5;
            weight *= (wrapShading * wrapShading) + 0.2;

            var depthDir = -biasedPosToAdjProbe;//probe - world
            depthDir = applyQuaternion(depthDir, quaternion);
            var probeTextureUV : vec2<f32> = textureCoordFromDirection(depthDir.xyz,
                adjacentProbeIndex,
                irradianceFieldSurface.irradianceTextureWidth,
                irradianceFieldSurface.irradianceTextureHeight,
                irradianceFieldSurface.irradianceProbeSideLength);

            var filteredDistance : vec2<f32> = 2.0 * textureSampleLevel(irradianceDepthMap, irradianceDepthMapSampler, probeTextureUV,0.0).rg ;
           
            var variance = abs((filteredDistance.x * filteredDistance.x) - filteredDistance.y);

            var chebyshevWeight = 1.0;
            if(biasedPosToAdjProbeDist > filteredDistance.x ) // occluded
            {
                var v = biasedPosToAdjProbeDist - filteredDistance.x ;
                chebyshevWeight = variance / (variance + (v * v));
                // Increase the contrast in the weight
                chebyshevWeight = max((chebyshevWeight * chebyshevWeight * chebyshevWeight), 0.0);
            }

            weight *= max(0.05, chebyshevWeight);
            weight = max(0.000001, weight);

            let crushThreshold = 0.2;
            if (weight < crushThreshold)
            {
                weight *= (weight * weight) * (1.0 / (crushThreshold * crushThreshold));
            }

            weight *= trilinearWeight;
            
            //worldPosToAdjProbe
            let rotateDir = applyQuaternion(-direction, quaternion);
            probeTextureUV = textureCoordFromDirection((rotateDir),
            adjacentProbeIndex,
            irradianceFieldSurface.irradianceTextureWidth,
            irradianceFieldSurface.irradianceTextureHeight,
            irradianceFieldSurface.irradianceProbeSideLength);

            var probeIrradiance: vec3<f32> = textureSampleLevel(irradianceMap, irradianceMapSampler, probeTextureUV ,0.0).xyz;

            var exponent =  irradianceData.ddgiGamma * 0.5;
            probeIrradiance = pow(probeIrradiance, vec3<f32>(exponent));
            
            irradiance += (weight * probeIrradiance);
            accumulatedWeights += weight;
        }

        if(accumulatedWeights == 0.0){
            return vec4<f32>(0.0, 0.0, 0.0,1.0);
        }

        irradiance *= (1.0 / accumulatedWeights);   
        irradiance *= irradiance;                   

        irradiance *= 6.2831853071795864;
        irradiance *= irradianceData.indirectIntensity;
        return vec4<f32>(irradiance,1.0) ;
    }

`,jo=`
#include "Clearcoat_frag"
    #include "EnvMap_frag"
    #include "BrdfLut_frag"
    #include "ColorUtil_frag"
    
    struct FragData {
        Ao: f32,
        Metallic: f32,
        Roughness: f32,

        Albedo: vec4<f32>,
        Emissive: vec3<f32>,

        N: vec3<f32>,
        V: vec3<f32>,
        R: vec3<f32>,

        F0: vec3<f32>,
        F: vec3<f32>,
        KS: vec3<f32>,
        KD: vec3<f32>,
        Shadow: f32,
        Indirect: f32,
        Reflectance: f32,

        NoV: f32,
        FaceDirection:f32,

        ClearcoatRoughness:f32,
        EnvColor: vec3<f32>,
        Irradiance: vec3<f32>,

        LightChannel: vec3<f32>,
        TangentChannel: vec3<f32>,
    };

    var<private> fragData: FragData;

    struct BxDFContext
    {
        NoV : f32 ,
        NoL : f32 ,
        VoL : f32 ,
        NoH : f32 ,
        VoH : f32
    };

    fn getContext( N:vec3<f32>, V:vec3<f32>, H:vec3<f32>, L:vec3<f32> ) -> BxDFContext
    {
        var Context:BxDFContext ;
        Context.NoL = saturate(dot(N, L))  ;
        Context.NoV = saturate(dot(N, V))  ;
        Context.VoL = saturate(dot(V, L)) ;
        Context.NoH = saturate(dot(N, H));
        Context.VoH = saturate(dot(V, H));

        // Context.NoL = max(dot(N, L),0.0);
        // Context.NoV = max(dot(N, V),0.0);
        // Context.VoL = max(dot(V, L),0.0) ;
        // Context.NoH = saturate(dot(N, H));
        // Context.VoH = max(dot(V, H),0.0);
        return Context ;
    }

    // convert roughness to mipmapLevel
    fn roughnessToMipmapLevel( roughness: f32 , mipmapCount:i32 ) -> f32{
        let level = roughness * (1.7 - 0.7 * roughness );
        return level * f32(mipmapCount);
    }

    fn IORToF0(ior:f32)->f32{
        var dc = ior - 1.0 ;
        dc *= dc ;
        var dt = ior + 1.0 ;
        dt *= dt ;
        return dc / dt ;
    }

    fn Fd90( NoL:f32, roughness:f32) -> f32
    {
        return (2.0 * NoL * roughness) + 0.4;
    }

    fn KDisneyTerm( NoL:f32, NoV:f32 , roughness:f32) -> f32
    {
        return (1.0 + Fd90(NoL, roughness) * pow(1.0 - NoL, 5.0)) * (1.0 + Fd90(NoV, roughness) * pow(1.0 - NoV, 5.0));
    }

    fn FresnelSchlick( NoV:f32,  F0:vec3<f32>) -> vec3<f32>
    {
        return F0 + (1.0 - F0) * pow(1.0 - NoV, 5.0);
    }

    fn FresnelTerm( cosA:f32,  F0:vec3<f32>) -> vec3<f32>
    {
        let t = pow5( 1.0 - cosA );
        return F0 + (1.0 - F0) * t;
    }

    fn FresnelLerp( cosA:f32, F0:vec3<f32> , F90:vec3<f32>) -> vec3<f32>
    {
        let t = pow5( 1.0 - cosA );
        return mix( F0 ,F90,t ) ;
    }

    fn FresnelSchlickRoughness( NoV:f32,  F0:vec3<f32>,  roughness:f32) -> vec3<f32>
    {
        return F0 + (max(vec3(roughness), F0) - F0) * pow(1.0 - NoV, 5.0);
    }

    fn DistributionGGX( NdotH:f32 ,  roughness:f32 ) -> f32
    {
        let alpha = roughness * roughness;
        let alpha2 = roughness * roughness;

        let NdotH2 = NdotH * NdotH;

        let nom   = alpha2;
        var denom = (NdotH2 * (alpha2 - 1.0) + 1.0);
        denom = PI * denom * denom;

        return nom / denom;
    }

    // [Heitz 2014, "Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs"]
    fn Vis_SmithJoint( NoV : f32 ,  NoL : f32 ,  a2 : f32) -> f32
    {
        var Vis_SmithV = NoL * sqrt(NoV * (NoV - NoV * a2) + a2);
        var Vis_SmithL = NoV * sqrt(NoL * (NoL - NoL * a2) + a2);
        return 0.5 * rcp(Vis_SmithV + Vis_SmithL);
    }

    fn GeometrySchlickGGX( NdotV : f32 , roughness : f32 ) -> f32
    {
        //roughness compute ks
        let r = (roughness + 1.0);
        let k = (r*r) / 8.0;

        let nom   = NdotV;
        let denom = NdotV * (1.0 - k) + k;
        
        return nom / denom;
    }
    
    fn GeometrySmith( NdotV:f32 , NdotL:f32 , roughness : f32) -> f32
    {
        // let NdotV = max(dot(N, V), 0.0);
        // let NdotL = max(dot(N, L), 0.0);
        let ggx1 = GeometrySchlickGGX(NdotV, roughness);
        let ggx2 = GeometrySchlickGGX(NdotL, roughness);
        return ggx1 * ggx2;
    }

    fn GeometryAttenuationGGXSmith( NdotL:f32,  NdotV:f32,  roughness:f32) -> f32
    {
        var NdotL2 = NdotL * NdotL;
        var NdotV2 = NdotV * NdotV;
        var kRough2 = roughness * roughness + 0.0001;

        var ggxL = (2.0 * NdotL) / (NdotL + sqrt(NdotL2 + kRough2 * (1.0 - NdotL2)));
        var ggxV = (2.0 * NdotV) / (NdotV + sqrt(NdotV2 + kRough2 * (1.0 - NdotV2)));

        return ggxL * ggxV;
    }

    fn colorLinear( colorVector:vec3<f32> ) -> vec3<f32>
    {
        var linearColor = pow(colorVector.rgb, vec3<f32>(2.2));
        return linearColor;
    }

    fn computeFresnelSchlick( NoV:f32 , F0:vec3<f32>) -> vec3<f32>
    {
        return F0 + (1.0 - F0) * pow(clamp(1.0 - NoV,0.0,1.0), 5.0);
    }

    fn computeFresnelSchlickRoughness(NoV:f32 , F0:vec3<f32>,  roughness:f32) -> vec3<f32>
    {
        return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(clamp(1.0 - fragData.NoV,0.0,1.0), 5.0);
    }

    fn computeDistributionGGX( N:vec3<f32>,  H:vec3<f32>,  roughness:f32) -> f32
    {
        var alpha = roughness * roughness;
        var alpha2 = alpha * alpha; 

        var NdotH = saturate(dot(N, H));
        var NdotH2 = NdotH * NdotH;

        return (alpha2) / (PI * (NdotH2 * (alpha2 - 1.0) + 1.0) * (NdotH2 * (alpha2 - 1.0) + 1.0));
    }

    fn D_GGX( NoH:f32,  roughness:f32 ) -> f32
    {
        var d = ( NoH * roughness - NoH ) * NoH + 1.0;	// 2 mad
        return roughness / ( PI*d*d );					// 4 mul, 1 rcp
    }

    fn computeGeometryAttenuationGGXSmith( NdotL:f32 ,  NdotV:f32,  roughness:f32) -> f32
    {
        var NdotL2 = NdotL * NdotL;
        var NdotV2 = NdotV * NdotV;
        var kRough2 = roughness * roughness + 0.0001;

        var ggxL = (2.0 * NdotL) / (NdotL + sqrt(NdotL2 + kRough2 * (1.0 - NdotL2)));
        var ggxV = (2.0 * NdotV) / (NdotV + sqrt(NdotV2 + kRough2 * (1.0 - NdotV2)));

        return ggxL * ggxV;
    }

    fn Vis_Smith(  NoL:f32 ,  NoV:f32,  a2:f32 )-> f32
    {
        var Vis_SmithV = NoV + sqrt( NoV * (NoV - NoV * a2) + a2 );
        var Vis_SmithL = NoL + sqrt( NoL * (NoL - NoL * a2) + a2 );
        return rcp( Vis_SmithV * Vis_SmithL );
    }

    fn simpleBRDF( albedo:vec3<f32>, N:vec3<f32>, V:vec3<f32>,L:vec3<f32>,att:f32,lightColor:vec3<f32>,roughness:f32 ,metallic:f32)-> vec3<f32>{
        let H = normalize(V + L);
        let Context:BxDFContext = getContext(N,V,H,L);

        let F0 = mix(vec3<f32>(materialUniform.materialF0.rgb), albedo , metallic);
        let D = DistributionGGX( Context.NoH , roughness);
        let G = GeometrySmith(Context.NoV,Context.NoL, roughness );
        let F = FresnelSchlick(Context.VoH, vec3<f32>(F0));
        let specular = ( D * G * F ) / (4.0 * Context.NoV * Context.NoL + 0.001);
        let kS = F;
        var kd = 1.0 - kS ;
        kd *= 1.0 - metallic ;
        var diffuse = kd * (albedo.rgb / PI ) ;
        let ambient = specular.rgb ;

        fragData.KD += kd;
        fragData.KS += F;

        var col = (diffuse + ambient) * Context.NoL * lightColor * att ;
        // var col = (diffuse + ambient) * Context.NoL * lightColor ;
        return (col.rgb ) ;
    }

    fn getSpecularDominantDir (  N : vec3<f32> , R : vec3<f32> , roughness : f32 ) -> vec3<f32>
    {
        var smoothness = saturate (1.0 - roughness );
        var lerpFactor = smoothness * ( sqrt ( smoothness ) + roughness );
        // The result is not normalized as we fetch in a cubemap
        return mix (N, R, lerpFactor );
    }

    fn approximateSpecularIBL( specularColor:vec3<f32> , roughness:f32 , R:vec3<f32> , NoV:f32 ) -> vec3<f32> {
       
        let MAX_REFLECTION_LOD  = i32(textureNumLevels(prefilterMap)) ;
        let mip = roughnessToMipmapLevel(roughness,MAX_REFLECTION_LOD);
        var prefilteredColor: vec3<f32> = (textureSampleLevel(prefilterMap, prefilterMapSampler, getSpecularDominantDir(fragData.N,R,roughness) , mip ).rgb);
        prefilteredColor = globalUniform.skyExposure * (prefilteredColor);
        var envBRDF = textureSampleLevel(brdflutMap, brdflutMapSampler, vec2<f32>(NoV, roughness) , 0.0 ) ;
        return prefilteredColor * (specularColor.rgb * envBRDF.x + saturate( 50.0 * specularColor.g ) * envBRDF.y) ;
    }

    fn fresnel_coat(n:vec3<f32>,v:vec3<f32>,ior:f32) -> f32 {
        var f0 = (1.0-ior)/(1.0+ior);
        f0 = f0 * f0  ;
        let fr = pow((f0 + (1.0 - f0)*(1.0 - abs( max(dot(n,v),0.0) ))) , 5.0 ) ;  
        return fr ;
    }

    fn reflectEnvMap(n:vec3<f32> , v:vec3<f32> , roughness:f32) -> vec3<f32> {
        let MAX_REFLECTION_LOD  = i32(textureNumLevels(envMap)) ;
        let mip = roughnessToMipmapLevel(roughness,MAX_REFLECTION_LOD);
        let R = 2.0 * dot( v , n ) * n - v ;
        var prefilteredColor: vec3<f32> = globalUniform.skyExposure * (textureSampleLevel(envMap, envMapSampler, R , mip ).rgb);
        prefilteredColor = LinearToGammaSpace(prefilteredColor);
        return prefilteredColor ;
    }

    fn Specular_D_GGX( NoH:f32,  roughness:f32 ) -> f32
    {
        let a2 = roughness * roughness ;
        let f = (NoH * a2 - NoH) * NoH + 1.0;
        return a2 / (PI * f * f) ;
    }

    fn V_Kelemen( LoH : f32 ) -> f32 {
        return 0.25 / (LoH * LoH);
    }

    fn F_Schlick( f0:vec3<f32> ,  f90 : f32 ,  VoH : f32 ) -> vec3<f32> {
        return f0 + (f90 - f0) * pow(1.0 - VoH,5.0);
    }

    fn F_Schlick2(  SpecularColor:vec3<f32>,  VoH :f32 )-> vec3<f32> {
        var Fc = pow5( 1.0 - VoH );
        let rt = clamp(50.0 * SpecularColor.g,0.0,1.0) ;
        return rt * Fc + (1.0 - Fc) * SpecularColor;
    }

    fn oneMinusReflectivity ( metallic : f32 , F0:f32 ) -> f32 {
        let range = 1.0 - F0;
        return range - metallic * range;
    }

    //https://google.github.io/filament/Filament.html materialsystem/clearcoatmodel/clearcoatparameterization
    fn CoatSpecular_brdf( f:vec3<f32>, s:vec3<f32>, n:vec3<f32> , v:vec3<f32> , l:vec3<f32> , att:f32 , layer :vec3<f32> , clearcoatRoughnessFactor:f32 ) -> vec3<f32> {
        let H = normalize(v + l); 
        let VdotNc = max(dot(v,n),0.0);
        let LdotNc = max(dot(l,n),0.0);
        let NoH = max(dot(n,H),0.0);
        let LoH = saturate(dot(l, H))  ;
        let NoL = max(dot(n,l),0.0);

        let Fd = f ; 
        let Fr = s ; 

        let factor = clamp(clearcoatRoughnessFactor,0.089,1.0);
        let clearCoatRoughness = factor * factor ;

        let Dc = D_GGX( NoH , factor ) ;
        let Vc = V_Kelemen( LoH ) * NoL ;
        let Fc = F_Schlick(vec3<f32>(0.04), 2.0 , LoH); 
        let Frc = (Dc * Vc) * Fc ;
        // return layer * vec3<f32>((Fd + Fr * (1.0 - Fc)) * (1.0 - Fc) + Frc) * ( 0.5 + NoL * 0.5 ) ;
        return vec3<f32>(Frc) ;
    }

    #if USE_CLEARCOAT
    fn approximate_coating(base:vec3<f32> , clearColor: vec3<f32>, n:vec3<f32> , v:vec3<f32> , light:LightData , clearcoatRoughnessFactor:f32 ) -> vec3<f32> {
        let factor = clamp(clearcoatRoughnessFactor,0.084,1.0);
        var clearcoatAlpha = factor * factor + fragData.ClearcoatRoughness;

        // var lightColor = getHDRColor( lightCC.rgb , light.linear )  ;
        var att = light.intensity / LUMEN ;
        let l = light.direction ;
   
        let NdotV = max(dot(n,v),0.0);
        let MAX_REFLECTION_LOD  = f32(textureNumLevels(prefilterMap)) ;
        // let mip = roughnessToMipmapLevel(clearcoatAlpha,MAX_REFLECTION_LOD);
        let R = 2.0 * dot( v , n ) * n - v ;
        var envIBL: vec3<f32> = globalUniform.skyExposure * (textureSampleLevel(prefilterMap, prefilterMapSampler, R , MAX_REFLECTION_LOD * clearcoatRoughnessFactor ).rgb) ;
        // envIBL = LinearToGammaSpace(envIBL);

        let clearCoat = materialUniform.clearcoatFactor ;
        // let f = FresnelSchlickRoughness( max(dot(n,v),0.0) , vec3<f32>(0.0) , clearcoatAlpha ) ;
        let clearcoat_brdf =  CoatSpecular_brdf( vec3<f32>(0.04) , vec3<f32>( 0.04 ) , n , v , -l , att , vec3<f32>( 0.04 ) , factor ) ;

        // return clearcoat_brdf;+ fragData.ClearcoatRoughness 
        return mix(base, clearcoat_brdf,materialUniform.clearcoatWeight ) ;
    }
    #endif
   
`,qo=`
  #include "Clearcoat_frag"
  #include "BRDF_frag"
  #include "MathShader"
  #include "FastMathShader"
  #include "Common_frag"
  #include "GlobalUniform"

  #include "PhysicMaterialUniform_frag"
  #include "NormalMap_frag"
  #include "LightingFunction_frag"
  #include "Irradiance_frag"
  #include "ColorUtil_frag"
  #include "BxdfDebug_frag"


 
  //ORI_ShadingInput
  fn initFragData() {
      fragData.Albedo = ORI_ShadingInput.BaseColor * ORI_ShadingInput.BaseColor.a ;
      fragData.Ao = ORI_ShadingInput.AmbientOcclusion ; 
      fragData.Roughness = clamp(ORI_ShadingInput.Roughness,0.003,1.0) ; 
      fragData.Metallic = ORI_ShadingInput.Metallic ; 
      fragData.Emissive = ORI_ShadingInput.EmissiveColor.rgb ; 
      fragData.N = ORI_ShadingInput.Normal;
      let viewDir = normalize(globalUniform.CameraPos.xyz - ORI_VertexVarying.vWorldPos.xyz) ;
      fragData.V = viewDir ;
    //   fragData.V = normalize(globalUniform.cameraWorldMatrix[3].xyz - ORI_VertexVarying.vWorldPos.xyz) ;

      let R = 2.0 * dot( fragData.V , fragData.N ) * fragData.N - fragData.V ;
      fragData.R = R ;//reflect( fragData.V , fragData.N ) ;

      fragData.NoV = saturate(dot(fragData.N, fragData.V)) ;

      fragData.F0 = mix(vec3<f32>(materialUniform.materialF0.rgb), fragData.Albedo.rgb, fragData.Metallic);
      
      fragData.F = computeFresnelSchlick(fragData.NoV, fragData.F0);
      fragData.KD = vec3<f32>(fragData.F) ;
      fragData.KS = vec3<f32>(0.0) ;

      fragData.Indirect = 0.0 ;
      fragData.Reflectance = 1.0 ;

      fragData.ClearcoatRoughness = materialUniform.clearcoatRoughnessFactor ;
      #if USE_CLEARCOAT_ROUGHNESS
        fragData.ClearcoatRoughness = getClearcoatRoughness() * materialUniform.clearcoatRoughnessFactor;
      #endif
  }

  fn BxDFShading(){
      initFragData();

      var irradiance = vec3<f32>(0.0) ;
      #if USEGI
          irradiance += getIrradiance().rgb ;
      #else
          let MAX_REFLECTION_LOD  = f32(textureNumLevels(prefilterMap)) ;
          irradiance += (globalUniform.skyExposure * textureSampleLevel(prefilterMap, prefilterMapSampler, fragData.N.xyz, 0.8 * (MAX_REFLECTION_LOD) ).rgb);
      #endif
      irradiance = LinearToGammaSpace(irradiance.rgb);
      fragData.Irradiance = irradiance.rgb ;

      #if USE_TANGENT
        fragData.TangentChannel = vec3<f32>(ORI_VertexVarying.TANGENT.w);// ORI_VertexVarying.TANGENT.xyz * ORI_VertexVarying.TANGENT.w ;
      #endif

      //***********lighting-PBR part********* 
      var specColor = vec3<f32>(0.0) ;
      let lightIndex = getCluster();
      let start = max(lightIndex.start, 0.0);
      let count = max(lightIndex.count, 0.0);
      let end = max(start + count , 0.0);
      for(var i:i32 = i32(start) ; i < i32(end); i += 1 )
      {
        let light = getLight(i32(i));

        switch (light.lightType) {
          case PointLightType: {
            specColor += pointLighting( fragData.Albedo.rgb,ORI_VertexVarying.vWorldPos.xyz,fragData.N,fragData.V,fragData.Roughness,fragData.Metallic,light) ;
          }
          case DirectLightType: {
            specColor += directLighting( fragData.Albedo.rgb ,fragData.N,fragData.V,fragData.Roughness ,fragData.Metallic, light , globalUniform.shadowBias) ;
          }
          case SpotLightType: {
            specColor += spotLighting( fragData.Albedo.rgb,ORI_VertexVarying.vWorldPos.xyz,fragData.N,fragData.V,fragData.Roughness,fragData.Metallic , light ) ;
          }
          default: {
          }
        }
      }
      fragData.LightChannel = specColor ;


      //***********lighting-PBR part********* 
      var F = FresnelSchlickRoughness(fragData.NoV, fragData.F0, fragData.Roughness);
      var kS = F;
      var kD = vec3(1.0) - kS;
      kD = kD * (1.0 - fragData.Metallic);
      let env =  materialUniform.envIntensity * approximateSpecularIBL( F , fragData.Roughness , fragData.R , fragData.NoV ) ;
      fragData.EnvColor = env ;
      //***********indirect-specular part********* 
      
      var surfaceReduction = 1.0/(fragData.Roughness*fragData.Roughness+1.0);   //Reduce the reflection coefficient of non-metallic materials     
      var oneMinusReflectivity = oneMinusReflectivity(fragData.Metallic , materialUniform.materialF0.r );// materialUniform.materialF0.a - materialUniform.materialF0.a * fragData.Metallic ;
      var grazingTerm = clamp((1.0 - fragData.Roughness ) + (1.0 - oneMinusReflectivity),0.0,1.0);
      var t = pow5(fragData.NoV);
      var fresnelLerp = FresnelLerp(fragData.NoV,fragData.F0.rgb,vec3<f32>(grazingTerm)) ;   //Controlling Fresnel and metallic reflections
      var iblSpecularResult = surfaceReduction*env*fresnelLerp ;
      //***********indirect-specular part********* 
      
      //***********indirect-ambient part********* 
      var kdLast = (1.0 - fragData.F0.r) * (1.0 - fragData.Metallic);     //Dim the edges, there should be more specular reflection at the edges
      var iblDiffuseResult = irradiance * kdLast * fragData.Albedo.rgb ;
      //***********indirect-ambient part********* 
      let sunLight = lightBuffer[0] ;
      var indirectResult = (iblSpecularResult + iblDiffuseResult) * fragData.Ao * max(sunLight.quadratic,0.05) ;
      // let test = indirectResult ;

      ORI_FragmentOutput.color = vec4<f32>(0.0);

      // Using stripped down, 'pure log', formula. Parameterized by grey points and dynamic range covered.
      #if USEGBUFFER
          var normal_rgba8unorm = (ORI_VertexVarying.vWorldNormal + 1.0) * 0.5;
          normal_rgba8unorm = clamp(normal_rgba8unorm, vec3<f32>(0.0), vec3<f32>(1.0));
      #endif
      
      // ORI_FragmentOutput.color = vec4<f32>(ORI_FragmentOutput.color.xyz,fragData.Albedo.a) ;
      #if USE_WORLDPOS
          ORI_FragmentOutput.worldPos = vec4<f32>(ORI_VertexVarying.vWorldPos.xyzw);
      #endif

      #if USEGBUFFER
          ORI_FragmentOutput.worldNormal = vec4<f32>(normal_rgba8unorm,1.0);
          ORI_FragmentOutput.material = vec4<f32>(1.0,fragData.Roughness,fragData.Metallic,1.0);
      #endif
      
      var color = specColor + indirectResult ;
      color += fragData.Emissive.xyz ;

      var clearCoatColor = vec3<f32>(0.0);
      #if USE_CLEARCOAT
        let clearCoatBaseColor = vec3<f32>(1.0) * materialUniform.baseColor.rgb ;
        let clearNormal = fragData.N ;
        let clearcoatRoughness = fragData.ClearcoatRoughness ;
        let att = sunLight.intensity / LUMEN ;
        let clearCoatLayer = ClearCoat_BRDF( color , materialUniform.clearcoatColor.rgb , materialUniform.ior , clearNormal , -sunLight.direction ,-fragData.V , materialUniform.clearcoatWeight , clearcoatRoughness , att );
        color = vec3<f32>(clearCoatLayer.rgb/fragData.Albedo.a) ; 
      #endif
      
      ORI_FragmentOutput.color = vec4<f32>(LinearToGammaSpace(color.rgb),fragData.Albedo.a) ;

      // var iblSpecularResult = surfaceReduction*env*fresnelLerp ;
      // ORI_FragmentOutput.color = vec4<f32>(vec3<f32>(test),fragData.Albedo.a) ;
  }

  `,Ko=`
    #if USE_CLEARCOAT_ROUGHNESS
    @group(1) @binding(auto)
    var clearCoatRoughnessMapSampler: sampler;
    @group(1) @binding(auto)
    var clearCoatRoughnessMap: texture_2d<f32>;

    fn getClearcoatRoughness() -> f32{
        let clearcoatRoughness = textureSample(clearCoatRoughnessMap, clearCoatRoughnessMapSampler, ORI_VertexVarying.fragUV0.xy).r;
        return clearcoatRoughness;
    }
    #else
    fn getClearcoatRoughness() -> f32{
        return 1.0;
    }
    #endif

    #if USE_CLEARCOAT
    fn ClearCoat_BRDF( baseColor:vec3<f32>, clearCoatColor:vec3<f32> , ior:f32 ,N:vec3<f32>, L:vec3<f32> ,  V:vec3<f32> , clearCoatStrength:f32, clearCoatPerceptualRoughness:f32 , att:f32) -> vec3<f32> {
        var factor = clamp(clearCoatPerceptualRoughness, 0.0001, 1.0);
        var clearCoatRoughness = factor * factor;

        let H = normalize(-V + L);
        let R = 2.0 * dot( -V , N ) * N + V ;
        let LoH = dot(L,H);
        let NoV = max(dot(N,-V),0.0);
        let NoL = max(dot(N,L),0.0);
        let NoH = max(dot(N,H),0.00001);

        let Fr = FresnelSchlickRoughness( NoV , vec3<f32>(0.0) , clearCoatRoughness ) ;
        var Fd = clearCoatColor / 3.1415926 ;
        let F0 = IORToF0(ior) ;
        // clear coat BRDF
        var Dc = D_GGX(NoH,clearCoatRoughness);
        var Vc = V_Kelemen(LoH) * NoL;
        var Fc = F_Schlick( vec3<f32>(F0) , 1.0, NoV) * materialUniform.clearcoatFactor;
        var Frc = (Dc * Vc) * Fc;
        // base layer attenuation for energy compensation
        let oneMinusFc  = 1.0 - Fc;
        let brdfSpecular = ((Fd + Fr * oneMinusFc) * oneMinusFc + Frc)  * att ; 
        var iblSpecular = vec3<f32>(brdfSpecular);
        iblSpecular += approximateSpecularIBL(vec3<f32>(1.0),clearCoatRoughness,R, NoV) * Fc ;
        return vec3<f32>(mix(baseColor,iblSpecular,materialUniform.clearcoatWeight));
    }
    #endif
`,Jo=`
    #include "Common_vert"
    #include "Common_frag"
    #include "BxDF_frag"

    fn vert(inputData:VertexAttributes) -> VertexOutput {
        ORI_Vert(inputData) ;
        return ORI_VertexOut ;
    }

    fn frag(){
        ORI_ShadingInput.BaseColor = materialUniform.baseColor ;
        ORI_ShadingInput.Roughness = materialUniform.roughness  ;
        ORI_ShadingInput.Metallic = materialUniform.metallic ;
        ORI_ShadingInput.Specular = 0.5 ;
        ORI_ShadingInput.AmbientOcclusion = materialUniform.ao ;
        ORI_ShadingInput.EmissiveColor = vec4<f32>(0.0);

        ORI_ShadingInput.Normal = ORI_VertexVarying.vWorldNormal.rgb ;

        BxDFShading();
    }
`,Zo=`
    #include "Common_vert"
    #include "Common_frag"
    #include "BxDF_frag"

    @group(1) @binding(auto)
    var baseMapSampler: sampler;
    @group(1) @binding(auto)
    var baseMap: texture_2d<f32>;

    @group(1) @binding(auto)
    var normalMapSampler: sampler;
    @group(1) @binding(auto)
    var normalMap: texture_2d<f32>;

    #if USE_ARMC
        @group(1) @binding(auto)
        var maskMapSampler: sampler;
        @group(1) @binding(auto)
        var maskMap: texture_2d<f32>;
    #endif

    #if USE_MR
        @group(1) @binding(auto)
        var maskMapSampler: sampler;
        @group(1) @binding(auto)
        var maskMap: texture_2d<f32>;
    #endif

    #if USE_AOTEX
        @group(1) @binding(auto)
        var aoMapSampler: sampler;
        @group(1) @binding(auto)
        var aomapMap: texture_2d<f32>;
    #endif

    @group(1) @binding(auto)
    var emissiveMapSampler: sampler;
    @group(1) @binding(auto)
    var emissiveMap: texture_2d<f32>;

    fn vert(inputData:VertexAttributes) -> VertexOutput {
        ORI_Vert(inputData) ;
        return ORI_VertexOut ;
    }

    fn frag(){
        var transformUV1 = materialUniform.transformUV1;
        var transformUV2 = materialUniform.transformUV2;

        var uv = transformUV1.zw * ORI_VertexVarying.fragUV0 + transformUV1.xy; 

        ORI_ShadingInput.BaseColor = textureSample(baseMap, baseMapSampler, uv ) ;
        ORI_ShadingInput.BaseColor = vec4<f32>(gammaToLiner(ORI_ShadingInput.BaseColor.rgb*ORI_ShadingInput.BaseColor.w ) * materialUniform.baseColor.rgb,ORI_ShadingInput.BaseColor.w*materialUniform.baseColor.a)  ;
        #if USE_ALPHACUT
            if( (ORI_ShadingInput.BaseColor.a - materialUniform.alphaCutoff) <= 0.0 ){
                ORI_FragmentOutput.color = vec4<f32>(0.0,0.0,0.0,1.0);
                ORI_FragmentOutput.worldPos = vec4<f32>(0.0,0.0,0.0,1.0);
                ORI_FragmentOutput.worldNormal = vec4<f32>(0.0,0.0,0.0,1.0);
                ORI_FragmentOutput.material = vec4<f32>(0.0,0.0,0.0,1.0);
                discard;
            }
        #endif

        #if USE_SHADOWMAPING
            useShadow();
        #endif

        #if USE_ARMC
            var maskTex = textureSample(maskMap, maskMapSampler, uv ) ;

            ORI_ShadingInput.AmbientOcclusion = maskTex.r * materialUniform.ao ; 

            #if USE_AOTEX
                var aoMap = textureSample(aomapMap, aoMapSampler, uv );
                ORI_ShadingInput.AmbientOcclusion = mix(0.0,aoMap.r,materialUniform.ao) ;
            #endif

            ORI_ShadingInput.Roughness = maskTex.g * materialUniform.roughness ;
            ORI_ShadingInput.Metallic =  maskTex.b * materialUniform.metallic ;

        #elseif USE_MR
            var maskTex = textureSample(maskMap, maskMapSampler, uv ) ;
            #if USE_AOTEX
                var aoMap = textureSample(aomapMap, aoMapSampler, uv );
                ORI_ShadingInput.AmbientOcclusion = mix(0.0,aoMap.r,materialUniform.ao) ;
            #else
                ORI_ShadingInput.AmbientOcclusion = materialUniform.ao ; 
            #endif

            ORI_ShadingInput.Roughness = maskTex.g * materialUniform.roughness ;
            ORI_ShadingInput.Metallic =  maskTex.b * materialUniform.metallic;
        #else
            ORI_ShadingInput.Roughness = materialUniform.roughness ;
            ORI_ShadingInput.Metallic = materialUniform.metallic ;
            ORI_ShadingInput.AmbientOcclusion =  materialUniform.ao ;
            #if USE_AOTEX
                var aoMap = textureSample(aomapMap, aoMapSampler, uv );
                ORI_ShadingInput.AmbientOcclusion = mix(0.0,aoMap.r,materialUniform.ao) ;
            #endif
        #endif

        ORI_ShadingInput.Roughness = clamp(ORI_ShadingInput.Roughness,0.084,1.0);
        ORI_ShadingInput.Specular = 0.5 ;

        var emissiveColor = textureSample(emissiveMap, emissiveMapSampler , ORI_VertexVarying.fragUV0.xy) ;
        emissiveColor = vec4<f32>(gammaToLiner(emissiveColor.rgb),emissiveColor.w);
        ORI_ShadingInput.EmissiveColor = vec4<f32>(materialUniform.emissiveColor.rgb * emissiveColor.rgb * materialUniform.emissiveIntensity,1.0);

        var Normal = textureSample(normalMap,normalMapSampler,uv).rgb ;
        // Normal.y = 1.0 - Normal.y ;
        // let normal = unPackNormal(Normal,1.0,materialUniform.normalScale) ;
        let normal = unPackNormal(Normal,materialUniform.normalScale) ;  
        ORI_ShadingInput.Normal = normal ;

        BxDFShading();
    }
`,$o=`
#include "ClusterDebug_frag" 

        fn debugPosition(){
            ORI_FragmentOutput.color = vec4<f32>(ORI_VertexVarying.vWorldPos.xyz,1.0);
        }

        fn debugMeshID(){
            let meshIDColor = u32(ORI_VertexVarying.vWorldPos.w ) ;
            let color = colorSet[ meshIDColor % 9u] ;
            ORI_FragmentOutput.color = vec4<f32>(vec3<f32>(color.rgb),1.0);
        }

        fn debugNormal(){
            ORI_FragmentOutput.color = vec4<f32>(ORI_ShadingInput.Normal.xyz,1.0);
        }

        fn debugUV(){
            ORI_FragmentOutput.color = vec4<f32>(ORI_VertexVarying.fragUV0.xy,0.0,1.0);
        }

        fn debugColor(){
            ORI_FragmentOutput.color = vec4<f32>(fragData.Albedo.rgb,1.0);
        }

        fn debugDiffuse(){
            ORI_FragmentOutput.color = vec4<f32>( fragData.LightChannel.rgb,1.0);
            // ORI_FragmentOutput.color = vec4<f32>(0.2,0.2,0.2,1.0);
        }

        fn debugAmbient(){
            ORI_FragmentOutput.color = vec4<f32>(fragData.Irradiance * fragData.Albedo.rgb,1.0);
        }
        
        fn debugEmissive(){
            ORI_FragmentOutput.color = vec4<f32>(fragData.Emissive.rgb,1.0);
        }

        fn debugEnvment(){
            ORI_FragmentOutput.color = vec4<f32>(fragData.EnvColor.rgb,1.0);
        }

        fn debugAo(){
            ORI_FragmentOutput.color = vec4<f32>(vec3<f32>(fragData.Ao),1.0);
        }

        fn debugRoughness(){
            ORI_FragmentOutput.color = vec4<f32>(vec3<f32>(fragData.Roughness),1.0);
        }

        fn debugMetallic(){
            ORI_FragmentOutput.color = vec4<f32>(vec3<f32>(fragData.Metallic),1.0);
        }

        fn debugIrradiance(){
            ORI_FragmentOutput.color = vec4<f32>(vec3<f32>(fragData.Irradiance),1.0);
        }

        fn debugTangent(){
            ORI_FragmentOutput.color = vec4<f32>(vec3<f32>(fragData.TangentChannel),1.0);
        }

        fn debugFragmentOut(){
            if(ORI_VertexVarying.fragCoord.x > globalUniform.renderState_split) {
                switch (globalUniform.renderState_right)
                {
                  case 0: {
                    debugPosition();
                  }
                  case 1: {
                    debugColor();
                  }
                  case 2: {
                    debugNormal();
                  }
                  case 3: {
                    debugIrradiance();
                  }
                  case 4: {
                    debugTangent();
                  }
                  case 5: {
                    // debugTangent();
                  }
                  case 6: {
                    debugEmissive();
                  }
                  case 7: {
                    debugEnvment();
                  }
                  case 8: {
                    debugAo();
                  }
                  case 9: {
                    debugRoughness();
                  }
                  case 10: {
                    debugMetallic();
                  }
                  case 11: {
                    debugDiffuse();
                  }
                  case 12: {
                    debugAmbient();
                  }
                  case 13: {
                    debugMeshID();
                  }
                  case 14: {
                    #if DEBUG_CLUSTER
                      debugCluster( ORI_VertexVarying.fragCoord );
                    #endif
                  }
                  case 15: {
                    #if DEBUG_CLUSTER
                      debugClusterBox( ORI_VertexVarying.fragCoord );
                    #endif
                  }
                  case 16: {
                    #if DEBUG_CLUSTER
                      debugClusterLightCount( vec4<f32>(ORI_VertexVarying.fragCoord.xyz,0.0));
                      #endif
                  }
                  default: {
                  }
                }
              } else {
                switch (globalUniform.renderState_left)
                {
                  case 0: {
                    debugPosition();
                  }
                  case 1: {
                    debugColor();
                  }
                  case 2: {
                    debugNormal();
                  }
                  case 3: {
                    debugIrradiance();
                  }
                  case 4: {
                    debugTangent();
                  }
                  case 5: {
                    // debugTangent();
                  }
                  case 6: {
                    debugEmissive();
                  }
                  case 7: {
                    debugEnvment();
                  }
                  case 8: {
                    debugAo();
                  }
                  case 9: {
                    debugRoughness();
                  }
                  case 10: {
                    debugMetallic();
                  }
                  case 11: {
                    debugDiffuse();
                  }
                  case 12: {
                    debugAmbient();
                  }
                  case 13: {
                    debugMeshID();
                  }
                  case 14: {
                    #if DEBUG_CLUSTER
                      debugCluster( ORI_VertexVarying.fragCoord );
                    #endif
                  }
                  case 15: {
                    #if DEBUG_CLUSTER
                      debugClusterBox( ORI_VertexVarying.fragCoord );
                    #endif
                  }
                  case 16: {
                    #if DEBUG_CLUSTER
                      debugClusterLightCount( vec4<f32>(ORI_VertexVarying.fragCoord.xyz,0.0));
                      #endif
                  }
                  default: {
                  }
                }
              }
        }
`,el=`
    #include "WorldMatrixUniform"
    #include "GlobalUniform"

    struct MaterialUniform {
    x:f32,
    y:f32,
    width:f32,
    height:f32,
    };

    struct VertexOutput {
        @location(0) fragUV: vec2<f32>,
        @builtin(position) position: vec4<f32>
    };

    @vertex
    fn main(@builtin(vertex_index) vertexIndex : u32, @builtin(instance_index) index : u32 ) -> VertexOutput {
        const pos = array(
        vec2(-1.0, -1.0), vec2(1.0, -1.0), vec2(-1.0, 1.0),
        vec2(-1.0, 1.0), vec2(1.0, -1.0), vec2(1.0, 1.0),
        );
        const uv = array(
        vec2(1.0, 0.0), vec2(1.0, 1.0), vec2(0.0, 1.0), 
        vec2(1.0, 0.0), vec2(0.0, 1.0), vec2(0.0, 0.0),
        );
        let id = u32(index) ;
        var output : VertexOutput;
        output.fragUV = uv[vertexIndex] ;
        output.position = vec4<f32>(pos[vertexIndex] , 0.0, 1.0) ;
        return output ;
    }
`,tl=`
#include "WorldMatrixUniform"
      #include "GlobalUniform"
   
      struct MaterialUniform {
        x:f32,
        y:f32,
        width:f32,
        height:f32,
      };

      struct VertexOutput {
          @location(0) fragUV: vec2<f32>,
          @builtin(position) member: vec4<f32>
      };

      @vertex
      fn main(@builtin(instance_index) index : u32,@location(0) position: vec3<f32>, @location(1) TEXCOORD_1: vec2<f32>) -> VertexOutput {
          let id = u32(index) ;
          let worldMatrix = models.matrix[id];

          let windowSize = vec2<f32>(globalUniform.windowWidth,globalUniform.windowHeight) ;

        //   let pos = worldMatrix[3].xy ;

          let size = vec2<f32>(worldMatrix[0].x,worldMatrix[1].y) / windowSize ;

          let uv = vec2(((TEXCOORD_1.xy * 2.0) - vec2<f32>(1.0)))  ;// / windowSize * size - offset ;

          return VertexOutput(TEXCOORD_1, vec4<f32>(uv, 0.0, 1.0));
      }
`,il=`
    struct FragmentOutput {
        @location(0) o_Target: vec4<f32>
    };

    var<private> fragUV1: vec2<f32>;
    var<private> o_Target: vec4<f32>;
    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_2d<f32>;

    @fragment
    fn main(@location(0) fragUV: vec2<f32>) -> FragmentOutput {
        var uv = fragUV ;
        uv.y = 1.0 - uv.y ;
        var color: vec4<f32> = textureSample(baseMap, baseMapSampler, uv );

        return FragmentOutput(color);
    }
`,rl=`
    struct FragmentOutput {
        @location(0) o_Target: vec4<f32>
    }; 

    var<private> fragUV1: vec2<f32>;
    var<private> o_Target: vec4<f32>;

    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_depth_2d ;

    fn Linear01Depth(  z : f32 ) -> f32
    {
        return 1.0 / (1.0 * z + 5000.0);
    }

    @fragment
    fn main(@location(0) fragUV: vec2<f32>) -> FragmentOutput {
        var uv = fragUV ;
        uv.y = 1.0 - uv.y ;
        var depth = textureSample(baseMap, baseMapSampler, uv , vec2<i32>(0) ) ;
        return FragmentOutput(vec4<f32>(depth,0.0,0.0,1.0));
    }
`,al=`
    struct FragmentOutput {
        @location(0) o_Target: vec4<f32>
    };

    var<private> fragUV1: vec2<f32>;
    var<private> o_Target: vec4<f32>;

    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_depth_cube ;

    fn uvToXYZ( face : i32 ,  uv : vec2<f32> ) -> vec3<f32>
    {
        var out : vec3<f32> ;
        if(face == 0){
            out = vec3<f32>( 1.0, uv.y, -uv.x);
        }else if(face == 1){
            out = vec3<f32>( -1.0, uv.y, uv.x);
        }else if(face == 2){
            out = vec3<f32>( uv.x, -1.0, uv.y);
        }else if(face == 3){
            out = vec3<f32>( uv.x,  1.0, -uv.y);
        }else if(face == 4){
            out = vec3<f32>( uv.x, uv.y, 1.0);
        }else{	
            out = vec3<f32>( -uv.x, uv.y, -1.0);
        }
        return out ;
    }

    @fragment
    fn main(@location(0) fragUV: vec2<f32>) -> FragmentOutput {
        var uv = fragUV ;
        uv.y = 1.0 - uv.y ;
        var ii = 0.16 ;
        var ouv = vec3<f32>(0.0);
        if(uv.x < ii * 6.0){
            ouv = uvToXYZ(5,uv/ii);
        }
        if(uv.x < ii * 5.0){
            ouv = uvToXYZ(4,uv/ii);
        }
        if(uv.x < ii * 4.0){
            ouv = uvToXYZ(3,uv/ii);
        } 
        if(uv.x < ii * 3.0){
            ouv = uvToXYZ(2,uv/ii);
        }
        if(uv.x < ii * 2.0){
            ouv = uvToXYZ(1,uv/ii);
        }
        if(uv.x < ii * 1.0){
            ouv = uvToXYZ(0,uv/ii);
        }
        var depth = textureSample(baseMap, baseMapSampler, ouv ) ;
        depth = 1.0 - depth; 

        return FragmentOutput(vec4<f32>(depth,0.0,0.0,1.0));
    }
`,Yf=`
    struct FragmentOutput {
        @location(0) o_Target: vec4<f32>
    };

    var<private> fragUV1: vec2<f32>;
    var<private> o_Target: vec4<f32>;

    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_2d_array ;

    struct MaterialData{
        index:f32;
    }

    @fragment
    fn main(@location(0) fragUV: vec2<f32>) -> FragmentOutput {
        var uv = fragUV ;
        uv.y = 1.0 - uv.y ;
    
        var depth = textureSample(baseMap, baseMapSampler, ouv ) ;
        depth = 1.0 - depth; 

        return FragmentOutput(vec4<f32>(depth,0.0,0.0,1.0));
    }
`,Ts=`
    fn getHDRColor(color: vec3<f32>, exposure: f32) -> vec3 < f32 > {
        // var newColor = color * (  1.0 / 255.0 ) ;
        return color * pow(2.4, exposure) ;
    }

    fn lambda2rgb(lambda : f32) -> vec3 < f32 > {
        let ultraviolet = 400.0;
        let infrared = 700.0;

        var a = (lambda - ultraviolet) / (infrared - ultraviolet);
        let c = 10.0;
        var b = vec3<f32>(a) - vec3<f32>(0.75, 0.5, 0.25);
        return max((1.0 - c * b * b), vec3<f32>(0.0));
    }

    fn CEToneMapping(color: vec3<f32>, adapted_lum: f32) -> vec3<f32>
    {
        return 1.0 - exp(-adapted_lum * color);
    }

    fn ACESToneMapping(color: vec3<f32>, adapted_lum: f32) -> vec3<f32>
    {
        let A = 2.51;
        let B = 0.03;
        let C = 2.43;
        let D = 0.59;
        let E = 0.14;

        var color2 = color * adapted_lum;
        color2 = (color2 * (A * color2 + B)) / (color2 * (C * color2 + D) + E);
        return color2;
    }

    fn gammaToLiner(color: vec3<f32>) -> vec3 < f32 > {
        let gammaCorrect = 2.4;
        var color2 = pow(color, vec3<f32>(gammaCorrect));
        return color2 ;
    }

    fn linerToGamma4(color: vec4<f32>) -> vec4 < f32 > {
        let gammaCorrect = 0.416666667;
        var color2 = pow(color, vec4<f32>(gammaCorrect));
        return color2 ;
    }

    fn linerToGamma3(color: vec3<f32>) -> vec3 < f32 > {
        let gammaCorrect = 0.416666667;
        var color2 = pow(color, vec3<f32>(gammaCorrect));
        return color2 ;
    }

    fn LinearToGammaSpace(linRGB0: vec3<f32>) -> vec3 < f32 > {
        var linRGB = max(linRGB0, vec3(0.0, 0.0, 0.0));
        linRGB.r = pow(linRGB.r, 0.416666667);
        linRGB.g = pow(linRGB.g, 0.416666667);
        linRGB.b = pow(linRGB.b, 0.416666667);
        return max(1.055 * linRGB - 0.055, vec3(0.0, 0.0, 0.0));
    }

    var<private>sRGB_2_LMS_MAT: mat3x3<f32> = mat3x3<f32>(
        17.8824, 43.5161, 4.1193,
        3.4557, 27.1554, 3.8671,
        0.02996, 0.18431, 1.4670,
    );

    var<private>LMS_2_sRGB_MAT: mat3x3<f32> = mat3x3<f32>(
        0.0809, -0.1305, 0.1167,
        -0.0102, 0.0540, -0.1136,
        -0.0003, -0.0041, 0.6935,
    );

    fn sRGB_2_LMS(RGB: vec3<f32>) -> vec3<f32>
    {
        return sRGB_2_LMS_MAT * RGB;
    }

    fn LMS_2_sRGB(LMS: vec3<f32>) -> vec3<f32>
    {
        return LMS_2_sRGB_MAT * LMS;
    }

    fn LinearToSrgbBranchless(lin: vec3<f32>) -> vec3<f32>
    {
        var lin2 = max(vec3<f32>(6.10352e-5), lin);
        return min(lin2 * 12.92, pow(max(lin2, vec3<f32>(0.00313067)), vec3<f32>(0.416666667)) * vec3<f32>(1.055) - vec3<f32>(0.055));
    }

    fn sRGBToLinear(color : vec3<f32>) -> vec3<f32>
    {
        let color2 = max(vec3<f32>(6.10352e-5), color);
        let c = 0.04045;
        if (color2.r > c && color2.g > c && color2.b > c) {
            return pow(color2 * (1.0 / 1.055) + 0.0521327, vec3<f32>(2.4));
        } else {
            return color2 * (1.0 / 12.92);
        }
    }

//     fn ReorientedBlendNormal(){
//         vec3 t = texture(baseMap,   uv).xyz * vec3( 2.0,  2.0, 2.0) + vec3(-1.0, -1.0,  0.0);
// vec3 u = texture(detailMap, uv).xyz * vec3(-2.0, -2.0, 2.0) + vec3( 1.0,  1.0, -1.0);
// vec3 r = normalize(t * dot(t, u) - u * t.z);
// return r;
//     }

//     fn UDNBlendNormal(){
    // vec3 t = texture(baseMap,   uv).xyz * 2.0 - 1.0;
    // vec3 u = texture(detailMap, uv).xyz * 2.0 - 1.0;
    // vec3 r = normalize(t.xy + u.xy, t.z);
    // return r;
//     }
`,sl=`
    fn madfrac(A:f32, B:f32)-> f32 {
        return A*B-floor(A*B) ;
    }

    fn sampleRandomDir(count:u32,SAMPLE_COUNT:u32) -> vec3<f32>{
    var ray_dir = sphericalFibonacci(f32((count)), f32(SAMPLE_COUNT) );
    return normalize(ray_dir) ;
    }

    fn sphericalFibonacci( i : f32 ,  n : f32 ) -> vec3<f32>{
        const PHI = sqrt(5.0) * 0.5 + 0.5;
        let phi = 2.0 * PI * madfrac(i, PHI - 1);
        let cosTheta = 1.0 - (2.0 * i + 1.0) * (1.0 / n);
        let sinTheta = sqrt(saturate(1.0 - cosTheta*cosTheta));

        return vec3<f32>(
            cos(phi) * sinTheta,
            sin(phi) * sinTheta,
            cosTheta);

    }
`;class N{static init(){N.register("MathShader",Ba),N.register("FastMathShader",Go),N.register("MatrixShader",wc),N.register("GlobalUniform",Ta),N.register("WorldMatrixUniform",Es),N.register("NormalMap_frag",Qo),N.register("LightingFunction_frag",Bo),N.register("PhysicMaterialUniform_frag",To),N.register("UnLitMaterialUniform_frag",Do),N.register("VideoUniform_frag",Ro),N.register("InstanceUniform",zo),N.register("Inline_vert",Uo),N.register("VertexAttributes_vert",Po),N.register("Common_vert",No),N.register("Common_frag",Oo),N.register("FragmentVarying",Vo),N.register("ColorPassFragmentOutput",Bs),N.register("ClusterLight",Ac),N.register("ShadingInput",Ho),N.register("IESProfiles_frag",Yo),N.register("ShadowMapping_frag",Xo),N.register("Irradiance_frag",Wo),N.register("IrradianceVolumeData_frag",Lo),N.register("BrdfLut_frag",Fo),N.register("EnvMap_frag",ko),N.register("ColorUtil_frag",Ts),N.register("ColorUtil",Ts),N.register("BRDF_frag",jo),N.register("BxDF_frag",qo),N.register("UnLit_frag",Mo),N.register("UnLit",On),N.register("Clearcoat_frag",Ko),N.register("LitShader",Jo),N.register("PBRLItShader",Zo),N.register("ClusterDebug_frag",Eo),N.register("BxdfDebug_frag",$o),N.register("GenerayRandomDir",sl),N.register("Quad_vert_wgsl",tl),N.register("Quad_frag_wgsl",il),N.register("Quad_depth2d_frag_wgsl",rl),N.register("Quad_depthCube_frag_wgsl",al),N.register("sky_vs_frag_wgsl",Ir.sky_vs_frag_wgsl),N.register("sky_fs_frag_wgsl",Ir.sky_fs_frag_wgsl),N.register("Bloom_Brightness_frag_wgsl",Ci.Bloom_Brightness_frag_wgsl),N.register("Bloom_blur_frag_wgsl",Ci.Bloom_blur_frag_wgsl),N.register("Bloom_composite_frag_wgsl",Ci.Bloom_composite_frag_wgsl),N.register("LambertShader",Cc),N.register("QuadGlsl_vs",_c),N.register("QuadGlsl_fs",vc),N.register("SkyGBuffer_fs",dc),N.register("gbuffer_vs",Ln),N.register("gbuffer_fs",Ln),N.register("castPointShadowMap_vert",uc),N.register("shadowCastMap_frag",cc),N.register("shadowCastMap_vert",hc),N.register("directionShadowCastMap_frag",fc),N.register("ZPass_shader_vs",mc),N.register("ZPass_shader_fs",pc)}static register(e,t){N[e.toLowerCase()]||(N[e.toLowerCase()]=t)}static getShader(e){return N[e.toLowerCase()],N[e.toLowerCase()]}}const Se=class{constructor(i=0,e=0){n(this,"x",0),n(this,"y",0),this.x=i,this.y=e}static getAngle(i,e){return Math.atan2(e.y-i.y,e.x-i.x)}static slerp(i,e,t){let r=new Se,a=i.dot(e);if(a<0&&(e.x=-e.x,e.y=-e.y,a=-a),a>.9995)return r.x=i.x+t*(e.x-i.x),r.y=i.y+t*(e.y-i.y),r;let s=Math.acos(a),o=Math.sin(s),l=Math.sin((1-t)*s)/o,h=Math.sin(t*s)/o;return r.x=l*i.x+h*e.x,r.y=l*i.y+h*e.y,r}static lerp(i,e,t){return Se.HELP_0.copyFrom(i),Se.HELP_1.copyFrom(e),Se.HELP_0.scale(t),Se.HELP_1.scale(1-t),new Se(Se.HELP_0.x+Se.HELP_1.x,Se.HELP_0.y+Se.HELP_1.y)}set(i=0,e=0){return this.x=i,this.y=e,this}distance(i){return Math.sqrt(Math.pow(this.x-i.x,2)+Math.pow(this.y-i.y,2))}add(i,e){return e=e||new Se,e.x=this.x+i.x,e.y=this.y+i.y,e}sub(i,e){return e=e||new Se,e.x=this.x-i.x,e.y=this.y-i.y,e}scale(i){return this.x=this.x*i,this.y=this.y*i,this}multiply(i,e){return e=e||new Se,e.x=this.x*i,e.y=this.y*i,e}multiplyScaler(i){return this.x*=i,this.y*=i,this}divide(i,e){return e=e||new Se,e.x=this.x/i,e.y=this.y/i,e}neg(i){return i||(i=new Se),i.x=-i.x,i.y=-i.y,i}abs(){return Math.sqrt(this.x*this.x+this.y*this.y)}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}getAngle(i){return Math.atan2(i.y-this.y,i.x-this.x)}unt(i){i=i||new Se;let e=this.abs();return i.x=this.x/e,i.y=this.y/e,i}angleTo(i){let e=i.x-this.x,t=i.y-this.y;return Math.atan2(t,e)}equals(i){return Math.abs(this.x-i.x)<1e-6&&Math.abs(this.y-i.y)<1e-6}pal(i){let e=this.unt(),t=i.unt();return e.equals(t)?1:e.equals(t.neg())?-1:0}clone(){return new Se(this.x,this.y)}copyFrom(i){return this.x=i.x,this.y=i.y,this}dot(i){return this.x*i.x+this.y*i.y}normalize(){let i=this.abs();return this.x=this.x/i,this.y=this.y/i,this}addInPlace(i){return this.x+=i.x,this.y+=i.y,this}addScalar(i){return this.x+=i,this.y+=i,this}clampScalar(i,e){return this.x=Math.max(i,Math.min(e,this.x)),this.y=Math.max(i,Math.min(e,this.y)),this}};let $=Se;n($,"HELP_0",new Se),n($,"HELP_1",new Se),n($,"ZERO",new Se(0,0)),n($,"SAFE_MAX",new Se(Number.MAX_SAFE_INTEGER,Number.MAX_SAFE_INTEGER)),n($,"SAFE_MIN",new Se(Number.MIN_SAFE_INTEGER,Number.MIN_SAFE_INTEGER));const De=class{constructor(i=0,e=0,t=0,r=0){n(this,"x",0),n(this,"y",0),n(this,"z",0),n(this,"w",1),this.x=i,this.y=e,this.z=t,this.w=r}get width(){return this.z}get height(){return this.w}static crossVectors(i,e,t){t=t||new De;var r=i.x,a=i.y,s=i.z,o=e.x,l=e.y,h=e.z;return t.x=a*h-s*l,t.y=s*o-r*h,t.z=r*l-a*o,t}static distance(i,e){let t=i.x-e.x,r=i.y-e.y,a=i.z-e.z,s=i.w-e.w;return Math.sqrt(t*t+r*r+a*a+s*s)}set(i,e,t,r){return this.x=i,this.y=e,this.z=t,this.w=r,this}multiplyScalar(i){return this.x*=i,this.y*=i,this.z*=i,this.w*=i,this}copyFrom(i){return this.x=i.x,this.y=i.y,this.z=i.z,this.w=i.w,this}clone(){return new De(this.x,this.y,this.z,this.w)}};let q=De;n(q,"X_AXIS",new De(1,0,0)),n(q,"Y_AXIS",new De(0,1,0)),n(q,"Z_AXIS",new De(0,0,1)),n(q,"HELP_0",new De),n(q,"HELP_1",new De),n(q,"HELP_2",new De),n(q,"EPSILON",1e-5),n(q,"HELP_3",new De),n(q,"HELP_4",new De),n(q,"HELP_5",new De),n(q,"HELP_6",new De),n(q,"ZERO",new De),n(q,"ONE",new De(1,1,1,1)),n(q,"LEFT",new De(-1,0,0)),n(q,"RIGHT",new De(1,0,0)),n(q,"UP",new De(0,-1,0)),n(q,"DOWN",new De(0,1,0)),n(q,"BACK",new De(0,0,-1)),n(q,"FORWARD",new De(0,0,1));var $e=(i=>(i[i.Number=0]="Number",i[i.Vector2=1]="Vector2",i[i.Vector3=2]="Vector3",i[i.Vector4=3]="Vector4",i[i.Color=4]="Color",i[i.Float32Array=5]="Float32Array",i))($e||{});class ee{constructor(e){n(this,"size"),n(this,"memoryInfo"),n(this,"bindOnChange"),n(this,"_data"),n(this,"_type",$e.Number),n(this,"_x",0),n(this,"_y",0),n(this,"_z",0),n(this,"_w",0),this.data=e}get data(){return this._data}set data(e){this._data=e,this._type=$e.Number,e instanceof $?(this.size=2,this._x=e.x,this._y=e.y,this._type=$e.Vector2):e instanceof p?(this.size=3,this._x=e.x,this._y=e.y,this._z=e.z,this._type=$e.Vector3):e instanceof q?(this.size=4,this._x=e.x,this._y=e.y,this._z=e.z,this._w=e.w,this._type=$e.Vector4):e instanceof z?(this.size=4,this._x=e.r,this._y=e.g,this._z=e.b,this._w=e.a,this._type=$e.Color):e instanceof Float32Array?(this.size=e.length,this._type=$e.Float32Array):(this.size=1,this._x=e,this._data=e,this._type=$e.Number)}getColor(e){return e?e.copyFrom(this._data):e=this._data,e}get color(){return new z(this._data.r,this._data.g,this._data.b,this._data.a)}set color(e){(this._x!=e.r||this._y!=e.g||this._z!=e.b||this._w!=e.a)&&(this._data.r=e.r,this._data.g=e.g,this._data.b=e.b,this._data.a=e.a,this._x=e.r,this._y=e.g,this._z=e.b,this._w=e.a,this.onChange())}get value(){return this._x}set value(e){this._x!=e&&(this._data=e,this._x=e,this.onChange())}get vector2(){return this._data}set vector2(e){(this._x!=e.x||this._y!=e.y)&&(this._data.x=e.x,this._data.y=e.y,this._x=e.x,this._y=e.y,this.onChange())}get vector3(){return this._data}set vector3(e){(this._x!=e.x||this._y!=e.y||this._z!=e.z)&&(this._data.x=e.x,this._data.y=e.y,this._data.z=e.z,this._x=e.x,this._y=e.y,this._z=e.z,this.onChange())}get vector4(){return this._data}set vector4(e){(this._x!=e.x||this._y!=e.y||this._z!=e.z||this._w!=e.w)&&(this._data.x=e.x,this._data.y=e.y,this._data.z=e.z,this._data.w=e.w,this._x=e.x,this._y=e.y,this._z=e.z,this._w=e.w,this.onChange())}onChange(){this.bindOnChange&&this.bindOnChange()}float32Array(e){this._data.set(e),this.onChange()}update(){switch(this._type){case $e.Number:this.memoryInfo.dataBytes.setFloat32(0*Float32Array.BYTES_PER_ELEMENT,this._data,!0);break;case $e.Vector2:this.memoryInfo.setVector2(0,this._data);break;case $e.Vector3:this.memoryInfo.setVector3(0,this._data);break;case $e.Vector4:this.memoryInfo.setVector4(0,this._data);break;case $e.Color:this.memoryInfo.setColor(0,this._data);break;case $e.Float32Array:this.memoryInfo.setFloat32Array(0,this._data);break}}}let Et={clamp_to_edge:"clamp-to-edge",repeat:"repeat",mirror_repeat:"mirror-repeat"},Xf={zero:"zero",one:"one",src:"src",one_minus_src:"one-minus-src",src_alpha:"src-alpha",one_minus_src_alpha:"one-minus-src-alpha",dst:"dst",one_minus_dst:"one-minus-dst",dst_alpha:"dst-alpha",one_minus_dst_alpha:"one-minus-dst-alpha",src_alpha_saturated:"src-alpha-saturated",constant:"constant",one_minus_constant:"one-minus-constant"};const Wf={srcFactor:"one",dstFactor:"zero",operation:"add"},jf={compare:"always",failOp:"keep",depthFailOp:"keep",passOp:"keep"};let _t={never:"never",less:"less",equal:"equal",less_equal:"less-equal",greater:"greater",not_equal:"not-equal",greater_equal:"greater-equal",always:"always"},ui={none:"none",front:"front",back:"back"},Br={nearest:"nearest",linear:"linear"},Da={point_list:"point-list",line_list:"line-list",line_strip:"line-strip",triangle_list:"triangle-list",triangle_strip:"triangle-strip"},G={r8unorm:"r8unorm",r8snorm:"r8snorm",r8uint:"r8uint",r8sint:"r8sint",r16uint:"r16uint",r16sint:"r16sint",r16float:"r16float",rg8unorm:"rg8unorm",rg8snorm:"rg8snorm",rg8uint:"rg8uint",rg8sint:"rg8sint",r32uint:"r32uint",r32sint:"r32sint",r32float:"r32float",rg16uint:"rg16uint",rg16sint:"rg16sint",rg16float:"rg16float",rgba8unorm:"rgba8unorm",rgba8unorm_srgb:"rgba8unorm-srgb",rgba8snorm:"rgba8snorm",rgba8uint:"rgba8uint",rgba8sint:"rgba8sint",bgra8unorm:"bgra8unorm",bgra8unorm_srgb:"bgra8unorm-srgb",rgb9e5ufloat:"rgb9e5ufloat",rgb10a2unorm:"rgb10a2unorm",rg11b10ufloat:"rg11b10ufloat",rg32uint:"rg32uint",rg32sint:"rg32sint",rg32float:"rg32float",rgba16uint:"rgba16uint",rgba16sint:"rgba16sint",rgba16float:"rgba16float",rgba32uint:"rgba32uint",rgba32sint:"rgba32sint",rgba32float:"rgba32float",stencil8:"stencil8",depth16unorm:"depth16unorm",depth24plus:"depth24plus",depth24plus_stencil8:"depth24plus-stencil8",depth32float:"depth32float",bc1_rgba_unorm:"bc1-rgba-unorm",bc1_rgba_unorm_srgb:"bc1-rgba-unorm-srgb",bc2_rgba_unorm:"bc2-rgba-unorm",bc2_rgba_unorm_srgb:"bc2-rgba-unorm-srgb",bc3_rgba_unorm:"bc3-rgba-unorm",bc3_rgba_unorm_srgb:"bc3-rgba-unorm-srgb",bc4_r_unorm:"bc4-r-unorm",bc4_r_snorm:"bc4-r-snorm",bc5_rg_unorm:"bc5-rg-unorm",bc5_rg_snorm:"bc5-rg-snorm",bc6h_rgb_ufloat:"bc6h-rgb-ufloat",bc6h_rgb_float:"bc6h-rgb-float",bc7_rgba_unorm:"bc7-rgba-unorm",bc7_rgba_unorm_srgb:"bc7-rgba-unorm-srgb",depth24unorm_stencil8:"depth24unorm-stencil8",depth32float_stencil8:"depth32float-stencil8"},Tr={uint8x2:"uint8x2",uint8x4:"uint8x4",sint8x2:"sint8x2",sint8x4:"sint8x4",unorm8x2:"unorm8x2",unorm8x4:"unorm8x4",snorm8x2:"snorm8x2",snorm8x4:"snorm8x4",uint16x2:"uint16x2",uint16x4:"uint16x4",sint16x2:"sint16x2",sint16x4:"sint16x4",unorm16x2:"unorm16x2",unorm16x4:"unorm16x4",snorm16x2:"snorm16x2",snorm16x4:"snorm16x4",float16x2:"float16x2",float16x4:"float16x4",float32:"float32",float32x2:"float32x2",float32x3:"float32x3",float32x4:"float32x4",uint32:"uint32",uint32x2:"uint32x2",uint32x3:"uint32x3",uint32x4:"uint32x4",sint32:"sint32",sint32x2:"sint32x2",sint32x3:"sint32x3",sint32x4:"sint32x4"},qf={vertex:"vertex",instance:"instance"};class Ae{}n(Ae,"colorBufferTex_NAME","colorBufferTex"),n(Ae,"positionBufferTex_NAME","positionBufferTex"),n(Ae,"normalBufferTex_NAME","normalBufferTex"),n(Ae,"materialBufferTex_NAME","materialBufferTex"),n(Ae,"zBufferTexture_NAME","zBufferTexture"),n(Ae,"zPreDepthTexture_NAME","zPreDepthTexture"),n(Ae,"outTex_NAME","outTex");var Le=(i=>(i[i.Default=1]="Default",i[i.IgnoreDepthPass=2]="IgnoreDepthPass",i[i.Sky=6]="Sky",i[i.Particle=10]="Particle",i[i.SkinnedMesh=16]="SkinnedMesh",i[i.MorphTarget=32]="MorphTarget",i[i.Terrain=64]="Terrain",i[i.UI=128]="UI",i))(Le||{});class Bt{static addMask(e,t){return e|t}static removeMask(e,t){return e&~t}static hasMask(e,t){return(e&t)==t}}const Dr=class{constructor(){n(this,"__refection"),n(this,"__size",0)}getValueType(){if(!this.__refection){let i=this;this.__refection=[];for(const e in i)if(!e.includes("__")){const t=i[e];let r={name:e,type:t.constructor.name};this.__refection.push(r)}}return this.__refection}static getValueSize(i){switch(i.constructor.name){case"Boolean":return 1*4;case"Number":return 1*4;case"f32":return 1*4;case"i32":return 1*4;case"u32":return 1*4;case"Float32Array":return i.byteLength*4;case"Vector2":return 2*4;case"Vector3":return 4*4;case"Vector4":return 4*4;case"Color":return 4*4;case"Array":let t=0;for(let r=0,a=i.length;r<a;r++)t+=Dr.getValueSize(i[r]);return t}return 0}static Ref(i){return this.Get(i).getValueType()}static Get(i){let e=Dr.__cacheStruct.get(i.prototype);return e||(e=new i,Dr.__cacheStruct.set(i.prototype,e)),e}static GetSize(i){let e=this.Get(i);if(e.__size==0){for(const t in e)if(t.indexOf("__")==-1){const r=e[t];e.__size+=Dr.getValueSize(r)}e.__size>4&&(e.__size=Math.ceil(e.__size/4)*4)}return e.__size}};let bi=Dr;n(bi,"__cacheStruct",new Map);class nl{constructor(){n(this,"byteOffset"),n(this,"byteSize"),n(this,"offset",0),n(this,"dataBytes")}get x(){return this.dataBytes.getFloat32(0*Float32Array.BYTES_PER_ELEMENT,!0)}set x(e){this.dataBytes.setFloat32(0*Float32Array.BYTES_PER_ELEMENT,e,!0)}get y(){return this.dataBytes.getFloat32(1*Float32Array.BYTES_PER_ELEMENT,!0)}set y(e){this.dataBytes.setFloat32(1*Float32Array.BYTES_PER_ELEMENT,e,!0)}get z(){return this.dataBytes.getFloat32(2*Float32Array.BYTES_PER_ELEMENT,!0)}set z(e){this.dataBytes.setFloat32(2*Float32Array.BYTES_PER_ELEMENT,e,!0)}get w(){return this.dataBytes.getFloat32(3*Float32Array.BYTES_PER_ELEMENT,!0)}set w(e){this.dataBytes.setFloat32(3*Float32Array.BYTES_PER_ELEMENT,e,!0)}setX(e){this.x=e}setXY(e,t){this.x=e,this.y=t}setXYZ(e,t,r){this.x=e,this.y=t,this.z=r}setXYZW(e,t,r,a){this.x=e,this.y=t,this.z=r,this.w=a}setVector2Array(e){for(let t=0;t<e.length;t++){const r=e[t];this.dataBytes.setFloat32((t*2+0)*Float32Array.BYTES_PER_ELEMENT,r.x,!0),this.dataBytes.setFloat32((t*2+1)*Float32Array.BYTES_PER_ELEMENT,r.y,!0)}}setVector3Array(e){for(let t=0;t<e.length;t++){const r=e[t];this.dataBytes.setFloat32((t*3+0)*Float32Array.BYTES_PER_ELEMENT,r.x,!0),this.dataBytes.setFloat32((t*3+1)*Float32Array.BYTES_PER_ELEMENT,r.y,!0),this.dataBytes.setFloat32((t*3+2)*Float32Array.BYTES_PER_ELEMENT,r.z,!0)}}setVector4Array(e){for(let t=0;t<e.length;t++){const r=e[t];this.dataBytes.setFloat32((t*4+0)*Float32Array.BYTES_PER_ELEMENT,r.x,!0),this.dataBytes.setFloat32((t*4+1)*Float32Array.BYTES_PER_ELEMENT,r.y,!0),this.dataBytes.setFloat32((t*4+2)*Float32Array.BYTES_PER_ELEMENT,r.z,!0),this.dataBytes.setFloat32((t*4+3)*Float32Array.BYTES_PER_ELEMENT,r.w,!0)}}setColorArray(e){for(let t=0;t<e.length;t++){const r=e[t];this.dataBytes.setFloat32((t*4+0)*Float32Array.BYTES_PER_ELEMENT,r.r,!0),this.dataBytes.setFloat32((t*4+1)*Float32Array.BYTES_PER_ELEMENT,r.g,!0),this.dataBytes.setFloat32((t*4+2)*Float32Array.BYTES_PER_ELEMENT,r.b,!0),this.dataBytes.setFloat32((t*4+3)*Float32Array.BYTES_PER_ELEMENT,r.a,!0)}}setInt8(e,t=0){this.dataBytes.setInt8(t*Int8Array.BYTES_PER_ELEMENT,e)}getInt8(e=0){return this.dataBytes.getInt8(e*Int8Array.BYTES_PER_ELEMENT)}setInt16(e,t=0){this.dataBytes.setInt16(t*Int16Array.BYTES_PER_ELEMENT,e,!0)}getInt16(e=0){return this.dataBytes.getInt16(e*Int16Array.BYTES_PER_ELEMENT,!0)}setInt32(e,t=0){this.dataBytes.setInt32(t*Int32Array.BYTES_PER_ELEMENT,e,!0)}getInt32(e=0){return this.dataBytes.getInt32(e*Int32Array.BYTES_PER_ELEMENT,!0)}setFloat(e,t=0){this.dataBytes.setFloat32(t*Float32Array.BYTES_PER_ELEMENT,e,!0)}getFloat(e=0){return this.dataBytes.getFloat32(e*Float32Array.BYTES_PER_ELEMENT,!0)}setUint8(e,t=0){this.dataBytes.setUint8(t*Uint8Array.BYTES_PER_ELEMENT,e)}getUint8(e=0){return this.dataBytes.getUint8(e*Uint8Array.BYTES_PER_ELEMENT)}setUint16(e,t=0){this.dataBytes.setUint16(t*Uint16Array.BYTES_PER_ELEMENT,e,!0)}getUint16(e=0){return this.dataBytes.getUint16(e*Uint16Array.BYTES_PER_ELEMENT,!0)}setUint32(e,t=0){this.dataBytes.setUint32(t*Uint32Array.BYTES_PER_ELEMENT,e,!0)}getUint32(e=0){return this.dataBytes.getUint32(e*Uint32Array.BYTES_PER_ELEMENT,!0)}setArray(e,t){for(let r=0;r<t.length;r++){const a=t[r];this.dataBytes.setFloat32((e+r)*Float32Array.BYTES_PER_ELEMENT,a,!0)}}setFloat32Array(e,t){new Float32Array(this.dataBytes.buffer,this.dataBytes.byteOffset+e*Float32Array.BYTES_PER_ELEMENT,t.length).set(t)}setArrayBuffer(e,t){t instanceof Uint8Array?this.setUint8Array(e,t):t instanceof Uint16Array?this.setUint16Array(e,t):t instanceof Uint32Array?this.setUint32Array(e,t):t instanceof Int8Array?this.setInt8Array(e,t):t instanceof Int16Array?this.setInt16Array(e,t):t instanceof Int32Array?this.setInt32Array(e,t):t instanceof Float32Array&&this.setFloat32Array(e,t)}setInt8Array(e,t){new Int8Array(this.dataBytes.buffer,this.dataBytes.byteOffset+e*Int8Array.BYTES_PER_ELEMENT).set(t)}setInt16Array(e,t){new Int16Array(this.dataBytes.buffer,this.dataBytes.byteOffset+e*Int16Array.BYTES_PER_ELEMENT).set(t)}setInt32Array(e,t){new Int32Array(this.dataBytes.buffer,this.dataBytes.byteOffset+e*Int32Array.BYTES_PER_ELEMENT).set(t)}setUint8Array(e,t){new Uint8Array(this.dataBytes.buffer,this.dataBytes.byteOffset+e*Uint8Array.BYTES_PER_ELEMENT).set(t)}setUint16Array(e,t){new Uint16Array(this.dataBytes.buffer,this.dataBytes.byteOffset+e*Uint16Array.BYTES_PER_ELEMENT).set(t)}setUint32Array(e,t){new Uint32Array(this.dataBytes.buffer,this.dataBytes.byteOffset+e*Uint32Array.BYTES_PER_ELEMENT).set(t)}setData(e,t){this.dataBytes.setFloat32(e*Float32Array.BYTES_PER_ELEMENT,t,!0)}setVector2(e,t){this.dataBytes.setFloat32(e*Float32Array.BYTES_PER_ELEMENT,t.x,!0),this.dataBytes.setFloat32((e+1)*Float32Array.BYTES_PER_ELEMENT,t.y,!0)}setVector3(e,t){this.dataBytes.setFloat32(e*Float32Array.BYTES_PER_ELEMENT,t.x,!0),this.dataBytes.setFloat32((e+1)*Float32Array.BYTES_PER_ELEMENT,t.y,!0),this.dataBytes.setFloat32((e+2)*Float32Array.BYTES_PER_ELEMENT,t.z,!0)}setVector4(e,t){this.dataBytes.setFloat32(e*Float32Array.BYTES_PER_ELEMENT,t.x,!0),this.dataBytes.setFloat32((e+1)*Float32Array.BYTES_PER_ELEMENT,t.y,!0),this.dataBytes.setFloat32((e+2)*Float32Array.BYTES_PER_ELEMENT,t.z,!0),this.dataBytes.setFloat32((e+3)*Float32Array.BYTES_PER_ELEMENT,t.w,!0)}setColor(e,t){this.dataBytes.setFloat32(e*Float32Array.BYTES_PER_ELEMENT,t.r,!0),this.dataBytes.setFloat32((e+1)*Float32Array.BYTES_PER_ELEMENT,t.g,!0),this.dataBytes.setFloat32((e+2)*Float32Array.BYTES_PER_ELEMENT,t.b,!0),this.dataBytes.setFloat32((e+3)*Float32Array.BYTES_PER_ELEMENT,t.a,!0)}getData(e){return this.dataBytes.getFloat32(e*Float32Array.BYTES_PER_ELEMENT,!0)}writeFloat(e){this.dataBytes.setFloat32(this.offset,e,!0),this.offset+=Float32Array.BYTES_PER_ELEMENT}writeInt8(e){this.dataBytes.setInt8(this.offset,e),this.offset+=Int8Array.BYTES_PER_ELEMENT}writeInt16(e){this.dataBytes.setInt16(this.offset,e,!0),this.offset+=Int16Array.BYTES_PER_ELEMENT}writeInt32(e){this.dataBytes.setInt32(this.offset,e,!0),this.offset+=Int32Array.BYTES_PER_ELEMENT}writeUint8(e){this.dataBytes.setUint8(this.offset,e),this.offset+=Uint8Array.BYTES_PER_ELEMENT}writeUint16(e){this.dataBytes.setUint16(this.offset,e,!0),this.offset+=Uint16Array.BYTES_PER_ELEMENT}writeUint32(e){this.dataBytes.setUint32(this.offset,e,!0),this.offset+=Uint32Array.BYTES_PER_ELEMENT}writeVector2(e){this.writeFloat(e.x),this.writeFloat(e.y)}writeVector3(e){this.writeFloat(e.x),this.writeFloat(e.y),this.writeFloat(e.z)}writeVector4(e){this.writeFloat(e.x),this.writeFloat(e.y),this.writeFloat(e.z),this.writeFloat(e.w)}writeRGBColor(e){this.writeFloat(e.r),this.writeFloat(e.g),this.writeFloat(e.b)}writeArray(e){for(let t=0;t<e.length;t++){const r=e[t];this.writeFloat(r)}}writeFloat32Array(e){new Float32Array(this.dataBytes.buffer,this.dataBytes.byteOffset+this.offset).set(e),this.offset+=e.byteLength}writeInt8Array(e){new Int8Array(this.dataBytes.buffer,this.dataBytes.byteOffset+this.offset).set(e),this.offset+=e.byteLength}writeInt16Array(e){new Int16Array(this.dataBytes.buffer,this.dataBytes.byteOffset+this.offset).set(e),this.offset+=e.byteLength}writeInt32Array(e){new Int32Array(this.dataBytes.buffer,this.dataBytes.byteOffset+this.offset).set(e),this.offset+=e.byteLength}writeUint8Array(e){new Uint8Array(this.dataBytes.buffer,this.dataBytes.byteOffset+this.offset).set(e),this.offset+=e.byteLength}writeUint16Array(e){new Uint16Array(this.dataBytes.buffer,this.dataBytes.byteOffset+this.offset).set(e),this.offset+=e.byteLength}writeUint32Array(e){new Uint32Array(this.dataBytes.buffer,this.dataBytes.byteOffset+this.offset).set(e),this.offset+=e.byteLength}reset(){this.offset=0}destroy(){this.byteOffset=null,this.byteSize=null,this.offset=null,this.dataBytes=null}}class Mr{constructor(){n(this,"shareDataBuffer"),n(this,"_byteOffset",0)}allocation(e){this.shareDataBuffer&&this.shareDataBuffer.byteLength<e?this._byteOffset=0:this.shareDataBuffer=new ArrayBuffer(e)}allocation_node(e){if(this._byteOffset+e>this.shareDataBuffer.byteLength)return console.error("memory not enough!",this._byteOffset,e,this.shareDataBuffer.byteLength),null;let t=new nl;return t.byteOffset=this._byteOffset,t.byteSize=e,t.dataBytes=new DataView(this.shareDataBuffer,this._byteOffset,t.byteSize),this._byteOffset+=t.byteSize,t}allocation_memory(e){return this._byteOffset+e.byteSize>this.shareDataBuffer.byteLength?(console.error("memory not enough!",this._byteOffset,e.byteSize,this.shareDataBuffer.byteLength),null):(e.byteOffset=this._byteOffset,e.dataBytes=new DataView(this.shareDataBuffer,this._byteOffset,e.byteSize),this._byteOffset+=e.byteSize,e)}reset(){this._byteOffset=0}destroy(e){this.shareDataBuffer=null,this._byteOffset=0}}class qt{constructor(){n(this,"bufferType"),n(this,"buffer"),n(this,"memory"),n(this,"memoryNodes"),n(this,"seek"),n(this,"outFloat32Array"),n(this,"byteSize"),n(this,"usage"),n(this,"visibility",GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE),n(this,"mapAsyncBuffersOutstanding",0),n(this,"mapAsyncReady"),n(this,"_readBuffer"),n(this,"_dataView"),n(this,"_readFlag",!1),this.mapAsyncReady=[],this.memory=new Mr,this.memoryNodes=new Map,this._dataView=new Float32Array(this.memory.shareDataBuffer)}debug(){}reset(e=!1,t=0,r){this.seek=0,this.memory.reset(),e&&this.createBuffer(this.usage,t,r)}setBoolean(e,t){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(1*4),this.memoryNodes.set(e,r)),r.setX(t?1:0)}setFloat(e,t){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(1*4),this.memoryNodes.set(e,r)),r.setX(t)}setInt8(e,t){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(1*1),this.memoryNodes.set(e,r)),r.setInt8(t)}setInt16(e,t){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(1*2),this.memoryNodes.set(e,r)),r.setInt16(t)}setInt32(e,t){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(1*4),this.memoryNodes.set(e,r)),r.setInt32(t)}setUint8(e,t){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(1*1),this.memoryNodes.set(e,r)),r.setUint8(t)}setUint16(e,t){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(1*2),this.memoryNodes.set(e,r)),r.setUint16(t)}setUint32(e,t){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(1*4),this.memoryNodes.set(e,r)),r.setUint32(t)}setVector2(e,t){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(2*4),this.memoryNodes.set(e,r)),r.setXY(t.x,t.y)}setVector3(e,t){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(3*4),this.memoryNodes.set(e,r)),r.setXYZ(t.x,t.y,t.z)}setVector4(e,t){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(4*4),this.memoryNodes.set(e,r)),r.setXYZW(t.x,t.y,t.z,t.w)}setVector4Array(e,t){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(4*4*t.length),this.memoryNodes.set(e,r)),r.setVector4Array(t)}setColor(e,t){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(4*4),this.memoryNodes.set(e,r)),r.setXYZW(t.r,t.g,t.b,t.a)}setColorArray(e,t){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(4*4*t.length),this.memoryNodes.set(e,r)),r.setColorArray(t)}setMatrix(e,t){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(16*4),this.memoryNodes.set(e,r)),r.setFloat32Array(0,t.rawData)}setMatrixArray(e,t){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(16*4*t.length),this.memoryNodes.set(e,r));for(let a=0;a<t.length;a++){const s=t[a];r.setFloat32Array(a*16,s.rawData)}}setArray(e,t){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(t.length*4),this.memoryNodes.set(e,r)),r.setArray(0,t)}setFloat32Array(e,t){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(t.length*4),this.memoryNodes.set(e,r)),r.setFloat32Array(0,t)}setInt32Array(e,t){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(t.length*4),this.memoryNodes.set(e,r)),r.setInt32Array(0,t)}setUint32Array(e,t){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(t.length*4),this.memoryNodes.set(e,r)),r.setUint32Array(0,t)}setStruct(e,t,r,a){let s=bi.Ref(e);bi.GetSize(e);let o=t,l=this.memoryNodes.get(o);l.reset();let h=r;a&&(h=h[a]);for(let u=0;u<s.length;u++){const c=s[u];let d=h[c.name];switch(c.type){case"Boolean":l.writeFloat(d);break;case"Number":l.writeFloat(d);break;case"Float32Array":l.writeFloat32Array(d);break;case"Vector2":l.writeVector2(d);break;case"Vector3":l.writeVector3(d);break;case"Vector4":l.writeVector4(d);break;case"Color":l.writeRGBColor(d);break;case"Array":l.writeArray(d);break}}}setStructArray(e,t,r){let a=t.length;for(let s=0;s<a;s++){const o=t[s];this.setStruct(e,s,o,r)}}clean(){this._dataView.fill(0,0,this._dataView.length)}apply(){I.device.queue.writeBuffer(this.buffer,0,this.memory.shareDataBuffer)}applyMapAsync(){this.mapAsyncWrite(new Float32Array(this.memory.shareDataBuffer),this.memory.shareDataBuffer.byteLength/4)}mapAsyncWrite(e,t){let r=I.device;if(e.length>0){let a=null;for(;this.mapAsyncReady.length&&(a=this.mapAsyncReady.shift(),a.usedSize!=e.byteLength);)a.destroy(),this.mapAsyncBuffersOutstanding--,a=null;a||(a=r.createBuffer({size:e.byteLength,usage:GPUBufferUsage.COPY_SRC|GPUBufferUsage.MAP_WRITE,mappedAtCreation:!0}),a.usedSize=e.byteLength,this.mapAsyncBuffersOutstanding++,this.mapAsyncBuffersOutstanding>10&&console.warn(` Warning: mapAsync requests from ${this.mapAsyncBuffersOutstanding} frames ago have not resolved yet.  MB of staging buffers allocated.`));let s=new Float32Array(e.buffer,e.byteOffset,t);new Float32Array(a.getMappedRange(0,t*4)).set(s),a.unmap();const l=r.createCommandEncoder();l.copyBufferToBuffer(a,0,this.buffer,0,t*4),r.queue.submit([l.finish()]),a.mapAsync(GPUMapMode.WRITE).then(()=>this.mapAsyncReady.push(a))}}destroy(e){this.memoryNodes&&this.memoryNodes.forEach(t=>{t.destroy()}),this.bufferType=null,this.seek=null,this.byteSize=null,this.usage=null,this.visibility=null,this.outFloat32Array=null,this.buffer&&this.buffer.destroy(),this.buffer=null,this.memory&&this.memory.destroy(),this.memory=null,this._readBuffer&&this._readBuffer.destroy()}createBuffer(e,t,r){let a=I.device;this.byteSize=t*4,this.usage=e,this.buffer&&this.destroy(),this.buffer=a.createBuffer({size:this.byteSize,usage:e,mappedAtCreation:!1}),this.memory.allocation(this.byteSize),r&&(this.memory.allocation_node(r.length*4).setArrayBuffer(0,r),this.apply())}createNewBuffer(e,t){let r=I.device,a=t*4,s=e;return this.buffer&&this.destroy(),r.createBuffer({size:a,usage:s,mappedAtCreation:!1})}createBufferByStruct(e,t,r){let a=bi.GetSize(t),s=a*r,o=I.device;this.buffer=o.createBuffer({size:s,usage:e,mappedAtCreation:!1}),this.memory.allocation(s);for(let l=0;l<r;l++){let h=l,u=this.memoryNodes.get(h);u||(u=this.memory.allocation_node(a),this.memoryNodes.set(h,u))}}readBuffer(){return this.outFloat32Array||(this.outFloat32Array=new Float32Array(this.memory.shareDataBuffer.byteLength/4)),this._readBuffer||(this._readBuffer=I.device.createBuffer({size:this.memory.shareDataBuffer.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ,mappedAtCreation:!1})),this._readFlag||this.read(),this.outFloat32Array}async read(){this._readFlag=!0;let e=I.device.createCommandEncoder();e.copyBufferToBuffer(this.buffer,0,this._readBuffer,0,this.memory.shareDataBuffer.byteLength),I.device.queue.submit([e.finish()]),await this._readBuffer.mapAsync(GPUMapMode.READ);const t=this._readBuffer.getMappedRange();this.outFloat32Array.set(new Float32Array(t),0),this._readBuffer.unmap(),this._readFlag=!1}}var Tt=(i=>(i[i.IndicesGPUBuffer=0]="IndicesGPUBuffer",i[i.VertexGPUBuffer=1]="VertexGPUBuffer",i[i.UniformGPUBuffer=2]="UniformGPUBuffer",i[i.StorageGPUBuffer=3]="StorageGPUBuffer",i[i.ComputeGPUBuffer=4]="ComputeGPUBuffer",i[i.MaterialDataUniformGPUBuffer=5]="MaterialDataUniformGPUBuffer",i[i.StructStorageGPUBuffer=6]="StructStorageGPUBuffer",i))(Tt||{});class fe extends qt{constructor(e,t=0,r){super(),this.bufferType=Tt.StorageGPUBuffer,this.createBuffer(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|t,e,r)}}class Dt extends qt{constructor(e,t){super(),this.bufferType=Tt.UniformGPUBuffer,this.createBuffer(GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC,e,t)}genUniformNodes(){}}let Mt=function(i=16,e=16){var t="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(""),r=[],a;if(e=e||t.length,i)for(a=0;a<i;a++)r[a]=t[0|Math.random()*e];else{var s;for(r[8]=r[13]=r[18]=r[23]="-",r[14]="4",a=0;a<36;a++)r[a]||(s=0|Math.random()*16,r[a]=t[a==19?s&3|8:s])}return r.join("")},ol=1e6,Ds=function(){return ol++,ol},Kf=function(i,e){let t=0,r=i.length;for(t=0;t<r;t++)if(i[t]==e)return!0;return!1},Jf=function(i,e){let t=0,r=i.length;for(t=0;t<r;t++)if(i[t]==e)return t;return-1};class Ms{constructor(){n(this,"instanceID"),n(this,"shaderVariant"),n(this,"vsEntryPoint","main"),n(this,"fsEntryPoint","main"),n(this,"bindGroups"),n(this,"shaderReflection"),n(this,"defineValue"),n(this,"constValues"),n(this,"uniforms"),n(this,"_bufferDic"),n(this,"_shaderChange",!0),n(this,"_valueChange",!1),this.instanceID=Mt(),this.defineValue={},this.constValues={},this.uniforms={},this._bufferDic=new Map}noticeShaderChange(){this._shaderChange=!0}noticeValueChange(){this._valueChange=!0}setStorageBuffer(e,t){this._bufferDic.has(e)?this._bufferDic.set(e,t):(this._bufferDic.set(e,t),this.noticeBufferChange(e))}setStructStorageBuffer(e,t){this._bufferDic.has(e)?(this._bufferDic.set(e,t),this.noticeBufferChange(e)):this._bufferDic.set(e,t)}setUniformBuffer(e,t){this._bufferDic.has(e)?(this._bufferDic.set(e,t),this.noticeBufferChange(e)):this._bufferDic.set(e,t)}setDefine(e,t){(this.defineValue[e]==null||this.defineValue[e]!=t)&&(this.defineValue[e]=t,this.noticeValueChange(),this.noticeShaderChange()),this.defineValue[e]=t}hasDefine(e){return this.defineValue[e]!=null}deleteDefine(e){delete this.defineValue[e],this.noticeShaderChange()}setUniformFloat(e,t){this.uniforms[e]?this.uniforms[e].value=t:(this.uniforms[e]=new ee(t),this.noticeValueChange())}setUniformVector2(e,t){this.uniforms[e]?this.uniforms[e].vector2=t:(this.uniforms[e]=new ee(t),this.noticeValueChange())}setUniformVector3(e,t){this.uniforms[e]?this.uniforms[e].vector3=t:this.uniforms[e]=new ee(t)}setUniformVector4(e,t){this.uniforms[e]?this.uniforms[e].vector4=t:this.uniforms[e]=new ee(t)}setUniformColor(e,t){this.uniforms[e]?this.uniforms[e].color=t:this.uniforms[e]=new ee(t)}setUniformArray(e,t){this.uniforms[e]?this.uniforms[e].float32Array(t):this.uniforms[e]=new ee(t)}setUniform(e,t){this.uniforms[e]?this.uniforms[e].data=t:this.uniforms[e]=new ee(t)}getUniform(e){return this.uniforms[e].data}noticeBufferChange(e){}destroy(e){}}var wi=(i=>(i[i.u32=1]="u32",i[i.f32=1]="f32",i[i["vec2<f32>"]=2]="vec2<f32>",i[i["vec3<f32>"]=3]="vec3<f32>",i[i["vec4<f32>"]=4]="vec4<f32>",i[i.float32=1]="float32",i[i.float32x2=2]="float32x2",i[i.float32x3=3]="float32x3",i[i.float32x4=4]="float32x4",i))(wi||{});let ll=[null,Tr.float32,Tr.float32x2,Tr.float32x3,Tr.float32x4];class ut{static parse(e,t){return e=this.filterComment(e),e=this.parsePreprocess(new hl,e,t),e=this.parseAutoBindingForGroupX(e,1),e}static parseComputeShader(e,t){return e=this.filterComment(e),e=this.parsePreprocess(new hl,e,t),e}static parsePreprocess(e,t,r){let a=t.indexOf("#");if(a==-1)return t;let s=t.substring(0,a),o=t.indexOf(`
`,t.lastIndexOf("#")),l=t.substring(a,o),h=t.substring(o);return s+this.parsePreprocessCommand(e,l,r)+h}static parseAutoBindingForGroupX(e,t){let r=0,a="",s=new Map;for(;r<e.length;){let o=e.indexOf("@group(",r);if(o==-1){a+=e.substring(r);break}let l=e.indexOf(")",o),h=Number.parseInt(e.substring(o+7,l));if(o=e.indexOf("@binding(",l),l=e.indexOf(")",o),a+=e.substring(r,o),h==t)if(s.has(h)){let u=s.get(h)+1;a+=`@binding(${u})`,s.set(h,u)}else a+="@binding(0)",s.set(h,0);else a+=e.substring(o,l+1);r=l+1}return a}static parsePreprocessCommand(e,t,r){let a="",s=t.split(`
`),o=[!1],l=[!1];for(let h=0;h<s.length;h++){let u=s[h],c=o[o.length-1];if(u.trim().indexOf("#")!=0){c||(a+=u+`
`);continue}let d=u.trim();if(d.indexOf("#if")!=-1){if(c&&o.length>1){o.push(c);continue}let g=d.substring(3).trim();c=!this.parseCondition(g,r),o.push(c),l.push(!c);continue}else if(d.indexOf("#elseif")!=-1||d.indexOf("#else")!=-1&&d.indexOf(" if")!=-1){if(l[l.length-1]){o.pop(),c=!0,o.push(c);continue}if(o.pop(),c=o[o.length-1],c&&o.length>1){o.push(c);continue}let m=d.substring(d.indexOf("if")+2).trim();m==""&&console.error(`preprocess command error, conditions missing: ${d}`),c=!this.parseCondition(m,r),o.push(c),l.push(!c);continue}else if(d.indexOf("#else")!=-1){o.pop(),c&&o.length>1&&o[o.length-1]?o.push(c):o.push(!c);continue}else if(d.indexOf("#endif")!=-1){o.pop(),l.pop();continue}else if(d.indexOf("#include")!=-1){let g="",m=d.charAt(d.length-1);if(m==">"?g=this.extract(d,"<",">"):g=this.extract(d,m,m),!e.includeMap.has(g)){e.includeMap.set(g,!0);let A=N.getShader(g);if(!A)throw`${d} error: '${g}' not found`;A=this.filterComment(A),A=this.parsePreprocess(e,A,r),a+=A+`\r
`}continue}else if(d.indexOf("#define ")!=-1){let g=d.substring(d.indexOf("#define ")+8).trim(),m=g.indexOf(" "),A=g,v="";m!=-1&&(A=g.substring(0,m).trim(),v=g.substring(m+1).trim()),r[A]=v;continue}else throw"nonsupport: "+d}return a}static parseCondition(e,t){let r=t[e];return r==null?!1:r==!0||r!=0}static filterComment(e){let t="",r=!0,a=!0;for(let s=0;s<e.length;){let o=r?e.indexOf("//",s):-1,l=a?e.indexOf("/*",s):-1;if(o==-1&&l==-1){t+=e.substring(s);break}r=o!=-1,a=l!=-1,o!=-1&&l!=-1&&(o<l?l=-1:o=-1),o!=-1?(l=e.indexOf(`
`,o),t+=e.substring(s,o),s=l!=-1?l:e.length):l!=-1&&(o=e.indexOf("*/",l),t+=e.substring(s,l),s=o+2)}return t}static extract(e,t,r){let a=e.indexOf(t)+t.length,s=e.indexOf(r,a);return e.substring(a,s).trim()}}class hl{constructor(){n(this,"includeMap",new Map)}}const Ma=class{constructor(){n(this,"attributes",[]),n(this,"vs_variables",[]),n(this,"fs_variables",[]),n(this,"cs_variables",[]),n(this,"groups",[]),n(this,"variables",{}),n(this,"useSplit",!1)}static parser(i,e){e.shaderReflection||(e.shaderReflection=new Ma),i.indexOf("@vertex")!=-1?(e.shaderReflection.attributes=this.parserVertexOld(i),e.shaderReflection.vs_variables=this.parserVariables(i)):i.indexOf("@fragment")!=-1?e.shaderReflection.fs_variables=this.parserVariables(i):i.indexOf("@compute")!=-1&&(e.shaderReflection.cs_variables=this.parserVariables(i))}static parser2(i,e){e.shaderReflection||(e.shaderReflection=new Ma);let t=e.shaderReflection;i.indexOf("@vertex")!=-1?(t.attributes=this.parserVertex(e.vsEntryPoint,i),t.vs_variables=this.parserVariables(i)):i.indexOf("@fragment")!=-1?t.fs_variables=this.parserVariables(i):i.indexOf("@compute")!=-1&&(t.cs_variables=this.parserVariables(i)),i.indexOf("splitTexture")!=-1&&(t.useSplit=!0)}static combineShaderReflectionVarInfo(i,e){for(const t of e){i.groups[t.group]||(i.groups[t.group]=[]);let r=t;if(i.groups[t.group][t.binding]){let a=i.groups[t.group][t.binding],s=t;if(a.dataFields)for(let o=0;o<a.dataFields.length;o++)a.dataFields[o];if(s.dataFields)for(let o=0;o<s.dataFields.length;o++)s.dataFields[o]}i.groups[t.group][t.binding]=r,i.variables[t.varName]=r}}static final(i){let e=i.shaderReflection;this._shaderReflectionMap.set(i.shaderVariant,e),this.combineShaderReflectionVarInfo(e,e.vs_variables),this.combineShaderReflectionVarInfo(e,e.fs_variables)}static getShaderReflection2(i,e){if(e.shaderVariant!=null){let t=ut.parse(i,e.defineValue);Ma.parser2(t,e)}}static poolGetReflection(i){return this._shaderReflectionMap.get(i)}static genShaderVar(i){let e=`${i.vs}${i.fs}${i.compute}`;e+="|";for(const t in i.uniforms)e+=t+":";e+="|";for(const t in i.constValues)e+=t+":",e+=i.constValues[t];e+="|";for(const t in i.defines)e+=t+":",e+=i.defines[t];e+="|";for(const t in i.shaderState)e+=t+":",e+=i.shaderState[t]+";";return e}static genShaderVariant(i){let e="";for(const t in i.uniforms)e+=t+":";e+="|";for(const t in i.constValues)e+=t+":",e+=i.constValues[t];e+="|";for(const t in i.defineValue)e+=t+":",e+=i.defineValue[t];return e}static genRenderShaderVariant(i){let e=`RenderShader(${i.vsName},${i.fsName})`;e+="|",e+=this.genShaderVariant(i),e+="|";for(const t in i.shaderState)e+=t+":",e+=i.shaderState[t]+";";return e}static genComputeShaderVariant(i){let e=`ComputeShader(${i.instanceID})`;return e+="|",e+=this.genShaderVariant(i),e}combine(i){let e=i.shaderReflection,t=i.defines,r={};for(let s=0;s<this.attributes.length;s++){let o=this.attributes[s];t[o.name]&&(r[o.name]=o)}let a=e.attributes.length;for(let s=0;s<a;s++){const o=e.attributes[s];if(!r[o.name])this.attributes.push(o);else{let l=r[o.name];l.location==o.location&&l.name!=o.name&&console.log("location must same!")}}}static parserVariables(i){let e=0,t=[];for(;e<i.length;){let r=i.indexOf("@group(",e);if(r<0)break;let a=i.indexOf(";",r);e=a;let s=i.substring(r,a),o=this.extract(s,"@group(",")"),l=this.extract(s,"@binding(",")"),h="",u="var";s.indexOf("var<")!=-1?(h=this.extract(s,">",":"),u=this.extract(s,"var<",">").replace(",","-").replaceAll(" ","")):h=this.extract(s,"var",":");let c=s.substring(s.lastIndexOf(":")+1).trim(),d={group:0,binding:0,varType:"",varName:"",dataType:"",dataIsBuiltinType:!0,dataFields:null};d.group=Number.parseInt(o),d.binding=Number.parseInt(l),d.varType=u,d.varName=h,d.dataType=c,d.dataIsBuiltinType=this.isBuiltinTypes(d.dataType),d.dataIsBuiltinType||(d.dataFields=this.parserStructFields(i,d.dataType)),t.push(d)}return t}static extract(i,e,t){let r=i.indexOf(e)+e.length,a=i.indexOf(t,r);return i.substring(r,a).trim()}static isBuiltinTypes(i){switch(i){case"i32":return!0;case"u32":return!0;case"f32":return!0;default:let e=i.indexOf("<");if(e!=-1)switch(i.substring(0,e)){case"vec2":return!0;case"vec3":return!0;case"vec4":return!0;case"mat3":return!0;case"mat4":return!0;case"array":return this.isBuiltinTypes(i.substring(e+1,i.lastIndexOf(">")))}break}return!1}static parserStructFields(i,e){let t=[],r=0;for(;r<i.length;){let a=i.indexOf("struct ",r);if(a<0)break;let s=i.indexOf("{",a);if(r=s,i.substring(a+6,s).trim()===e){a=i.indexOf("{",a),s=i.indexOf("}",a);let h=i.substring(a+1,s).split(",");for(let u of h){let c=u.indexOf(":");if(c!=-1){let d={name:u.substring(0,c).trim(),type:u.substring(c+1).trim()};t.push(d)}}break}}return t}static parserVertexOld(i){let e=[],r=i.split("fn main(")[1].split("->")[0],a=r.split("@");if(a&&a.length>1)for(let o=1;o<a.length;o++){let h=a[o].replace(/\s*$/g,"");h=h.replaceAll(",",""),h=h.replaceAll(`
`,""),h=h.replaceAll("  "," "),this.parserAttribute(h,e)}else{var s=r.split(":")[1];s=s.replaceAll("  ",""),s=s.replaceAll(" ",""),s=s.replaceAll(")",""),s=i.split(`struct ${s}`)[1];let l=s.indexOf("{"),h=s.indexOf("}");s=s.slice(l,h),a=s.split("@");for(let u=1;u<a.length;u++){let d=a[u].replace(/\s*$/g,"");d=d.replaceAll(`
`,""),d=d.split(",")[0],d=d.replaceAll("  "," "),this.parserAttribute(d,e)}}return e}static parserVertex(i,e){let t=[],a=e.split(`fn ${i}(`)[1].split("->")[0],s=a.split("@");if(s&&s.length>1)for(let l=1;l<s.length;l++){let u=s[l].replace(/\s*$/g,"");u=u.replaceAll(",",""),u=u.replaceAll(`
`,""),u=u.replaceAll("  "," "),this.parserAttribute(u,t)}else{var o=a.split(":")[1];o=o.replaceAll("  ",""),o=o.replaceAll(" ",""),o=o.replaceAll(")",""),o=e.split(`struct ${o}`)[1];let h=o.indexOf("{"),u=o.indexOf("}");o=o.slice(h,u),s=o.split("@");for(let c=1;c<s.length;c++){let g=s[c].replace(/\s*$/g,"");g=g.replaceAll(`
`,""),g=g.split(",")[0],g=g.replaceAll("  "," "),this.parserAttribute(g,t)}}return t}static parserAttribute(i,e){let t={name:"",group:0,location:0,type:"",valueType:"",value:0,size:0,format:"float32"};if(i.indexOf("builtin")!=-1){t.type="builtin";var r=i.match(/\((.+?)\)/g)[0];r=i.match(/\((.+?)\)/g)[0],r=r.replace("(",""),r=r.replaceAll(")",""),t.location=parseInt(r);let a=i.split(":");t.name=a[0].split(" ")[1],t.name=t.name.replaceAll("  "," "),t.name=t.name.replaceAll(" ",""),t.valueType=a[1],t.valueType=t.valueType.replaceAll("  "," "),t.valueType=t.valueType.replaceAll(" ",""),t.valueType=t.valueType.replaceAll("\r",""),t.valueType=t.valueType.replaceAll(")",""),t.valueType=t.valueType.replaceAll(")",""),t.size=wi[t.valueType],e.push(t)}else if(i.indexOf("location")!=-1){t.type="location";var r=i.match(/\((.+?)\)/g)[0];r=i.match(/\((.+?)\)/g)[0],r=r.replace("(",""),r=r.replaceAll(")",""),t.location=parseInt(r);let s=i.split(":");t.name=s[0].split(" ")[1],t.name=t.name.replaceAll("  "," "),t.name=t.name.replaceAll(" ",""),t.valueType=s[1],t.valueType=t.valueType.replaceAll("  "," "),t.valueType=t.valueType.replaceAll(" ",""),t.valueType=t.valueType.replaceAll("\r",""),t.valueType=t.valueType.replaceAll(")",""),t.valueType=t.valueType.replaceAll(")",""),t.size=wi[t.valueType],e.push(t)}t.format=ll[wi[t.valueType]]}};let ct=Ma;n(ct,"_shaderReflectionMap",new Map);class be extends Ms{constructor(e){super(),n(this,"entryPoint","CsMain"),n(this,"workerSizeX",1),n(this,"workerSizeY",0),n(this,"workerSizeZ",0),n(this,"_computePipeline"),n(this,"_csShaderModule"),n(this,"_destCS"),n(this,"_sourceCS"),n(this,"_storageTextureDic"),n(this,"_sampleTextureDic"),n(this,"_groupsShaderReflectionVarInfos"),n(this,"_groupCache",{}),this._sourceCS=e,ct.getShaderReflection2(e,this),this._storageTextureDic=new Map,this._sampleTextureDic=new Map}setStorageTexture(e,t){this._storageTextureDic.has(e)||this._storageTextureDic.set(e,t)}setSamplerTexture(e,t){this._sampleTextureDic.set(e,t)}compute(e){this._computePipeline||this.genComputePipeline(),e.setPipeline(this._computePipeline);for(let t=0;t<this.bindGroups.length;++t)e.setBindGroup(t,this.bindGroups[t]);this.workerSizeX&&this.workerSizeY&&this.workerSizeZ?e.dispatchWorkgroups(this.workerSizeX,this.workerSizeY,this.workerSizeZ):this.workerSizeX&&this.workerSizeY?e.dispatchWorkgroups(this.workerSizeX,this.workerSizeY):e.dispatchWorkgroups(this.workerSizeX)}createBufferBindGroup(e,t,r,a){let s=this._bufferDic.get(t);if(s){let o={binding:r,resource:{buffer:s.buffer,offset:0,size:s.memory.shareDataBuffer.byteLength}};a.push(o)}else console.error(`ComputeShader(${this.instanceID})`,`buffer ${t} is missing!`)}noticeBufferChange(e){let t=this._groupCache[e];t&&this.genGroups(t.groupIndex,t.infos,!0)}genGroups(e,t,r=!1){if(!this.bindGroups[e]||r){const a=t[e];let s=[];for(let l=0;l<a.length;++l){const h=a[l];if(h)switch(h.varType){case"uniform":case"storage-read":case"storage-read_write":this.createBufferBindGroup(e,h.varName,h.binding,s),this._groupCache[h.varName]={groupIndex:e,infos:t};break;case"var":if(h.dataType=="sampler"){let u=h.varName.replace("Sampler",""),c=this._sampleTextureDic.get(u);if(c){let d={binding:h.binding,resource:c.gpuSampler};s.push(d)}else console.error(`ComputeShader(${this.instanceID})`,`texture ${h.varName} is missing! `)}else if(h.dataType=="sampler_comparison"){let u=h.varName.replace("Sampler",""),c=this._sampleTextureDic.get(u);if(c){let d={binding:h.binding,resource:c.gpuSampler_comparison};s.push(d)}else console.error(`ComputeShader(${this.instanceID})`,`texture ${h.varName} is missing! `)}else if(h.dataType.indexOf("texture_storage")!=-1){let u=this._storageTextureDic.get(h.varName);if(u){let c={binding:h.binding,resource:u.getGPUView()};s.push(c),ae.getInstance().attached(u,this)}else console.error(`ComputeShader(${this.instanceID})`,`texture ${h.varName} is missing! `)}else if(h.dataType.indexOf("texture")!=-1){let u=this._sampleTextureDic.get(h.varName);if(u){let c={binding:h.binding,resource:u.getGPUView()};s.push(c),ae.getInstance().attached(u,this)}else console.error(`ComputeShader(${this.instanceID})`,`texture ${h.varName} is missing! `)}break;default:console.error("unprocessed type:",h.varType);break}}let o=I.device.createBindGroup({layout:this._computePipeline.getBindGroupLayout(e),entries:s});this.bindGroups[e]=o}}genComputePipeline(){this.preCompileShader(this._sourceCS),this.genReflection(),this._computePipeline=I.device.createComputePipeline({layout:"auto",compute:{module:this.compileShader(),entryPoint:this.entryPoint}}),this._groupsShaderReflectionVarInfos=[];let e=this.shaderReflection;this.bindGroups=[];for(let t=0;t<e.groups.length;++t){let r=e.groups[t];this._groupsShaderReflectionVarInfos[t]=r,this.genGroups(t,this._groupsShaderReflectionVarInfos)}}preCompileShader(e){for(const t in this.constValues)if(Object.prototype.hasOwnProperty.call(this.constValues,t)){const r=this.constValues[t];e=e.replaceAll(`&${t}`,r.toString())}this._destCS=ut.parseComputeShader(e,this.defineValue)}compileShader(){let e=I.device.createShaderModule({label:`ComputeShader(${this.instanceID})`,code:this._destCS});return e.getCompilationInfo().then(t=>{t.messages.length>0&&console.log(this._destCS)}),this._csShaderModule=e,e}genReflection(){this.shaderVariant+=ct.genComputeShaderVariant(this);let e=ct.poolGetReflection(this.shaderVariant);e?this.shaderReflection=e:(ct.getShaderReflection2(this._destCS,this),ct.combineShaderReflectionVarInfo(this.shaderReflection,this.shaderReflection.cs_variables))}}class ft{static start(e){let t=this.profilerLabelMap.get(e);t||(t={lable:e,start:0,end:0,total:0,count:0,child:new Map},this.profilerLabelMap.set(e,t)),t.start=performance.now(),t.end=performance.now(),t.count=0,t.child.clear()}static end(e){let t=this.profilerLabelMap.get(e);t&&(t.end=performance.now(),t.total=t.end-t.start)}static countStart(e,t=""){let r=this.profilerLabelMap.get(e);if(r&&(r.count++,t!="")){let a=r.child.get(t);a||(a={lable:t,start:0,end:0,total:0,count:0}),a.start=performance.now(),a.end=performance.now(),a.count=0,r.child.set(t,a)}}static countEnd(e,t){let r=this.profilerLabelMap.get(e);if(r&&t!=""){let a=r.child.get(t);a||(a={lable:t,start:0,end:0,total:0,count:0}),a.end=performance.now(),a.total=a.end-a.start,a.count++}}static print(e){let t=this.profilerLabelMap.get(e);t&&console.log("performance",e,t.total+" ms")}}n(ft,"profilerLabelMap",new Map);const Zf=`var Module=typeof Module!="undefined"?Module:{};var moduleOverrides=Object.assign({},Module);var arguments_=[];var thisProgram="./this.program";var quit_=(status,toThrow)=>{throw toThrow};var ENVIRONMENT_IS_WEB=typeof window=="object";var ENVIRONMENT_IS_WORKER=typeof importScripts=="function";var ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";var scriptDirectory="";function locateFile(path){if(Module["locateFile"]){return Module["locateFile"](path,scriptDirectory)}return scriptDirectory+path}var read_,readAsync,readBinary,setWindowTitle;if(ENVIRONMENT_IS_NODE){var fs=require("fs");var nodePath=require("path");if(ENVIRONMENT_IS_WORKER){scriptDirectory=nodePath.dirname(scriptDirectory)+"/"}else{scriptDirectory=__dirname+"/"}read_=(filename,binary)=>{filename=isFileURI(filename)?new URL(filename):nodePath.normalize(filename);return fs.readFileSync(filename,binary?undefined:"utf8")};readBinary=filename=>{var ret=read_(filename,true);if(!ret.buffer){ret=new Uint8Array(ret)}return ret};readAsync=(filename,onload,onerror,binary=true)=>{filename=isFileURI(filename)?new URL(filename):nodePath.normalize(filename);fs.readFile(filename,binary?undefined:"utf8",((err,data)=>{if(err)onerror(err);else onload(binary?data.buffer:data)}))};if(!Module["thisProgram"]&&process.argv.length>1){thisProgram=process.argv[1].replace(/\\\\/g,"/")}arguments_=process.argv.slice(2);if(typeof module!="undefined"){module["exports"]=Module}process.on("uncaughtException",(ex=>{if(ex!=="unwind"&&!(ex instanceof ExitStatus)&&!(ex.context instanceof ExitStatus)){throw ex}}));quit_=(status,toThrow)=>{process.exitCode=status;throw toThrow};Module["inspect"]=()=>"[Emscripten Module object]"}else if(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER){if(ENVIRONMENT_IS_WORKER){scriptDirectory=self.location.href}else if(typeof document!="undefined"&&document.currentScript){scriptDirectory=document.currentScript.src}if(scriptDirectory.indexOf("blob:")!==0){scriptDirectory=scriptDirectory.substr(0,scriptDirectory.replace(/[?#].*/,"").lastIndexOf("/")+1)}else{scriptDirectory=""}{read_=url=>{var xhr=new XMLHttpRequest;xhr.open("GET",url,false);xhr.send(null);return xhr.responseText};if(ENVIRONMENT_IS_WORKER){readBinary=url=>{var xhr=new XMLHttpRequest;xhr.open("GET",url,false);xhr.responseType="arraybuffer";xhr.send(null);return new Uint8Array(xhr.response)}}readAsync=(url,onload,onerror)=>{var xhr=new XMLHttpRequest;xhr.open("GET",url,true);xhr.responseType="arraybuffer";xhr.onload=()=>{if(xhr.status==200||xhr.status==0&&xhr.response){onload(xhr.response);return}onerror()};xhr.onerror=onerror;xhr.send(null)}}setWindowTitle=title=>document.title=title}else{}var out=Module["print"]||console.log.bind(console);var err=Module["printErr"]||console.error.bind(console);Object.assign(Module,moduleOverrides);moduleOverrides=null;if(Module["arguments"])arguments_=Module["arguments"];if(Module["thisProgram"])thisProgram=Module["thisProgram"];if(Module["quit"])quit_=Module["quit"];var wasmBinary;if(Module["wasmBinary"])wasmBinary=Module["wasmBinary"];var noExitRuntime=Module["noExitRuntime"]||true;if(typeof WebAssembly!="object"){abort("no native wasm support detected")}var wasmMemory;var ABORT=false;var EXITSTATUS;var HEAP8,HEAPU8,HEAP16,HEAPU16,HEAP32,HEAPU32,HEAPF32,HEAPF64;function updateMemoryViews(){var b=wasmMemory.buffer;Module["HEAP8"]=HEAP8=new Int8Array(b);Module["HEAP16"]=HEAP16=new Int16Array(b);Module["HEAP32"]=HEAP32=new Int32Array(b);Module["HEAPU8"]=HEAPU8=new Uint8Array(b);Module["HEAPU16"]=HEAPU16=new Uint16Array(b);Module["HEAPU32"]=HEAPU32=new Uint32Array(b);Module["HEAPF32"]=HEAPF32=new Float32Array(b);Module["HEAPF64"]=HEAPF64=new Float64Array(b)}var wasmTable;var __ATPRERUN__=[];var __ATINIT__=[];var __ATMAIN__=[];var __ATPOSTRUN__=[];var runtimeInitialized=false;var runtimeKeepaliveCounter=0;function keepRuntimeAlive(){return noExitRuntime||runtimeKeepaliveCounter>0}function preRun(){if(Module["preRun"]){if(typeof Module["preRun"]=="function")Module["preRun"]=[Module["preRun"]];while(Module["preRun"].length){addOnPreRun(Module["preRun"].shift())}}callRuntimeCallbacks(__ATPRERUN__)}function initRuntime(){runtimeInitialized=true;callRuntimeCallbacks(__ATINIT__)}function preMain(){callRuntimeCallbacks(__ATMAIN__)}function postRun(){if(Module["postRun"]){if(typeof Module["postRun"]=="function")Module["postRun"]=[Module["postRun"]];while(Module["postRun"].length){addOnPostRun(Module["postRun"].shift())}}callRuntimeCallbacks(__ATPOSTRUN__)}function addOnPreRun(cb){__ATPRERUN__.unshift(cb)}function addOnInit(cb){__ATINIT__.unshift(cb)}function addOnPostRun(cb){__ATPOSTRUN__.unshift(cb)}var runDependencies=0;var runDependencyWatcher=null;var dependenciesFulfilled=null;function addRunDependency(id){runDependencies++;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies)}}function removeRunDependency(id){runDependencies--;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies)}if(runDependencies==0){if(runDependencyWatcher!==null){clearInterval(runDependencyWatcher);runDependencyWatcher=null}if(dependenciesFulfilled){var callback=dependenciesFulfilled;dependenciesFulfilled=null;callback()}}}function abort(what){if(Module["onAbort"]){Module["onAbort"](what)}what="Aborted("+what+")";err(what);ABORT=true;EXITSTATUS=1;what+=". Build with -sASSERTIONS for more info.";var e=new WebAssembly.RuntimeError(what);throw e}var dataURIPrefix="data:application/octet-stream;base64,";function isDataURI(filename){return filename.startsWith(dataURIPrefix)}function isFileURI(filename){return filename.startsWith("file://")}var wasmBinaryFile;wasmBinaryFile="data:application/octet-stream;base64,AGFzbQEAAAABfBRgAX8Bf2ABfwBgA39/fwF/YAN/f38AYAAAYAV/f39/fwBgBH9/f38AYAZ/f39/f38AYAABf2ACf38Bf2AEf39/fwF/YAF8AX1gAnx/AXxgAn9/AGABfQF9YAN/f30AYAJ+fwF/YAZ/fH9/f38Bf2ACfX8Bf2ADf35/AX4CHwUBYQFhAAoBYQFiAAMBYQFjAAABYQFkAAQBYQFlAAMDSEcDBQsLAgEAEAEADAEDDQ4CAA4PBAQABAABAAYDCQAAAAkRAwAKDAACARINAQAAAQAAAAAHBwUFAQYGAgEBEwACCQ8BCAgICAQFAXABICAFBwEBgAKAgAIGCAF/AUHgtwQLBzUNAWYCAAFnABsBaAEAAWkAMAFqAEsBawBKAWwASQFtAEgBbgBHAW8ARgFwAEUBcQAxAXIANwklAQBBAQsfIh5BQDwzQ0RCJiINLS0/ODo+DTk7PQ01DTQNNh0yHQryvgFHFwAgAC0AAEEgcUUEQCABIAIgABAUGgsLbgEBfyMAQYACayIFJAACQCACIANMDQAgBEGAwARxDQAgBSABQf8BcSACIANrIgNBgAIgA0GAAkkiARsQESABRQRAA0AgACAFQYACEAUgA0GAAmsiA0H/AUsNAAsLIAAgBSADEAULIAVBgAJqJAALSwECfCAAIACiIgEgAKIiAiABIAGioiABRKdGO4yHzcY+okR058ri+QAqv6CiIAIgAUSy+26JEBGBP6JEd6zLVFVVxb+goiAAoKC2C08BAXwgACAAoiIAIAAgAKIiAaIgAERpUO7gQpP5PqJEJx4P6IfAVr+goiABREI6BeFTVaU/oiAARIFeDP3//9+/okQAAAAAAADwP6CgoLYLdAEBfyACRQRAIAAoAgQgASgCBEYPCyAAIAFGBEBBAQ8LIAEoAgQiAi0AACEBAkAgACgCBCIDLQAAIgBFDQAgACABRw0AA0AgAi0AASEBIAMtAAEiAEUNASACQQFqIQIgA0EBaiEDIAAgAUYNAAsLIAAgAUYL0gsBB38CQCAARQ0AIABBCGsiAiAAQQRrKAIAIgFBeHEiAGohBQJAIAFBAXENACABQQNxRQ0BIAIgAigCACIBayICQfgzKAIASQ0BIAAgAWohAAJAAkBB/DMoAgAgAkcEQCABQf8BTQRAIAFBA3YhBCACKAIMIgEgAigCCCIDRgRAQegzQegzKAIAQX4gBHdxNgIADAULIAMgATYCDCABIAM2AggMBAsgAigCGCEGIAIgAigCDCIBRwRAIAIoAggiAyABNgIMIAEgAzYCCAwDCyACQRRqIgQoAgAiA0UEQCACKAIQIgNFDQIgAkEQaiEECwNAIAQhByADIgFBFGoiBCgCACIDDQAgAUEQaiEEIAEoAhAiAw0ACyAHQQA2AgAMAgsgBSgCBCIBQQNxQQNHDQJB8DMgADYCACAFIAFBfnE2AgQgAiAAQQFyNgIEIAUgADYCAA8LQQAhAQsgBkUNAAJAIAIoAhwiA0ECdEGYNmoiBCgCACACRgRAIAQgATYCACABDQFB7DNB7DMoAgBBfiADd3E2AgAMAgsgBkEQQRQgBigCECACRhtqIAE2AgAgAUUNAQsgASAGNgIYIAIoAhAiAwRAIAEgAzYCECADIAE2AhgLIAIoAhQiA0UNACABIAM2AhQgAyABNgIYCyACIAVPDQAgBSgCBCIBQQFxRQ0AAkACQAJAAkAgAUECcUUEQEGANCgCACAFRgRAQYA0IAI2AgBB9DNB9DMoAgAgAGoiADYCACACIABBAXI2AgQgAkH8MygCAEcNBkHwM0EANgIAQfwzQQA2AgAPC0H8MygCACAFRgRAQfwzIAI2AgBB8DNB8DMoAgAgAGoiADYCACACIABBAXI2AgQgACACaiAANgIADwsgAUF4cSAAaiEAIAFB/wFNBEAgAUEDdiEEIAUoAgwiASAFKAIIIgNGBEBB6DNB6DMoAgBBfiAEd3E2AgAMBQsgAyABNgIMIAEgAzYCCAwECyAFKAIYIQYgBSAFKAIMIgFHBEBB+DMoAgAaIAUoAggiAyABNgIMIAEgAzYCCAwDCyAFQRRqIgQoAgAiA0UEQCAFKAIQIgNFDQIgBUEQaiEECwNAIAQhByADIgFBFGoiBCgCACIDDQAgAUEQaiEEIAEoAhAiAw0ACyAHQQA2AgAMAgsgBSABQX5xNgIEIAIgAEEBcjYCBCAAIAJqIAA2AgAMAwtBACEBCyAGRQ0AAkAgBSgCHCIDQQJ0QZg2aiIEKAIAIAVGBEAgBCABNgIAIAENAUHsM0HsMygCAEF+IAN3cTYCAAwCCyAGQRBBFCAGKAIQIAVGG2ogATYCACABRQ0BCyABIAY2AhggBSgCECIDBEAgASADNgIQIAMgATYCGAsgBSgCFCIDRQ0AIAEgAzYCFCADIAE2AhgLIAIgAEEBcjYCBCAAIAJqIAA2AgAgAkH8MygCAEcNAEHwMyAANgIADwsgAEH/AU0EQCAAQXhxQZA0aiEBAn9B6DMoAgAiA0EBIABBA3Z0IgBxRQRAQegzIAAgA3I2AgAgAQwBCyABKAIICyEAIAEgAjYCCCAAIAI2AgwgAiABNgIMIAIgADYCCA8LQR8hAyAAQf///wdNBEAgAEEmIABBCHZnIgFrdkEBcSABQQF0a0E+aiEDCyACIAM2AhwgAkIANwIQIANBAnRBmDZqIQECQAJAAkBB7DMoAgAiBEEBIAN0IgdxRQRAQewzIAQgB3I2AgAgASACNgIAIAIgATYCGAwBCyAAQRkgA0EBdmtBACADQR9HG3QhAyABKAIAIQEDQCABIgQoAgRBeHEgAEYNAiADQR12IQEgA0EBdCEDIAQgAUEEcWoiB0EQaigCACIBDQALIAcgAjYCECACIAQ2AhgLIAIgAjYCDCACIAI2AggMAQsgBCgCCCIAIAI2AgwgBCACNgIIIAJBADYCGCACIAQ2AgwgAiAANgIIC0GINEGINCgCAEEBayIAQX8gABs2AgALC08BAn9B2CkoAgAiASAAQQdqQXhxIgJqIQACQCACQQAgACABTRsNACAAPwBBEHRLBEAgABACRQ0BC0HYKSAANgIAIAEPC0GoMkEwNgIAQX8LgwECA38BfgJAIABCgICAgBBUBEAgACEFDAELA0AgAUEBayIBIAAgAEIKgCIFQgp+fadBMHI6AAAgAEL/////nwFWIQIgBSEAIAINAAsLIAWnIgIEQANAIAFBAWsiASACIAJBCm4iA0EKbGtBMHI6AAAgAkEJSyEEIAMhAiAEDQALCyABCwYAIAAQCgs1AQF/QQEgACAAQQFNGyEAAkADQCAAECQiAQ0BQdg3KAIAIgEEQCABEQQADAELCxADAAsgAQuoAQACQCABQYAITgRAIABEAAAAAAAA4H+iIQAgAUH/D0kEQCABQf8HayEBDAILIABEAAAAAAAA4H+iIQBB/RcgASABQf0XThtB/g9rIQEMAQsgAUGBeEoNACAARAAAAAAAAGADoiEAIAFBuHBLBEAgAUHJB2ohAQwBCyAARAAAAAAAAGADoiEAQfBoIAEgAUHwaEwbQZIPaiEBCyAAIAFB/wdqrUI0hr+iCwYAIAAQCgvwAgICfwF+AkAgAkUNACAAIAE6AAAgACACaiIDQQFrIAE6AAAgAkEDSQ0AIAAgAToAAiAAIAE6AAEgA0EDayABOgAAIANBAmsgAToAACACQQdJDQAgACABOgADIANBBGsgAToAACACQQlJDQAgAEEAIABrQQNxIgRqIgMgAUH/AXFBgYKECGwiADYCACADIAIgBGtBfHEiAmoiAUEEayAANgIAIAJBCUkNACADIAA2AgggAyAANgIEIAFBCGsgADYCACABQQxrIAA2AgAgAkEZSQ0AIAMgADYCGCADIAA2AhQgAyAANgIQIAMgADYCDCABQRBrIAA2AgAgAUEUayAANgIAIAFBGGsgADYCACABQRxrIAA2AgAgAiADQQRxQRhyIgFrIgJBIEkNACAArUKBgICAEH4hBSABIANqIQEDQCABIAU3AxggASAFNwMQIAEgBTcDCCABIAU3AwAgAUEgaiEBIAJBIGsiAkEfSw0ACwsLMgAgACABKgIAIAAqAgCSOAIAIAAgASoCBCAAKgIEkjgCBCAAIAEqAgggACoCCJI4AggL/gICA38BfCMAQRBrIgEkAAJAIAC8IgNB/////wdxIgJB2p+k+gNNBEAgAkGAgIDMA0kNASAAuxAHIQAMAQsgAkHRp+2DBE0EQCAAuyEEIAJB45fbgARNBEAgA0EASARAIAREGC1EVPsh+T+gEAiMIQAMAwsgBEQYLURU+yH5v6AQCCEADAILRBgtRFT7IQnARBgtRFT7IQlAIANBAE4bIASgmhAHIQAMAQsgAkHV44iHBE0EQCACQd/bv4UETQRAIAC7IQQgA0EASARAIARE0iEzf3zZEkCgEAghAAwDCyAERNIhM3982RLAoBAIjCEADAILRBgtRFT7IRlARBgtRFT7IRnAIANBAEgbIAC7oBAHIQAMAQsgAkGAgID8B08EQCAAIACTIQAMAQsCQAJAAkACQCAAIAFBCGoQLkEDcQ4DAAECAwsgASsDCBAHIQAMAwsgASsDCBAIIQAMAgsgASsDCJoQByEADAELIAErAwgQCIwhAAsgAUEQaiQAIAALwAEBA38CQCABIAIoAhAiAwR/IAMFIAIQFQ0BIAIoAhALIAIoAhQiBWtLBEAgAiAAIAEgAigCJBECAA8LAkAgAigCUEEASARAQQAhAwwBCyABIQQDQCAEIgNFBEBBACEDDAILIAAgA0EBayIEai0AAEEKRw0ACyACIAAgAyACKAIkEQIAIgQgA0kNASAAIANqIQAgASADayEBIAIoAhQhBQsgBSAAIAEQLBogAiACKAIUIAFqNgIUIAEgA2ohBAsgBAtZAQF/IAAgACgCSCIBQQFrIAFyNgJIIAAoAgAiAUEIcQRAIAAgAUEgcjYCAEF/DwsgAEIANwIEIAAgACgCLCIBNgIcIAAgATYCFCAAIAEgACgCMGo2AhBBAAvoAgIDfwF8IwBBEGsiASQAAn0gALwiA0H/////B3EiAkHan6T6A00EQEMAAIA/IAJBgICAzANJDQEaIAC7EAgMAQsgAkHRp+2DBE0EQCACQeSX24AETwRARBgtRFT7IQlARBgtRFT7IQnAIANBAEgbIAC7oBAIjAwCCyAAuyEEIANBAEgEQCAERBgtRFT7Ifk/oBAHDAILRBgtRFT7Ifk/IAShEAcMAQsgAkHV44iHBE0EQCACQeDbv4UETwRARBgtRFT7IRlARBgtRFT7IRnAIANBAEgbIAC7oBAIDAILIANBAEgEQETSITN/fNkSwCAAu6EQBwwCCyAAu0TSITN/fNkSwKAQBwwBCyAAIACTIAJBgICA/AdPDQAaAkACQAJAAkAgACABQQhqEC5BA3EOAwABAgMLIAErAwgQCAwDCyABKwMImhAHDAILIAErAwgQCIwMAQsgASsDCBAHCyEAIAFBEGokACAACzMBAn0gASoCACAClCEDIAEqAgQgApQhBCAAIAEqAgggApQ4AgggACAEOAIEIAAgAzgCAAsqAQF/QQQQIyIAQeQmNgIAIABBvCY2AgAgAEHQJjYCACAAQcAnQQEQAQALXwEDf0EIECMiAEHkJjYCACAAQdQnNgIAQZ0IECsiAUENahAOIgJBADYCCCACIAE2AgQgAiABNgIAIAAgAkEMakGdCCABQQFqECw2AgQgAEGEKDYCACAAQaQoQQIQAQALfwAgAP0MAAAAAAAAAAAAAAAAAAAAAP0LAiQgAP0MAAAAAAAAAAAAAAAAAAAAAP0LAhQgAP0MAAAAAAAAAAAAAAAAAAAAAP0LAgQgAEGAgID8AzYCPCAAQYCAgPwDNgIAIABCADcCNCAAQYCAgPwDNgIoIABBgICA/AM2AhQgAAtTAEHsKUEANgIAQeQpQgA3AgBB+ClBADYCAEHwKUIANwIAQYQqQQA2AgBB/ClCADcCAEGQKkEANgIAQYgqQgA3AgBBxDNBzDI2AgBB/DJBKjYCAAv8BwMIfw59EHsjAEFAaiICJABB5CkoAgAgAEEGdGohAUH8KSgCACAAQQR0aiIFKAIABEAgBSgCBCEDIwBBEGsiBiQAIABBJGwiBEHwKSgCAGoiAEEYaiEHIABBDGohCCADBEAgBkEEaiIDQYgqKAIAIARqIgRB4CkqAgAQFyAAIAMQEiADIARBDGpB4CkqAgAQFyAIIAMQEiADIARBGGpB4CkqAgAQFyAHIAMQEgsgACoCFCEJIAAqAhAhCiAAKgIAIRIgACoCBCETIAAqAgghECAIKgIAIQwgAUEANgIsIAFBADYCHCABQQA2AgwgDEM1+o48lEMAAAA/lCIMEBMhDiAKQzX6jjyUQwAAAD+UIgoQEyERIAlDNfqOPJRDAAAAP5QiDRATIQkgDBAWIQsgChAWIQ8gASAQIAsgEZQiFCANEBYiCpQgCSAOIA+UIg2UkiIMIAkgCyAPlCILlCAKIA4gEZQiD5STIhEgEZIiDpQiFSALIAqUIA8gCZSSIgsgDSAKlCAJIBSUkyIJIAmSIg+UIg2TlDgCJCABIBAgCSAOlCIUIAsgDCAMkiIKlCIWkpQ4AiAgASATIBUgDZKUOAIYIAEgEyAJIAqUIg0gCyAOlCILk5Q4AhAgASASIBQgFpOUOAIIIAEgEiANIAuSlDgCBCABIBBDAACAPyAJIA+UIgkgDCAKlCIQkpOUOAIoIAEgE0MAAIA/IAkgESAOlCIJkpOUOAIUIAEgEkMAAIA/IBAgCZKTlDgCACABIAcqAgA4AjAgASAAKgIcOAI0IAAqAiAhCSABQYCAgPwDNgI8IAEgCTgCOCAGQRBqJAAgBSgCCCIAQX9HBEAgABAcIQAgAhAaGiAB/QkCDCEbIAH9CQIIIRwgAf0JAgAhHSAB/QkCBCEeIAH9CQIcIR8gAf0JAhghICAB/QkCECEhIAH9CQIUISIgAf0JAiwhIyAB/QkCKCEkIAH9CQIgISUgAf0JAiQhJiACIAD9AAIwIhcgAf0JAjz95gEgAP0AAiAiGCAB/QkCOP3mASAA/QACACIZIAH9CQIw/eYBIAD9AAIQIhogAf0JAjT95gH95AH95AH95AH9CwIwIAIgFyAj/eYBIBggJP3mASAZICX95gEgGiAm/eYB/eQB/eQB/eQB/QsCICACIBcgH/3mASAYICD95gEgGSAh/eYBIBogIv3mAf3kAf3kAf3kAf0LAhAgAiAXIBv95gEgGCAc/eYBIBkgHf3mASAeIBr95gH95AH95AH95AH9CwIAIAEgAv0AAjD9CwIwIAEgAv0AAiD9CwIgIAEgAv0AAhD9CwIQIAEgAv0AAgD9CwIACyAFQQA2AgALIAJBQGskACABCwsAIAAQHhogABAKCzEBAn8gAEHUJzYCACAAKAIEQQxrIgEgASgCCEEBayICNgIIIAJBAEgEQCABEBALIAALmgEAIABBAToANQJAIAAoAgQgAkcNACAAQQE6ADQCQCAAKAIQIgJFBEAgAEEBNgIkIAAgAzYCGCAAIAE2AhAgA0EBRw0CIAAoAjBBAUYNAQwCCyABIAJGBEAgACgCGCICQQJGBEAgACADNgIYIAMhAgsgACgCMEEBRw0CIAJBAUYNAQwCCyAAIAAoAiRBAWo2AiQLIABBAToANgsLXQEBfyAAKAIQIgNFBEAgAEEBNgIkIAAgAjYCGCAAIAE2AhAPCwJAIAEgA0YEQCAAKAIYQQJHDQEgACACNgIYDwsgAEEBOgA2IABBAjYCGCAAIAAoAiRBAWo2AiQLC7kCAQN/IwBBQGoiAiQAIAAoAgAiA0EEaygCACEEIANBCGsoAgAhAyACQgA3AiAgAkIANwIoIAJCADcCMCACQgA3ADcgAkIANwIYIAJBADYCFCACQZQkNgIQIAIgADYCDCACIAE2AgggACADaiEAQQAhAwJAIAQgAUEAEAkEQCACQQE2AjggBCACQQhqIAAgAEEBQQAgBCgCACgCFBEHACAAQQAgAigCIEEBRhshAwwBCyAEIAJBCGogAEEBQQAgBCgCACgCGBEFAAJAAkAgAigCLA4CAAECCyACKAIcQQAgAigCKEEBRhtBACACKAIkQQFGG0EAIAIoAjBBAUYbIQMMAQsgAigCIEEBRwRAIAIoAjANASACKAIkQQFHDQEgAigCKEEBRw0BCyACKAIYIQMLIAJBQGskACADCwQAIAALDgAgAEHQAGoQJEHQAGoLnCgBC38jAEEQayILJAACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABB9AFNBEBB6DMoAgAiBkEQIABBC2pBeHEgAEELSRsiBUEDdiIAdiIBQQNxBEACQCABQX9zQQFxIABqIgJBA3QiAUGQNGoiACABQZg0aigCACIBKAIIIgRGBEBB6DMgBkF+IAJ3cTYCAAwBCyAEIAA2AgwgACAENgIICyABQQhqIQAgASACQQN0IgJBA3I2AgQgASACaiIBIAEoAgRBAXI2AgQMDwsgBUHwMygCACIHTQ0BIAEEQAJAQQIgAHQiAkEAIAJrciABIAB0cSIAQQAgAGtxaCIBQQN0IgBBkDRqIgIgAEGYNGooAgAiACgCCCIERgRAQegzIAZBfiABd3EiBjYCAAwBCyAEIAI2AgwgAiAENgIICyAAIAVBA3I2AgQgACAFaiIIIAFBA3QiASAFayIEQQFyNgIEIAAgAWogBDYCACAHBEAgB0F4cUGQNGohAUH8MygCACECAn8gBkEBIAdBA3Z0IgNxRQRAQegzIAMgBnI2AgAgAQwBCyABKAIICyEDIAEgAjYCCCADIAI2AgwgAiABNgIMIAIgAzYCCAsgAEEIaiEAQfwzIAg2AgBB8DMgBDYCAAwPC0HsMygCACIKRQ0BIApBACAKa3FoQQJ0QZg2aigCACICKAIEQXhxIAVrIQMgAiEBA0ACQCABKAIQIgBFBEAgASgCFCIARQ0BCyAAKAIEQXhxIAVrIgEgAyABIANJIgEbIQMgACACIAEbIQIgACEBDAELCyACKAIYIQkgAiACKAIMIgRHBEBB+DMoAgAaIAIoAggiACAENgIMIAQgADYCCAwOCyACQRRqIgEoAgAiAEUEQCACKAIQIgBFDQMgAkEQaiEBCwNAIAEhCCAAIgRBFGoiASgCACIADQAgBEEQaiEBIAQoAhAiAA0ACyAIQQA2AgAMDQtBfyEFIABBv39LDQAgAEELaiIAQXhxIQVB7DMoAgAiCEUNAEEAIAVrIQMCQAJAAkACf0EAIAVBgAJJDQAaQR8gBUH///8HSw0AGiAFQSYgAEEIdmciAGt2QQFxIABBAXRrQT5qCyIHQQJ0QZg2aigCACIBRQRAQQAhAAwBC0EAIQAgBUEZIAdBAXZrQQAgB0EfRxt0IQIDQAJAIAEoAgRBeHEgBWsiBiADTw0AIAEhBCAGIgMNAEEAIQMgASEADAMLIAAgASgCFCIGIAYgASACQR12QQRxaigCECIBRhsgACAGGyEAIAJBAXQhAiABDQALCyAAIARyRQRAQQAhBEECIAd0IgBBACAAa3IgCHEiAEUNAyAAQQAgAGtxaEECdEGYNmooAgAhAAsgAEUNAQsDQCAAKAIEQXhxIAVrIgIgA0khASACIAMgARshAyAAIAQgARshBCAAKAIQIgEEfyABBSAAKAIUCyIADQALCyAERQ0AIANB8DMoAgAgBWtPDQAgBCgCGCEHIAQgBCgCDCICRwRAQfgzKAIAGiAEKAIIIgAgAjYCDCACIAA2AggMDAsgBEEUaiIBKAIAIgBFBEAgBCgCECIARQ0DIARBEGohAQsDQCABIQYgACICQRRqIgEoAgAiAA0AIAJBEGohASACKAIQIgANAAsgBkEANgIADAsLIAVB8DMoAgAiBE0EQEH8MygCACEAAkAgBCAFayIBQRBPBEAgACAFaiICIAFBAXI2AgQgACAEaiABNgIAIAAgBUEDcjYCBAwBCyAAIARBA3I2AgQgACAEaiIBIAEoAgRBAXI2AgRBACECQQAhAQtB8DMgATYCAEH8MyACNgIAIABBCGohAAwNCyAFQfQzKAIAIgJJBEBB9DMgAiAFayIBNgIAQYA0QYA0KAIAIgAgBWoiAjYCACACIAFBAXI2AgQgACAFQQNyNgIEIABBCGohAAwNC0EAIQAgBUEvaiIDAn9BwDcoAgAEQEHINygCAAwBC0HMN0J/NwIAQcQ3QoCggICAgAQ3AgBBwDcgC0EMakFwcUHYqtWqBXM2AgBB1DdBADYCAEGkN0EANgIAQYAgCyIBaiIGQQAgAWsiCHEiASAFTQ0MQaA3KAIAIgQEQEGYNygCACIHIAFqIgkgB00NDSAEIAlJDQ0LAkBBpDctAABBBHFFBEACQAJAAkACQEGANCgCACIEBEBBqDchAANAIAQgACgCACIHTwRAIAcgACgCBGogBEsNAwsgACgCCCIADQALC0EAEAsiAkF/Rg0DIAEhBkHENygCACIAQQFrIgQgAnEEQCABIAJrIAIgBGpBACAAa3FqIQYLIAUgBk8NA0GgNygCACIABEBBmDcoAgAiBCAGaiIIIARNDQQgACAISQ0ECyAGEAsiACACRw0BDAULIAYgAmsgCHEiBhALIgIgACgCACAAKAIEakYNASACIQALIABBf0YNASAFQTBqIAZNBEAgACECDAQLQcg3KAIAIgIgAyAGa2pBACACa3EiAhALQX9GDQEgAiAGaiEGIAAhAgwDCyACQX9HDQILQaQ3QaQ3KAIAQQRyNgIACyABEAshAkEAEAshACACQX9GDQUgAEF/Rg0FIAAgAk0NBSAAIAJrIgYgBUEoak0NBQtBmDdBmDcoAgAgBmoiADYCAEGcNygCACAASQRAQZw3IAA2AgALAkBBgDQoAgAiAwRAQag3IQADQCACIAAoAgAiASAAKAIEIgRqRg0CIAAoAggiAA0ACwwEC0H4MygCACIAQQAgACACTRtFBEBB+DMgAjYCAAtBACEAQaw3IAY2AgBBqDcgAjYCAEGINEF/NgIAQYw0QcA3KAIANgIAQbQ3QQA2AgADQCAAQQN0IgFBmDRqIAFBkDRqIgQ2AgAgAUGcNGogBDYCACAAQQFqIgBBIEcNAAtB9DMgBkEoayIAQXggAmtBB3FBACACQQhqQQdxGyIBayIENgIAQYA0IAEgAmoiATYCACABIARBAXI2AgQgACACakEoNgIEQYQ0QdA3KAIANgIADAQLIAIgA00NAiABIANLDQIgACgCDEEIcQ0CIAAgBCAGajYCBEGANCADQXggA2tBB3FBACADQQhqQQdxGyIAaiIBNgIAQfQzQfQzKAIAIAZqIgIgAGsiADYCACABIABBAXI2AgQgAiADakEoNgIEQYQ0QdA3KAIANgIADAMLQQAhBAwKC0EAIQIMCAtB+DMoAgAgAksEQEH4MyACNgIACyACIAZqIQFBqDchAAJAAkACQANAIAEgACgCAEcEQCAAKAIIIgANAQwCCwsgAC0ADEEIcUUNAQtBqDchAANAIAMgACgCACIBTwRAIAEgACgCBGoiBCADSw0DCyAAKAIIIQAMAAsACyAAIAI2AgAgACAAKAIEIAZqNgIEIAJBeCACa0EHcUEAIAJBCGpBB3EbaiIHIAVBA3I2AgQgAUF4IAFrQQdxQQAgAUEIakEHcRtqIgYgBSAHaiIFayEAIAMgBkYEQEGANCAFNgIAQfQzQfQzKAIAIABqIgA2AgAgBSAAQQFyNgIEDAgLQfwzKAIAIAZGBEBB/DMgBTYCAEHwM0HwMygCACAAaiIANgIAIAUgAEEBcjYCBCAAIAVqIAA2AgAMCAsgBigCBCIDQQNxQQFHDQYgA0F4cSEJIANB/wFNBEAgBigCDCIBIAYoAggiAkYEQEHoM0HoMygCAEF+IANBA3Z3cTYCAAwHCyACIAE2AgwgASACNgIIDAYLIAYoAhghCCAGIAYoAgwiAkcEQCAGKAIIIgEgAjYCDCACIAE2AggMBQsgBkEUaiIBKAIAIgNFBEAgBigCECIDRQ0EIAZBEGohAQsDQCABIQQgAyICQRRqIgEoAgAiAw0AIAJBEGohASACKAIQIgMNAAsgBEEANgIADAQLQfQzIAZBKGsiAEF4IAJrQQdxQQAgAkEIakEHcRsiAWsiCDYCAEGANCABIAJqIgE2AgAgASAIQQFyNgIEIAAgAmpBKDYCBEGENEHQNygCADYCACADIARBJyAEa0EHcUEAIARBJ2tBB3EbakEvayIAIAAgA0EQakkbIgFBGzYCBCABQbA3KQIANwIQIAFBqDcpAgA3AghBsDcgAUEIajYCAEGsNyAGNgIAQag3IAI2AgBBtDdBADYCACABQRhqIQADQCAAQQc2AgQgAEEIaiECIABBBGohACACIARJDQALIAEgA0YNACABIAEoAgRBfnE2AgQgAyABIANrIgJBAXI2AgQgASACNgIAIAJB/wFNBEAgAkF4cUGQNGohAAJ/QegzKAIAIgFBASACQQN2dCICcUUEQEHoMyABIAJyNgIAIAAMAQsgACgCCAshASAAIAM2AgggASADNgIMIAMgADYCDCADIAE2AggMAQtBHyEAIAJB////B00EQCACQSYgAkEIdmciAGt2QQFxIABBAXRrQT5qIQALIAMgADYCHCADQgA3AhAgAEECdEGYNmohAQJAAkBB7DMoAgAiBEEBIAB0IgZxRQRAQewzIAQgBnI2AgAgASADNgIADAELIAJBGSAAQQF2a0EAIABBH0cbdCEAIAEoAgAhBANAIAQiASgCBEF4cSACRg0CIABBHXYhBCAAQQF0IQAgASAEQQRxaiIGKAIQIgQNAAsgBiADNgIQCyADIAE2AhggAyADNgIMIAMgAzYCCAwBCyABKAIIIgAgAzYCDCABIAM2AgggA0EANgIYIAMgATYCDCADIAA2AggLQfQzKAIAIgAgBU0NAEH0MyAAIAVrIgE2AgBBgDRBgDQoAgAiACAFaiICNgIAIAIgAUEBcjYCBCAAIAVBA3I2AgQgAEEIaiEADAgLQagyQTA2AgBBACEADAcLQQAhAgsgCEUNAAJAIAYoAhwiAUECdEGYNmoiBCgCACAGRgRAIAQgAjYCACACDQFB7DNB7DMoAgBBfiABd3E2AgAMAgsgCEEQQRQgCCgCECAGRhtqIAI2AgAgAkUNAQsgAiAINgIYIAYoAhAiAQRAIAIgATYCECABIAI2AhgLIAYoAhQiAUUNACACIAE2AhQgASACNgIYCyAAIAlqIQAgBiAJaiIGKAIEIQMLIAYgA0F+cTYCBCAFIABBAXI2AgQgACAFaiAANgIAIABB/wFNBEAgAEF4cUGQNGohAQJ/QegzKAIAIgJBASAAQQN2dCIAcUUEQEHoMyAAIAJyNgIAIAEMAQsgASgCCAshACABIAU2AgggACAFNgIMIAUgATYCDCAFIAA2AggMAQtBHyEDIABB////B00EQCAAQSYgAEEIdmciAWt2QQFxIAFBAXRrQT5qIQMLIAUgAzYCHCAFQgA3AhAgA0ECdEGYNmohAQJAAkBB7DMoAgAiAkEBIAN0IgRxRQRAQewzIAIgBHI2AgAgASAFNgIADAELIABBGSADQQF2a0EAIANBH0cbdCEDIAEoAgAhAgNAIAIiASgCBEF4cSAARg0CIANBHXYhAiADQQF0IQMgASACQQRxaiIEKAIQIgINAAsgBCAFNgIQCyAFIAE2AhggBSAFNgIMIAUgBTYCCAwBCyABKAIIIgAgBTYCDCABIAU2AgggBUEANgIYIAUgATYCDCAFIAA2AggLIAdBCGohAAwCCwJAIAdFDQACQCAEKAIcIgBBAnRBmDZqIgEoAgAgBEYEQCABIAI2AgAgAg0BQewzIAhBfiAAd3EiCDYCAAwCCyAHQRBBFCAHKAIQIARGG2ogAjYCACACRQ0BCyACIAc2AhggBCgCECIABEAgAiAANgIQIAAgAjYCGAsgBCgCFCIARQ0AIAIgADYCFCAAIAI2AhgLAkAgA0EPTQRAIAQgAyAFaiIAQQNyNgIEIAAgBGoiACAAKAIEQQFyNgIEDAELIAQgBUEDcjYCBCAEIAVqIgIgA0EBcjYCBCACIANqIAM2AgAgA0H/AU0EQCADQXhxQZA0aiEAAn9B6DMoAgAiAUEBIANBA3Z0IgNxRQRAQegzIAEgA3I2AgAgAAwBCyAAKAIICyEBIAAgAjYCCCABIAI2AgwgAiAANgIMIAIgATYCCAwBC0EfIQAgA0H///8HTQRAIANBJiADQQh2ZyIAa3ZBAXEgAEEBdGtBPmohAAsgAiAANgIcIAJCADcCECAAQQJ0QZg2aiEBAkACQCAIQQEgAHQiBnFFBEBB7DMgBiAIcjYCACABIAI2AgAMAQsgA0EZIABBAXZrQQAgAEEfRxt0IQAgASgCACEFA0AgBSIBKAIEQXhxIANGDQIgAEEddiEGIABBAXQhACABIAZBBHFqIgYoAhAiBQ0ACyAGIAI2AhALIAIgATYCGCACIAI2AgwgAiACNgIIDAELIAEoAggiACACNgIMIAEgAjYCCCACQQA2AhggAiABNgIMIAIgADYCCAsgBEEIaiEADAELAkAgCUUNAAJAIAIoAhwiAEECdEGYNmoiASgCACACRgRAIAEgBDYCACAEDQFB7DMgCkF+IAB3cTYCAAwCCyAJQRBBFCAJKAIQIAJGG2ogBDYCACAERQ0BCyAEIAk2AhggAigCECIABEAgBCAANgIQIAAgBDYCGAsgAigCFCIARQ0AIAQgADYCFCAAIAQ2AhgLAkAgA0EPTQRAIAIgAyAFaiIAQQNyNgIEIAAgAmoiACAAKAIEQQFyNgIEDAELIAIgBUEDcjYCBCACIAVqIgQgA0EBcjYCBCADIARqIAM2AgAgBwRAIAdBeHFBkDRqIQBB/DMoAgAhAQJ/QQEgB0EDdnQiBSAGcUUEQEHoMyAFIAZyNgIAIAAMAQsgACgCCAshBiAAIAE2AgggBiABNgIMIAEgADYCDCABIAY2AggLQfwzIAQ2AgBB8DMgAzYCAAsgAkEIaiEACyALQRBqJAAgAAuXAgAgAEUEQEEADwsCfwJAIAAEfyABQf8ATQ0BAkBBxDMoAgAoAgBFBEAgAUGAf3FBgL8DRg0DDAELIAFB/w9NBEAgACABQT9xQYABcjoAASAAIAFBBnZBwAFyOgAAQQIMBAsgAUGAQHFBgMADRyABQYCwA09xRQRAIAAgAUE/cUGAAXI6AAIgACABQQx2QeABcjoAACAAIAFBBnZBP3FBgAFyOgABQQMMBAsgAUGAgARrQf//P00EQCAAIAFBP3FBgAFyOgADIAAgAUESdkHwAXI6AAAgACABQQZ2QT9xQYABcjoAAiAAIAFBDHZBP3FBgAFyOgABQQQMBAsLQagyQRk2AgBBfwVBAQsMAQsgACABOgAAQQELC5YYAxJ/AXwCfiMAQbAEayIMJAAgDEEANgIsAkAgAb0iGUIAUwRAQQEhEEGKCCETIAGaIgG9IRkMAQsgBEGAEHEEQEEBIRBBjQghEwwBC0GQCEGLCCAEQQFxIhAbIRMgEEUhFQsCQCAZQoCAgICAgID4/wCDQoCAgICAgID4/wBRBEAgAEEgIAIgEEEDaiIDIARB//97cRAGIAAgEyAQEAUgAEGzCEH2CCAFQSBxIgUbQcwIQfoIIAUbIAEgAWIbQQMQBSAAQSAgAiADIARBgMAAcxAGIAMgAiACIANIGyEJDAELIAxBEGohEQJAAn8CQCABIAxBLGoQKiIBIAGgIgFEAAAAAAAAAABiBEAgDCAMKAIsIgZBAWs2AiwgBUEgciIOQeEARw0BDAMLIAVBIHIiDkHhAEYNAiAMKAIsIQpBBiADIANBAEgbDAELIAwgBkEdayIKNgIsIAFEAAAAAAAAsEGiIQFBBiADIANBAEgbCyELIAxBMGpBoAJBACAKQQBOG2oiDSEHA0AgBwJ/IAFEAAAAAAAA8EFjIAFEAAAAAAAAAABmcQRAIAGrDAELQQALIgM2AgAgB0EEaiEHIAEgA7ihRAAAAABlzc1BoiIBRAAAAAAAAAAAYg0ACwJAIApBAEwEQCAKIQMgByEGIA0hCAwBCyANIQggCiEDA0BBHSADIANBHU4bIQMCQCAHQQRrIgYgCEkNACADrSEaQgAhGQNAIAYgGUL/////D4MgBjUCACAahnwiGSAZQoCU69wDgCIZQoCU69wDfn0+AgAgBkEEayIGIAhPDQALIBmnIgZFDQAgCEEEayIIIAY2AgALA0AgCCAHIgZJBEAgBkEEayIHKAIARQ0BCwsgDCAMKAIsIANrIgM2AiwgBiEHIANBAEoNAAsLIANBAEgEQCALQRlqQQluQQFqIQ8gDkHmAEYhEgNAQQlBACADayIDIANBCU4bIQkCQCAGIAhNBEAgCCgCACEHDAELQYCU69wDIAl2IRRBfyAJdEF/cyEWQQAhAyAIIQcDQCAHIAMgBygCACIXIAl2ajYCACAWIBdxIBRsIQMgB0EEaiIHIAZJDQALIAgoAgAhByADRQ0AIAYgAzYCACAGQQRqIQYLIAwgDCgCLCAJaiIDNgIsIA0gCCAHRUECdGoiCCASGyIHIA9BAnRqIAYgBiAHa0ECdSAPShshBiADQQBIDQALC0EAIQMCQCAGIAhNDQAgDSAIa0ECdUEJbCEDQQohByAIKAIAIglBCkkNAANAIANBAWohAyAJIAdBCmwiB08NAAsLIAsgA0EAIA5B5gBHG2sgDkHnAEYgC0EAR3FrIgcgBiANa0ECdUEJbEEJa0gEQEEEQaQCIApBAEgbIAxqIAdBgMgAaiIJQQltIg9BAnRqQdAfayEKQQohByAJIA9BCWxrIglBB0wEQANAIAdBCmwhByAJQQFqIglBCEcNAAsLAkAgCigCACISIBIgB24iDyAHbGsiCUUgCkEEaiIUIAZGcQ0AAkAgD0EBcUUEQEQAAAAAAABAQyEBIAdBgJTr3ANHDQEgCCAKTw0BIApBBGstAABBAXFFDQELRAEAAAAAAEBDIQELRAAAAAAAAOA/RAAAAAAAAPA/RAAAAAAAAPg/IAYgFEYbRAAAAAAAAPg/IAkgB0EBdiIURhsgCSAUSRshGAJAIBUNACATLQAAQS1HDQAgGJohGCABmiEBCyAKIBIgCWsiCTYCACABIBigIAFhDQAgCiAHIAlqIgM2AgAgA0GAlOvcA08EQANAIApBADYCACAIIApBBGsiCksEQCAIQQRrIghBADYCAAsgCiAKKAIAQQFqIgM2AgAgA0H/k+vcA0sNAAsLIA0gCGtBAnVBCWwhA0EKIQcgCCgCACIJQQpJDQADQCADQQFqIQMgCSAHQQpsIgdPDQALCyAKQQRqIgcgBiAGIAdLGyEGCwNAIAYiByAITSIJRQRAIAdBBGsiBigCAEUNAQsLAkAgDkHnAEcEQCAEQQhxIQoMAQsgA0F/c0F/IAtBASALGyIGIANKIANBe0pxIgobIAZqIQtBf0F+IAobIAVqIQUgBEEIcSIKDQBBdyEGAkAgCQ0AIAdBBGsoAgAiDkUNAEEKIQlBACEGIA5BCnANAANAIAYiCkEBaiEGIA4gCUEKbCIJcEUNAAsgCkF/cyEGCyAHIA1rQQJ1QQlsIQkgBUFfcUHGAEYEQEEAIQogCyAGIAlqQQlrIgZBACAGQQBKGyIGIAYgC0obIQsMAQtBACEKIAsgAyAJaiAGakEJayIGQQAgBkEAShsiBiAGIAtKGyELC0F/IQkgC0H9////B0H+////ByAKIAtyIhIbSg0BIAsgEkEAR2pBAWohDgJAIAVBX3EiFUHGAEYEQCADIA5B/////wdzSg0DIANBACADQQBKGyEGDAELIBEgAyADQR91IgZzIAZrrSAREAwiBmtBAUwEQANAIAZBAWsiBkEwOgAAIBEgBmtBAkgNAAsLIAZBAmsiDyAFOgAAIAZBAWtBLUErIANBAEgbOgAAIBEgD2siBiAOQf////8Hc0oNAgsgBiAOaiIDIBBB/////wdzSg0BIABBICACIAMgEGoiBSAEEAYgACATIBAQBSAAQTAgAiAFIARBgIAEcxAGAkACQAJAIBVBxgBGBEAgDEEQaiIGQQhyIQMgBkEJciEKIA0gCCAIIA1LGyIJIQgDQCAINQIAIAoQDCEGAkAgCCAJRwRAIAYgDEEQak0NAQNAIAZBAWsiBkEwOgAAIAYgDEEQaksNAAsMAQsgBiAKRw0AIAxBMDoAGCADIQYLIAAgBiAKIAZrEAUgCEEEaiIIIA1NDQALIBIEQCAAQf4IQQEQBQsgByAITQ0BIAtBAEwNAQNAIAg1AgAgChAMIgYgDEEQaksEQANAIAZBAWsiBkEwOgAAIAYgDEEQaksNAAsLIAAgBkEJIAsgC0EJThsQBSALQQlrIQYgCEEEaiIIIAdPDQMgC0EJSiEDIAYhCyADDQALDAILAkAgC0EASA0AIAcgCEEEaiAHIAhLGyEJIAxBEGoiBkEIciEDIAZBCXIhDSAIIQcDQCANIAc1AgAgDRAMIgZGBEAgDEEwOgAYIAMhBgsCQCAHIAhHBEAgBiAMQRBqTQ0BA0AgBkEBayIGQTA6AAAgBiAMQRBqSw0ACwwBCyAAIAZBARAFIAZBAWohBiAKIAtyRQ0AIABB/ghBARAFCyAAIAYgDSAGayIGIAsgBiALSBsQBSALIAZrIQsgB0EEaiIHIAlPDQEgC0EATg0ACwsgAEEwIAtBEmpBEkEAEAYgACAPIBEgD2sQBQwCCyALIQYLIABBMCAGQQlqQQlBABAGCyAAQSAgAiAFIARBgMAAcxAGIAUgAiACIAVIGyEJDAELIBMgBUEadEEfdUEJcWohCAJAIANBC0sNAEEMIANrIQZEAAAAAAAAMEAhGANAIBhEAAAAAAAAMECiIRggBkEBayIGDQALIAgtAABBLUYEQCAYIAGaIBihoJohAQwBCyABIBigIBihIQELIBEgDCgCLCIGIAZBH3UiBnMgBmutIBEQDCIGRgRAIAxBMDoADyAMQQ9qIQYLIBBBAnIhCyAFQSBxIQ0gDCgCLCEHIAZBAmsiCiAFQQ9qOgAAIAZBAWtBLUErIAdBAEgbOgAAIARBCHEhBiAMQRBqIQcDQCAHIgUCfyABmUQAAAAAAADgQWMEQCABqgwBC0GAgICAeAsiB0HgI2otAAAgDXI6AAAgASAHt6FEAAAAAAAAMECiIQECQCAFQQFqIgcgDEEQamtBAUcNAAJAIAYNACADQQBKDQAgAUQAAAAAAAAAAGENAQsgBUEuOgABIAVBAmohBwsgAUQAAAAAAAAAAGINAAtBfyEJQf3///8HIAsgESAKayIGaiINayADSA0AIABBICACIA0gA0ECaiAHIAxBEGoiB2siBSAFQQJrIANIGyAFIAMbIglqIgMgBBAGIAAgCCALEAUgAEEwIAIgAyAEQYCABHMQBiAAIAcgBRAFIABBMCAJIAVrQQBBABAGIAAgCiAGEAUgAEEgIAIgAyAEQYDAAHMQBiADIAIgAiADSBshCQsgDEGwBGokACAJC7QCAAJAAkACQAJAAkACQAJAAkACQAJAAkAgAUEJaw4SAAgJCggJAQIDBAoJCgoICQUGBwsgAiACKAIAIgFBBGo2AgAgACABKAIANgIADwsgAiACKAIAIgFBBGo2AgAgACABMgEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMwEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMAAANwMADwsgAiACKAIAIgFBBGo2AgAgACABMQAANwMADwsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKwMAOQMADwsACw8LIAIgAigCACIBQQRqNgIAIAAgATQCADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATUCADcDAA8LIAIgAigCAEEHakF4cSIBQQhqNgIAIAAgASkDADcDAAtyAQN/IAAoAgAsAABBMGtBCk8EQEEADwsDQCAAKAIAIQNBfyEBIAJBzJmz5gBNBEBBfyADLAAAQTBrIgEgAkEKbCICaiABIAJB/////wdzShshAQsgACADQQFqNgIAIAEhAiADLAABQTBrQQpJDQALIAILkRQCE38BfkGHCSELIwBB0ABrIgUkACAFQYcJNgJMIAVBN2ohFSAFQThqIRACQAJAAkACQANAIAshCiAEIAxB/////wdzSg0BIAQgDGohDAJAAkACQCAKIgQtAAAiBgRAA0ACQAJAIAZB/wFxIgtFBEAgBCELDAELIAtBJUcNASAEIQYDQCAGLQABQSVHBEAgBiELDAILIARBAWohBCAGLQACIQcgBkECaiILIQYgB0ElRg0ACwsgBCAKayIEIAxB/////wdzIhZKDQcgAARAIAAgCiAEEAULIAQNBiAFIAs2AkwgC0EBaiEEQX8hDQJAIAssAAFBMGtBCk8NACALLQACQSRHDQAgC0EDaiEEIAssAAFBMGshDUEBIRELIAUgBDYCTEEAIQgCQCAELAAAIgZBIGsiC0EfSwRAIAQhBwwBCyAEIQdBASALdCILQYnRBHFFDQADQCAFIARBAWoiBzYCTCAIIAtyIQggBCwAASIGQSBrIgtBIE8NASAHIQRBASALdCILQYnRBHENAAsLAkAgBkEqRgRAAn8CQCAHLAABQTBrQQpPDQAgBy0AAkEkRw0AIAcsAAFBAnQgA2pBwAFrQQo2AgAgB0EDaiEGQQEhESAHLAABQQN0IAJqQYADaygCAAwBCyARDQYgB0EBaiEGIABFBEAgBSAGNgJMQQAhEUEAIQ4MAwsgASABKAIAIgRBBGo2AgBBACERIAQoAgALIQ4gBSAGNgJMIA5BAE4NAUEAIA5rIQ4gCEGAwAByIQgMAQsgBUHMAGoQKCIOQQBIDQggBSgCTCEGC0EAIQRBfyEJAn8gBi0AAEEuRwRAIAYhC0EADAELIAYtAAFBKkYEQAJ/AkAgBiwAAkEwa0EKTw0AIAYtAANBJEcNACAGLAACQQJ0IANqQcABa0EKNgIAIAZBBGohCyAGLAACQQN0IAJqQYADaygCAAwBCyARDQYgBkECaiELQQAgAEUNABogASABKAIAIgdBBGo2AgAgBygCAAshCSAFIAs2AkwgCUF/c0EfdgwBCyAFIAZBAWo2AkwgBUHMAGoQKCEJIAUoAkwhC0EBCyESA0AgBCEPQRwhByALIhQsAAAiBEH7AGtBRkkNCSAUQQFqIQsgBCAPQTpsakHPH2otAAAiBEEBa0EISQ0ACyAFIAs2AkwCQAJAIARBG0cEQCAERQ0LIA1BAE4EQCADIA1BAnRqIAQ2AgAgBSACIA1BA3RqKQMANwNADAILIABFDQggBUFAayAEIAEQJwwCCyANQQBODQoLQQAhBCAARQ0HCyAIQf//e3EiBiAIIAhBgMAAcRshCEEAIQ1BgAghEyAQIQcCQAJAAkACfwJAAkACQAJAAn8CQAJAAkACQAJAAkACQCAULAAAIgRBX3EgBCAEQQ9xQQNGGyAEIA8bIgRB2ABrDiEEFBQUFBQUFBQOFA8GDg4OFAYUFBQUAgUDFBQJFAEUFAQACwJAIARBwQBrDgcOFAsUDg4OAAsgBEHTAEYNCQwTCyAFKQNAIRdBgAgMBQtBACEEAkACQAJAAkACQAJAAkAgD0H/AXEOCAABAgMEGgUGGgsgBSgCQCAMNgIADBkLIAUoAkAgDDYCAAwYCyAFKAJAIAysNwMADBcLIAUoAkAgDDsBAAwWCyAFKAJAIAw6AAAMFQsgBSgCQCAMNgIADBQLIAUoAkAgDKw3AwAMEwtBCCAJIAlBCE0bIQkgCEEIciEIQfgAIQQLIBAhCiAFKQNAIhdCAFIEQCAEQSBxIQYDQCAKQQFrIgogF6dBD3FB4CNqLQAAIAZyOgAAIBdCD1YhDyAXQgSIIRcgDw0ACwsgBSkDQFANAyAIQQhxRQ0DIARBBHZBgAhqIRNBAiENDAMLIBAhBCAFKQNAIhdCAFIEQANAIARBAWsiBCAXp0EHcUEwcjoAACAXQgdWIQogF0IDiCEXIAoNAAsLIAQhCiAIQQhxRQ0CIAkgECAKayIEQQFqIAQgCUgbIQkMAgsgBSkDQCIXQgBTBEAgBUIAIBd9Ihc3A0BBASENQYAIDAELIAhBgBBxBEBBASENQYEIDAELQYIIQYAIIAhBAXEiDRsLIRMgFyAQEAwhCgsgEkEAIAlBAEgbDQ4gCEH//3txIAggEhshCAJAIAUpA0AiF0IAUg0AIAkNACAQIQpBACEJDAwLIAkgF1AgECAKa2oiBCAEIAlIGyEJDAsLAn9B/////wcgCSAJQf////8HTxsiDyIHQQBHIQgCQAJAAkAgBSgCQCIEQYAJIAQbIgoiBEEDcUUNACAHRQ0AA0AgBC0AAEUNAiAHQQFrIgdBAEchCCAEQQFqIgRBA3FFDQEgBw0ACwsgCEUNAQJAIAQtAABFDQAgB0EESQ0AA0AgBCgCACIIQX9zIAhBgYKECGtxQYCBgoR4cQ0CIARBBGohBCAHQQRrIgdBA0sNAAsLIAdFDQELA0AgBCAELQAARQ0CGiAEQQFqIQQgB0EBayIHDQALC0EACyIEIAprIA8gBBsiBCAKaiEHIAlBAE4EQCAGIQggBCEJDAsLIAYhCCAEIQkgBy0AAA0NDAoLIAkEQCAFKAJADAILQQAhBCAAQSAgDkEAIAgQBgwCCyAFQQA2AgwgBSAFKQNAPgIIIAUgBUEIaiIENgJAQX8hCSAECyEGQQAhBAJAA0AgBigCACIKRQ0BAkAgBUEEaiAKECUiCkEASCIHDQAgCiAJIARrSw0AIAZBBGohBiAEIApqIgQgCUkNAQwCCwsgBw0NC0E9IQcgBEEASA0LIABBICAOIAQgCBAGIARFBEBBACEEDAELQQAhByAFKAJAIQYDQCAGKAIAIgpFDQEgBUEEaiAKECUiCiAHaiIHIARLDQEgACAFQQRqIAoQBSAGQQRqIQYgBCAHSw0ACwsgAEEgIA4gBCAIQYDAAHMQBiAOIAQgBCAOSBshBAwICyASQQAgCUEASBsNCEE9IQcgACAFKwNAIA4gCSAIIAQQJiIEQQBODQcMCQsgBSAFKQNAPAA3QQEhCSAVIQogBiEIDAQLIAQtAAEhBiAEQQFqIQQMAAsACyAADQcgEUUNAkEBIQQDQCADIARBAnRqKAIAIgAEQCACIARBA3RqIAAgARAnQQEhDCAEQQFqIgRBCkcNAQwJCwtBASEMIARBCk8NBwNAIAMgBEECdGooAgANASAEQQFqIgRBCkcNAAsMBwtBHCEHDAQLIAkgByAKayIPIAkgD0obIgkgDUH/////B3NKDQJBPSEHIA4gCSANaiIGIAYgDkgbIgQgFkoNAyAAQSAgBCAGIAgQBiAAIBMgDRAFIABBMCAEIAYgCEGAgARzEAYgAEEwIAkgD0EAEAYgACAKIA8QBSAAQSAgBCAGIAhBgMAAcxAGDAELC0EAIQwMAwtBPSEHC0GoMiAHNgIAC0F/IQwLIAVB0ABqJAAgDAt+AgF/AX4gAL0iA0I0iKdB/w9xIgJB/w9HBHwgAkUEQCABIABEAAAAAAAAAABhBH9BAAUgAEQAAAAAAADwQ6IgARAqIQAgASgCAEFAags2AgAgAA8LIAEgAkH+B2s2AgAgA0L/////////h4B/g0KAgICAgICA8D+EvwUgAAsLegEDfwJAAkAgACIBQQNxRQ0AIAAtAABFBEBBAA8LA0AgAUEBaiIBQQNxRQ0BIAEtAAANAAsMAQsDQCABIgJBBGohASACKAIAIgNBf3MgA0GBgoQIa3FBgIGChHhxRQ0ACwNAIAIiAUEBaiECIAEtAAANAAsLIAEgAGsLgAQBA38gAkGABE8EQCAAIAEgAhAEIAAPCyAAIAJqIQMCQCAAIAFzQQNxRQRAAkAgAEEDcUUEQCAAIQIMAQsgAkUEQCAAIQIMAQsgACECA0AgAiABLQAAOgAAIAFBAWohASACQQFqIgJBA3FFDQEgAiADSQ0ACwsCQCADQXxxIgRBwABJDQAgAiAEQUBqIgVLDQADQCACIAEoAgA2AgAgAiABKAIENgIEIAIgASgCCDYCCCACIAEoAgw2AgwgAiABKAIQNgIQIAIgASgCFDYCFCACIAEoAhg2AhggAiABKAIcNgIcIAIgASgCIDYCICACIAEoAiQ2AiQgAiABKAIoNgIoIAIgASgCLDYCLCACIAEoAjA2AjAgAiABKAI0NgI0IAIgASgCODYCOCACIAEoAjw2AjwgAUFAayEBIAJBQGsiAiAFTQ0ACwsgAiAETw0BA0AgAiABKAIANgIAIAFBBGohASACQQRqIgIgBEkNAAsMAQsgA0EESQRAIAAhAgwBCyAAIANBBGsiBEsEQCAAIQIMAQsgACECA0AgAiABLQAAOgAAIAIgAS0AAToAASACIAEtAAI6AAIgAiABLQADOgADIAFBBGohASACQQRqIgIgBE0NAAsLIAIgA0kEQANAIAIgAS0AADoAACABQQFqIQEgAkEBaiICIANHDQALCyAACwMAAQv4DwIUfwN8IwBBEGsiCyQAAkAgALwiEUH/////B3EiA0Han6TuBE0EQCABIAC7IhcgF0SDyMltMF/kP6JEAAAAAAAAOEOgRAAAAAAAADjDoCIWRAAAAFD7Ifm/oqAgFkRjYhphtBBRvqKgIhg5AwAgGEQAAABg+yHpv2MhAgJ/IBaZRAAAAAAAAOBBYwRAIBaqDAELQYCAgIB4CyEDIAIEQCABIBcgFkQAAAAAAADwv6AiFkQAAABQ+yH5v6KgIBZEY2IaYbQQUb6ioDkDACADQQFrIQMMAgsgGEQAAABg+yHpP2RFDQEgASAXIBZEAAAAAAAA8D+gIhZEAAAAUPsh+b+ioCAWRGNiGmG0EFG+oqA5AwAgA0EBaiEDDAELIANBgICA/AdPBEAgASAAIACTuzkDAEEAIQMMAQsgCyADIANBF3ZBlgFrIgNBF3Rrvrs5AwggC0EIaiEOIwBBsARrIgUkACADIANBA2tBGG0iAkEAIAJBAEobIg1BaGxqIQZB8AkoAgAiB0EATgRAIAdBAWohAyANIQIDQCAFQcACaiAEQQN0aiACQQBIBHxEAAAAAAAAAAAFIAJBAnRBgApqKAIAtws5AwAgAkEBaiECIARBAWoiBCADRw0ACwsgBkEYayEIQQAhAyAHQQAgB0EAShshBANAQQAhAkQAAAAAAAAAACEWA0AgDiACQQN0aisDACAFQcACaiADIAJrQQN0aisDAKIgFqAhFiACQQFqIgJBAUcNAAsgBSADQQN0aiAWOQMAIAMgBEYhAiADQQFqIQMgAkUNAAtBLyAGayESQTAgBmshDyAGQRlrIRMgByEDAkADQCAFIANBA3RqKwMAIRZBACECIAMhBCADQQBMIglFBEADQCAFQeADaiACQQJ0agJ/An8gFkQAAAAAAABwPqIiF5lEAAAAAAAA4EFjBEAgF6oMAQtBgICAgHgLtyIXRAAAAAAAAHDBoiAWoCIWmUQAAAAAAADgQWMEQCAWqgwBC0GAgICAeAs2AgAgBSAEQQFrIgRBA3RqKwMAIBegIRYgAkEBaiICIANHDQALCwJ/IBYgCBAPIhYgFkQAAAAAAADAP6KcRAAAAAAAACDAoqAiFplEAAAAAAAA4EFjBEAgFqoMAQtBgICAgHgLIQogFiAKt6EhFgJAAkACQAJ/IAhBAEwiFEUEQCADQQJ0IAVqIgIgAigC3AMiAiACIA91IgIgD3RrIgQ2AtwDIAIgCmohCiAEIBJ1DAELIAgNASADQQJ0IAVqKALcA0EXdQsiDEEATA0CDAELQQIhDCAWRAAAAAAAAOA/Zg0AQQAhDAwBC0EAIQJBACEEIAlFBEADQCAFQeADaiACQQJ0aiIVKAIAIQlB////ByEQAn8CQCAEDQBBgICACCEQIAkNAEEADAELIBUgECAJazYCAEEBCyEEIAJBAWoiAiADRw0ACwsCQCAUDQBB////AyECAkACQCATDgIBAAILQf///wEhAgsgA0ECdCAFaiIJIAkoAtwDIAJxNgLcAwsgCkEBaiEKIAxBAkcNAEQAAAAAAADwPyAWoSEWQQIhDCAERQ0AIBZEAAAAAAAA8D8gCBAPoSEWCyAWRAAAAAAAAAAAYQRAQQAhBAJAIAcgAyICTg0AA0AgBUHgA2ogAkEBayICQQJ0aigCACAEciEEIAIgB0oNAAsgBEUNACAIIQYDQCAGQRhrIQYgBUHgA2ogA0EBayIDQQJ0aigCAEUNAAsMAwtBASECA0AgAiIEQQFqIQIgBUHgA2ogByAEa0ECdGooAgBFDQALIAMgBGohBANAIAVBwAJqIANBAWoiA0EDdGogAyANakECdEGACmooAgC3OQMAQQAhAkQAAAAAAAAAACEWA0AgDiACQQN0aisDACAFQcACaiADIAJrQQN0aisDAKIgFqAhFiACQQFqIgJBAUcNAAsgBSADQQN0aiAWOQMAIAMgBEgNAAsgBCEDDAELCwJAIBZBGCAGaxAPIhZEAAAAAAAAcEFmBEAgBUHgA2ogA0ECdGoCfwJ/IBZEAAAAAAAAcD6iIheZRAAAAAAAAOBBYwRAIBeqDAELQYCAgIB4CyICt0QAAAAAAABwwaIgFqAiFplEAAAAAAAA4EFjBEAgFqoMAQtBgICAgHgLNgIAIANBAWohAwwBCwJ/IBaZRAAAAAAAAOBBYwRAIBaqDAELQYCAgIB4CyECIAghBgsgBUHgA2ogA0ECdGogAjYCAAtEAAAAAAAA8D8gBhAPIRYCQCADQQBIDQAgAyECA0AgBSACIgRBA3RqIBYgBUHgA2ogAkECdGooAgC3ojkDACACQQFrIQIgFkQAAAAAAABwPqIhFiAEDQALIANBAEgNACADIQQDQEQAAAAAAAAAACEWQQAhAiAHIAMgBGsiBiAGIAdKGyIIQQBOBEADQCACQQN0QdAfaisDACAFIAIgBGpBA3RqKwMAoiAWoCEWIAIgCEchDSACQQFqIQIgDQ0ACwsgBUGgAWogBkEDdGogFjkDACAEQQBKIQIgBEEBayEEIAINAAsLRAAAAAAAAAAAIRYgA0EATgRAA0AgAyICQQFrIQMgFiAFQaABaiACQQN0aisDAKAhFiACDQALCyALIBaaIBYgDBs5AwAgBUGwBGokACAKQQdxIQMgCysDACEWIBFBAEgEQCABIBaaOQMAQQAgA2shAwwBCyABIBY5AwALIAtBEGokACADC/YEAQh/IAEgACgCCCIEIAAoAgQiAmtBJG1NBEAgACABBH8gAiABQSRsaiEAA0AgAv0MAAAAAAAAAAAAAAAAAAAAAP0LAgAgAkEANgIgIAL9DAAAAAAAAAAAAAAAAAAAAAD9CwIQIAJBADYCCCACQgA3AgAgAkEMaiIBQQA2AgggAUIANwIAIAJBGGoiAUEANgIIIAFCADcCACACQSRqIgIgAEcNAAsgAAUgAgs2AgQPCwJAIAIgACgCACICa0EkbSIGIAFqIgNByOPxOEkEQEHH4/E4IAQgAmtBJG0iAkEBdCIEIAMgAyAESRsgAkHj8bgcTxsiBARAIARByOPxOE8NAiAEQSRsEA4hBQsgBSAGQSRsaiIDIAFBJGxqIQYgAyECA0AgAv0MAAAAAAAAAAAAAAAAAAAAAP0LAgAgAkEANgIgIAL9DAAAAAAAAAAAAAAAAAAAAAD9CwIQIAJBADYCCCACQgA3AgAgAkEMaiIBQQA2AgggAUIANwIAIAJBGGoiAUEANgIIIAFCADcCACACQSRqIgIgBkcNAAsgBSAEQSRsaiEIAkAgACgCBCICIAAoAgAiCUYEQCADIQUMAQsDQCADQSRrIgUgAkEkayIBKgIAOAIAIAUgASoCBDgCBCAFIAEqAgg4AgggA0EYayIEIAJBGGsiByoCADgCACAEIAcqAgQ4AgQgBCAHKgIIOAIIIANBDGsiAyACQQxrIgIqAgA4AgAgAyACKgIEOAIEIAMgAioCCDgCCCAFIQMgASICIAlHDQALIAAoAgAhAgsgACAINgIIIAAgBjYCBCAAIAU2AgAgAgRAIAIQCgsPCxAZAAsQGAALrgoBCH8CQEHoKSgCAEHkKSgCACICa0EGdSIBIABJBEAgACABayIDQewpKAIAIgRB6CkoAgAiAWtBBnVNBEBB6CkgAwR/IAEgA0EGdGohAgNAIAEQGkFAayIBIAJHDQALIAIFIAELNgIADAILAkAgAUHkKSgCACICa0EGdSIGIANqIgVBgICAIEkEQEH///8fIAQgAmsiAUEFdSICIAUgAiAFSxsgAUHA////B08bIgcEfyAHQYCAgCBPDQIgB0EGdBAOBUEACyIEIAZBBnRqIgIgA0EGdGohBSACIQEDQCABEBpBQGsiASAFRw0AC0HoKSgCACIBQeQpKAIAIgZHBEADQCACQUBqIgMgAUFAaiIBIgL9AAIA/QsCACADIAL9AAIw/QsCMCADIAL9AAIg/QsCICADIAL9AAIQ/QsCECADIQIgASAGRw0AC0HkKSgCACEBC0HsKSAEIAdBBnRqNgIAQegpIAU2AgBB5CkgAjYCACABBEAgARAQCwwDCxAZAAsQGAALIAAgAU8NAEHoKSACIABBBnRqNgIACwJAQfQpKAIAQfApKAIAIgJrQSRtIgEgAEkEQEHwKSAAIAFrEC8MAQsgACABTw0AQfQpIAIgAEEkbGo2AgALAkBBgCooAgBB/CkoAgAiAmtBBHUiASAASQRAQQAhBEEAIQcgACABayIDQYQqKAIAIgZBgCooAgAiAmtBBHVNBEACQCADRQ0AIAIhASADQQdxIggEQANAIAFC/////w83AgggAUIANwIAIAFBEGohASAEQQFqIgQgCEcNAAsLIANBBHQgAmohAiADQQFrQf////8AcUEHSQ0AA0AgAUIANwJwIAFCADcCYCABQgA3AlAgAUIANwJAIAFCADcCMCABQgA3AiAgAUIANwIQIAFC/////w83AgggAUIANwIAIAFC/////w83AnggAUL/////DzcCaCABQv////8PNwJYIAFC/////w83AkggAUL/////DzcCOCABQv////8PNwIoIAFC/////w83AhggAUGAAWoiASACRw0ACwtBgCogAjYCAAwCCwJAIAJB/CkoAgAiAWtBBHUiBCADaiIFQYCAgIABSQRAQf////8AIAYgAWsiBkEDdSIBIAUgASAFSxsgBkHw////B08bIgUEQCAFQYCAgIABTw0CIAVBBHQQDiEHCyAHIARBBHRqIgQhASADQQdxIgYEQANAIAFC/////w83AgggAUIANwIAIAFBEGohASAIQQFqIgggBkcNAAsLIANBBHQgBGohCCADQQFrQf////8AcUEHTwRAA0AgAUIANwJwIAFCADcCYCABQgA3AlAgAUIANwJAIAFCADcCMCABQgA3AiAgAUIANwIQIAFC/////w83AgggAUIANwIAIAFC/////w83AnggAUL/////DzcCaCABQv////8PNwJYIAFC/////w83AkggAUL/////DzcCOCABQv////8PNwIoIAFC/////w83AhggAUGAAWoiASAIRw0ACwtB/CkoAgAiASACRwRAA0AgBEEQayIEIAJBEGsiAv0AAgD9CwIAIAEgAkcNAAtB/CkoAgAhAgtBhCogByAFQQR0ajYCAEGAKiAINgIAQfwpIAQ2AgAgAgRAIAIQEAsMAwsQGQALEBgACyAAIAFPDQBBgCogAiAAQQR0ajYCAAtBjCooAgBBiCooAgAiAmtBJG0iASAASQRAQYgqIAAgAWsQLw8LIAAgAUkEQEGMKiACIABBJGxqNgIACwsQACMAIABrQXBxIgAkACAACwcAIAAoAgQLGQBBiCooAgAiAARAQYwqIAA2AgAgABAKCwsFAEG3CAsFAEHnCAsFAEGkCAsVACAARQRAQQAPCyAAQaQlECFBAEcLGgAgACABKAIIIAUQCQRAIAEgAiADIAQQHwsLNwAgACABKAIIIAUQCQRAIAEgAiADIAQQHw8LIAAoAggiACABIAIgAyAEIAUgACgCACgCFBEHAAunAQAgACABKAIIIAQQCQRAAkAgASgCBCACRw0AIAEoAhxBAUYNACABIAM2AhwLDwsCQCAAIAEoAgAgBBAJRQ0AAkAgAiABKAIQRwRAIAEoAhQgAkcNAQsgA0EBRw0BIAFBATYCIA8LIAEgAjYCFCABIAM2AiAgASABKAIoQQFqNgIoAkAgASgCJEEBRw0AIAEoAhhBAkcNACABQQE6ADYLIAFBBDYCLAsLiAIAIAAgASgCCCAEEAkEQAJAIAEoAgQgAkcNACABKAIcQQFGDQAgASADNgIcCw8LAkAgACABKAIAIAQQCQRAAkAgAiABKAIQRwRAIAEoAhQgAkcNAQsgA0EBRw0CIAFBATYCIA8LIAEgAzYCIAJAIAEoAixBBEYNACABQQA7ATQgACgCCCIAIAEgAiACQQEgBCAAKAIAKAIUEQcAIAEtADUEQCABQQM2AiwgAS0ANEUNAQwDCyABQQQ2AiwLIAEgAjYCFCABIAEoAihBAWo2AiggASgCJEEBRw0BIAEoAhhBAkcNASABQQE6ADYPCyAAKAIIIgAgASACIAMgBCAAKAIAKAIYEQUACwsZAEH8KSgCACIABEBBgCogADYCACAAEAoLCzEAIAAgASgCCEEAEAkEQCABIAIgAxAgDwsgACgCCCIAIAEgAiADIAAoAgAoAhwRBgALGAAgACABKAIIQQAQCQRAIAEgAiADECALC5sBAQF/IwBBQGoiAyQAAn9BASAAIAFBABAJDQAaQQAgAUUNABpBACABQcQkECEiAUUNABogA0EMakEAQTQQESADQQE2AjggA0F/NgIUIAMgADYCECADIAE2AgggASADQQhqIAIoAgBBASABKAIAKAIcEQYAIAMoAiAiAEEBRgRAIAIgAygCGDYCAAsgAEEBRgshACADQUBrJAAgAAsZAEHwKSgCACIABEBB9CkgADYCACAAEAoLCxkAQeQpKAIAIgAEQEHoKSAANgIAIAAQCgsLBABCAAsEAEEAC/QCAQd/IwBBIGsiAyQAIAMgACgCHCIENgIQIAAoAhQhBSADIAI2AhwgAyABNgIYIAMgBSAEayIBNgIUIAEgAmohBUECIQcCfwJAAkACQCAAKAI8IANBEGoiAUECIANBDGoQACIEBH9BqDIgBDYCAEF/BUEACwRAIAEhBAwBCwNAIAUgAygCDCIGRg0CIAZBAEgEQCABIQQMBAsgASAGIAEoAgQiCEsiCUEDdGoiBCAGIAhBACAJG2siCCAEKAIAajYCACABQQxBBCAJG2oiASABKAIAIAhrNgIAIAUgBmshBSAAKAI8IAQiASAHIAlrIgcgA0EMahAAIgYEf0GoMiAGNgIAQX8FQQALRQ0ACwsgBUF/Rw0BCyAAIAAoAiwiATYCHCAAIAE2AhQgACABIAAoAjBqNgIQIAIMAQsgAEEANgIcIABCADcDECAAIAAoAgBBIHI2AgBBACAHQQJGDQAaIAIgBCgCBGsLIQAgA0EgaiQAIAALhwIAQZQpKAIAGgJAQX9BAAJ/QdAIECsiAAJ/QZQpKAIAQQBIBEBB0AggAEHIKBAUDAELQdAIIABByCgQFAsiASAARg0AGiABCyAARxtBAEgNAAJAQZgpKAIAQQpGDQBB3CgoAgAiAEHYKCgCAEYNAEHcKCAAQQFqNgIAIABBCjoAAAwBCyMAQRBrIgAkACAAQQo6AA8CQAJAQdgoKAIAIgEEfyABBUHIKBAVDQJB2CgoAgALQdwoKAIAIgFGDQBBmCkoAgBBCkYNAEHcKCABQQFqNgIAIAFBCjoAAAwBC0HIKCAAQQ9qQQFB7CgoAgARAgBBAUcNACAALQAPGgsgAEEQaiQAC0EACyYAQeApIAI4AgAgACABSARAA0AgABAcGiAAQQFqIgAgAUcNAAsLC+UEAgZ/D30jAEGAAWsiASQAQeQpKAIAIABBBnRqIgAqAgAhByAAKgIEIQggACoCCCEJIAAqAgwhCiAAKgIQIQsgACoCFCEMIAAqAhghDSAAKgIcIQ4gACoCICEPIAAqAiQhECAAKgIoIREgACoCLCESIAAqAjAhEyAAKgI0IRQgACoCOCEVIAEgACoCPLs5A3ggASAVuzkDcCABIBS7OQNoIAEgE7s5A2AgASASuzkDWCABIBG7OQNQIAEgELs5A0ggAUFAayAPuzkDACABIA67OQM4IAEgDbs5AzAgASAMuzkDKCABIAu7OQMgIAEgCrs5AxggASAJuzkDECABIAi7OQMIIAEgB7s5AwAjAEEQayIEJAAgBCABNgIMIwBB0AFrIgAkACAAIAE2AswBIABBoAFqIgJBAEEoEBEgACAAKALMATYCyAECQEEAIABByAFqIABB0ABqIAIQKUEASA0AQZQpKAIAQQBOIQVByCgoAgAhAkGQKSgCAEEATARAQcgoIAJBX3E2AgALAn8CQAJAQfgoKAIARQRAQfgoQdAANgIAQeQoQQA2AgBB2ChCADcDAEH0KCgCACEDQfQoIAA2AgAMAQtB2CgoAgANAQtBf0HIKBAVDQEaC0HIKCAAQcgBaiAAQdAAaiAAQaABahApCyEGIAMEf0HIKEEAQQBB7CgoAgARAgAaQfgoQQA2AgBB9CggAzYCAEHkKEEANgIAQdwoKAIAGkHYKEIANwMAQQAFIAYLGkHIKEHIKCgCACACQSBxcjYCACAFRQ0ACyAAQdABaiQAIARBEGokACABQYABaiQACwgAQYgqKAIACwgAQfwpKAIACwgAQfApKAIACwgAQeQpKAIACwvnHxQAQYAIC8cXLSsgICAwWDB4AC0wWCswWCAwWC0weCsweCAweAB2ZWN0b3IAc3RkOjpleGNlcHRpb24AbmFuAGJhZF9hcnJheV9uZXdfbGVuZ3RoAGluZgBlbXNjcmlwdGVuIGhhdmUgbG9hZGVkAHN0ZDo6YmFkX2FsbG9jAE5BTgBJTkYALgAobnVsbCkAWyUuMmYsICUuMmYsICUuMmYsICUuMmZdDQpbJS4yZiwgJS4yZiwgJS4yZiwgJS4yZl0NClslLjJmLCAlLjJmLCAlLjJmLCAlLjJmXQ0KWyUuMmYsICUuMmYsICUuMmYsICUuMmZdDQoAAwAAAAQAAAAEAAAABgAAAIP5ogBETm4A/CkVANFXJwDdNPUAYtvAADyZlQBBkEMAY1H+ALveqwC3YcUAOm4kANJNQgBJBuAACeouAByS0QDrHf4AKbEcAOg+pwD1NYIARLsuAJzphAC0JnAAQX5fANaROQBTgzkAnPQ5AItfhAAo+b0A+B87AN7/lwAPmAUAES/vAApaiwBtH20Az342AAnLJwBGT7cAnmY/AC3qXwC6J3UA5evHAD178QD3OQcAklKKAPtr6gAfsV8ACF2NADADVgB7/EYA8KtrACC8zwA29JoA46kdAF5hkQAIG+YAhZllAKAUXwCNQGgAgNj/ACdzTQAGBjEAylYVAMmocwB74mAAa4zAABnERwDNZ8MACejcAFmDKgCLdsQAphyWAESv3QAZV9EApT4FAAUH/wAzfj8AwjLoAJhP3gC7fTIAJj3DAB5r7wCf+F4ANR86AH/yygDxhx0AfJAhAGokfADVbvoAMC13ABU7QwC1FMYAwxmdAK3EwgAsTUEADABdAIZ9RgDjcS0Am8aaADNiAAC00nwAtKeXADdV1QDXPvYAoxAYAE12/ABknSoAcNerAGN8+AB6sFcAFxXnAMBJVgA71tkAp4Q4ACQjywDWincAWlQjAAAfuQDxChsAGc7fAJ8x/wBmHmoAmVdhAKz7RwB+f9gAImW3ADLoiQDmv2AA78TNAGw2CQBdP9QAFt7XAFg73gDem5IA0iIoACiG6ADiWE0AxsoyAAjjFgDgfcsAF8BQAPMdpwAY4FsALhM0AIMSYgCDSAEA9Y5bAK2wfwAe6fIASEpDABBn0wCq3dgArl9CAGphzgAKKKQA05m0AAam8gBcd38Ao8KDAGE8iACKc3gAr4xaAG/XvQAtpmMA9L/LAI2B7wAmwWcAVcpFAMrZNgAoqNIAwmGNABLJdwAEJhQAEkabAMRZxADIxUQATbKRAAAX8wDUQ60AKUnlAP3VEAAAvvwAHpTMAHDO7gATPvUA7PGAALPnwwDH+CgAkwWUAMFxPgAuCbMAC0XzAIgSnACrIHsALrWfAEeSwgB7Mi8ADFVtAHKnkABr5x8AMcuWAHkWSgBBeeIA9N+JAOiUlwDi5oQAmTGXAIjtawBfXzYAu/0OAEiatABnpGwAcXJCAI1dMgCfFbgAvOUJAI0xJQD3dDkAMAUcAA0MAQBLCGgALO5YAEeqkAB05wIAvdYkAPd9pgBuSHIAnxbvAI6UpgC0kfYA0VNRAM8K8gAgmDMA9Ut+ALJjaADdPl8AQF0DAIWJfwBVUikAN2TAAG3YEAAySDIAW0x1AE5x1ABFVG4ACwnBACr1aQAUZtUAJwedAF0EUAC0O9sA6nbFAIf5FwBJa30AHSe6AJZpKQDGzKwArRRUAJDiagCI2YkALHJQAASkvgB3B5QA8zBwAAD8JwDqcagAZsJJAGTgPQCX3YMAoz+XAEOU/QANhowAMUHeAJI5nQDdcIwAF7fnAAjfOwAVNysAXICgAFqAkwAQEZIAD+jYAGyArwDb/0sAOJAPAFkYdgBipRUAYcu7AMeJuQAQQL0A0vIEAEl1JwDrtvYA2yK7AAoUqgCJJi8AZIN2AAk7MwAOlBoAUTqqAB2jwgCv7a4AXCYSAG3CTQAtepwAwFaXAAM/gwAJ8PYAK0CMAG0xmQA5tAcADCAVANjDWwD1ksQAxq1LAE7KpQCnN80A5qk2AKuSlADdQmgAGWPeAHaM7wBoi1IA/Ns3AK6hqwDfFTEAAK6hAAz72gBkTWYA7QW3ACllMABXVr8AR/86AGr5uQB1vvMAKJPfAKuAMABmjPYABMsVAPoiBgDZ5B0APbOkAFcbjwA2zQkATkLpABO+pAAzI7UA8KoaAE9lqADSwaUACz8PAFt4zQAj+XYAe4sEAIkXcgDGplMAb27iAO/rAACbSlgAxNq3AKpmugB2z88A0QIdALHxLQCMmcEAw613AIZI2gD3XaAAxoD0AKzwLwDd7JoAP1y8ANDebQCQxx8AKtu2AKMlOgAAr5oArVOTALZXBAApLbQAS4B+ANoHpwB2qg4Ae1mhABYSKgDcty0A+uX9AInb/gCJvv0A5HZsAAap/AA+gHAAhW4VAP2H/wAoPgcAYWczACoYhgBNveoAs+evAI9tbgCVZzkAMb9bAITXSAAw3xYAxy1DACVhNQDJcM4AMMu4AL9s/QCkAKIABWzkAFrdoAAhb0cAYhLSALlchABwYUkAa1bgAJlSAQBQVTcAHtW3ADPxxAATbl8AXTDkAIUuqQAdssMAoTI2AAi3pADqsdQAFvchAI9p5AAn/3cADAOAAI1ALQBPzaAAIKWZALOi0wAvXQoAtPlCABHaywB9vtAAm9vBAKsXvQDKooEACGpcAC5VFwAnAFUAfxTwAOEHhgAUC2QAlkGNAIe+3gDa/SoAayW2AHuJNAAF8/4Aub+eAGhqTwBKKqgAT8RaAC34vADXWpgA9MeVAA1NjQAgOqYApFdfABQ/sQCAOJUAzCABAHHdhgDJ3rYAv2D1AE1lEQABB2sAjLCsALLA0ABRVUgAHvsOAJVywwCjBjsAwEA1AAbcewDgRcwATin6ANbKyADo80EAfGTeAJtk2ADZvjEApJfDAHdY1ABp48UA8NoTALo6PABGGEYAVXVfANK99QBuksYArC5dAA5E7QAcPkIAYcSHACn96QDn1vMAInzKAG+RNQAI4MUA/9eNAG5q4gCw/cYAkwjBAHxddABrrbIAzW6dAD5yewDGEWoA98+pAClz3wC1yboAtwBRAOKyDQB0uiQA5X1gAHTYigANFSwAgRgMAH5mlAABKRYAn3p2AP39vgBWRe8A2X42AOzZEwCLurkAxJf8ADGoJwDxbsMAlMU2ANioVgC0qLUAz8wOABKJLQBvVzQALFaJAJnO4wDWILkAa16qAD4qnAARX8wA/QtKAOH0+wCOO20A4oYsAOnUhAD8tKkA7+7RAC41yQAvOWEAOCFEABvZyACB/AoA+0pqAC8c2ABTtIQATpmMAFQizAAqVdwAwMbWAAsZlgAacLgAaZVkACZaYAA/Uu4AfxEPAPS1EQD8y/UANLwtADS87gDoXcwA3V5gAGeOmwCSM+8AyRe4AGFYmwDhV7wAUYPGANg+EADdcUgALRzdAK8YoQAhLEYAWfPXANl6mACeVMAAT4b6AFYG/ADlea4AiSI2ADitIgBnk9wAVeiqAIImOADK55sAUQ2kAJkzsQCp1w4AaQVIAGWy8AB/iKcAiEyXAPnRNgAhkrMAe4JKAJjPIQBAn9wA3EdVAOF0OgBn60IA/p3fAF7UXwB7Z6QAuqx6AFX2ogAriCMAQbpVAFluCAAhKoYAOUeDAInj5gDlntQASftAAP9W6QAcD8oAxVmKAJT6KwDTwcUAD8XPANtargBHxYYAhUNiACGGOwAseZQAEGGHACpMewCALBoAQ78SAIgmkAB4PIkAqMTkAOXbewDEOsIAJvTqAPdnigANkr8AZaMrAD2TsQC9fAsApFHcACfdYwBp4d0AmpQZAKgplQBozigACe20AESfIABOmMoAcIJjAH58IwAPuTIAp/WOABRW5wAh8QgAtZ0qAG9+TQClGVEAtfmrAILf1gCW3WEAFjYCAMQ6nwCDoqEAcu1tADmNegCCuKkAazJcAEYnWwAANO0A0gB3APz0VQABWU0A4HGAAEHTHwt+QPsh+T8AAAAALUR0PgAAAICYRvg8AAAAYFHMeDsAAACAgxvwOQAAAEAgJXo4AAAAgCKC4zYAAAAAHfNpNRkACgAZGRkAAAAABQAAAAAAAAkAAAAACwAAAAAAAAAAGQARChkZGQMKBwABAAkLGAAACQYLAAALAAYZAAAAGRkZAEHhIAshDgAAAAAAAAAAGQAKDRkZGQANAAACAAkOAAAACQAOAAAOAEGbIQsBDABBpyELFRMAAAAAEwAAAAAJDAAAAAAADAAADABB1SELARAAQeEhCxUPAAAABA8AAAAACRAAAAAAABAAABAAQY8iCwESAEGbIgseEQAAAAARAAAAAAkSAAAAAAASAAASAAAaAAAAGhoaAEHSIgsOGgAAABoaGgAAAAAAAAkAQYMjCwEUAEGPIwsVFwAAAAAXAAAAAAkUAAAAAAAUAAAUAEG9IwsBFgBBySML/QQVAAAAABUAAAAACRYAAAAAABYAABYAADAxMjM0NTY3ODlBQkNERUZOMTBfX2N4eGFiaXYxMTZfX3NoaW1fdHlwZV9pbmZvRQAAAADgEgAA8BEAAEAUAABOMTBfX2N4eGFiaXYxMTdfX2NsYXNzX3R5cGVfaW5mb0UAAADgEgAAIBIAABQSAABOMTBfX2N4eGFiaXYxMTdfX3BiYXNlX3R5cGVfaW5mb0UAAADgEgAAUBIAABQSAABOMTBfX2N4eGFiaXYxMTlfX3BvaW50ZXJfdHlwZV9pbmZvRQDgEgAAgBIAAHQSAAAAAAAARBIAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAAAAAAACgTAAALAAAAEwAAAA0AAAAOAAAADwAAABQAAAAVAAAAFgAAAE4xMF9fY3h4YWJpdjEyMF9fc2lfY2xhc3NfdHlwZV9pbmZvRQAAAADgEgAAABMAAEQSAAAAAAAAmBMAAAEAAAAXAAAAGAAAAAAAAADAEwAAAQAAABkAAAAaAAAAAAAAAIATAAABAAAAGwAAABwAAABTdDlleGNlcHRpb24AAAAAuBIAAHATAABTdDliYWRfYWxsb2MAAAAA4BIAAIgTAACAEwAAU3QyMGJhZF9hcnJheV9uZXdfbGVuZ3RoAAAAAOASAACkEwAAmBMAAAAAAADwEwAAAgAAAB0AAAAeAAAAU3QxMWxvZ2ljX2Vycm9yAOASAADgEwAAgBMAAAAAAAAkFAAAAgAAAB8AAAAeAAAAU3QxMmxlbmd0aF9lcnJvcgAAAADgEgAAEBQAAPATAABTdDl0eXBlX2luZm8AAAAAuBIAADAUAEHIKAsBBQBB1CgLAQcAQewoCw4IAAAACQAAACgVAAAABABBhCkLAQEAQZQpCwX/////CgBB2CkLA+AbAQ==";if(!isDataURI(wasmBinaryFile)){wasmBinaryFile=locateFile(wasmBinaryFile)}function getBinarySync(file){if(file==wasmBinaryFile&&wasmBinary){return new Uint8Array(wasmBinary)}if(readBinary){return readBinary(file)}throw"both async and sync fetching of the wasm failed"}function getBinaryPromise(binaryFile){if(!wasmBinary&&(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER)){if(typeof fetch=="function"&&!isFileURI(binaryFile)){return fetch(binaryFile,{credentials:"same-origin"}).then((response=>{if(!response["ok"]){throw"failed to load wasm binary file at '"+binaryFile+"'"}return response["arrayBuffer"]()})).catch((()=>getBinarySync(binaryFile)))}else if(readAsync){return new Promise(((resolve,reject)=>{readAsync(binaryFile,(response=>resolve(new Uint8Array(response))),reject)}))}}return Promise.resolve().then((()=>getBinarySync(binaryFile)))}function instantiateArrayBuffer(binaryFile,imports,receiver){return getBinaryPromise(binaryFile).then((binary=>WebAssembly.instantiate(binary,imports))).then((instance=>instance)).then(receiver,(reason=>{err("failed to asynchronously prepare wasm: "+reason);abort(reason)}))}function instantiateAsync(binary,binaryFile,imports,callback){if(!binary&&typeof WebAssembly.instantiateStreaming=="function"&&!isDataURI(binaryFile)&&!isFileURI(binaryFile)&&!ENVIRONMENT_IS_NODE&&typeof fetch=="function"){return fetch(binaryFile,{credentials:"same-origin"}).then((response=>{var result=WebAssembly.instantiateStreaming(response,imports);return result.then(callback,(function(reason){err("wasm streaming compile failed: "+reason);err("falling back to ArrayBuffer instantiation");return instantiateArrayBuffer(binaryFile,imports,callback)}))}))}return instantiateArrayBuffer(binaryFile,imports,callback)}function createWasm(){var info={"a":wasmImports};function receiveInstance(instance,module){var exports=instance.exports;Module["asm"]=exports;wasmMemory=Module["asm"]["f"];updateMemoryViews();wasmTable=Module["asm"]["h"];addOnInit(Module["asm"]["g"]);removeRunDependency("wasm-instantiate");return exports}addRunDependency("wasm-instantiate");function receiveInstantiationResult(result){receiveInstance(result["instance"])}if(Module["instantiateWasm"]){try{return Module["instantiateWasm"](info,receiveInstance)}catch(e){err("Module.instantiateWasm callback failed with error: "+e);return false}}instantiateAsync(wasmBinary,wasmBinaryFile,info,receiveInstantiationResult);return{}}function ExitStatus(status){this.name="ExitStatus";this.message=\`Program terminated with exit(\${status})\`;this.status=status}var callRuntimeCallbacks=callbacks=>{while(callbacks.length>0){callbacks.shift()(Module)}};function ExceptionInfo(excPtr){this.excPtr=excPtr;this.ptr=excPtr-24;this.set_type=function(type){HEAPU32[this.ptr+4>>2]=type};this.get_type=function(){return HEAPU32[this.ptr+4>>2]};this.set_destructor=function(destructor){HEAPU32[this.ptr+8>>2]=destructor};this.get_destructor=function(){return HEAPU32[this.ptr+8>>2]};this.set_caught=function(caught){caught=caught?1:0;HEAP8[this.ptr+12>>0]=caught};this.get_caught=function(){return HEAP8[this.ptr+12>>0]!=0};this.set_rethrown=function(rethrown){rethrown=rethrown?1:0;HEAP8[this.ptr+13>>0]=rethrown};this.get_rethrown=function(){return HEAP8[this.ptr+13>>0]!=0};this.init=function(type,destructor){this.set_adjusted_ptr(0);this.set_type(type);this.set_destructor(destructor)};this.set_adjusted_ptr=function(adjustedPtr){HEAPU32[this.ptr+16>>2]=adjustedPtr};this.get_adjusted_ptr=function(){return HEAPU32[this.ptr+16>>2]};this.get_exception_ptr=function(){var isPointer=___cxa_is_pointer_type(this.get_type());if(isPointer){return HEAPU32[this.excPtr>>2]}var adjusted=this.get_adjusted_ptr();if(adjusted!==0)return adjusted;return this.excPtr}}var exceptionLast=0;var uncaughtExceptionCount=0;function ___cxa_throw(ptr,type,destructor){var info=new ExceptionInfo(ptr);info.init(type,destructor);exceptionLast=ptr;uncaughtExceptionCount++;throw exceptionLast}var _abort=()=>{abort("")};var _emscripten_memcpy_big=(dest,src,num)=>HEAPU8.copyWithin(dest,src,src+num);var getHeapMax=()=>2147483648;var growMemory=size=>{var b=wasmMemory.buffer;var pages=size-b.byteLength+65535>>>16;try{wasmMemory.grow(pages);updateMemoryViews();return 1}catch(e){}};var _emscripten_resize_heap=requestedSize=>{var oldSize=HEAPU8.length;requestedSize>>>=0;var maxHeapSize=getHeapMax();if(requestedSize>maxHeapSize){return false}var alignUp=(x,multiple)=>x+(multiple-x%multiple)%multiple;for(var cutDown=1;cutDown<=4;cutDown*=2){var overGrownHeapSize=oldSize*(1+.2/cutDown);overGrownHeapSize=Math.min(overGrownHeapSize,requestedSize+100663296);var newSize=Math.min(maxHeapSize,alignUp(Math.max(requestedSize,overGrownHeapSize),65536));var replacement=growMemory(newSize);if(replacement){return true}}return false};var printCharBuffers=[null,[],[]];var UTF8Decoder=typeof TextDecoder!="undefined"?new TextDecoder("utf8"):undefined;var UTF8ArrayToString=(heapOrArray,idx,maxBytesToRead)=>{var endIdx=idx+maxBytesToRead;var endPtr=idx;while(heapOrArray[endPtr]&&!(endPtr>=endIdx))++endPtr;if(endPtr-idx>16&&heapOrArray.buffer&&UTF8Decoder){return UTF8Decoder.decode(heapOrArray.subarray(idx,endPtr))}var str="";while(idx<endPtr){var u0=heapOrArray[idx++];if(!(u0&128)){str+=String.fromCharCode(u0);continue}var u1=heapOrArray[idx++]&63;if((u0&224)==192){str+=String.fromCharCode((u0&31)<<6|u1);continue}var u2=heapOrArray[idx++]&63;if((u0&240)==224){u0=(u0&15)<<12|u1<<6|u2}else{u0=(u0&7)<<18|u1<<12|u2<<6|heapOrArray[idx++]&63}if(u0<65536){str+=String.fromCharCode(u0)}else{var ch=u0-65536;str+=String.fromCharCode(55296|ch>>10,56320|ch&1023)}}return str};var printChar=(stream,curr)=>{var buffer=printCharBuffers[stream];if(curr===0||curr===10){(stream===1?out:err)(UTF8ArrayToString(buffer,0));buffer.length=0}else{buffer.push(curr)}};var UTF8ToString=(ptr,maxBytesToRead)=>ptr?UTF8ArrayToString(HEAPU8,ptr,maxBytesToRead):"";var SYSCALLS={varargs:undefined,get(){SYSCALLS.varargs+=4;var ret=HEAP32[SYSCALLS.varargs-4>>2];return ret},getStr(ptr){var ret=UTF8ToString(ptr);return ret}};var _fd_write=(fd,iov,iovcnt,pnum)=>{var num=0;for(var i=0;i<iovcnt;i++){var ptr=HEAPU32[iov>>2];var len=HEAPU32[iov+4>>2];iov+=8;for(var j=0;j<len;j++){printChar(fd,HEAPU8[ptr+j])}num+=len}HEAPU32[pnum>>2]=num;return 0};var _proc_exit=code=>{EXITSTATUS=code;if(!keepRuntimeAlive()){if(Module["onExit"])Module["onExit"](code);ABORT=true}quit_(code,new ExitStatus(code))};var exitJS=(status,implicit)=>{EXITSTATUS=status;_proc_exit(status)};var handleException=e=>{if(e instanceof ExitStatus||e=="unwind"){return EXITSTATUS}quit_(1,e)};var lengthBytesUTF8=str=>{var len=0;for(var i=0;i<str.length;++i){var c=str.charCodeAt(i);if(c<=127){len++}else if(c<=2047){len+=2}else if(c>=55296&&c<=57343){len+=4;++i}else{len+=3}}return len};var stringToUTF8Array=(str,heap,outIdx,maxBytesToWrite)=>{if(!(maxBytesToWrite>0))return 0;var startIdx=outIdx;var endIdx=outIdx+maxBytesToWrite-1;for(var i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343){var u1=str.charCodeAt(++i);u=65536+((u&1023)<<10)|u1&1023}if(u<=127){if(outIdx>=endIdx)break;heap[outIdx++]=u}else if(u<=2047){if(outIdx+1>=endIdx)break;heap[outIdx++]=192|u>>6;heap[outIdx++]=128|u&63}else if(u<=65535){if(outIdx+2>=endIdx)break;heap[outIdx++]=224|u>>12;heap[outIdx++]=128|u>>6&63;heap[outIdx++]=128|u&63}else{if(outIdx+3>=endIdx)break;heap[outIdx++]=240|u>>18;heap[outIdx++]=128|u>>12&63;heap[outIdx++]=128|u>>6&63;heap[outIdx++]=128|u&63}}heap[outIdx]=0;return outIdx-startIdx};var stringToUTF8=(str,outPtr,maxBytesToWrite)=>stringToUTF8Array(str,HEAPU8,outPtr,maxBytesToWrite);var stringToUTF8OnStack=str=>{var size=lengthBytesUTF8(str)+1;var ret=stackAlloc(size);stringToUTF8(str,ret,size);return ret};var wasmImports={b:___cxa_throw,d:_abort,e:_emscripten_memcpy_big,c:_emscripten_resize_heap,a:_fd_write};var asm=createWasm();var ___wasm_call_ctors=function(){return(___wasm_call_ctors=Module["asm"]["g"]).apply(null,arguments)};var _allocation=Module["_allocation"]=function(){return(_allocation=Module["_allocation"]=Module["asm"]["i"]).apply(null,arguments)};var _getMatrixBufferPtr=Module["_getMatrixBufferPtr"]=function(){return(_getMatrixBufferPtr=Module["_getMatrixBufferPtr"]=Module["asm"]["j"]).apply(null,arguments)};var _getSRTPtr=Module["_getSRTPtr"]=function(){return(_getSRTPtr=Module["_getSRTPtr"]=Module["asm"]["k"]).apply(null,arguments)};var _getInfoPtr=Module["_getInfoPtr"]=function(){return(_getInfoPtr=Module["_getInfoPtr"]=Module["asm"]["l"]).apply(null,arguments)};var _getContinuedSRTPtr=Module["_getContinuedSRTPtr"]=function(){return(_getContinuedSRTPtr=Module["_getContinuedSRTPtr"]=Module["asm"]["m"]).apply(null,arguments)};var _printMatrix=Module["_printMatrix"]=function(){return(_printMatrix=Module["_printMatrix"]=Module["asm"]["n"]).apply(null,arguments)};var _updateAllMatrixContinueTransform=Module["_updateAllMatrixContinueTransform"]=function(){return(_updateAllMatrixContinueTransform=Module["_updateAllMatrixContinueTransform"]=Module["asm"]["o"]).apply(null,arguments)};var _main=Module["_main"]=function(){return(_main=Module["_main"]=Module["asm"]["p"]).apply(null,arguments)};var ___errno_location=function(){return(___errno_location=Module["asm"]["__errno_location"]).apply(null,arguments)};var stackAlloc=function(){return(stackAlloc=Module["asm"]["q"]).apply(null,arguments)};var ___cxa_is_pointer_type=function(){return(___cxa_is_pointer_type=Module["asm"]["r"]).apply(null,arguments)};var calledRun;dependenciesFulfilled=function runCaller(){if(!calledRun)run();if(!calledRun)dependenciesFulfilled=runCaller};function callMain(args=[]){var entryFunction=_main;args.unshift(thisProgram);var argc=args.length;var argv=stackAlloc((argc+1)*4);var argv_ptr=argv>>2;args.forEach((arg=>{HEAP32[argv_ptr++]=stringToUTF8OnStack(arg)}));HEAP32[argv_ptr]=0;try{var ret=entryFunction(argc,argv);exitJS(ret,true);return ret}catch(e){return handleException(e)}}function run(args=arguments_){if(runDependencies>0){return}preRun();if(runDependencies>0){return}function doRun(){if(calledRun)return;calledRun=true;Module["calledRun"]=true;if(ABORT)return;initRuntime();preMain();if(Module["onRuntimeInitialized"])Module["onRuntimeInitialized"]();if(shouldRunNow)callMain(args);postRun()}if(Module["setStatus"]){Module["setStatus"]("Running...");setTimeout((function(){setTimeout((function(){Module["setStatus"]("")}),1);doRun()}),1)}else{doRun()}}if(Module["preInit"]){if(typeof Module["preInit"]=="function")Module["preInit"]=[Module["preInit"]];while(Module["preInit"].length>0){Module["preInit"].pop()()}}var shouldRunNow=true;if(Module["noInitialRun"])shouldRunNow=false;run();

if (!Module['ENVIRONMENT_IS_PTHREAD']) {
    // console.log("is main");
    window['wasmMatrix'] = Module;
}
        `,Si=class{static async init(i){await new Promise(e=>{const t=document.createElement("script");t.async=!0,t.type="text/javascript",t.src=URL.createObjectURL(new Blob([Zf])),document.head.appendChild(t),t.onload=()=>{let r=()=>{this.wasm=window.wasmMatrix,this.wasm&&this.wasm.calledRun?e(!0):setTimeout(r,20)};r()}}),this.allocMatrix(i)}static allocMatrix(i){i>H.maxCount&&console.error(`The maximum allocation size is exceeded! current:${i}, limit:${H.maxCount}`),this.wasm._allocation(i),this.matrixBufferPtr=this.wasm._getMatrixBufferPtr(),this.matrixSRTBufferPtr=this.wasm._getSRTPtr(),this.matrixStateBufferPtr=this.wasm._getInfoPtr(),this.matrixContinuedSRTBufferPtr=this.wasm._getContinuedSRTPtr(),this.matrixBuffer=new Float32Array(this.wasm.HEAPF32.buffer,this.matrixBufferPtr,16*i),this.matrixSRTBuffer=new Float32Array(this.wasm.HEAPF32.buffer,this.matrixSRTBufferPtr,3*3*i),this.matrixContinuedSRTBuffer=new Float32Array(this.wasm.HEAPF32.buffer,this.matrixContinuedSRTBufferPtr,3*3*i),this.matrixStateBuffer=new Int32Array(this.wasm.HEAP32.buffer,this.matrixStateBufferPtr,Si.stateStruct*i),H.allocMatrix(i)}static updateAllContinueTransform(i,e,t){this.wasm._updateAllMatrixContinueTransform(i,e,t)}static setParent(i,e,t){this.matrixStateBuffer[i*Si.stateStruct+2]=e>=0?e:-1,this.matrixStateBuffer[i*Si.stateStruct+3]=t}static setTranslate(i,e,t,r){this.matrixSRTBuffer[i*9+6]=e,this.matrixSRTBuffer[i*9+7]=t,this.matrixSRTBuffer[i*9+8]=r}static setRotation(i,e,t,r){this.matrixSRTBuffer[i*9+3]=e%360,this.matrixSRTBuffer[i*9+4]=t%360,this.matrixSRTBuffer[i*9+5]=r%360}static setScale(i,e,t,r){this.matrixSRTBuffer[i*9+0]=e,this.matrixSRTBuffer[i*9+1]=t,this.matrixSRTBuffer[i*9+2]=r}static setContinueTranslate(i,e,t,r){(e!=0||t!=0||r!=0)&&(this.matrixContinuedSRTBuffer[i*9+6]=e,this.matrixContinuedSRTBuffer[i*9+7]=t,this.matrixContinuedSRTBuffer[i*9+8]=r,this.matrixStateBuffer[i*Si.stateStruct+1]=1)}static setContinueRotation(i,e,t,r){(e!=0||t!=0||r!=0)&&(this.matrixContinuedSRTBuffer[i*9+3]=e,this.matrixContinuedSRTBuffer[i*9+4]=t,this.matrixContinuedSRTBuffer[i*9+5]=r,this.matrixStateBuffer[i*Si.stateStruct+1]=1)}static setContinueScale(i,e,t,r){(e!=0||t!=0||r!=0)&&(this.matrixContinuedSRTBuffer[i*9+0]=e,this.matrixContinuedSRTBuffer[i*9+1]=t,this.matrixContinuedSRTBuffer[i*9+2]=r,this.matrixStateBuffer[i*Si.stateStruct+1]=1)}};let te=Si;n(te,"matrixBuffer"),n(te,"matrixSRTBuffer"),n(te,"matrixContinuedSRTBuffer"),n(te,"matrixStateBuffer"),n(te,"matrixBufferPtr"),n(te,"matrixSRTBufferPtr"),n(te,"matrixContinuedSRTBufferPtr"),n(te,"matrixStateBufferPtr"),n(te,"wasm"),n(te,"stateStruct",4);class vt{}n(vt,"AXIS_ANGLE","axisAngle"),n(vt,"EULER_ANGLES","eulerAngles"),n(vt,"QUATERNION","quaternion");const dt=class{constructor(i=0,e=0,t=0,r=1){n(this,"x",0),n(this,"y",0),n(this,"z",0),n(this,"w",1),this.x=i,this.y=e,this.z=t,this.w=r}static identity(){return dt._zero}static quaternionToMatrix(i,e){let t=i.x*2,r=i.y*2,a=i.z*2,s=i.x*t,o=i.y*r,l=i.z*a,h=i.x*r,u=i.x*a,c=i.y*a,d=i.w*t,g=i.w*r,m=i.w*a;e.rawData[0]=1-(o+l),e.rawData[1]=h+m,e.rawData[2]=u-g,e.rawData[3]=0,e.rawData[4]=h-m,e.rawData[5]=1-(s+l),e.rawData[6]=c+d,e.rawData[7]=0,e.rawData[8]=u+g,e.rawData[9]=c-d,e.rawData[10]=1-(s+o),e.rawData[11]=0,e.rawData[12]=0,e.rawData[13]=0,e.rawData[14]=0,e.rawData[15]=1}get magnitude(){return Math.sqrt(this.w*this.w+this.x*this.x+this.y*this.y+this.z*this.z)}set(i=0,e=0,t=0,r=1){this.x=i,this.y=e,this.z=t,this.w=r}divide(i){return i instanceof dt?new dt(this.x/i.x,this.y/i.y,this.z/i.z):(this.x=this.x/i,this.y=this.y/i,this.z=this.z/i,this)}setFromArray(i){return this.x=i[0],this.y=i[1],this.z=i[2],this.w=i[3],this}multiply(i,e){var t=i.w,r=i.x,a=i.y,s=i.z,o=e.w,l=e.x,h=e.y,u=e.z;this.w=t*o-r*l-a*h-s*u,this.x=t*l+r*o+a*u-s*h,this.y=t*h-r*u+a*o+s*l,this.z=t*u+r*h-a*l+s*o}multiplyVector(i,e=null){e||(e=new dt);var t=i.x,r=i.y,a=i.z;return e.w=-this.x*t-this.y*r-this.z*a,e.x=this.w*t+this.y*a-this.z*r,e.y=this.w*r-this.x*a+this.z*t,e.z=this.w*a+this.x*r-this.y*t,e}fromAxisAngle(i,e){e*=Math.PI/180;var t=e*.5,r=Math.sin(t);this.w=Math.cos(t),this.x=i.x*r,this.y=i.y*r,this.z=i.z*r,this.normalize()}toAxisAngle(i){var e=this.x*this.x+this.y*this.y+this.z*this.z,t=0;return e>0?(t=2*Math.acos(this.w),e=1/Math.sqrt(e),i.x=this.x*e,i.y=this.y*e,i.z=this.z*e):(t=0,i.x=1,i.y=0,i.z=0),t}slerp(i,e,t){var r=i.w,a=i.x,s=i.y,o=i.z,l=e.w,h=e.x,u=e.y,c=e.z,d=r*l+a*h+s*u+o*c;if(d<0&&(d=-d,l=-l,h=-h,u=-u,c=-c),d<.95){var g=Math.acos(d),m=1/Math.sin(g),A=Math.sin(g*(1-t))*m,v=Math.sin(g*t)*m;this.w=r*A+l*v,this.x=a*A+h*v,this.y=s*A+u*v,this.z=o*A+c*v}else{this.w=r+t*(l-r),this.x=a+t*(h-a),this.y=s+t*(u-s),this.z=o+t*(c-o);var y=1/Math.sqrt(this.w*this.w+this.x*this.x+this.y*this.y+this.z*this.z);this.w*=y,this.x*=y,this.y*=y,this.z*=y}}lerp(i,e,t){var r=i.w,a=i.x,s=i.y,o=i.z,l=e.w,h=e.x,u=e.y,c=e.z,d;r*l+a*h+s*u+o*c<0&&(l=-l,h=-h,u=-u,c=-c),this.w=r+t*(l-r),this.x=a+t*(h-a),this.y=s+t*(u-s),this.z=o+t*(c-o),d=1/Math.sqrt(this.w*this.w+this.x*this.x+this.y*this.y+this.z*this.z),this.w*=d,this.x*=d,this.y*=d,this.z*=d}fromEulerAngles(i,e,t){i*=_e,e*=_e,t*=_e;var r=i*.5,a=e*.5,s=t*.5,o=Math.cos(r),l=Math.sin(r),h=Math.cos(a),u=Math.sin(a),c=Math.cos(s),d=Math.sin(s);return this.w=o*h*c+l*u*d,this.x=l*h*c-o*u*d,this.y=o*u*c+l*h*d,this.z=o*h*d-l*u*c,this}setFromRotationMatrix(i){const e=i.rawData,t=e[0],r=e[4],a=e[8],s=e[1],o=e[5],l=e[9],h=e[2],u=e[6],c=e[10],d=t+o+c;if(d>0){const g=.5/Math.sqrt(d+1);this.w=.25/g,this.x=(u-l)*g,this.y=(a-h)*g,this.z=(s-r)*g}else if(t>o&&t>c){const g=2*Math.sqrt(1+t-o-c);this.w=(u-l)/g,this.x=.25*g,this.y=(r+s)/g,this.z=(a+h)/g}else if(o>c){const g=2*Math.sqrt(1+o-t-c);this.w=(a-h)/g,this.x=(r+s)/g,this.y=.25*g,this.z=(l+u)/g}else{const g=2*Math.sqrt(1+c-t-o);this.w=(s-r)/g,this.x=(a+h)/g,this.y=(l+u)/g,this.z=.25*g}return this}getEulerAngles(i){var e,t,r,a,s,o,l,h;return i||(i=new p),a=this.x,s=this.y,o=this.z,l=this.w,h=2*(l*s-a*o),h<=-.99999?(e=2*Math.atan2(a,l),t=-Math.PI/2,r=0):h>=.99999?(e=2*Math.atan2(a,l),t=Math.PI/2,r=0):(e=Math.atan2(2*(l*a+s*o),1-2*(a*a+s*s)),t=Math.asin(h),r=Math.atan2(2*(l*o+a*s),1-2*(s*s+o*o))),i.set(e,t,r).scaleBy(qi)}normalize(i=1){var e=i/Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w);this.x*=e,this.y*=e,this.z*=e,this.w*=e}toString(){return"{x:"+this.x+" y:"+this.y+" z:"+this.z+" w:"+this.w+"}"}fromMatrix(i){var e=i.decompose(vt.QUATERNION)[1];this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w}inverse(i=null){i||(i=new dt);var e=this.w*this.w+this.x*this.x+this.y*this.y+this.z*this.z;if(e>0){var t=1/e;i.w=this.w*t,i.x=-this.x*t,i.y=-this.y*t,i.z=-this.z*t}return i}clone(){return new dt(this.x,this.y,this.z,this.w)}transformVector(i,e=null){var t,r,a,s,o=i.x,l=i.y,h=i.z;return e||(e=new p),s=-this.x*o-this.y*l-this.z*h,t=this.w*o+this.y*h-this.z*l,r=this.w*l-this.x*h+this.z*o,a=this.w*h+this.x*l-this.y*o,e.x=-s*this.x+t*this.w-r*this.z+a*this.y,e.y=-s*this.y+t*this.z+r*this.w-a*this.x,e.z=-s*this.z-t*this.y+r*this.x+a*this.w,e}copyFrom(i){var e=this;return e.x=i.x,e.y=i.y,e.z=i.z,e.w=i.w,this}mul(i,e,t){let r=t||new dt;return r.x=i.w*e.x+i.x*e.w+i.y*e.z-i.z*e.y,r.y=i.w*e.y+i.y*e.w+i.z*e.x-i.x*e.z,r.z=i.w*e.z+i.z*e.w+i.x*e.y-i.y*e.x,r.w=i.w*e.w-i.x*e.x-i.y*e.y-i.z*e.z,r}clampf(i,e,t){if(e>t){var r=e;e=t,t=r}return i<e?e:i<t?i:t}};let K=dt;n(K,"HELP_0",new dt(0,0,0,1)),n(K,"HELP_1",new dt(0,0,0,1)),n(K,"HELP_2",new dt(0,0,0,1)),n(K,"_zero",new dt(0,0,0,1)),n(K,"CALCULATION_QUATERNION",new dt);function $f(i,e,t){let r=i.x*2,a=i.y*2,s=i.z*2,o=i.x*r,l=i.y*a,h=i.z*s,u=i.x*a,c=i.x*s,d=i.y*s,g=i.w*r,m=i.w*a,A=i.w*s,v=t||new p;return v.x=(1-(l+h))*e.x+(u-A)*e.y+(c+m)*e.z,v.y=(u+A)*e.x+(1-(o+h))*e.y+(d-g)*e.z,v.z=(c-m)*e.x+(d+g)*e.y+(1-(o+l))*e.z,v}class Pr{constructor(e=0){n(this,"_x",0),n(this,"_y",0),n(this,"_z",0),n(this,"_w",0),this.seed=e}get seed(){return this._x}set seed(e){this._x=e,this._y=this._x*1812433253+1,this._z=this._y*1812433253+1,this._w=this._z*1812433253+1}static getFloatFromInt(e){return Math.floor((e&8388607)*(1/8388607))}static getByteFromInt(e){return e>>23-8}clone(){let e=new Pr;return e._x=this._x,e._y=this._y,e._z=this._z,e._w=this._w,e}get(){let e=this._x^this._x<<11;return this._x=this._y,this._y=this._z,this._z=this._w,this._w=this._w^this._w>>19^(e^e>>8)}getFloat(){return fl(this.get())}getSignedFloat(){return this.getFloat()*2-1}}let qi=180/Math.PI,_e=Math.PI/180,ed=2147483647,td=-2147483647;function J(i,e,t){return Math.max(e,Math.min(t,i))}class et{static gaussFunction(e,t,r,a){let s=Math.pow(e-r,2),o=2*Math.pow(a,2),l=-1*(s/o),h=Math.pow(Math.E,l);return Math.round(h*t)}static computeGaussian(e,t){return 1/Math.sqrt(2*Math.PI*t)*Math.exp(-(e*e)/(2*t*t))}static gaussCoef(e){e<.5&&(e=.5);let t=Math.exp(.726*.726)/e,r=Math.exp(-t),a=Math.exp(-2*t),s=(1-r)*(1-r)/(1+2*t*r-a),o=s,l=s*(t-1)*r,h=s*(t+1)*r,u=-s*a,c=2*r,d=-a,g=(o+l)/(1-c-d),m=(h+u)/(1-c-d);return new Float32Array([o,l,h,u,c,d,g,m])}static clampf(e,t,r){if(t>r){let a=t;t=r,r=a}return e<t?t:e<r?e:r}static normalizeAngle(e){for(;e>180;)e-=360;for(;e<-180;)e+=360;return e}static fract(e){return e-Math.floor(e)}static getRandDirXZ(e){let t=e*Math.random(),r=360*Math.random()*_e,a=Math.cos(r)*t,s=Math.sin(r)*t;return{x:a,z:s}}static getRandDirXYZ(e){let t=e*Math.random(),r=360*Math.random()*_e,a=Math.cos(r)*t,s=Math.tan(r)*t,o=Math.sin(r)*t;return new p(a,s,o)}static getCycleXYZ(e){let t=e*Math.random(),r=360*Math.random()*_e,a=Math.cos(r)*t,s=e*Math.random()-e*.5,o=Math.sin(r)*t;return new p(a,s,o)}static angle(e,t){let r=$.HELP_0,a=$.HELP_1;return r.set(e.x,e.z),a.set(t.x,t.z),Math.acos((r.x*a.x+r.y*a.y)/(r.abs()*a.abs()))}static angle_360(e,t){let r=p.HELP_0;return e.crossProduct(t,r),r.z>0?et.angle(e,t):360-et.angle(e,t)}getRotationY(e){return et.normalizeAngle(Math.atan2(e.z,e.x)*qi)}static fromToRotation(e,t,r=null){r||(r=new K);let a=H.help_matrix_2;return H.fromToRotation(e,t,a),r.fromMatrix(a),r}static getEularDir_yUp(e){let t=K.HELP_0;return t.fromEulerAngles(0,e,0),t.transformVector(p.Z_AXIS,p.HELP_5),p.HELP_5}static transformVector(e,t,r=null){r||(r=new p);let a=e.rawData,s=a[0],o=a[1],l=a[2],h=a[3],u=a[4],c=a[5],d=a[6],g=a[7],m=a[8],A=a[9],v=a[10],y=a[11],C=a[12],S=a[13],T=a[14],D=a[15],M=t.x,P=t.y,R=t.z;return r.x=s*M+u*P+m*R+C,r.y=o*M+c*P+A*R+S,r.z=l*M+d*P+v*R+T,r.w=h*M+g*P+y*R+D,r}}let Ii=function(i,e,t){return i*(1-t)+e*t};function id(i,e,t){let r=new p,a=i.x,s=i.y,o=i.z,l=i.w,h=e.x,u=e.y,c=e.z,d=e.w;return r.x=(h-a)*t+a,r.y=(u-s)*t+s,r.z=(c-o)*t+o,r.w=(d-l)*t+l,r}function rd(i,e,t){let r=new z;return r.r=(1-t)*i.r+t*e.r,r.g=(1-t)*i.g+t*e.g,r.b=(1-t)*i.b+t*e.b,r.a=(1-t)*i.a+t*e.a,r}function ad(i,e,t){return i+((e-i)*t>>8)&255}let Ps=function(i,e,t){let r=t-e;return Math.floor(i/r)%2==0?i%r+e:t-i%r+e},Rs=function(i,e,t){let r=t-e;return i%r+e},sd=function(i,e){let t=0;for(let r in i)r==e&&t++;return t};class nd{constructor(){n(this,"x",0),n(this,"y",0),n(this,"z",0),n(this,"w",0),n(this,"randSeedList"),this.randSeedList=[]}reset(){this.x=Math.random()*1,this.y=Math.random()*1,this.z=Math.random()*1,this.w=Math.random()*1,this.randSeedList.length=0;for(let e=0;e<20;e++)this.randSeedList.push(Math.random()*1)}}function tt(i,e){return i instanceof p&&e instanceof p||i instanceof K&&e instanceof K?i.x*e.x+i.y*e.y+i.z*e.z:i.x*e.x+i.y*e.y}function Ls(i,e){return new p(i.x*e.x,i.y*e.y,i.z*e.z)}function ul(i){return Math.sqrt(i)}function Us(i){return ul(tt(i,i))}function cl(i,e){if(Us(i)>p.EPSILON)return i.divide(Us(i));if(i instanceof $)return new $;if(i instanceof p)return new p;if(i instanceof K)return new K}function fl(i){return(i&8388607)*(1/8388607)}function Ki(i){return i.getFloat()}function qe(i,e,t){let r=i.getFloat();return r=e*r+(1-r)*t,r}function od(i,e,t){let r;if(e<t){r=t-e;let a=i.get()%r;return a+=e,a}else if(e>t){r=e-t;let a=i.get()%r;return a=e-a,a}else return e}function Pa(i){let e=qe(i,-1,1),t=qe(i,0,2*Math.PI),r=Math.sqrt(1-e*e),a=r*Math.cos(t),s=r*Math.sin(t);return new p(a,s,e)}function dl(i){let e=qe(i,0,2*Math.PI),t=Math.cos(e),r=Math.sin(e);return new $(t,r)}function ld(i){let e=new K;return e.x=qe(i,-1,1),e.y=qe(i,-1,1),e.z=qe(i,-1,1),e.w=qe(i,-1,1),e=cl(e),tt(e,K.identity())<0?-e:e}function hd(i){const e=2*Math.PI;let t=qe(i,0,1),r=qe(i,0,e),a=qe(i,0,e),s=Math.sqrt(1-t),o=Math.sqrt(t),l=new K(s*Math.sin(r),s*Math.cos(r),o*Math.sin(a),o*Math.cos(a));return tt(l,K.identity())<0?-l:l}function ud(i,e){return new p(qe(i,-e.x,e.x),qe(i,-e.y,e.y),qe(i,-e.z,e.z))}function gl(i){let e=Pa(i);return e.scaleBy(Math.pow(Ki(i),1/3)),e}function cd(i,e){return Ls(gl(i),e)}function fd(i,e,t){let r=Pa(i),a=Math.pow(qe(i,0,1),1/3);return r.scaleBy(e+(t-e)*a),r}function dd(i){let e=dl(i);return e.multiply(Math.pow(qe(i,0,1),1/2),e),e}function gd(i,e,t){let r=Ls(Pa(i),e),a=Math.pow(qe(i,t,1),1/3);return r.scaleBy(a),r}function pd(i){let e=i.getFloat(),t=i.getFloat();e+t>1&&(e=1-e,t=1-t);let r=1-e-t;return new p(e,t,r)}function md(i){return i/360*2*Math.PI}function Ad(i){return 180*i/Math.PI}function _d(i){return Math.sin(i)}function vd(i){return Math.cos(i)}f.randomSeed=4919;function xd(){return++f.randomSeed}function yd(i,e,t){let r=i[e],a=i[t];i[e]=a,i[t]=r}function pl(i){return Math.floor(i)}function Os(i){return pl(i+.5)}function Cd(i){return i=Math.max(i,0),i=Math.min(i,1),Os(i*65535)}function bd(i){return i=Math.max(i,0),i=Math.min(i,1),Os(i*255)}function ml(i){return Math.abs(i)==0?i:1/Math.sqrt(i)}function wd(i){let e=Ns(i);return i.scaleBy(ml(e))}function Sd(i,e){return i.crossProduct(e)}function Ns(i){return tt(i,i)}function Id(i){let e=new Pr(i);return Ki(e)}function Ed(i,e){let t=new Pr(e);i.x=Ki(t),i.y=Ki(t),i.z=Ki(t)}function Bd(i,e,t){return i<e?t:i>t?e:i}function Fs(i,e){return i-Math.floor(i/e)*e}const Td=1e-6,k=class{constructor(i=!1){if(n(this,"index",0),n(this,"offset",0),n(this,"rawData"),n(this,"_position"),k.useCount>=k.allocCount){let e=k.allocCount+k.allocOnceCount;te.allocMatrix(e)}this.index=k.useCount,this.offset=k.wasmMatrixPtr+this.index*k.blockBytes,k.dynamicGlobalMatrixRef[this.index]=this,k.useCount++,this.rawData=new Float32Array(k.dynamicMatrixBytes.buffer,this.offset,16),this._position=new p,this.identity()}static allocMatrix(i){this.allocCount=i,k.dynamicMatrixBytes=te.matrixBuffer,k.buffer=k.dynamicMatrixBytes.buffer,k.wasmMatrixPtr=te.matrixBufferPtr,this.dynamicGlobalMatrixRef||(this.dynamicGlobalMatrixRef=[]),this.dynamicGlobalMatrixRef.forEach(e=>{e.offset=k.wasmMatrixPtr+e.index*k.blockBytes,e.rawData=new Float32Array(k.dynamicMatrixBytes.buffer,e.offset,16)}),k.help_matrix_0||(k.help_matrix_0=new k),k.help_matrix_1||(k.help_matrix_1=new k),k.help_matrix_2||(k.help_matrix_2=new k),k.helpMatrix||(k.helpMatrix=new k),k.helpMatrix2||(k.helpMatrix2=new k),k._getEulerMatrix||(k._getEulerMatrix=new k),k._getEulerMatrix.identity()}static fromToRotation(i,e,t){return t||(t=new k),t.transformDir(i,e),t}static getAxisRotation(i,e,t,r){let a=new k,s=r*(Math.PI/180),o=Math.cos(s),l=Math.sin(s),h=1-o,u,c;return a.rawData[0]=o+i*i*h,a.rawData[5]=o+e*e*h,a.rawData[10]=o+t*t*h,u=i*e*h,c=t*l,a.rawData[1]=u+c,a.rawData[4]=u-c,u=i*t*h,c=e*l,a.rawData[8]=u+c,a.rawData[2]=u-c,u=e*t*h,c=i*l,a.rawData[9]=u-c,a.rawData[6]=u+c,a}static sanitizeEuler(i){k.makePositive(i)}static makePositive(i){let e=-1e-4,t=Math.PI*2-1e-4;i.x<e?i.x+=2*Math.PI:i.x>t&&(i.x-=2*Math.PI),i.y<e?i.y+=2*Math.PI:i.y>t&&(i.y-=2*Math.PI),i.z<e?i.z+=2*Math.PI:i.z>t&&(i.z-=2*Math.PI)}static matrixToEuler(i,e){return i.get(1,2)<.999?i.get(1,2)>-.999?(e.x=Math.asin(-i.get(1,2)),e.y=Math.atan2(i.get(0,2),i.get(2,2)),e.z=Math.atan2(i.get(1,0),i.get(1,1)),k.sanitizeEuler(e),!0):(e.x=Math.PI*.5,e.y=Math.atan2(i.get(0,1),i.get(0,0)),e.z=0,k.sanitizeEuler(e),!1):(e.x=-Math.PI*.5,e.y=Math.atan2(-i.get(0,1),i.get(0,0)),e.z=0,k.sanitizeEuler(e),!1)}static matrixMultiply(i,e,t){k.wasm.Matrix_Multiply(i.index,e.index,t.index)}static matrixAppend(i,e,t){k.wasm.Matrix_Append(i.index,e.index,t.index)}static matrixRotateY(i,e){k.wasm.Matrix_Append(i,e.index)}static matrixRotate(i,e,t){k.wasm.Matrix_Rotate(i,e,t.index)}lookAt(i,e,t=p.Y_AXIS){let r=this.rawData,a=e.subtract(i,p.HELP_0);a.length<1e-4&&(a.z=1),a.normalize();let s=t.crossProduct(a,p.HELP_1);s.length<1e-4&&(Math.abs(t.z)>.9999?a.x+=1e-4:a.z+=1e-4,a.normalize()),s=t.crossProduct(a,s).normalize();let o=a.crossProduct(s,p.HELP_2).normalize();r[0]=s.x,r[1]=o.x,r[2]=a.x,r[3]=0,r[4]=s.y,r[5]=o.y,r[6]=a.y,r[7]=0,r[8]=s.z,r[9]=o.z,r[10]=a.z,r[11]=0,r[12]=-s.dotProduct(i),r[13]=-o.dotProduct(i),r[14]=-a.dotProduct(i),r[15]=1}multiply(i){let e=this.rawData,t=i.rawData,r=k.float32Array;r[0]=e[0]*t[0]+e[1]*t[4]+e[2]*t[8]+e[3]*t[12],r[1]=e[0]*t[1]+e[1]*t[5]+e[2]*t[9]+e[3]*t[13],r[2]=e[0]*t[2]+e[1]*t[6]+e[2]*t[10]+e[3]*t[14],r[3]=e[0]*t[3]+e[1]*t[7]+e[2]*t[11]+e[3]*t[15],r[4]=e[4]*t[0]+e[5]*t[4]+e[6]*t[8]+e[7]*t[12],r[5]=e[4]*t[1]+e[5]*t[5]+e[6]*t[9]+e[7]*t[13],r[6]=e[4]*t[2]+e[5]*t[6]+e[6]*t[10]+e[7]*t[14],r[7]=e[4]*t[3]+e[5]*t[7]+e[6]*t[11]+e[7]*t[15],r[8]=e[8]*t[0]+e[9]*t[4]+e[10]*t[8]+e[11]*t[12],r[9]=e[8]*t[1]+e[9]*t[5]+e[10]*t[9]+e[11]*t[13],r[10]=e[8]*t[2]+e[9]*t[6]+e[10]*t[10]+e[11]*t[14],r[11]=e[8]*t[3]+e[9]*t[7]+e[10]*t[11]+e[11]*t[15],r[12]=e[12]*t[0]+e[13]*t[4]+e[14]*t[8]+e[15]*t[12],r[13]=e[12]*t[1]+e[13]*t[5]+e[14]*t[9]+e[15]*t[13],r[14]=e[12]*t[2]+e[13]*t[6]+e[14]*t[10]+e[15]*t[14],r[15]=e[12]*t[3]+e[13]*t[7]+e[14]*t[11]+e[15]*t[15],e[0]=r[0],e[1]=r[1],e[2]=r[2],e[3]=r[3],e[4]=r[4],e[5]=r[5],e[6]=r[6],e[7]=r[7],e[8]=r[8],e[9]=r[9],e[10]=r[10],e[11]=r[11],e[12]=r[12],e[13]=r[13],e[14]=r[14],e[15]=r[15]}multiplyMatrices(i,e){const t=i.rawData,r=e.rawData,a=this.rawData,s=t[0],o=t[4],l=t[8],h=t[12],u=t[1],c=t[5],d=t[9],g=t[13],m=t[2],A=t[6],v=t[10],y=t[14],C=t[3],S=t[7],T=t[11],D=t[15],M=r[0],P=r[4],R=r[8],U=r[12],E=r[1],F=r[5],V=r[9],Y=r[13],j=r[2],oe=r[6],pe=r[10],we=r[14],Xe=r[3],ke=r[7],ce=r[11],me=r[15];return a[0]=s*M+o*E+l*j+h*Xe,a[4]=s*P+o*F+l*oe+h*ke,a[8]=s*R+o*V+l*pe+h*ce,a[12]=s*U+o*Y+l*we+h*me,a[1]=u*M+c*E+d*j+g*Xe,a[5]=u*P+c*F+d*oe+g*ke,a[9]=u*R+c*V+d*pe+g*ce,a[13]=u*U+c*Y+d*we+g*me,a[2]=m*M+A*E+v*j+y*Xe,a[6]=m*P+A*F+v*oe+y*ke,a[10]=m*R+A*V+v*pe+y*ce,a[14]=m*U+A*Y+v*we+y*me,a[3]=C*M+S*E+T*j+D*Xe,a[7]=C*P+S*F+T*oe+D*ke,a[11]=C*R+S*V+T*pe+D*ce,a[15]=C*U+S*Y+T*we+D*me,this}multiplyPoint3(i,e){e||(e=new p);let t=this.rawData;return e.x=t[0]*i.x+t[4]*i.y+t[8]*i.z+t[12],e.y=t[1]*i.x+t[5]*i.y+t[9]*i.z+t[13],e.z=t[2]*i.x+t[6]*i.y+t[10]*i.z+t[14],e}multiplyVector4(i,e){e||(e=new p);let t=this.rawData,r=i.x,a=i.y,s=i.z,o=t[3]*r+t[7]*a+t[11]*s+t[15];return o=o||1,e.x=(t[0]*r+t[4]*a+t[8]*s+t[12])/o,e.y=(t[1]*r+t[5]*a+t[9]*s+t[13])/o,e.z=(t[2]*r+t[6]*a+t[10]*s+t[14])/o,e.w=1,e}transformVector4(i,e){let t=this.rawData;e||(e=new p);let r=i.x,a=i.y,s=i.z,o=i.w;return e.x=r*t[0]+a*t[4]+s*t[8]+o*t[12],e.y=r*t[1]+a*t[5]+s*t[9]+o*t[13],e.z=r*t[2]+a*t[6]+s*t[10]+o*t[14],e.w=r*t[3]+a*t[7]+s*t[11]+o*t[15],e}perspectiveMultiplyPoint3(i,e){let t=p.HELP_2,r,a=this.rawData;if(t.x=a[0]*i.x+a[4]*i.y+a[8]*i.z+a[12],t.y=a[1]*i.x+a[5]*i.y+a[9]*i.z+a[13],t.z=a[2]*i.x+a[6]*i.y+a[10]*i.z+a[14],r=a[3]*i.x+a[7]*i.y+a[11]*i.z+a[15],Math.abs(r)>1e-7){let s=1/r;return e.x=t.x*s,e.y=t.y*s,e.z=t.z*s,!0}else return e.x=0,e.y=0,e.z=0,!1}perspective(i,e,t,r){let a=this.rawData,s=i*_e/2,o=Math.cos(s)/Math.sin(s);a[0]=-o/e,a[1]=0,a[2]=0,a[3]=0,a[4]=0,a[5]=o,a[6]=0,a[7]=0,a[8]=0,a[9]=0,a[10]=r/(r-t),a[11]=1,a[12]=0,a[13]=0,a[14]=-t*r/(r-t),a[15]=0}perspective3(i,e,t,r){var a=Math.tan(i*Math.PI/360)*t,s=a*e;this.frustum(-s,s,-a,a,t,r)}frustum(i,e,t,r,a,s){var o=this.rawData;o[0]=-2*a/(e-i),o[1]=0,o[2]=0,o[3]=0,o[4]=0,o[5]=2*a/(r-t),o[6]=0,o[7]=0,o[8]=(e+i)/(e-i),o[9]=(r+t)/(r-t),o[10]=s/(s-a),o[11]=1,o[12]=0,o[13]=0,o[14]=-s*a/(s-a),o[15]=0}ortho(i,e,t,r){let a=this.rawData;return a[0]=2/i,a[1]=0,a[2]=0,a[3]=0,a[4]=0,a[5]=2/e,a[6]=0,a[7]=0,a[8]=0,a[9]=0,a[10]=1/(r-t),a[11]=0,a[12]=0,a[13]=0,a[14]=t/(t-r),a[15]=1,this}orthoZO(i,e,t,r,a,s){let o=this.rawData,l=1/(i-e),h=1/(t-r),u=1/(a-s);return o[0]=-2*l,o[1]=0,o[2]=0,o[3]=0,o[4]=0,o[5]=-2*h,o[6]=0,o[7]=0,o[8]=0,o[9]=0,o[10]=u,o[11]=0,o[12]=(i+e)*l,o[13]=(r+t)*h,o[14]=a*u,o[15]=1,this}orthoOffCenter(i,e,t,r,a,s){let o=this.rawData;o[0]=2/(e-i),o[1]=0,o[2]=0,o[3]=0,o[4]=0,o[5]=2/(r-t),o[6]=0,o[7]=0,o[8]=0,o[9]=0,o[10]=1/(s-a),o[11]=0,o[12]=(i+e)/(i-e),o[13]=(r+t)/(t-r),o[14]=a/(a-s),o[15]=1}transformDir(i,e){let t=this.rawData,r=1e-6,a=p.ZERO;e.crossProduct(i,a);let s=e.dotProduct(i);if(s>1-r)this.identity();else{let o,l,h,u,c,d=a.dotProduct(a),g=(1-s)/d;o=g*a.x,l=g*a.z,h=o*a.y,u=o*a.z,c=l*a.y,t[0]=s+o*a.x,t[1]=h-a.z,t[2]=u+a.y,t[4]=h+a.z,t[5]=s+g*a.y*a.y,t[6]=c-a.x,t[8]=u-a.y,t[9]=c+a.x,t[10]=s+l*a.z,t[3]=0,t[7]=0,t[11]=0,t[15]=1}}append(i){let e=this.rawData,t=e[0],r=e[4],a=e[8],s=e[12],o=e[1],l=e[5],h=e[9],u=e[13],c=e[2],d=e[6],g=e[10],m=e[14],A=e[3],v=e[7],y=e[11],C=e[15];e[0]=t*i.rawData[0]+o*i.rawData[4]+c*i.rawData[8]+A*i.rawData[12],e[1]=t*i.rawData[1]+o*i.rawData[5]+c*i.rawData[9]+A*i.rawData[13],e[2]=t*i.rawData[2]+o*i.rawData[6]+c*i.rawData[10]+A*i.rawData[14],e[3]=t*i.rawData[3]+o*i.rawData[7]+c*i.rawData[11]+A*i.rawData[15],e[4]=r*i.rawData[0]+l*i.rawData[4]+d*i.rawData[8]+v*i.rawData[12],e[5]=r*i.rawData[1]+l*i.rawData[5]+d*i.rawData[9]+v*i.rawData[13],e[6]=r*i.rawData[2]+l*i.rawData[6]+d*i.rawData[10]+v*i.rawData[14],e[7]=r*i.rawData[3]+l*i.rawData[7]+d*i.rawData[11]+v*i.rawData[15],e[8]=a*i.rawData[0]+h*i.rawData[4]+g*i.rawData[8]+y*i.rawData[12],e[9]=a*i.rawData[1]+h*i.rawData[5]+g*i.rawData[9]+y*i.rawData[13],e[10]=a*i.rawData[2]+h*i.rawData[6]+g*i.rawData[10]+y*i.rawData[14],e[11]=a*i.rawData[3]+h*i.rawData[7]+g*i.rawData[11]+y*i.rawData[15],e[12]=s*i.rawData[0]+u*i.rawData[4]+m*i.rawData[8]+C*i.rawData[12],e[13]=s*i.rawData[1]+u*i.rawData[5]+m*i.rawData[9]+C*i.rawData[13],e[14]=s*i.rawData[2]+u*i.rawData[6]+m*i.rawData[10]+C*i.rawData[14],e[15]=s*i.rawData[3]+u*i.rawData[7]+m*i.rawData[11]+C*i.rawData[15]}add(i){let e=this.rawData,t=e[0],r=e[4],a=e[8],s=e[12],o=e[1],l=e[5],h=e[9],u=e[13],c=e[2],d=e[6],g=e[10],m=e[14],A=e[3],v=e[7],y=e[11],C=e[15],S=i.rawData[0],T=i.rawData[4],D=i.rawData[8],M=i.rawData[12],P=i.rawData[1],R=i.rawData[5],U=i.rawData[9],E=i.rawData[13],F=i.rawData[2],V=i.rawData[6],Y=i.rawData[10],j=i.rawData[14],oe=i.rawData[3],pe=i.rawData[7],we=i.rawData[11],Xe=i.rawData[15];return e[0]=t+S,e[1]=o+P,e[2]=c+F,e[3]=A+oe,e[4]=r+T,e[5]=l+R,e[6]=d+V,e[7]=v+pe,e[8]=a+D,e[9]=h+U,e[10]=g+Y,e[11]=y+we,e[12]=s+M,e[13]=u+E,e[14]=m+j,e[15]=C+Xe,this}sub(i){let e=this.rawData,t=e[0],r=e[4],a=e[8],s=e[12],o=e[1],l=e[5],h=e[9],u=e[13],c=e[2],d=e[6],g=e[10],m=e[14],A=e[3],v=e[7],y=e[11],C=e[15],S=i.rawData[0],T=i.rawData[4],D=i.rawData[8],M=i.rawData[12],P=i.rawData[1],R=i.rawData[5],U=i.rawData[9],E=i.rawData[13],F=i.rawData[2],V=i.rawData[6],Y=i.rawData[10],j=i.rawData[14],oe=i.rawData[3],pe=i.rawData[7],we=i.rawData[11],Xe=i.rawData[15];return e[0]=t-S,e[1]=o-P,e[2]=c-F,e[3]=A-oe,e[4]=r-T,e[5]=l-R,e[6]=d-V,e[7]=v-pe,e[8]=a-D,e[9]=h-U,e[10]=g-Y,e[11]=y-we,e[12]=s-M,e[13]=u-E,e[14]=m-j,e[15]=C-Xe,this}mult(i){let e=this.rawData;return e[0]*=i,e[1]*=i,e[2]*=i,e[3]*=i,e[4]*=i,e[5]*=i,e[6]*=i,e[7]*=i,e[8]*=i,e[9]*=i,e[10]*=i,e[11]*=i,e[12]*=i,e[13]*=i,e[14]*=i,e[15]*=i,this}appendRotation(i,e){let t=k.getAxisRotation(e.x,e.y,e.z,i);this.append(t)}createByRotation(i,e){let t=k.helpMatrix,r,a,s=i*_e;r=Math.sin(s),a=Math.cos(s),e.x==1&&(t.rawData[0]=1,t.rawData[1]=0,t.rawData[2]=0,t.rawData[3]=0,t.rawData[4]=0,t.rawData[5]=a,t.rawData[6]=r,t.rawData[7]=0,t.rawData[8]=0,t.rawData[9]=-r,t.rawData[10]=a,t.rawData[11]=0,t.rawData[12]=0,t.rawData[13]=0,t.rawData[14]=0,t.rawData[15]=1),e.y==1&&(t.rawData[0]=a,t.rawData[1]=0,t.rawData[2]=-r,t.rawData[3]=0,t.rawData[4]=0,t.rawData[5]=1,t.rawData[6]=0,t.rawData[7]=0,t.rawData[8]=r,t.rawData[9]=0,t.rawData[10]=a,t.rawData[11]=0,t.rawData[12]=0,t.rawData[13]=0,t.rawData[14]=0,t.rawData[15]=1),e.z==1&&(t.rawData[0]=a,t.rawData[1]=r,t.rawData[2]=0,t.rawData[3]=0,t.rawData[4]=-r,t.rawData[5]=a,t.rawData[6]=0,t.rawData[7]=0,t.rawData[8]=0,t.rawData[9]=0,t.rawData[10]=1,t.rawData[11]=0,t.rawData[12]=0,t.rawData[13]=0,t.rawData[14]=0,t.rawData[15]=1),this.append(t)}appendScale(i,e,t){k.helpMatrix.createByScale(i,e,t),this.append(k.helpMatrix)}createByScale(i,e,t){let r=this.rawData;r[0]=i,r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[5]=e,r[6]=0,r[7]=0,r[8]=0,r[9]=0,r[10]=t,r[11]=0,r[12]=0,r[13]=0,r[14]=0,r[15]=1}appendTranslation(i,e,t){let r=this.rawData;r[12]+=i,r[13]+=e,r[14]+=t}clone(){let i=new k;return i.copyFrom(this),i}copyRowFrom(i,e){let t=this.rawData;switch(i){case 0:t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w;break;case 1:t[4]=e.x,t[5]=e.y,t[6]=e.z,t[7]=e.w;break;case 2:t[8]=e.x,t[9]=e.y,t[10]=e.z,t[11]=e.w;break;case 3:t[12]=e.x,t[13]=e.y,t[14]=e.z,t[15]=e.w;break}}copyRowTo(i,e){let t=this.rawData;switch(i){case 0:e.x=t[0],e.y=t[1],e.z=t[2],e.w=t[3];break;case 1:e.x=t[4],e.y=t[5],e.z=t[6],e.w=t[7];break;case 2:e.x=t[8],e.y=t[9],e.z=t[10],e.w=t[11];break;case 3:e.x=t[12],e.y=t[13],e.z=t[14],e.w=t[15];break}}copyFrom(i){let e=this.rawData;return e[0]=i.rawData[0],e[1]=i.rawData[1],e[2]=i.rawData[2],e[3]=i.rawData[3],e[4]=i.rawData[4],e[5]=i.rawData[5],e[6]=i.rawData[6],e[7]=i.rawData[7],e[8]=i.rawData[8],e[9]=i.rawData[9],e[10]=i.rawData[10],e[11]=i.rawData[11],e[12]=i.rawData[12],e[13]=i.rawData[13],e[14]=i.rawData[14],e[15]=i.rawData[15],this}copyRawDataTo(i,e=0,t=!1){let r=this.rawData;i[0+e]=r[0],i[1+e]=r[1],i[2+e]=r[2],i[3+e]=r[3],i[4+e]=r[4],i[5+e]=r[5],i[6+e]=r[6],i[7+e]=r[7],i[8+e]=r[8],i[9+e]=r[9],i[10+e]=r[10],i[11+e]=r[11],i[12+e]=r[12],i[13+e]=r[13],i[14+e]=r[14],i[15+e]=r[15]}copyColFrom(i,e){let t=this.rawData;switch(i){case 0:t[0]=e.x,t[4]=e.y,t[8]=e.z,t[12]=e.w;break;case 1:t[1]=e.x,t[5]=e.y,t[9]=e.z,t[13]=e.w;break;case 2:t[2]=e.x,t[6]=e.y,t[10]=e.z,t[14]=e.w;break;case 3:t[3]=e.x,t[7]=e.y,t[11]=e.z,t[15]=e.w;break}}copyColTo(i,e){let t=this.rawData;switch(i){case 0:e.x=t[0],e.y=t[4],e.z=t[8],e.w=t[12];break;case 1:e.x=t[1],e.y=t[5],e.z=t[9],e.w=t[13];break;case 2:e.x=t[2],e.y=t[6],e.z=t[10],e.w=t[14];break;case 3:e.x=t[3],e.y=t[7],e.z=t[11],e.w=t[15];break}}copyToMatrix3D(i){i.rawData=this.rawData.slice(0)}makeRotationFromQuaternion(i){return this.compose(k._zero,i,k._one),this}decompose(i="eulerAngles",e){let t=K.CALCULATION_QUATERNION,r=e||k._prs;this.copyRawDataTo(k.decomposeRawData);let a=k.decomposeRawData,s=r[0];s.x=a[12],s.y=a[13],s.z=a[14],a[12]=0,a[13]=0,a[14]=0;let o=r[2];o.x=Math.sqrt(a[0]*a[0]+a[1]*a[1]+a[2]*a[2]),o.y=Math.sqrt(a[4]*a[4]+a[5]*a[5]+a[6]*a[6]),o.z=Math.sqrt(a[8]*a[8]+a[9]*a[9]+a[10]*a[10]),a[0]*(a[5]*a[10]-a[6]*a[9])-a[1]*(a[4]*a[10]-a[6]*a[8])+a[2]*(a[4]*a[9]-a[5]*a[8])<0&&(o.z=-o.z),a[0]/=o.x,a[1]/=o.x,a[2]/=o.x,a[4]/=o.y,a[5]/=o.y,a[6]/=o.y,a[8]/=o.z,a[9]/=o.z,a[10]/=o.z;let l=r[1],h;switch(i){case vt.AXIS_ANGLE:l.w=Math.acos((a[0]+a[5]+a[10]-1)/2);let u=Math.sqrt((a[6]-a[9])*(a[6]-a[9])+(a[8]-a[2])*(a[8]-a[2])+(a[1]-a[4])*(a[1]-a[4]));l.x=(a[6]-a[9])/u,l.y=(a[8]-a[2])/u,l.z=(a[1]-a[4])/u;break;case vt.QUATERNION:h=a[0]+a[5]+a[10],h>0?(l.w=Math.sqrt(1+h)/2,l.x=(a[6]-a[9])/(4*l.w),l.y=(a[8]-a[2])/(4*l.w),l.z=(a[1]-a[4])/(4*l.w)):a[0]>a[5]&&a[0]>a[10]?(l.x=Math.sqrt(1+a[0]-a[5]-a[10])/2,l.w=(a[6]-a[9])/(4*l.x),l.y=(a[1]+a[4])/(4*l.x),l.z=(a[8]+a[2])/(4*l.x)):a[5]>a[10]?(l.y=Math.sqrt(1+a[5]-a[0]-a[10])/2,l.x=(a[1]+a[4])/(4*l.y),l.w=(a[8]-a[2])/(4*l.y),l.z=(a[6]+a[9])/(4*l.y)):(l.z=Math.sqrt(1+a[10]-a[0]-a[5])/2,l.x=(a[8]+a[2])/(4*l.z),l.y=(a[6]+a[9])/(4*l.z),l.w=(a[1]-a[4])/(4*l.z));break;case vt.EULER_ANGLES:h=a[0]+a[5]+a[10],h>0?(t.w=Math.sqrt(1+h)/2,t.x=(a[6]-a[9])/(4*t.w),t.y=(a[8]-a[2])/(4*t.w),t.z=(a[1]-a[4])/(4*t.w)):a[0]>a[5]&&a[0]>a[10]?(t.x=Math.sqrt(1+a[0]-a[5]-a[10])/2,t.w=(a[6]-a[9])/(4*t.x),t.y=(a[1]+a[4])/(4*t.x),t.z=(a[8]+a[2])/(4*t.x)):a[5]>a[10]?(l.y=Math.sqrt(1+a[5]-a[0]-a[10])/2,t.x=(a[1]+a[4])/(4*t.y),t.w=(a[8]-a[2])/(4*t.y),t.z=(a[6]+a[9])/(4*t.y)):(t.z=Math.sqrt(1+a[10]-a[0]-a[5])/2,t.x=(a[8]+a[2])/(4*t.z),t.y=(a[6]+a[9])/(4*t.z),t.w=(a[1]-a[4])/(4*t.z)),t.getEulerAngles(l);break}return r[0]=s,r[1]=l,r[2]=o,r}static getEuler(i,e,t=!0,r){return i||(i=new p),k._getEulerMatrix.makeRotationFromQuaternion(e).makeEuler(i,t,r),i}compose(i,e,t){const r=this.rawData,a=e.x,s=e.y,o=e.z,l=e.w,h=a+a,u=s+s,c=o+o,d=a*h,g=a*u,m=a*c,A=s*u,v=s*c,y=o*c,C=l*h,S=l*u,T=l*c,D=t.x,M=t.y,P=t.z;return r[0]=(1-(A+y))*D,r[1]=(g+T)*D,r[2]=(m-S)*D,r[3]=0,r[4]=(g-T)*M,r[5]=(1-(d+y))*M,r[6]=(v+C)*M,r[7]=0,r[8]=(m+S)*P,r[9]=(v-C)*P,r[10]=(1-(d+A))*P,r[11]=0,r[12]=i.x,r[13]=i.y,r[14]=i.z,r[15]=1,this}deltaTransformVector(i,e){e||(e=new p);let t=this.rawData,r=i.x,a=i.y,s=i.z;return e.x=r*t[0]+a*t[4]+s*t[8],e.y=r*t[1]+a*t[5]+s*t[9],e.z=r*t[2]+a*t[6]+s*t[10],e.w=r*t[3]+a*t[7]+s*t[11],e}identity(){let i=this.rawData;return i[0]=1,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=1,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[10]=1,i[11]=0,i[12]=0,i[13]=0,i[14]=0,i[15]=1,this}fill(i){let e=this.rawData;e[1]=i,e[2]=i,e[3]=i,e[4]=i,e[6]=i,e[7]=i,e[8]=i,e[9]=i,e[11]=i,e[12]=i,e[13]=i,e[14]=i,e[0]=i,e[5]=i,e[10]=i,e[15]=i}invers33(){let i=this.rawData,e=i[5]*i[10]-i[9]*i[6],t=i[8]*i[6]-i[4]*i[10],r=i[4]*i[9]-i[8]*i[5],a=i[9]*i[2]-i[1]*i[10],s=i[0]*i[10]-i[8]*i[2],o=i[8]*i[1]-i[0]*i[9],l=i[1]*i[6]-i[5]*i[2],h=i[4]*i[2]-i[0]*i[6],u=i[0]*i[5]-i[4]*i[1],c=i[0]*e+i[4]*a+i[8]*l;if(Math.abs(c)>1e-11){let d=1/c;i[0]=d*e,i[4]=d*t,i[8]=d*r,i[1]=d*a,i[5]=d*s,i[9]=d*o,i[2]=d*l,i[6]=d*h,i[10]=d*u}}invert(){let i=this.determinant,e=Math.abs(i)>1e-11,t=this.rawData;if(e){i=1/i;let r=t[0],a=t[4],s=t[8],o=t[12],l=t[1],h=t[5],u=t[9],c=t[13],d=t[2],g=t[6],m=t[10],A=t[14],v=t[3],y=t[7],C=t[11],S=t[15];t[0]=i*(h*(m*S-A*C)-u*(g*S-A*y)+c*(g*C-m*y)),t[1]=-i*(l*(m*S-A*C)-u*(d*S-A*v)+c*(d*C-m*v)),t[2]=i*(l*(g*S-A*y)-h*(d*S-A*v)+c*(d*y-g*v)),t[3]=-i*(l*(g*C-m*y)-h*(d*C-m*v)+u*(d*y-g*v)),t[4]=-i*(a*(m*S-A*C)-s*(g*S-A*y)+o*(g*C-m*y)),t[5]=i*(r*(m*S-A*C)-s*(d*S-A*v)+o*(d*C-m*v)),t[6]=-i*(r*(g*S-A*y)-a*(d*S-A*v)+o*(d*y-g*v)),t[7]=i*(r*(g*C-m*y)-a*(d*C-m*v)+s*(d*y-g*v)),t[8]=i*(a*(u*S-c*C)-s*(h*S-c*y)+o*(h*C-u*y)),t[9]=-i*(r*(u*S-c*C)-s*(l*S-c*v)+o*(l*C-u*v)),t[10]=i*(r*(h*S-c*y)-a*(l*S-c*v)+o*(l*y-h*v)),t[11]=-i*(r*(h*C-u*y)-a*(l*C-u*v)+s*(l*y-h*v)),t[12]=-i*(a*(u*A-c*m)-s*(h*A-c*g)+o*(h*m-u*g)),t[13]=i*(r*(u*A-c*m)-s*(l*A-c*d)+o*(l*m-u*d)),t[14]=-i*(r*(h*A-c*g)-a*(l*A-c*d)+o*(l*g-h*d)),t[15]=i*(r*(h*m-u*g)-a*(l*m-u*d)+s*(l*g-h*d))}return e}transformPoint(i,e){let t=this.rawData;e||(e=new p);let r=i.x,a=i.y,s=i.z;return e.x=r*t[0]+a*t[4]+s*t[8]+t[12],e.y=r*t[1]+a*t[5]+s*t[9]+t[13],e.z=r*t[2]+a*t[6]+s*t[10]+t[14],e}transformVector(i,e){let t=this.rawData;e||(e=new p);let r=i.x,a=i.y,s=i.z;return e.x=r*t[0]+a*t[4]+s*t[8],e.y=r*t[1]+a*t[5]+s*t[9],e.z=r*t[2]+a*t[6]+s*t[10],e}transpose(){let i=this.rawData;for(let e=0;e<k.helpMatrix.rawData.length;e++)k.helpMatrix.rawData[e]=i[e];i[1]=k.helpMatrix.rawData[4],i[2]=k.helpMatrix.rawData[8],i[3]=k.helpMatrix.rawData[12],i[4]=k.helpMatrix.rawData[1],i[6]=k.helpMatrix.rawData[9],i[7]=k.helpMatrix.rawData[13],i[8]=k.helpMatrix.rawData[2],i[9]=k.helpMatrix.rawData[6],i[11]=k.helpMatrix.rawData[14],i[12]=k.helpMatrix.rawData[3],i[13]=k.helpMatrix.rawData[7],i[14]=k.helpMatrix.rawData[11]}get determinant(){let i=this.rawData;return(i[0]*i[5]-i[4]*i[1])*(i[10]*i[15]-i[14]*i[11])-(i[0]*i[9]-i[8]*i[1])*(i[6]*i[15]-i[14]*i[7])+(i[0]*i[13]-i[12]*i[1])*(i[6]*i[11]-i[10]*i[7])+(i[4]*i[9]-i[8]*i[5])*(i[2]*i[15]-i[14]*i[3])-(i[4]*i[13]-i[12]*i[5])*(i[2]*i[11]-i[10]*i[3])+(i[8]*i[13]-i[12]*i[9])*(i[2]*i[7]-i[6]*i[3])}getPosition(i){i||(i=new p);let e=this.rawData;return i.x=e[12],i.y=e[13],i.z=e[14],i}get position(){return this._position.set(this.rawData[12],this.rawData[13],this.rawData[14]),this._position}set position(i){let e=this.rawData;e[12]=i.x,e[13]=i.y,e[14]=i.z}get scale(){let i=this.rawData;return new p(i[0],i[5],i[10])}set scale(i){let e=this.rawData;e[0]=i.x,e[5]=i.y,e[10]=i.z}toString(){let i=this.rawData;return"matrix3d("+Math.round(i[0]*1e3)/1e3+","+Math.round(i[1]*1e3)/1e3+","+Math.round(i[2]*1e3)/1e3+","+Math.round(i[3]*1e3)/1e3+","+Math.round(i[4]*1e3)/1e3+","+Math.round(i[5]*1e3)/1e3+","+Math.round(i[6]*1e3)/1e3+","+Math.round(i[7]*1e3)/1e3+","+Math.round(i[8]*1e3)/1e3+","+Math.round(i[9]*1e3)/1e3+","+Math.round(i[10]*1e3)/1e3+","+Math.round(i[11]*1e3)/1e3+","+Math.round(i[12]*1e3)/1e3+","+Math.round(i[13]*1e3)/1e3+","+Math.round(i[14]*1e3)/1e3+","+Math.round(i[15]*1e3)/1e3+")"}lerp(i,e,t){this.copyFrom(e).sub(i).mult(t).add(i)}get(i,e){return this.rawData[i+e*4]}set(i,e,t){this.rawData[i+e*4]=t}getMaxScaleOnAxis(){let i=this.rawData,e=i[0]*i[0]+i[1]*i[1]+i[2]*i[2],t=i[4]*i[4]+i[5]*i[5]+i[6]*i[6],r=i[8]*i[8]+i[9]*i[9]+i[10]*i[10];return Math.sqrt(Math.max(e,t,r))}translate(i){let e=this.get(0,0)*i.x+this.get(0,1)*i.y+this.get(0,2)*i.z+this.get(0,3),t=this.get(1,0)*i.x+this.get(1,1)*i.y+this.get(1,2)*i.z+this.get(1,3),r=this.get(2,0)*i.x+this.get(2,1)*i.y+this.get(2,2)*i.z+this.get(2,3),a=this.get(3,0)*i.x+this.get(3,1)*i.y+this.get(3,2)*i.z+this.get(3,3);return this.set(0,3,e),this.set(1,3,t),this.set(2,3,r),this.set(3,3,a),this}setTRInverse(i,e){e=e.inverse(),K.quaternionToMatrix(e,this),this.translate(new p(-i.x,-i.y,-i.z))}setScale(i){return this.set(0,0,i.x),this.set(0,1,0),this.set(0,2,0),this.set(0,3,0),this.set(1,0,0),this.set(1,1,i.y),this.set(1,2,0),this.set(1,3,0),this.set(2,0,0),this.set(2,1,0),this.set(2,2,i.z),this.set(2,3,0),this.set(3,0,0),this.set(3,1,0),this.set(3,2,0),this.set(3,3,1),this}makeBasis(i,e,t){return this.setElements(i.x,e.x,t.x,0,i.y,e.y,t.y,0,i.z,e.z,t.z,0,0,0,0,1),this}makeRotationAxis(i,e){const t=Math.cos(e),r=Math.sin(e),a=1-t,s=i.x,o=i.y,l=i.z,h=a*s,u=a*o;return this.setElements(h*s+t,h*o-r*l,h*l+r*o,0,h*o+r*l,u*o+t,u*l-r*s,0,h*l-r*o,u*l+r*s,a*l*l+t,0,0,0,0,1),this}static transpose(i,e){e||(e=new k);let t=i.rawData,r=e.rawData;return r[0]=t[0],r[1]=t[4],r[2]=t[8],r[3]=t[12],r[4]=t[1],r[5]=t[5],r[6]=t[9],r[7]=t[13],r[8]=t[2],r[9]=t[6],r[10]=t[10],r[11]=t[14],r[12]=t[3],r[13]=t[7],r[14]=t[11],r[15]=t[15],e}static inverse(i,e){e||(e=new k);let t=i.rawData,r=e.rawData;r[0]=t[5]*t[10]*t[15]-t[5]*t[14]*t[11]-t[6]*t[9]*t[15]+t[6]*t[13]*t[11]+t[7]*t[9]*t[14]-t[7]*t[13]*t[10],r[1]=-t[1]*t[10]*t[15]+t[1]*t[14]*t[11]+t[2]*t[9]*t[15]-t[2]*t[13]*t[11]-t[3]*t[9]*t[14]+t[3]*t[13]*t[10],r[2]=t[1]*t[6]*t[15]-t[1]*t[14]*t[7]-t[2]*t[5]*t[15]+t[2]*t[13]*t[7]+t[3]*t[5]*t[14]-t[3]*t[13]*t[6],r[3]=-t[1]*t[6]*t[11]+t[1]*t[10]*t[7]+t[2]*t[5]*t[11]-t[2]*t[9]*t[7]-t[3]*t[5]*t[10]+t[3]*t[9]*t[6],r[4]=-t[4]*t[10]*t[15]+t[4]*t[14]*t[11]+t[6]*t[8]*t[15]-t[6]*t[12]*t[11]-t[7]*t[8]*t[14]+t[7]*t[12]*t[10],r[5]=t[0]*t[10]*t[15]-t[0]*t[14]*t[11]-t[2]*t[8]*t[15]+t[2]*t[12]*t[11]+t[3]*t[8]*t[14]-t[3]*t[12]*t[10],r[6]=-t[0]*t[6]*t[15]+t[0]*t[14]*t[7]+t[2]*t[4]*t[15]-t[2]*t[12]*t[7]-t[3]*t[4]*t[14]+t[3]*t[12]*t[6],r[7]=t[0]*t[6]*t[11]-t[0]*t[10]*t[7]-t[2]*t[4]*t[11]+t[2]*t[8]*t[7]+t[3]*t[4]*t[10]-t[3]*t[8]*t[6],r[8]=t[4]*t[9]*t[15]-t[4]*t[13]*t[11]-t[5]*t[8]*t[15]+t[5]*t[12]*t[11]+t[7]*t[8]*t[13]-t[7]*t[12]*t[9],r[9]=-t[0]*t[9]*t[15]+t[0]*t[13]*t[11]+t[1]*t[8]*t[15]-t[1]*t[12]*t[11]-t[3]*t[8]*t[13]+t[3]*t[12]*t[9],r[10]=t[0]*t[5]*t[15]-t[0]*t[13]*t[7]-t[1]*t[4]*t[15]+t[1]*t[12]*t[7]+t[3]*t[4]*t[13]-t[3]*t[12]*t[5],r[11]=-t[0]*t[5]*t[11]+t[0]*t[9]*t[7]+t[1]*t[4]*t[11]-t[1]*t[8]*t[7]-t[3]*t[4]*t[9]+t[3]*t[8]*t[5],r[12]=-t[4]*t[9]*t[14]+t[4]*t[13]*t[10]+t[5]*t[8]*t[14]-t[5]*t[12]*t[10]-t[6]*t[8]*t[13]+t[6]*t[12]*t[9],r[13]=t[0]*t[9]*t[14]-t[0]*t[13]*t[10]-t[1]*t[8]*t[14]+t[1]*t[12]*t[10]+t[2]*t[8]*t[13]-t[2]*t[12]*t[9],r[14]=-t[0]*t[5]*t[14]+t[0]*t[13]*t[6]+t[1]*t[4]*t[14]-t[1]*t[12]*t[6]-t[2]*t[4]*t[13]+t[2]*t[12]*t[5],r[15]=t[0]*t[5]*t[10]-t[0]*t[9]*t[6]-t[1]*t[4]*t[10]+t[1]*t[8]*t[6]+t[2]*t[4]*t[9]-t[2]*t[8]*t[5];let a=t[0]*r[0]+t[1]*r[4]+t[2]*r[8]+t[3]*r[12];for(let s=0;s<16;s++)r[s]/=a;return e}makeEuler(i,e,t="XYZ"){const r=this.rawData,a=r[0],s=r[4],o=r[8],l=r[1],h=r[5],u=r[9],c=r[2],d=r[6],g=r[10];switch(t){case"XYZ":i.y=Math.asin(J(o,-1,1)),Math.abs(o)<.9999999?(i.x=Math.atan2(-u,g),i.z=Math.atan2(-s,a)):(i.x=Math.atan2(d,h),i.z=0);break;case"YXZ":i.x=Math.asin(-J(u,-1,1)),Math.abs(u)<.9999999?(i.y=Math.atan2(o,g),i.z=Math.atan2(l,h)):(i.y=Math.atan2(-c,a),i.z=0);break;case"ZXY":i.x=Math.asin(J(d,-1,1)),Math.abs(d)<.9999999?(i.y=Math.atan2(-c,g),i.z=Math.atan2(-s,h)):(i.y=0,i.z=Math.atan2(l,a));break;case"ZYX":i.y=Math.asin(-J(c,-1,1)),Math.abs(c)<.9999999?(i.x=Math.atan2(d,g),i.z=Math.atan2(l,a)):(i.x=0,i.z=Math.atan2(-s,h));break;case"YZX":i.z=Math.asin(J(l,-1,1)),Math.abs(l)<.9999999?(i.x=Math.atan2(-u,h),i.y=Math.atan2(-c,a)):(i.x=0,i.y=Math.atan2(o,g));break;case"XZY":i.z=Math.asin(-J(s,-1,1)),Math.abs(s)<.9999999?(i.x=Math.atan2(d,h),i.y=Math.atan2(o,a)):(i.x=Math.atan2(-u,g),i.y=0);break}return e&&i.multiplyScalar(qi),i}setElements(i,e,t,r,a,s,o,l,h,u,c,d,g,m,A,v){const y=this.rawData;return y[0]=i,y[4]=e,y[8]=t,y[12]=r,y[1]=a,y[5]=s,y[9]=o,y[13]=l,y[2]=h,y[6]=u,y[10]=c,y[14]=d,y[3]=g,y[7]=m,y[11]=A,y[15]=v,this}makeMatrix44ByQuaternion(i,e,t){this.identity(),K.quaternionToMatrix(t,this),this.appendTranslation(i.x,i.y,i.z),this.appendScale(e.x,e.y,e.z)}};let H=k;n(H,"blockBytes",16*4),n(H,"block",16),n(H,"allocCount",1e3),n(H,"allocOnceCount",1e3),n(H,"maxCount",50*1e4),n(H,"useCount",0),n(H,"buffer"),n(H,"wasmMatrixPtr",0),n(H,"dynamicMatrixBytes"),n(H,"dynamicGlobalMatrixRef"),n(H,"wasm"),n(H,"help_matrix_0"),n(H,"help_matrix_1"),n(H,"help_matrix_2"),n(H,"helpMatrix"),n(H,"helpMatrix2"),n(H,"_getEulerMatrix"),n(H,"_zero",new p(0,0,0)),n(H,"_one",new p(1,1,1)),n(H,"_prs",[new p,new p,new p]),n(H,"float32Array",new Float32Array(16).fill(0)),n(H,"decomposeRawData",new Float32Array(16).fill(0));function Al(i,e,t){for(let r=0;r<4;r++)t.rawData[r]=i.rawData[r]*e.rawData[0]+i.rawData[r+4]*e.rawData[1]+i.rawData[r+8]*e.rawData[2]+i.rawData[r+12]*e.rawData[3],t.rawData[r+4]=i.rawData[r]*e.rawData[4]+i.rawData[r+4]*e.rawData[5]+i.rawData[r+8]*e.rawData[6]+i.rawData[r+12]*e.rawData[7],t.rawData[r+8]=i.rawData[r]*e.rawData[8]+i.rawData[r+4]*e.rawData[9]+i.rawData[r+8]*e.rawData[10]+i.rawData[r+12]*e.rawData[11],t.rawData[r+12]=i.rawData[r]*e.rawData[12]+i.rawData[r+4]*e.rawData[13]+i.rawData[r+8]*e.rawData[14]+i.rawData[r+12]*e.rawData[15]}function Ra(i,e,t,r){let a=r.rawData,s=i.x*_e,o=i.y*_e,l=i.z*_e,h=0,u=s*.5,c=o*.5,d=l*.5,g=Math.cos(u),m=Math.sin(u),A=Math.cos(c),v=Math.sin(c),y=Math.cos(d),C=Math.sin(d);h=g*A*y+m*v*C,s=m*A*y-g*v*C,o=g*v*y+m*A*C,l=g*A*C-m*v*y;let S=s+s,T=o+o,D=l+l,M=s*S,P=s*T,R=s*D,U=o*T,E=o*D,F=l*D,V=h*S,Y=h*T,j=h*D,oe=t.x,pe=t.y,we=t.z;a[0]=(1-(U+F))*oe,a[1]=(P+j)*oe,a[2]=(R-Y)*oe,a[3]=0,a[4]=(P-j)*pe,a[5]=(1-(M+F))*pe,a[6]=(E+V)*pe,a[7]=0,a[8]=(R+Y)*we,a[9]=(E-V)*we,a[10]=(1-(M+U))*we,a[11]=0,a[12]=e.x,a[13]=e.y,a[14]=e.z,a[15]=1}function _l(i,e,t){let r=i.rawData,a=t.rawData,s=r[0],o=r[4],l=r[8],h=r[12],u=r[1],c=r[5],d=r[9],g=r[13],m=r[2],A=r[6],v=r[10],y=r[14],C=r[3],S=r[7],T=r[11],D=r[15];a[0]=s*e.rawData[0]+u*e.rawData[4]+m*e.rawData[8]+C*e.rawData[12],a[1]=s*e.rawData[1]+u*e.rawData[5]+m*e.rawData[9]+C*e.rawData[13],a[2]=s*e.rawData[2]+u*e.rawData[6]+m*e.rawData[10]+C*e.rawData[14],a[3]=s*e.rawData[3]+u*e.rawData[7]+m*e.rawData[11]+C*e.rawData[15],a[4]=o*e.rawData[0]+c*e.rawData[4]+A*e.rawData[8]+S*e.rawData[12],a[5]=o*e.rawData[1]+c*e.rawData[5]+A*e.rawData[9]+S*e.rawData[13],a[6]=o*e.rawData[2]+c*e.rawData[6]+A*e.rawData[10]+S*e.rawData[14],a[7]=o*e.rawData[3]+c*e.rawData[7]+A*e.rawData[11]+S*e.rawData[15],a[8]=l*e.rawData[0]+d*e.rawData[4]+v*e.rawData[8]+T*e.rawData[12],a[9]=l*e.rawData[1]+d*e.rawData[5]+v*e.rawData[9]+T*e.rawData[13],a[10]=l*e.rawData[2]+d*e.rawData[6]+v*e.rawData[10]+T*e.rawData[14],a[11]=l*e.rawData[3]+d*e.rawData[7]+v*e.rawData[11]+T*e.rawData[15],a[12]=h*e.rawData[0]+g*e.rawData[4]+y*e.rawData[8]+D*e.rawData[12],a[13]=h*e.rawData[1]+g*e.rawData[5]+y*e.rawData[9]+D*e.rawData[13],a[14]=h*e.rawData[2]+g*e.rawData[6]+y*e.rawData[10]+D*e.rawData[14],a[15]=h*e.rawData[3]+g*e.rawData[7]+y*e.rawData[11]+D*e.rawData[15]}function Dd(i,e){let t=e.x,r=e.y,a=e.z,s=e.w,o=i.rawData,l=2*t*r,h=2*t*a,u=2*t*s,c=2*r*a,d=2*r*s,g=2*a*s,m=t*t,A=r*r,v=a*a,y=s*s;return o[0]=m-A-v+y,o[4]=l-g,o[8]=h+d,o[12]=0,o[1]=l+g,o[5]=-m+A-v+y,o[9]=c-u,o[13]=0,o[2]=h-d,o[6]=c+u,o[10]=-m-A+v+y,o[14]=0,o[3]=0,o[7]=0,o[11]=0,o[15]=1,i}function Md(i,e){let t=e.rawData,r=Math.sin(i),a=Math.cos(i);return t[0]=a,t[1]=0,t[2]=-r,t[3]=0,t[8]=r,t[9]=0,t[10]=a,t[11]=0,t}function Pd(i,e,t){let r=e.x,a=e.y,s=e.z,o=Math.hypot(r,a,s),l,h,u,c,d,g,m,A,v,y,C,S;if(o<Td)return null;o=1/o,r*=o,a*=o,s*=o,l=Math.sin(i),h=Math.cos(i),u=1-h,c=r*r*u+h,d=a*r*u+s*l,g=s*r*u-a*l,m=r*a*u-s*l,A=a*a*u+h,v=s*a*u+r*l,y=r*s*u+a*l,C=a*s*u-r*l,S=s*s*u+h;let T=t.rawData;return T[0]=c,T[1]=d,T[2]=g,T[3]=0,T[4]=m,T[5]=A,T[6]=v,T[7]=0,T[8]=y,T[9]=C,T[10]=S,T[11]=0,T[12]=0,T[13]=0,T[14]=0,T[15]=1,T}function ks(i,e,t){let r=i.rawData,a=r[0],s=r[1],o=r[2],l=r[3],h=r[4],u=r[5],c=r[6],d=r[7],g=r[8],m=r[9],A=r[10],v=r[11],y=r[12],C=r[13],S=r[14],T=r[15],D=e.rawData,M=t.rawData,P=D[0],R=D[1],U=D[2],E=D[3];return M[0]=P*a+R*h+U*g+E*y,M[1]=P*s+R*u+U*m+E*C,M[2]=P*o+R*c+U*A+E*S,M[3]=P*l+R*d+U*v+E*T,P=D[4],R=D[5],U=D[6],E=D[7],M[4]=P*a+R*h+U*g+E*y,M[5]=P*s+R*u+U*m+E*C,M[6]=P*o+R*c+U*A+E*S,M[7]=P*l+R*d+U*v+E*T,P=D[8],R=D[9],U=D[10],E=D[11],M[8]=P*a+R*h+U*g+E*y,M[9]=P*s+R*u+U*m+E*C,M[10]=P*o+R*c+U*A+E*S,M[11]=P*l+R*d+U*v+E*T,P=D[12],R=D[13],U=D[14],E=D[15],M[12]=P*a+R*h+U*g+E*y,M[13]=P*s+R*u+U*m+E*C,M[14]=P*o+R*c+U*A+E*S,M[15]=P*l+R*d+U*v+E*T,M}var ze=(i=>(i[i.None=0]="None",i[i.PointLight=1]="PointLight",i[i.DirectionLight=2]="DirectionLight",i[i.SpotLight=3]="SpotLight",i[i.SkyLight=4]="SkyLight",i))(ze||{});class Rr extends bi{constructor(){super(...arguments),n(this,"index",-1),n(this,"lightType",-1),n(this,"radius",.5),n(this,"linear",1),n(this,"lightPosition",new p),n(this,"lightMatrixIndex",-1),n(this,"direction",new p),n(this,"quadratic",.032),n(this,"lightColor",new z(1,1,1,1)),n(this,"intensity",1),n(this,"innerAngle",0),n(this,"outerAngle",1),n(this,"range",100),n(this,"castShadowIndex",-1),n(this,"lightTangent",p.FORWARD),n(this,"iesIndex",-1)}}n(Rr,"lightSize",24);const vl=class{static init(){this._init||(this._init=!0,this.componentsUpdateList=new Map,this.componentsLateUpdateList=new Map,this.componentsBeforeUpdateList=new Map,this.componentsComputeList=new Map,this.componentsEnablePickerList=new Map,this.graphicComponent=new Map,this.waitStartComponent=new Map)}static bindUpdate(i,e,t){this.init();let r=this.componentsUpdateList.get(i);r||(r=new Map,this.componentsUpdateList.set(i,r)),r.set(e,t)}static unBindUpdate(i,e){this.init();let t=this.componentsUpdateList.get(i);t&&t.delete(e)}static bindLateUpdate(i,e,t){this.init();let r=this.componentsLateUpdateList.get(i);r||(r=new Map,this.componentsLateUpdateList.set(i,r)),r.set(e,t)}static unBindLateUpdate(i,e){this.init();let t=this.componentsLateUpdateList.get(i);t&&t.delete(e)}static bindBeforeUpdate(i,e,t){this.init();let r=this.componentsBeforeUpdateList.get(i);r||(r=new Map,this.componentsBeforeUpdateList.set(i,r)),r.set(e,t)}static unBindBeforeUpdate(i,e){this.init();let t=this.componentsBeforeUpdateList.get(i);t&&t.delete(e)}static bindCompute(i,e,t){this.init();let r=this.componentsComputeList.get(i);r||(r=new Map,this.componentsComputeList.set(i,r)),r.set(e,t)}static unBindCompute(i,e){this.init();let t=this.componentsComputeList.get(i);t&&t.delete(e)}static bindGraphic(i,e,t){this.init();let r=this.graphicComponent.get(i);r||(r=new Map,this.graphicComponent.set(i,r)),r.set(e,t)}static unBindGraphic(i,e){this.init();let t=this.graphicComponent.get(i);t&&t.delete(e)}static appendWaitStart(i){this.init();let e=this.waitStartComponent.get(i.object3D);e?e.indexOf(i)==-1&&e.push(i):this.waitStartComponent.set(i.object3D,[i])}static removeWaitStart(i,e){this.init();let t=vl.waitStartComponent.get(i);if(t){let r=t.indexOf(e);r!=-1&&t.splice(r)}}static bindEnablePick(i,e,t){this.init();let r=this.componentsEnablePickerList.get(i);r||(r=new Map,this.componentsEnablePickerList.set(i,r)),r.set(e,t)}static unBindEnablePick(i,e){this.init();let t=this.componentsEnablePickerList.get(i);t&&t.delete(e)}};let se=vl;n(se,"componentsUpdateList"),n(se,"componentsLateUpdateList"),n(se,"componentsBeforeUpdateList"),n(se,"componentsComputeList"),n(se,"componentsEnablePickerList"),n(se,"graphicComponent"),n(se,"waitStartComponent"),n(se,"_init",!1);class Ee{constructor(){n(this,"object3D",null),n(this,"_eventDispatcher"),n(this,"_enable",!0),n(this,"__isStart",!1),n(this,"isDestroyed")}get eventDispatcher(){return this._eventDispatcher||(this._eventDispatcher=new hi),this._eventDispatcher}set eventDispatcher(e){console.error("The eventDispatcher should not be set externally!")}get isStart(){return this.__isStart}get transform(){return this.object3D.transform}set enable(e){var t,r;this._enable!=e&&(this._enable=e,this._enable?(t=this.onEnable)==null||t.call(this,this.transform.view3D):(r=this.onDisable)==null||r.call(this,this.transform.view3D))}get enable(){return this._enable}__init(e){this.init(e)}__start(){var e,t;this.transform&&this.transform.scene3D&&this._enable&&((e=this.onEnable)==null||e.call(this,this.transform.view3D)),this.transform&&this.transform.scene3D&&this.__isStart==!1&&((t=this.start)==null||t.call(this),this.__isStart=!0),this.onUpdate&&this._onUpdate(this.onUpdate.bind(this)),this.onLateUpdate&&this._onLateUpdate(this.onLateUpdate.bind(this)),this.onBeforeUpdate&&this._onBeforeUpdate(this.onBeforeUpdate.bind(this)),this.onCompute&&this._onCompute(this.onCompute.bind(this)),this.onGraphic&&this._onGraphic(this.onGraphic.bind(this))}__stop(){var e;this.transform&&this.transform.scene3D&&((e=this.onDisable)==null||e.call(this,this.transform.view3D)),this._onUpdate(null),this._onLateUpdate(null),this._onBeforeUpdate(null),this._onCompute(null),this._onGraphic(null)}init(e){}start(){}stop(){}cloneTo(e){}copyComponent(e){return this}_onUpdate(e){e!=null?se.bindUpdate(this.transform.view3D,this,e):se.unBindUpdate(this.transform.view3D,this)}_onLateUpdate(e){e!=null?se.bindLateUpdate(this.transform.view3D,this,e):se.unBindLateUpdate(this.transform.view3D,this)}_onBeforeUpdate(e){e!=null?se.bindBeforeUpdate(this.transform.view3D,this,e):se.unBindBeforeUpdate(this.transform.view3D,this)}_onCompute(e){e!=null?se.bindCompute(this.transform.view3D,this,e):se.unBindCompute(this.transform.view3D,this)}_onGraphic(e){e!=null?se.bindGraphic(this.transform.view3D,this,e):se.unBindGraphic(this.transform.view3D,this)}beforeDestroy(e){se.removeWaitStart(this.object3D,this)}destroy(e){this.isDestroyed||(this.isDestroyed=!0,this.enable=!1,this.stop(),this._onBeforeUpdate(null),this._onUpdate(null),this._onLateUpdate(null),this.onEnable=null,this.onDisable=null,this.onUpdate=null,this.onLateUpdate=null,this.onBeforeUpdate=null,this.onCompute=null,this.onGraphic=null)}}class La{constructor(){n(this,"value",0),n(this,"inv_base",0)}static get(e,t){let r=0,a=1/t;for(;e>0;)r+=e%t*a,e/=t,a/=t;return r}getBase(e,t){let r=this.inv_base=1/t;for(;e>0;)this.value+=r*(e%t),e/=t,r*=this.inv_base}next(){let e=1-this.value-1e-7;if(this.inv_base<e)this.value+=this.inv_base;else{let t=this.inv_base,r;do r=t,t*=this.inv_base;while(t>=e);this.value+=r+t-1}}get(){return this.value}}const Ji=class{constructor(i,e){n(this,"origin",new p),n(this,"length",Number.MAX_VALUE),n(this,"_vector",new p),n(this,"_dir",new p),n(this,"_v0",new p),n(this,"_v1",new p),n(this,"_v2",new p),n(this,"_E1",new p),n(this,"_E2",new p),n(this,"_P",new p),n(this,"_T",new p),n(this,"_Q",new p),this.origin.copyFrom(i||new p),this._dir.copyFrom(e||new p),this._dir.normalize()}get direction(){return this._dir}set direction(i){this._dir.copyFrom(i),this._dir.normalize()}clone(){return new Ji(this.origin,this.direction)}intersectBox(i,e){let t=this.direction,r=this.origin,a,s,o,l,h,u;const c=1/t.x,d=1/t.y,g=1/t.z,m=i.min,A=i.max;return a=((c>=0?m.x:A.x)-r.x)*c,s=((c>=0?A.x:m.x)-r.x)*c,o=((d>=0?m.y:A.y)-r.y)*d,l=((d>=0?A.y:m.y)-r.y)*d,a>l||o>s||(o>a&&(a=o),l<s&&(s=l),h=((g>=0?m.z:A.z)-r.z)*g,u=((g>=0?A.z:m.z)-r.z)*g,a>u||h>s)||(h>a&&(a=h),u<s&&(s=u),s<0)?null:(e||(e=new p),this.pointAt(a>=0?a:s,e))}pointAt(i,e){return e||(e=new p),e.copy(this.direction),e.multiplyScalar(i),e.add(this.origin,e),e}copy(i){return this.origin.copy(i.origin),this.direction.copy(i.direction),this._dir.copy(i._dir),this.length=i.length,this}setApproxDirection(i){this._dir=i.normalize()}setOrigin(i){this.origin.copyFrom(i)}getOrigin(){return this.origin}getPoint(i){return this._dir.scaleBy(i),this.origin.add(this._dir)}sqrDistToPoint(i){let e=this._dir,t=i.subtract(this.origin),r=tt(t,e),a=tt(e,e),s=r/a,o=this.getPoint(s);return Ns(i.subtract(o))}applyMatrix(i){this.origin=i.transformPoint(this.origin),this._dir=i.transformVector(this._dir)}pointInTriangle(i,e,t,r){let a=this._v0,s=this._v1,o=this._v2;r.subtract(e,a),t.subtract(e,s),i.subtract(e,o);let l=p.dot(a,a),h=p.dot(a,s),u=p.dot(a,o),c=p.dot(s,s),d=p.dot(s,o),g=1/(l*c-h*h),m=(c*u-h*d)*g,A=(l*d-h*u)*g;return m>=0&&A>=0&&m+A<1}intersectTriangle(i,e,t){let r=t.v1,a=t.v2,s=t.v3;a.subtract(r,this._E1),s.subtract(r,this._E2),e.crossProduct(this._E2,this._P);let o=this._E1.dotProduct(this._P);if(o>0?i.subtract(r,this._T):(r.subtract(i,this._T),o=-o),o<1e-4||(t.u=this._T.dotProduct(this._P),t.u<0||t.u>o)||(this._T.crossProduct(this._E1,this._Q),t.v=e.dotProduct(this._Q),t.v<0||t.u+t.v>o))return null;let l=new p;t.t0=t.t=this._E2.dotProduct(this._Q);let h=1/o;return t.t*=h,t.u*=h,t.v*=h,l.x=i.x+t.t*e.x,l.y=i.y+t.t*e.y,l.z=i.z+t.t*e.z,l}intersectSphere(i,e,t,r){let a=i.subtract(t),s=p.dot(e,e),o=2*p.dot(a,e),l=p.dot(a,a)-r*r,h=o*o-4*s*l,u=p.HELP_3;if(h<0)return null;{let c=(-o-Math.sqrt(h))/(s*2);return c<0?null:(u.x=i.x+c*e.x,u.y=i.y+c*e.y,u.z=i.z+c*e.z,u)}}intersectionSegment(i,e,t){const r=this.origin,a=p.HELP_0,s=p.HELP_1,o=p.HELP_2,l=p.HELP_3;e.subtract(i,a),this._dir.scaleToRef(Ji._rayl,o),r.add(o,s),i.subtract(r,l);var h=p.dot(a,a),u=p.dot(a,o),c=p.dot(o,o),d=p.dot(a,l),g=p.dot(o,l),m=h*c-u*u,A,v,y=m,C,S,T=m;m<Ji._smallnum?(v=0,y=1,S=g,T=c):(v=u*g-c*d,S=h*g-u*d,v<0?(v=0,S=g,T=c):v>y&&(v=y,S=g+u,T=c)),S<0?(S=0,-d<0?v=0:-d>h?v=y:(v=-d,y=h)):S>T&&(S=T,-d+u<0?v=0:-d+u>h?v=y:(v=-d+u,y=h)),A=Math.abs(v)<Ji._smallnum?0:v/y,C=Math.abs(S)<Ji._smallnum?0:S/T;const D=p.HELP_4;o.scaleToRef(C,D);const M=p.HELP_5;a.scaleToRef(A,M),M.add(l,M);const P=p.HELP_6;M.subtract(D,P);var R=C>0&&C<=this._dir.length&&P.lengthSquared<t*t;if(R){let U=new p;return U.copyFrom(e.subtract(i)),U.scaleBy(A),U.add(i,U),{out:U,length:M.length}}return{out:null,length:-1}}get_vec(i,e){let t=p.HELP_1;return t.x=i.x-e.x,t.y=i.y-e.y,t.z=i.z-e.z,t}};let ci=Ji;n(ci,"_rayl",1e9),n(ci,"_smallnum",1e-8);class Lr{constructor(e=0,t=0,r=0,a=0){n(this,"x"),n(this,"y"),n(this,"w"),n(this,"h"),this.x=e,this.y=t,this.w=r,this.h=a}get width(){return this.w}set width(e){this.w=e}get height(){return this.h}set height(e){this.h=e}static pointInRect(e,t,r,a,s,o){return!(e<r||e>s||t<a||t>o)}clone(){return new Lr(this.x,this.y,this.w,this.h)}copyFrom(e){this.x=e.x,this.y=e.y,this.w=e.w,this.h=e.h}copyTo(e){e.copyFrom(this)}inner(e,t){return!(e<this.x||e>this.x+this.width||t<this.y||t>this.y+this.height)}equal(e){return!(this.x!=e.x||this.y!=e.y||this.width!=e.width||this.height!=e.height)}equalArea(e,t,r,a){return!(this.x!=e||this.y!=t||this.width!=r||this.height!=a)}equalInnerArea(e){var t=this.x,r=this.y,a=this.x+this.width,s=this.y+this.height,o=e.x,l=e.y,h=e.x+e.width,u=e.y+e.height;return Math.max(t,o)<=Math.min(a,h)&&Math.max(r,l)<=Math.min(s,u)}innerArea(e,t){t=t||new Lr;var r=this.x,a=this.y,s=this.x+this.width,o=this.y+this.height,l=e.x,h=e.y,u=e.x+e.width,c=e.y+e.height,d=Math.max(a,h),g=Math.min(o,c),m=Math.max(r,l),A=Math.min(u,s);return d>=0&&g>=0&&g-d>=0&&A-m>0?(t.x=m,t.y=d,t.width=A-m,t.height=g-d):(t.x=0,t.y=0,t.width=0,t.height=0),t}setTo(e,t,r,a){this.x=e,this.y=t,this.width=r,this.height=a}}const Ur=class{constructor(i,e){n(this,"center"),n(this,"extents"),n(this,"max"),n(this,"min"),n(this,"size"),i||(i=p.ZERO.clone()),e||(e=p.ZERO.clone()),this.setFromCenterAndSize(i,e)}makeEmpty(){return this.setFromMinMax(Ur.maxVector3,Ur.minVector3),this}setFromMinMax(i,e){return this.init(),e.subtract(i,this.size),i.add(e,this.center).multiplyScalar(.5),this.extents.copyFrom(this.size).multiplyScalar(.5),this.min.copyFrom(i),this.max.copyFrom(e),this}init(){return this.min||(this.min=new p),this.max||(this.max=new p),this.size||(this.size=new p),this.center||(this.center=new p),this.extents||(this.extents=new p),this}setFromCenterAndSize(i,e){return this.size=e,this.center=i,this.init(),this.extents.copy(e).multiplyScalar(.5),this.center.subtract(this.extents,this.min),this.center.add(this.extents,this.max),this}inFrustum(i,e){return e.containsBox(i.bound)}merge(i){i.min.x<this.min.x&&(this.min.x=i.min.x),i.min.y<this.min.y&&(this.min.y=i.min.y),i.min.z<this.min.z&&(this.min.z=i.min.z),i.max.x>this.max.x&&(this.max.x=i.max.x),i.max.y>this.max.y&&(this.max.y=i.max.y),i.max.z>this.max.z&&(this.max.z=i.max.z),this.size.x=i.max.x-i.min.x,this.size.y=i.max.y-i.min.y,this.size.z=i.max.z-i.min.z,this.extents.x=this.size.x*.5,this.extents.y=this.size.y*.5,this.extents.z=this.size.z*.5,this.center.x=this.extents.x+i.min.x,this.center.y=this.extents.y+i.min.y,this.center.z=this.extents.z+i.min.z}intersects(i){return this.min.x<=i.max.x&&this.max.x>=i.min.x&&this.min.y<=i.max.y&&this.max.y>=i.min.y&&this.min.z<=i.max.z&&this.max.z>=i.min.z}intersectsSphere(i){return this.min.x<=i.max.x&&this.max.x>=i.min.x&&this.min.y<=i.max.y&&this.max.y>=i.min.y&&this.min.z<=i.max.z&&this.max.z>=i.min.z}intersectsBox(i){return this.min.x<=i.max.x&&this.max.x>=i.min.x&&this.min.y<=i.max.y&&this.max.y>=i.min.y&&this.min.z<=i.max.z&&this.max.z>=i.min.z}equals(i){return this.center.equals(i.center)&&this.extents.equals(i.extents)}expandByPoint(i){i.x<this.min.x&&(this.min.x=i.x),i.x>this.max.x&&(this.max.x=i.x),i.y<this.min.y&&(this.min.y=i.y),i.y>this.max.y&&(this.max.y=i.y),i.z<this.min.z&&(this.min.z=i.z),i.z>this.max.z&&(this.max.z=i.z)}static fromPoints(i){for(var e=new Ur(new p,new p),t=0;t<i.length;t++)e.expandByPoint(i[t]);return e}calculateTransform(i){}clone(){var i=new Ur(this.center.clone(),this.size.clone());return i}intersectsRay(i,e){throw new Error("Method not implemented.")}containsPoint(i){return this.min.x<=i.x&&this.max.x>=i.x&&this.min.y<=i.y&&this.max.y>=i.y&&this.min.z<=i.z&&this.max.z>=i.z}containsBox(i){let e=this.min,t=this.max;return e.x<=i.min.x&&e.y<=i.min.y&&e.z<=i.min.z&&t.x>=i.max.x&&t.y>=i.max.y&&t.z>=i.max.z}updateBound(){}destroy(i){this.center=null,this.extents=null,this.min=null,this.max=null,this.size=null}};let Be=Ur;n(Be,"maxVector3",new p(1,1,1).multiplyScalar(Number.MAX_VALUE*.1)),n(Be,"minVector3",new p(1,1,1).multiplyScalar(-Number.MAX_VALUE*.1));class xl{constructor(){n(this,"planes"),n(this,"corners"),n(this,"boundingBox",new Be),this.planes=[],this.corners=[];for(var e=0;e<6;e++)this.planes[e]=new p;for(var e=0;e<2*2*2;e++)this.corners[e]=new p}updateBoundBox(e){this.boundingBox.makeEmpty();let t=this.boundingBox.min,r=this.boundingBox.max,a=0;for(let s=0;s<2;++s)for(let o=0;o<2;++o)for(let l=0;l<2;++l){let h=this.corners[a];a++,h.set(2*s-1,2*o-1,l,1),e.transformVector4(h,h),h.div(h.w,h),t.x=Math.min(h.x,t.x),t.y=Math.min(h.y,t.y),t.z=Math.min(h.z,t.z),r.x=Math.max(h.x,r.x),r.y=Math.max(h.y,r.y),r.z=Math.max(h.z,r.z)}return this.boundingBox.setFromMinMax(t,r),this}setFrustumCorners(e){let t=0;for(let r=0;r<2;++r)for(let a=0;a<2;++a)for(let s=0;s<2;++s){let o=this.corners[t];o.set(2*r-1,2*a-1,s,1),e.transformVector4(o,o),o.div(o.w,o),t++}}update(e){var t=e.rawData;this.planes[0].x=t[3]-t[0],this.planes[0].y=t[7]-t[4],this.planes[0].z=t[11]-t[8],this.planes[0].w=t[15]-t[12];var r=Math.sqrt(this.planes[0].x*this.planes[0].x+this.planes[0].y*this.planes[0].y+this.planes[0].z*this.planes[0].z);this.planes[0].x/=r,this.planes[0].y/=r,this.planes[0].z/=r,this.planes[0].w/=r,this.planes[1].x=t[3]+t[0],this.planes[1].y=t[7]+t[4],this.planes[1].z=t[11]+t[8],this.planes[1].w=t[15]+t[12],r=Math.sqrt(this.planes[1].x*this.planes[1].x+this.planes[1].y*this.planes[1].y+this.planes[1].z*this.planes[1].z),this.planes[1].x/=r,this.planes[1].y/=r,this.planes[1].z/=r,this.planes[1].w/=r,this.planes[2].x=t[3]+t[1],this.planes[2].y=t[7]+t[5],this.planes[2].z=t[11]+t[9],this.planes[2].w=t[15]+t[13],r=Math.sqrt(this.planes[2].x*this.planes[2].x+this.planes[2].y*this.planes[2].y+this.planes[2].z*this.planes[2].z),this.planes[2].x/=r,this.planes[2].y/=r,this.planes[2].z/=r,this.planes[2].w/=r,this.planes[3].x=t[3]-t[1],this.planes[3].y=t[7]-t[5],this.planes[3].z=t[11]-t[9],this.planes[3].w=t[15]-t[13],r=Math.sqrt(this.planes[3].x*this.planes[3].x+this.planes[3].y*this.planes[3].y+this.planes[3].z*this.planes[3].z),this.planes[3].x/=r,this.planes[3].y/=r,this.planes[3].z/=r,this.planes[3].w/=r,this.planes[4].x=t[3]-t[2],this.planes[4].y=t[7]-t[6],this.planes[4].z=t[11]-t[10],this.planes[4].w=t[15]-t[14],r=Math.sqrt(this.planes[4].x*this.planes[4].x+this.planes[4].y*this.planes[4].y+this.planes[4].z*this.planes[4].z),this.planes[4].x/=r,this.planes[4].y/=r,this.planes[4].z/=r,this.planes[4].w/=r,this.planes[5].x=t[3]+t[2],this.planes[5].y=t[7]+t[6],this.planes[5].z=t[11]+t[10],this.planes[5].w=t[15]+t[14],r=Math.sqrt(this.planes[5].x*this.planes[5].x+this.planes[5].y*this.planes[5].y+this.planes[5].z*this.planes[5].z),this.planes[5].x/=r,this.planes[5].y/=r,this.planes[5].z/=r,this.planes[5].w/=r}containsPoint(e){for(var t=0;t<6;t++)if(this.planes[t].x*e.x+this.planes[t].y*e.y+this.planes[t].z*e.z+this.planes[t].w<=0)return!1;return!0}containsSphere(e){let t=e.bound,r=0,a,s=e.transform.worldPosition,o=t.radius,l=t.center.x+s.x,h=t.center.y+s.y,u=t.center.z+s.z;for(let c of this.planes){if(a=c.x*l+c.y*h+c.z*u+c.w,a<=-o)return 0;a>o&&r++}return r===6?2:1}containsBox(e){let t=0,r,s=Math.max(e.size.x,e.size.y,e.size.z)*2,o=e.center.x,l=e.center.y,h=e.center.z;for(let u of this.planes){if(r=u.x*o+u.y*l+u.z*h+u.w,r<=-s)return 0;r>s&&t++}return t===6?2:1}containsBox2(e){let t=0,r,a=1.74*Math.max(e.extents.x,e.extents.y,e.extents.z);for(let s of this.planes){if(r=s.x*e.center.x+s.y*e.center.y+s.z*e.center.z+s.w,r<=-a)return 0;r>a&&t++}return t===6?2:1}}var Ie=(i=>(i[i.ortho=0]="ortho",i[i.perspective=1]="perspective",i[i.shadow=2]="shadow",i))(Ie||{});class Rd{constructor(e){n(this,"corners"),n(this,"index"),this.index=e,this.corners=[];for(let t=0;t<4;t++)this.corners.push(new p)}}class Ld{constructor(e,t,r){n(this,"bound"),n(this,"twoSections"),n(this,"name"),n(this,"color"),n(this,"shadowCamera"),n(this,"index"),this.bound=new Be,this.shadowCamera=Oe.createCamera3DObject(null,"csmShadowCamera_"+r),this.shadowCamera.isShadowCamera=!0,this.shadowCamera.orthoOffCenter(100,-100,100,-100,1,1e4),this.twoSections=[e,t],this.index=r,r==0?this.color=new z(1,0,0,1):r==1?this.color=new z(0,1,0,1):r==2?this.color=new z(0,0,1,1):r==3&&(this.color=new z(0,1,1,1)),this.name="child_"+r}updateBound(){this.bound.makeEmpty();let e=this.bound.min,t=this.bound.max;for(let r of this.twoSections)for(let a of r.corners)e.x=Math.min(a.x,e.x),e.y=Math.min(a.y,e.y),e.z=Math.min(a.z,e.z),t.x=Math.max(a.x,t.x),t.y=Math.max(a.y,t.y),t.z=Math.max(a.z,t.z);return this.bound.setFromMinMax(e,t),this}}class yl{constructor(e){n(this,"sections"),n(this,"children"),n(this,"name"),this.sections=[];let t=e+1;for(let r=0;r<t;r++)this.sections.push(new Rd(r));this.children=[];for(let r=0;r<e;r++)this.children.push(new Ld(this.sections[r],this.sections[r+1],r))}update(e,t,r,a,s){let o=this.sections.length-1;for(let l=0;l<=o;++l){let h=this.sections[l],u=0,c=this.logSplit(r,a,l,this.sections.length);{let g=(c-r)/a;g=g**s.csmScatteringExp,c=(a-r)*g+r}c*=s.csmAreaScale;let d=(e.rawData[10]*c+e.rawData[14])/c;for(let g=0;g<2;++g)for(let m=0;m<2;++m){let A=h.corners[u];u++,A.set(2*g-1,2*m-1,d,1),t.transformVector4(A,A),A.div(A.w,A)}}for(let l of this.children)l.updateBound();return this}squareSplit(e,t,r,a){return(r/(a-1))**4*(t-e)+e}uniformSplit(e,t,r,a){return r/(a-1)*(t-e)+e}logSplit(e,t,r,a){return e*(t/e)**(r/(a-1))}}class Zi extends Ee{constructor(){super(),n(this,"fov",1),n(this,"name"),n(this,"aspect",1),n(this,"near",1),n(this,"far",5e3),n(this,"viewPort",new Lr),n(this,"frustum"),n(this,"isShadowCamera",!1),n(this,"_projectionMatrixInv",new H),n(this,"_projectionMatrix",new H),n(this,"_viewMatrix",new H),n(this,"_unprojection",new H),n(this,"_pvMatrixInv",new H),n(this,"_pvMatrix",new H),n(this,"_halfw"),n(this,"_halfh"),n(this,"_ray"),n(this,"_enableCSM",!1),n(this,"lookTarget"),n(this,"type",Ie.perspective),n(this,"csm"),n(this,"cubeShadowCameras",[]),n(this,"_haltonSeq"),n(this,"_jitterOffsetList"),n(this,"_useJitterProjection",!1),n(this,"_jitterFrameIndex",0),n(this,"_sampleIndex",0),n(this,"_jitterX",0),n(this,"_jitterY",0)}get projectionMatrix(){return this._projectionMatrix}get enableCSM(){return this._enableCSM}set enableCSM(e){e&&!this.csm&&(this.csm=new yl(nt.Cascades)),this._enableCSM=e}init(){super.init(),this._ray=new ci,this.frustum=new xl,this.viewPort.x=0,this.viewPort.y=0,this.viewPort.w=I.presentationSize[0],this.viewPort.h=I.presentationSize[1],this.lookTarget=new p(0,0,0)}getShadowBias(e){let t=2*this.getShadowWorldExtents()/e,r=this.far-this.near;return t/r}getShadowWorldExtents(){let e=_.setting.shadow.shadowBound;return e?e*=.5:e=Math.round(.05*this.frustum.boundingBox.extents.length),e}getCSMShadowBias(e,t){let r=2*this.getCSMShadowWorldExtents(e)/t,a=this.far-this.near;return r/a}getCSMShadowWorldExtents(e){return Math.round(this.csm.children[e].bound.extents.length)}perspective(e,t,r,a){this.fov=e,this.aspect=t,this.near=r,this.far=a,this._projectionMatrix.perspective(e,t,r,a),this.type=Ie.perspective}resetPerspective(e){this.type==Ie.perspective&&this._projectionMatrix.perspective(this.fov,e,this.near,this.far)}ortho(e,t,r,a){this.near=Math.max(r,.1),this.far=a,this._projectionMatrix.ortho(e,t,r,a),this.type=Ie.ortho}orthoOffCenter(e,t,r,a,s,o){this.near=Math.max(s,.01),this.far=o,this._projectionMatrix.orthoOffCenter(e,t,r,a,s,o),this.type=Ie.ortho}orthoZo(e,t,r,a,s,o){this.near=Math.max(s,.01),this.far=o,this._projectionMatrix.orthoZO(e,t,r,a,s,o),this.type=Ie.ortho}get viewMatrix(){return this._viewMatrix.copyFrom(this.transform.worldMatrix),this._viewMatrix.invert(),this._viewMatrix}get shadowViewMatrix(){return this._viewMatrix.copyFrom(this.transform.worldMatrix),this._viewMatrix.appendScale(1,1,1),this._viewMatrix.invert(),this._viewMatrix}object3DToScreenRay(e,t=null){return t||(t=new p(0,0,0,1)),this._halfw=this.viewPort.width*.5,this._halfh=this.viewPort.height*.5,et.transformVector(this.viewMatrix,e,t),this.project(t,t),t.x=this._halfw+t.x*this._halfw,t.y=this.viewPort.height-(this._halfh-t.y*this._halfh),t}screenRayToObject3D(e,t=null){t||(t=new p),this._halfw=this.viewPort.width*.5,this._halfh=this.viewPort.height*.5;let r=e.x,a=e.y;return t.x=r/this.viewPort.width-.25,t.y=a/this.viewPort.height-.25,this.unProject(t.x,t.y,e.z,t),t}get pvMatrix(){return ks(this._projectionMatrix,this.viewMatrix,this._pvMatrix),this._pvMatrix}get pvMatrix2(){ks(this._projectionMatrix,this.transform.worldMatrix,this._pvMatrix);let e=this._pvMatrixInv.copyFrom(this.pvMatrix);return e.invert(),e}get pvMatrixInv(){let e=this._pvMatrixInv.copyFrom(this.pvMatrix);return e.invert(),e}get projectionMatrixInv(){return this._projectionMatrixInv.copyFrom(this._projectionMatrix),this._projectionMatrixInv.invert(),this._projectionMatrixInv}unProject(e,t,r,a){return a||(a=new p),a.x=e,a.y=-t,a.z=r,a.w=1,a.x*=r,a.y*=r,this._unprojection.copyFrom(this._projectionMatrix),this._unprojection.invert(),et.transformVector(this._unprojection,a,a),a.z=r,a}project(e,t){return this._projectionMatrix.perspectiveMultiplyPoint3(e,t),t.x=t.x/t.w,t.y=-t.y/t.w,t.z=e.z,t}screenPointToRay(e,t){let r=this._ray,a=Oe.UnProjection(e,t,.01,this),s=Oe.UnProjection(e,t,1,this);return s=s.subtract(a).normalize(),r.origin.copyFrom(a),r.direction=s,r}screenPointToWorld(e,t,r){return Oe.UnProjection(e,t,r,this)}worldToScreenPoint(e,t){return Oe.Projection(e,this,t)}lookAt(e,t,r=p.Y_AXIS){this.transform.lookAt(e,t,r),t&&this.lookTarget.copyFrom(t)}resetProjectMatrix(){this.perspective(this.fov,this.aspect,this.near,this.far)}onUpdate(){var e;this.type==Ie.perspective&&(this.aspect=I.aspect,this.resetProjectMatrix()),this._useJitterProjection&&this.getJitteredProjectionMatrix(),this.frustum.update(this.pvMatrix),this.frustum.updateBoundBox(this.pvMatrixInv);let t=_.setting.shadow;this.enableCSM&&((e=this.csm)==null||e.update(this._projectionMatrix,this._pvMatrixInv,this.near,this.far,t))}get jitterFrameIndex(){return this._jitterFrameIndex}get jitterX(){return this._jitterX}get jitterY(){return this._jitterY}enableJitterProjection(e){this._jitterFrameIndex=0,this._useJitterProjection=e,this._haltonSeq||(this._haltonSeq=new La),this._jitterOffsetList=[];for(let t=0;t<8;t++){let r=this.generateRandomOffset();this._jitterOffsetList.push(r)}this._jitterOffsetList.reverse()}generateRandomOffset(){let e=new $(La.get((this._sampleIndex&1023)+1,2)-.5,La.get((this._sampleIndex&1023)+1,3)-.5);const t=8;return++this._sampleIndex>=t&&(this._sampleIndex=0),e}getJitteredProjectionMatrix(){let e=_.setting.render.postProcessing.taa,t=this._projectionMatrix,r=e.temporalJitterScale,a=this._jitterFrameIndex%e.jitterSeedCount,s=this._jitterOffsetList[a].x*r,o=this._jitterOffsetList[a].y*r,l=t.get(0,2),h=t.get(1,2);this._jitterX=s/this.viewPort.width,this._jitterY=o/this.viewPort.height,l+=this._jitterX,h+=this._jitterY,t.set(0,2,l),t.set(1,2,h),this._jitterFrameIndex++}getWorldDirection(e){e||(e=new p);const t=this.transform._worldMatrix.rawData;return e.set(-t[8],-t[9],-t[10]).normalize()}}const Or=class extends Ee{constructor(){super(),n(this,"eventPositionChange",new je(Or.POSITION_ONCHANGE)),n(this,"eventRotationChange",new je(Or.ROTATION_ONCHANGE)),n(this,"eventScaleChange",new je(Or.SCALE_ONCHANGE)),n(this,"eventLocalChange",new je(Or.LOCAL_ONCHANGE)),n(this,"onPositionChange"),n(this,"onRotationChange"),n(this,"onScaleChange"),n(this,"_scene3d"),n(this,"_parent"),n(this,"_localPos"),n(this,"_localRot"),n(this,"_localRotQuat"),n(this,"_localScale"),n(this,"_localDetailPos"),n(this,"_localDetailRot"),n(this,"_localDetailScale"),n(this,"index"),n(this,"index2"),n(this,"_forward",new p),n(this,"_back",new p),n(this,"_right",new p),n(this,"_left",new p),n(this,"_up",new p),n(this,"_down",new p),n(this,"_worldMatrix"),n(this,"_targetPos"),n(this,"static",!1),n(this,"depthOrder",0),this._worldMatrix=new H(!0),this.index=this._worldMatrix.index,this.index2=this._worldMatrix.index*te.stateStruct,this._localPos=new p,this._localRot=new p,this._localRotQuat=new K,this._localScale=new p(1,1,1),te.setScale(this.index,this._localScale.x,this._localScale.y,this._localScale.z),te.setRotation(this.index,this._localRot.x,this._localRot.y,this._localRot.z),te.setTranslate(this.index,this._localPos.x,this._localPos.y,this._localPos.z)}get localChange(){return te.matrixStateBuffer[this.index2]!=0}set localChange(i){te.matrixStateBuffer[this.index2]=i?1:0}get targetPos(){return this._targetPos}set targetPos(i){this._targetPos=i}get parent(){return this._parent}set parent(i){var e;let t=(e=this._parent)==null?void 0:e.object3D;if(this._parent=i,this.depthOrder=i?i.depthOrder+1:0,te.setParent(this.index,i?i.worldMatrix.index:-1,this.depthOrder),this.localChange=!0,this.object3D){let r=i?i.scene3D:null;r?(this._scene3d=r,this.object3D.components.forEach(a=>{se.appendWaitStart(a)})):this.object3D.components.forEach(a=>{a.__stop()});for(let a of this.object3D.entityChildren)a.transform.parent=i?this:null;this.object3D.components.forEach(a=>{var s,o;(o=a.onParentChange)==null||o.call(a,t,(s=this._parent)==null?void 0:s.object3D)})}this.notifyLocalChange()}set enable(i){this.transform._scene3d&&i?super.enable=!0:super.enable=!1;for(let e of this.object3D.entityChildren)e.transform.enable=i}get enable(){return this._enable}get scene3D(){return this._scene3d}set scene3D(i){this._scene3d=i}get view3D(){return this._scene3d&&this._scene3d.view?this._scene3d.view:null}awake(){}start(){}stop(){}notifyLocalChange(){if(this.localChange=!0,this.object3D){let i=this.object3D.entityChildren,e=0,t=i.length;for(e=0;e<t;e++)i[e].transform.notifyLocalChange()}this.eventDispatcher.dispatchEvent(this.eventLocalChange)}get up(){return this.worldMatrix.transformVector(p.UP,this._up),this._up}set up(i){this._up.copyFrom(i),et.fromToRotation(p.UP,this._up,K.HELP_0),this.transform.localRotQuat=K.HELP_0}get down(){return this.worldMatrix.transformVector(p.DOWN,this._down),this._down}set down(i){var e;this._down.copyFrom(i),et.fromToRotation(p.DOWN,this._down,K.HELP_0),this.transform.localRotQuat=K.HELP_0,this.notifyLocalChange(),(e=this.onRotationChange)==null||e.call(this),this.eventRotationChange&&this.eventDispatcher.dispatchEvent(this.eventRotationChange)}get forward(){return this.worldMatrix.transformVector(p.FORWARD,this._forward),this._forward}set forward(i){var e;this._forward.copyFrom(i),et.fromToRotation(p.FORWARD,this._forward,K.HELP_0),this.transform.localRotQuat=K.HELP_0,this.notifyLocalChange(),(e=this.onRotationChange)==null||e.call(this),this.eventRotationChange&&this.eventDispatcher.dispatchEvent(this.eventRotationChange)}get back(){return this.worldMatrix.transformVector(p.BACK,this._back),this._back}set back(i){this._back.copyFrom(i),et.fromToRotation(p.BACK,this._back,K.HELP_0),this.transform.localRotQuat=K.HELP_0}get left(){return this.worldMatrix.transformVector(p.neg_X_AXIS,this._left),this._left}set left(i){this._left.copyFrom(i),et.fromToRotation(p.LEFT,this._left,K.HELP_0),this.transform.localRotQuat=K.HELP_0}get right(){return this.worldMatrix.transformVector(p.X_AXIS,this._right),this._right}set right(i){var e;this._right.copyFrom(i),et.fromToRotation(p.RIGHT,this._right,K.HELP_0),this.transform.localRotQuat=K.HELP_0,this.notifyLocalChange(),(e=this.onRotationChange)==null||e.call(this),this.eventRotationChange&&this.eventDispatcher.dispatchEvent(this.eventRotationChange)}get localRotQuat(){return this._localRotQuat}set localRotQuat(i){var e;(i.x!=this._localRotQuat.x||i.y!=this._localRotQuat.y||i.z!=this._localRotQuat.z||i.w!=this._localRotQuat.w)&&(this._localRotQuat.copyFrom(i),this._localRotQuat.getEulerAngles(this._localRot),te.setRotation(this.index,this._localRot.x,this._localRot.y,this._localRot.z),this.notifyLocalChange(),(e=this.onRotationChange)==null||e.call(this),this.eventRotationChange&&this.eventDispatcher.dispatchEvent(this.eventRotationChange))}notifyChange(){var i,e,t;this.notifyLocalChange(),(i=this.onRotationChange)==null||i.call(this),(e=this.onScaleChange)==null||e.call(this),(t=this.onPositionChange)==null||t.call(this),this.eventRotationChange&&this.eventDispatcher.dispatchEvent(this.eventRotationChange),this.eventPositionChange&&this.eventDispatcher.dispatchEvent(this.eventPositionChange),this.eventScaleChange&&this.eventDispatcher.dispatchEvent(this.eventScaleChange)}get worldMatrix(){return this.updateWorldMatrix(),this._worldMatrix}updateWorldMatrix(i=!1){(this.localChange||i)&&(this.parent?(Ra(this._localRot,this._localPos,this._localScale,this._worldMatrix),_l(this._worldMatrix,this.parent.worldMatrix,this._worldMatrix)):Ra(this._localRot,this._localPos,this._localScale,this._worldMatrix),this.localChange=!1)}updateChildTransform(){let i=this;if(i.localChange&&i.updateWorldMatrix(),i.object3D.numChildren>0)for(const e of i.object3D.entityChildren)e.transform.updateChildTransform()}lookTarget(i,e=p.UP){this.lookAt(this.transform.worldPosition,i,e)}lookAt(i,e,t=p.UP){this._targetPos||(this._targetPos=new p),this._targetPos.copyFrom(e),this.localPosition=i,H.helpMatrix.lookAt(i,e,t),H.helpMatrix.invert();var r=H.helpMatrix.decompose(vt.QUATERNION);this.localRotQuat=K.CALCULATION_QUATERNION.copyFrom(r[1])}decomposeFromMatrix(i,e="eulerAngles"){let t=i.decompose(e),r=this.transform;return r.localRotQuat.copyFrom(t[1]),r.localRotQuat=r.localRotQuat,r.localPosition.copyFrom(t[0]),r.localPosition=r.localPosition,r.localScale.copyFrom(t[2]),r.localScale=r.localScale,this}cloneTo(i){i.transform.localPosition=this.localPosition,i.transform.localRotation=this.localRotation,i.transform.localScale=this.localScale}set x(i){var e;this._localPos.x!=i&&(this._localPos.x=i,te.setTranslate(this.index,this._localPos.x,this._localPos.y,this._localPos.z),this.notifyLocalChange(),(e=this.onPositionChange)==null||e.call(this),this.eventPositionChange&&this.eventDispatcher.dispatchEvent(this.eventPositionChange))}get x(){return this._localPos.x}set y(i){var e;this._localPos.y!=i&&(this._localPos.y=i,te.setTranslate(this.index,this._localPos.x,this._localPos.y,this._localPos.z),this.notifyLocalChange(),(e=this.onPositionChange)==null||e.call(this),this.eventPositionChange&&this.eventDispatcher.dispatchEvent(this.eventPositionChange))}get y(){return this._localPos.y}set z(i){var e;this._localPos.z!=i&&(this._localPos.z=i,te.setTranslate(this.index,this._localPos.x,this._localPos.y,this._localPos.z),this.notifyLocalChange(),(e=this.onPositionChange)==null||e.call(this),this.eventPositionChange&&this.eventDispatcher.dispatchEvent(this.eventPositionChange))}get z(){return this._localPos.z}set scaleX(i){var e;this._localScale.x!=i&&(this._localScale.x=i,te.setScale(this.index,this._localScale.x,this._localScale.y,this._localScale.z),this.notifyLocalChange(),(e=this.onScaleChange)==null||e.call(this),this.eventScaleChange&&this.eventDispatcher.dispatchEvent(this.eventScaleChange))}get scaleX(){return this._localScale.x}set scaleY(i){var e;this._localScale.y!=i&&(this._localScale.y=i,te.setScale(this.index,this._localScale.x,this._localScale.y,this._localScale.z),this.notifyLocalChange(),(e=this.onScaleChange)==null||e.call(this),this.eventScaleChange&&this.eventDispatcher.dispatchEvent(this.eventScaleChange))}get scaleY(){return this._localScale.y}set scaleZ(i){var e;this._localScale.z!=i&&(this._localScale.z=i,te.setScale(this.index,this._localScale.x,this._localScale.y,this._localScale.z),this.notifyLocalChange(),(e=this.onScaleChange)==null||e.call(this),this.eventScaleChange&&this.eventDispatcher.dispatchEvent(this.eventScaleChange))}get scaleZ(){return this._localScale.z}set rotationX(i){var e;this._localRot.x!=i&&(this._localRot.x=i,te.setRotation(this.index,this._localRot.x,this._localRot.y,this._localRot.z),this.notifyLocalChange(),(e=this.onRotationChange)==null||e.call(this),this.eventRotationChange&&this.eventDispatcher.dispatchEvent(this.eventRotationChange))}get rotationX(){return this._localRot.x}set rotationY(i){var e;this._localRot.y!=i&&(this._localRot.y=i,te.setRotation(this.index,this._localRot.x,this._localRot.y,this._localRot.z),this.notifyLocalChange(),(e=this.onRotationChange)==null||e.call(this),this.eventRotationChange&&this.eventDispatcher.dispatchEvent(this.eventRotationChange))}get rotationY(){return this._localRot.y}set rotationZ(i){var e;this._localRot.z!=i&&(this._localRot.z=i,te.setRotation(this.index,this._localRot.x,this._localRot.y,this._localRot.z),this.notifyLocalChange(),(e=this.onRotationChange)==null||e.call(this),this.eventRotationChange&&this.eventDispatcher.dispatchEvent(this.eventRotationChange))}get rotationZ(){return this._localRot.z}get worldPosition(){return this.localChange&&this.updateWorldMatrix(),this._worldMatrix.position}set localPosition(i){var e;this._localPos.copyFrom(i),te.setTranslate(this.index,i.x,i.y,i.z),this.notifyLocalChange(),(e=this.onPositionChange)==null||e.call(this),this.eventPositionChange&&this.eventDispatcher.dispatchEvent(this.eventPositionChange)}get localPosition(){return this._localPos}set localRotation(i){var e;te.setRotation(this.index,i.x,i.y,i.z),this._localRot.copyFrom(i),this.notifyLocalChange(),(e=this.onRotationChange)==null||e.call(this),this.eventRotationChange&&this.eventDispatcher.dispatchEvent(this.eventRotationChange)}get localRotation(){return this._localRot}set localScale(i){var e;te.setScale(this.index,i.x,i.y,i.z),this._localScale.copyFrom(i),this.notifyLocalChange(),(e=this.onScaleChange)==null||e.call(this),this.eventScaleChange&&this.eventDispatcher.dispatchEvent(this.eventScaleChange)}get localScale(){return this._localScale}get localDetailScale(){return this._localDetailScale}set localDetailScale(i){this._localDetailScale=i,te.setContinueScale(this.index,i.x,i.y,i.z)}get localDetailRot(){return this._localDetailRot}set localDetailRot(i){this._localDetailRot=i,te.setContinueRotation(this.index,i.x,i.y,i.z)}get localDetailPos(){return this._localDetailPos}set localDetailPos(i){this._localDetailPos=i,te.setContinueTranslate(this.index,i.x,i.y,i.z)}beforeDestroy(i){this.parent&&this.parent.object3D&&this.parent.object3D.removeChild(this.object3D),super.beforeDestroy(i)}destroy(){super.destroy(),this.scene3D=null,this.eventPositionChange=null,this.eventRotationChange=null,this.eventScaleChange=null,this.onPositionChange=null,this.onRotationChange=null,this.onScaleChange=null,this._scene3d=null,this._parent=null,this._localPos=null,this._localRot=null,this._localRotQuat=null,this._localScale=null,this._forward=null,this._back=null,this._right=null,this._left=null,this._up=null,this._down=null,this.localChange=null,this._targetPos=null}};let Ue=Or;n(Ue,"LIMIT",1),n(Ue,"COMPONENT_NAME","UUTransform"),n(Ue,"COMPONENT_TYPE","Transform"),n(Ue,"POSITION_ONCHANGE","POSITION_ONCHANGE"),n(Ue,"ROTATION_ONCHANGE","ROTATION_ONCHANGE"),n(Ue,"SCALE_ONCHANGE","SCALE_ONCHANGE"),n(Ue,"PARENT_ONCHANGE","PARENT_ONCHANGE"),n(Ue,"CHILDREN_ONCHANGE","CHILDREN_ONCHANGE"),n(Ue,"ADD_ONCHANGE","ADD_ONCHANGE"),n(Ue,"LOCAL_ONCHANGE","LOCAL_ONCHANGE");const Cl=class{static genMeshBounds(i,e){let t=this.genMeshMinVector,r=this.genMeshMaxVector,a=this.genMeshVectorList8;e||(e=new Be(p.ZERO,p.ZERO)),e.setFromMinMax(this.maxVector,this.minVector);let s=i.getComponents(ue);for(const o of s)if(o&&o.geometry){let l=o.object3D.transform.worldMatrix;t.copy(o.geometry.bounds.min),r.copy(o.geometry.bounds.max),a[0].set(t.x,t.y,t.z),a[1].set(t.x,t.y,r.z),a[2].set(t.x,r.y,t.z),a[3].set(t.x,r.y,r.z),a[4].set(r.x,t.y,t.z),a[5].set(r.x,t.y,r.z),a[6].set(r.x,r.y,t.z),a[7].set(r.x,r.y,r.z);for(const h of a)l.transformPoint(h,h),e.expandByPoint(h)}return r.copyFrom(e.max),t.copyFrom(e.min),e.setFromMinMax(t,r),e}static transformBound(i,e,t){let r=this.genMeshMinVector.copyFrom(e.min),a=this.genMeshMaxVector.copyFrom(e.max),s=this.genMeshVectorList8;t||(t=new Be(p.ZERO,p.ZERO)),t.setFromMinMax(this.maxVector,this.minVector),s[0].set(r.x,r.y,r.z),s[1].set(r.x,r.y,a.z),s[2].set(r.x,a.y,r.z),s[3].set(r.x,a.y,a.z),s[4].set(a.x,r.y,r.z),s[5].set(a.x,r.y,a.z),s[6].set(a.x,a.y,r.z),s[7].set(a.x,a.y,a.z);for(const o of s)i.transformPoint(o,o),t.expandByPoint(o);return a.copyFrom(t.max),r.copyFrom(t.min),t.setFromMinMax(r,a),t}};let Kt=Cl;n(Kt,"maxVector",new p(Number.MAX_VALUE*.1,Number.MAX_VALUE*.1,Number.MAX_VALUE*.1)),n(Kt,"minVector",Cl.maxVector.clone().multiplyScalar(-1)),n(Kt,"genMeshMaxVector",p.ZERO.clone()),n(Kt,"genMeshMinVector",p.ZERO.clone()),n(Kt,"genMeshVectorList8",[new p,new p,new p,new p,new p,new p,new p,new p]);class bl extends hi{constructor(){super(),n(this,"name",""),n(this,"_instanceID",""),n(this,"_numChildren"),n(this,"transform"),n(this,"renderNode"),n(this,"entityChildren"),n(this,"components"),n(this,"waitDisposeComponents"),n(this,"_bound"),n(this,"_boundWorld"),n(this,"_isBoundChange",!0),n(this,"_dispose",!1),this.entityChildren=[],this.components=new Map,this._instanceID=Ds().toString(),this.waitDisposeComponents=[]}get instanceID(){return this._instanceID}getObjectByName(e){if(e.indexOf("/")>=0){let r=e.split("/"),a=this;for(;r.length>0&&a;){let s=r.shift();if(a=a.getChildByName(s,!1),!a)return null}return a}else return this.getChildByName(e,!1)}get numChildren(){return this._numChildren}addChild(e){return e==null?new console.error("child is null!"):e===this?new console.error("child is self!"):this.entityChildren.indexOf(e)==-1?(e.removeFromParent(),e.transform.parent=this.transform,this.entityChildren.push(e),this._numChildren=this.entityChildren.length,e):null}removeChild(e){if(e===null)return new console.error("remove child is null!");if(e===this)return new console.error("add child is self!");let t=this.entityChildren.indexOf(e);t!=-1&&(this.entityChildren.splice(t,1),e.transform.parent=null,this._numChildren=this.entityChildren.length)}removeAllChild(){for(;this.numChildren>0;)this.removeChild(this.entityChildren[0])}removeSelf(){return this.removeFromParent()}removeChildByIndex(e){e>=0&&e<this.entityChildren.length?this.removeChild(this.entityChildren[e]):console.error("remove child by index , index out of range")}hasChild(e){return this.entityChildren.indexOf(e)!=-1}removeFromParent(){let e=this.transform.parent;return e&&e.object3D&&e.object3D.removeChild(this),this}getChildByIndex(e){let t=null;return e<this.entityChildren.length&&(t=this.entityChildren[e]),t}getChildByName(e,t=!0){let r=null;for(const a of this.entityChildren){if(a.name==e)return r=a,r;if(t&&(r=a.getChildByName(e,t),r))return r}return r}update(){}instantiate(){return null}onTransformLocalChange(e){this._isBoundChange=!0}get bound(){return(this._isBoundChange||!this._bound)&&this.updateBound(),this._boundWorld}set bound(e){this._bound=e,this._boundWorld=this._bound.clone(),this._isBoundChange=!0}updateBound(){return this._bound||(this._bound=new Be,this._boundWorld=this._bound.clone(),this._isBoundChange=!0),this._isBoundChange&&(Kt.transformBound(this.transform.worldMatrix,this._bound,this._boundWorld),this._isBoundChange=!1),this._boundWorld}waitUpdate(){this._dispose?(this.transform.parent&&this.transform.parent.object3D.removeChild(this),this.components.forEach((e,t)=>{e.enable=!1,e.destroy()}),this.components.clear()):se.waitStartComponent.forEach((e,t)=>{for(;e.length>0;)e.shift().__start();se.waitStartComponent.delete(t)})}destroy(e){this._dispose||(this.components.forEach(t=>{t.beforeDestroy(e)}),this.components.forEach(t=>{t.destroy(e)}),this.components.clear(),this.entityChildren.forEach(t=>{t.destroy(e)}),this.removeAllChild(),this.transform.parent=null,this._dispose=!0,super.destroy())}}var Ud=Object.defineProperty,Od=Object.getOwnPropertyDescriptor,Nd=(i,e,t,r)=>{for(var a=r>1?void 0:r?Od(e,t):e,s=i.length-1,o;s>=0;s--)(o=i[s])&&(a=(r?o(e,t,a):o(a))||a);return r&&a&&Ud(e,t,a),a};f.Object3D=class extends bl{constructor(){super(),n(this,"_isScene3D"),n(this,"prefabRef"),n(this,"serializeTag"),this.transform=this.addComponent(Ue),this.transform.eventDispatcher.addEventListener(Ue.LOCAL_ONCHANGE,this.onTransformLocalChange,this)}get isScene3D(){return this._isScene3D}forChild(e){this.entityChildren.forEach(t=>{e(t),t.forChild(e)})}addComponent(e,t){let r=e.name;if(!this.components.has(r)){let a=new e;return a.object3D=this,this.components.set(r,a),a.__init(t),se.appendWaitStart(a),a}return null}getOrAddComponent(e){let t=e.name,r=this.components.get(t);return r||(r=this.addComponent(e)),r}removeComponent(e){let t=e.name;if(this.components.has(t)){let r=this.components.get(t);se.removeWaitStart(this,r),this.components.delete(t),r.__stop(),r.beforeDestroy(),r.destroy()}}hasComponent(e){let t=e.name;return this.components.has(t)}getComponent(e){let t=e.name;return this.components.get(t)}getComponentFromParent(e){if(!this.parent)return null;let t=this.parent.object3D.getComponent(e);return t||this.parent.object3D.getComponentFromParent(e)}getComponentsInChild(e){let t=[],r=e.name,a=this.components.get(r);a&&t.push(a);for(let s=0;s<this.entityChildren.length;s++){let l=this.entityChildren[s].getComponentsInChild(e);t.push(...l)}return t}getComponents(e,t,r){t||(t=[]);let a=this.getComponent(e);a&&(a.enable||r)&&t.push(a);for(let s=0,o=this.entityChildren.length;s<o;s++){let l=this.entityChildren[s];l&&l instanceof f.Object3D&&l.getComponents(e,t,r)}return t}getComponentsExt(e,t,r){t||(t=[]);let a=this.components.get(e.name);if(a&&(a.enable||r))t.push(a);else for(const s of this.entityChildren)s instanceof f.Object3D&&s.getComponentsExt(e,t,r);return t}getComponentsByProperty(e,t,r=!0,a,s){a||(a=[]);let o;for(const l of this.components.values())l&&(l.enable||s)&&l[e]==t&&(a.push(l),o=!0);if(!(o&&r))for(const l of this.entityChildren)l instanceof f.Object3D&&l.getComponentsByProperty(e,t,r,a,s);return a}clone(){return this.instantiate()}instantiate(){let e=new f.Object3D;return e.name=this.name,e.serializeTag=this.serializeTag,e.prefabRef=this.prefabRef,this.entityChildren.forEach((t,r)=>{let a=t.instantiate();e.addChild(a)}),this.components.forEach((t,r)=>{t.cloneTo(e)}),e}get localPosition(){return this.transform.localPosition}set localPosition(e){this.transform.localPosition=e}get localRotation(){return this.transform.localRotation}set localRotation(e){this.transform.localRotation=e}get localScale(){return this.transform.localScale}set localScale(e){this.transform.localScale=e}get localQuaternion(){return this.transform.localRotQuat}set localQuaternion(e){this.transform.localRotQuat=e}notifyChange(){this.transform.notifyChange()}get parent(){return this.transform.parent}get parentObject(){return this.transform.parent.object3D}set x(e){this.transform.x=e}get x(){return this.transform.x}set y(e){this.transform.y=e}get y(){return this.transform.y}set z(e){this.transform.z=e}get z(){return this.transform.z}set scaleX(e){this.transform.scaleX=e}get scaleX(){return this.transform.scaleX}set scaleY(e){this.transform.scaleY=e}get scaleY(){return this.transform.scaleY}set scaleZ(e){this.transform.scaleZ=e}get scaleZ(){return this.transform.scaleZ}set rotationX(e){this.transform.rotationX=e}get rotationX(){return this.transform.rotationX}set rotationY(e){this.transform.rotationY=e}get rotationY(){return this.transform.rotationY}set rotationZ(e){this.transform.rotationZ=e}get rotationZ(){return this.transform.rotationZ}fixedUpdate(){}lateUpdate(){}traverse(e){e(this);for(let t=0,r=this.entityChildren.length;t<r;t++){let a=this.entityChildren[t];a instanceof f.Object3D&&a.traverse(e)}}destroy(e){this.transform.eventDispatcher.removeEventListener(Ue.LOCAL_ONCHANGE,this.onTransformLocalChange,this),super.destroy(e)}},f.Object3D=Nd([Fd],f.Object3D);function Fd(i,e){return class extends f.Object3D{set active(t){this.transform.enable=t>0}get active(){return this.transform.enable?1:0}get materialColor(){var t;let r=this.getComponent(ue);return(t=r?.material)==null?void 0:t.defaultPass.baseColor}set materialColor(t){var r;let a=(r=this.getComponent(ue))==null?void 0:r.material;a&&(a.defaultPass.baseColor=t)}notifyMaterialColorChange(t,r){var a;let s=this.getComponent(ue).materials;(a=s?.[t])==null||a.defaultPass.uniforms[r].onChange()}}}class Oe{static createCamera3DObject(e,t){return this.createCamera3D(null,e,t)}static createCamera3D(e,t,r){return e||(e=new f.Object3D),t&&t.addChild(e),r&&(e.name=r),e.getOrAddComponent(Zi)}static UnProjection(e,t,r=1,a){let s=new p(e,t,0),o=1,l=p.HELP_0,h=I.canvas.offsetLeft,u=I.canvas.offsetTop,c=I.canvas.clientWidth,d=I.canvas.clientHeight;l.x=((s.x-h)*o/c-.5)*2,l.y=-((s.y-u)*o/d-.5)*2,l.z=r;let g=new p(0,0,0),m=H.helpMatrix2;m.copyFrom(a.projectionMatrix),m.invert();let A=H.helpMatrix;return A.identity(),A.multiply(m),A.multiply(a.transform.worldMatrix),A.perspectiveMultiplyPoint3(l,g),g}static Projection(e,t,r){let a=r||new p(0,0,0),s=H.helpMatrix;s.copyFrom(t.viewMatrix),s.multiply(t.projectionMatrix),s.perspectiveMultiplyPoint3(e,a);let o=I.canvas.clientWidth/2,l=I.canvas.clientHeight/2;return a.x=a.x*o+o,a.y=l-a.y*l,a}static UnProjection2(e,t,r,a,s){let o=s||new p(0,0,0),l=H.helpMatrix;l.copyFrom(a.pvMatrixInv);let h=I.canvas.clientWidth/2,u=I.canvas.clientHeight/2;return o.x=(e-h)/h,o.y=(u-t)/u,o.z=r,l.perspectiveMultiplyPoint3(o,o),o}}const zs=class{static init(){this.directionLightList=new Map,this.pointLightList=new Map,this.shadowBuffer=new Map,this.shadowLights=new Map}static createBuffer(i){if(!this.shadowBuffer.has(i)){let e=new fe(20);e.visibility=GPUShaderStage.FRAGMENT,this.shadowBuffer.set(i,e),e.setInt32("nDirShadowStart",0),e.setInt32("nDirShadowEnd",1),e.setInt32("nPointShadowStart",0),e.setInt32("nPointShadowEnd",0);let t=new Uint32Array(16);this.shadowLights.set(i,t),e.setUint32Array("shadowLights",t),e.apply()}}static getShadowLightList(i){if(!i.transform.view3D)return null;if(i.lightData.lightType==ze.DirectionLight){let e=this.directionLightList.get(i.transform.view3D.scene);return e||(e=[],this.directionLightList.set(i.transform.view3D.scene,e)),e}else if(i.lightData.lightType==ze.PointLight){let e=this.pointLightList.get(i.transform.view3D.scene);return e||(e=[],this.pointLightList.set(i.transform.view3D.scene,e)),e}else if(i.lightData.lightType==ze.SpotLight){let e=this.pointLightList.get(i.transform.view3D.scene);return e||(e=[],this.pointLightList.set(i.transform.view3D.scene,e)),e}}static getShadowLightWhichScene(i,e){if(e==ze.DirectionLight){let t=this.directionLightList.get(i);return t||(t=[],this.directionLightList.set(i,t)),t}else if(e==ze.PointLight){let t=this.pointLightList.get(i);return t||(t=[],this.pointLightList.set(i,t)),t}}static getDirectShadowLightWhichScene(i){let e=this.directionLightList.get(i);return e||(e=[],this.directionLightList.set(i,e)),e}static getPointShadowLightWhichScene(i){let e=this.pointLightList.get(i);return e||(e=[],this.pointLightList.set(i,e)),e}static addShadowLight(i){if(!i.transform.view3D)return null;let e=i.transform.view3D.scene;if(i.lightData.lightType==ze.DirectionLight){let t=this.directionLightList.get(e);if(t||(t=[],this.directionLightList.set(e,t)),!i.shadowCamera){i.shadowCamera=Oe.createCamera3DObject(null,"shadowCamera"),i.shadowCamera.isShadowCamera=!0;let r=-1e3;i.shadowCamera.orthoOffCenter(r,-r,r,-r,1,1e4)}return t.indexOf(i)==-1&&t.push(i),t}else if(i.lightData.lightType==ze.PointLight||i.lightData.lightType==ze.SpotLight){let t=this.pointLightList.get(e);return t&&t.length>=8||(t||(t=[],this.pointLightList.set(e,t)),t.indexOf(i)==-1&&t.push(i)),t}}static removeShadowLight(i){if(i.lightData.castShadowIndex=-1,!i.transform.view3D)return null;if(i.lightData.lightType==ze.DirectionLight){let e=this.directionLightList.get(i.transform.view3D.scene);if(e){let t=e.indexOf(i);t!=-1&&e.splice(t,1)}return i.lightData.castShadowIndex=-1,e}else if(i.lightData.lightType==ze.PointLight||i.lightData.lightType==ze.SpotLight){let e=this.pointLightList.get(i.transform.view3D.scene);if(e){let t=e.indexOf(i);t!=-1&&e.splice(t,1)}return i.lightData.castShadowIndex=-1,e}}static update(i){let e=this.shadowBuffer.get(i),t=this.shadowLights.get(i),r=zs.directionLightList.get(i),a=zs.pointLightList.get(i),s=0,o=0,l=0,h=0;if(t.fill(0),r){let u=0;for(let c=0;c<r.length;c++){const d=r[c];t[c]=d.lightData.index,d.lightData.castShadowIndex=u++}o=r.length}if(e.setInt32("nDirShadowStart",s),e.setInt32("nDirShadowEnd",o),a){l=o;let u=0;for(let c=l;c<a.length;c++){const d=a[c];t[c]=d.lightData.index,d.lightData.castShadowIndex=u++}h=l+a.length}e.setInt32("nPointShadowStart",l),e.setInt32("nPointShadowEnd",h),e.setUint32Array("shadowLights",t),e.apply()}};let Ge=zs;n(Ge,"maxNumDirectionShadow",8),n(Ge,"maxNumPointShadow",8),n(Ge,"directionLightList"),n(Ge,"pointLightList"),n(Ge,"shadowBuffer"),n(Ge,"shadowLights");class Nr{static getGlobalDataBindGroupLayout(){if(this._globalDataBindGroupLayout)return this._globalDataBindGroupLayout;let e=[];return e.push({binding:0,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,buffer:{type:"uniform"}}),e.push({binding:1,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}}),this._globalDataBindGroupLayout=I.device.createBindGroupLayout({entries:e}),this._globalDataBindGroupLayout}}n(Nr,"_globalDataBindGroupLayout");class wl{constructor(e){n(this,"uuid"),n(this,"usage"),n(this,"globalBindGroup"),n(this,"uniformGPUBuffer"),n(this,"matrixBindGroup"),n(this,"uniformByteLength"),n(this,"matrixesByteLength"),n(this,"shadowMatrixRaw",new Float32Array(8*16)),n(this,"csmMatrixRaw",new Float32Array(nt.Cascades*16)),n(this,"csmShadowBias",new Float32Array(4)),this.uuid=Mt(),this.usage=GPUBufferUsage.UNIFORM|GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,this.uniformGPUBuffer=new Dt(32*4*4+3*4*4+8*16+nt.Cascades*16+4+4),this.uniformGPUBuffer.visibility=GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,this.matrixBindGroup=e,this.createBindGroup()}createBindGroup(){this.uniformByteLength=this.uniformGPUBuffer.memory.shareDataBuffer.byteLength,this.matrixesByteLength=H.blockBytes*H.maxCount,this.globalBindGroup=I.device.createBindGroup({label:"global_bindGroupLayout",layout:Nr.getGlobalDataBindGroupLayout(),entries:[{binding:0,resource:{buffer:this.uniformGPUBuffer.buffer,offset:0,size:this.uniformByteLength}},{binding:1,resource:{buffer:this.matrixBindGroup.matrixBufferDst.buffer,offset:0,size:this.matrixesByteLength}}]})}setCamera(e){this.uniformGPUBuffer.setMatrix("_projectionMatrix",e.projectionMatrix),this.uniformGPUBuffer.setMatrix("_viewMatrix",e.viewMatrix),this.uniformGPUBuffer.setMatrix("_cameraWorldMatrix",e.transform.worldMatrix),this.uniformGPUBuffer.setMatrix("pvMatrixInv",e.projectionMatrixInv);let t=Ge.getDirectShadowLightWhichScene(e.transform.scene3D);this.csmShadowBias.fill(1e-4),this.shadowMatrixRaw.fill(0),this.csmMatrixRaw.fill(0);for(let o=0;o<8;o++)if(o<t.length){let l=t[o].shadowCamera;this.shadowMatrixRaw.set(l.pvMatrix.rawData,o*16)}else this.shadowMatrixRaw.set(e.transform.worldMatrix.rawData,o*16);this.uniformGPUBuffer.setFloat32Array("shadowMatrix",this.shadowMatrixRaw);let r=_.setting.shadow.shadowSize;if(nt.Cascades>1&&e.enableCSM&&t[0])for(let o=0;o<nt.Cascades;o++){let l=e.csm.children[o].shadowCamera;this.csmMatrixRaw.set(l.pvMatrix.rawData,o*16),this.csmShadowBias[o]=e.getCSMShadowBias(o,r)}this.uniformGPUBuffer.setFloat32Array("csmShadowBias",this.csmShadowBias),this.uniformGPUBuffer.setFloat32Array("csmMatrix",this.csmMatrixRaw),this.uniformGPUBuffer.setVector3("CameraPos",e.transform.worldPosition),this.uniformGPUBuffer.setFloat("frame",he.frame),this.uniformGPUBuffer.setFloat("time",he.frame),this.uniformGPUBuffer.setFloat("delta",he.delta),this.uniformGPUBuffer.setFloat("shadowBias",e.getShadowBias(r)),this.uniformGPUBuffer.setFloat("skyExposure",_.setting.sky.skyExposure),this.uniformGPUBuffer.setFloat("renderPassState",_.setting.render.renderPassState),this.uniformGPUBuffer.setFloat("quadScale",_.setting.render.quadScale),this.uniformGPUBuffer.setFloat("hdrExposure",_.setting.render.hdrExposure),this.uniformGPUBuffer.setInt32("renderState_left",_.setting.render.renderState_left),this.uniformGPUBuffer.setInt32("renderState_right",_.setting.render.renderState_right),this.uniformGPUBuffer.setFloat("renderState_split",_.setting.render.renderState_split);let a=_.inputSystem.mouseX*I.pixelRatio,s=_.inputSystem.mouseY*I.pixelRatio;this.uniformGPUBuffer.setFloat("mouseX",a),this.uniformGPUBuffer.setFloat("mouseY",s),this.uniformGPUBuffer.setFloat("windowWidth",I.windowWidth),this.uniformGPUBuffer.setFloat("windowHeight",I.windowHeight),this.uniformGPUBuffer.setFloat("near",e.near),this.uniformGPUBuffer.setFloat("far",e.far),this.uniformGPUBuffer.setFloat("pointShadowBias",_.setting.shadow.pointShadowBias),this.uniformGPUBuffer.setFloat("shadowMapSize",r),this.uniformGPUBuffer.setFloat("shadowSoft",_.setting.shadow.shadowSoft),this.uniformGPUBuffer.setFloat("enableCSM",e.enableCSM?1:0),this.uniformGPUBuffer.setFloat("csmMargin",_.setting.shadow.csmMargin),this.uniformGPUBuffer.apply()}setShadowCamera(e){this.uniformGPUBuffer.setMatrix("_projectionMatrix",e.projectionMatrix),this.uniformGPUBuffer.setMatrix("_viewMatrix",e.viewMatrix),this.uniformGPUBuffer.setMatrix("_pvMatrix",e.pvMatrix),this.uniformGPUBuffer.setMatrix("pvMatrixInv",e.projectionMatrixInv),this.csmShadowBias.fill(1e-4),this.shadowMatrixRaw.fill(0),this.csmMatrixRaw.fill(0),this.uniformGPUBuffer.setFloat32Array("shadowCamera",this.shadowMatrixRaw),this.uniformGPUBuffer.setFloat32Array("csmShadowBias",this.csmShadowBias),this.uniformGPUBuffer.setFloat32Array("csmMatrix",this.csmMatrixRaw),this.uniformGPUBuffer.setVector3("CameraPos",e.transform.worldPosition),this.uniformGPUBuffer.setFloat("frame",he.frame),this.uniformGPUBuffer.setFloat("time",he.frame),this.uniformGPUBuffer.setFloat("delta",he.delta),this.uniformGPUBuffer.setFloat("shadowBias",1e-4),this.uniformGPUBuffer.setFloat("skyExposure",_.setting.sky.skyExposure),this.uniformGPUBuffer.setFloat("renderPassState",_.setting.render.renderPassState),this.uniformGPUBuffer.setFloat("quadScale",_.setting.render.quadScale),this.uniformGPUBuffer.setFloat("hdrExposure",_.setting.render.hdrExposure),this.uniformGPUBuffer.setInt32("renderState_left",_.setting.render.renderState_left),this.uniformGPUBuffer.setInt32("renderState_right",_.setting.render.renderState_right),this.uniformGPUBuffer.setFloat("renderState_split",_.setting.render.renderState_split);let t=_.inputSystem.mouseX*I.pixelRatio,r=_.inputSystem.mouseY*I.pixelRatio;this.uniformGPUBuffer.setFloat("mouseX",t),this.uniformGPUBuffer.setFloat("mouseY",r),this.uniformGPUBuffer.setFloat("windowWidth",I.windowWidth),this.uniformGPUBuffer.setFloat("windowHeight",I.windowHeight),this.uniformGPUBuffer.setFloat("near",e.near),this.uniformGPUBuffer.setFloat("far",e.far),this.uniformGPUBuffer.setFloat("pointShadowBias",_.setting.shadow.pointShadowBias),this.uniformGPUBuffer.setFloat("shadowMapSize",_.setting.shadow.shadowSize),this.uniformGPUBuffer.setFloat("shadowSoft",_.setting.shadow.shadowSoft),this.uniformGPUBuffer.setFloat("enableCSM",0),this.uniformGPUBuffer.setFloat("csmMargin",_.setting.shadow.csmMargin),this.uniformGPUBuffer.apply()}addUniformNode(){}}const $i=class{constructor(i,e=0,t=null,r=0){n(this,"entities"),n(this,"box"),n(this,"subTrees",[]),n(this,"parent"),n(this,"level"),n(this,"index"),n(this,"uuid"),n(this,"__rayCastTempVector",new p),this.parent=t,this.box=i.clone(),this.level=r,this.index=e,this.uuid=r+"_"+e,this.entities=new Map}tryInsertEntity(i){let e=i.renderer.object3D.bound;if(this.level==0||this.box.containsBox(e)){this.subTrees.length==0&&this.level<$i.maxSplitLevel&&this.splitTree();let t;if(this.subTrees.length>0){for(let r of this.subTrees)if(r.tryInsertEntity(i)){t=!0;break}}return t||i.enterNode(this),!0}return!1}splitTree(){if(this.subTrees.length==0){const i=$i._v1,e=this.box.extents.clone();let t=this.level+1,r=0;for(let a=0;a<2;a++)for(let s=0;s<2;s++)for(let o=0;o<2;o++){const l=new Be;this.box.min.add(i.set(a,s,o).multiply(e),l.min),l.min.add(e,l.max),l.setFromMinMax(l.min,l.max);let h=new $i(l,r++,this,t);this.subTrees.push(h)}}}rayCasts(i,e){if(this.level==0||i.intersectBox(this.box,this.__rayCastTempVector)){this.entities.size>0&&e.push(...this.entities.values());for(let t of this.subTrees)t.rayCasts(i,e);return!0}return!1}frustumCasts(i,e){if(this.level==0||i.containsBox2(this.box)>0){if(this.entities.size>0)for(const t of this.entities.values())(this.level>$i.autoSplitLevel||i.containsBox2(t.renderer.object3D.bound)>0)&&e.push(t);for(let t of this.subTrees)t.frustumCasts(i,e);return!0}return!1}getRenderNode(i,e){if(this.level==0||i.containsBox2(this.box)>0){if(this.entities.size>0)for(const t of this.entities.values())(this.level>$i.autoSplitLevel||i.containsBox2(t.renderer.object3D.bound)>0)&&(t.renderer.renderOrder<3e3?e.opaqueList.push(t.renderer):t.renderer.renderOrder>=3e3&&e.transparentList.push(t.renderer));for(let t of this.subTrees)t.getRenderNode(i,e);return!0}return!1}boxCasts(i,e){if(i.intersectsBox(this.box)){this.entities.size>0&&e.push(...this.entities.values());for(let t of this.subTrees)t.boxCasts(i,e);return!0}return!1}clean(){for(let i of this.entities.values())i.leaveNode();return this.entities.clear(),this}};let er=$i;n(er,"_v1",new p),n(er,"_v2",new p),n(er,"maxSplitLevel",6),n(er,"autoSplitLevel",3);class Sl{constructor(){n(this,"_pool",[]),n(this,"_worldPosition",new p),n(this,"_viewPosition",new p),n(this,"_zSortList",[])}pop(){return this._pool.pop()||{}}recycle(){for(let e of this._zSortList)e.z=0,e.userData=null,e.obj3d=null,this._pool.push(e);this._zSortList.length=0}sort(e,t,r,a){this._zSortList=[];for(let s of t){let o=this.pop();o.userData=s,o.obj3d=r(s),o.z=this.worldToCameraDepth(o.obj3d,e),this._zSortList.push(o)}this._zSortList.sort((s,o)=>s.z-o.z>0?1:-1),a||(a=[]);for(let s of this._zSortList)a.push(s.userData);return this.recycle(),a}worldToCameraDepth(e,t){t||(t=e.transform.view3D.camera);let r=0;return t&&(this._worldPosition.copyFrom(e.transform.worldPosition),t.worldToScreenPoint(this._worldPosition,this._viewPosition),r=this._viewPosition.z),r}}let Il=new Sl;var Fr=(i=>(i[i.None=2]="None",i[i.StaticBatch=4]="StaticBatch",i[i.DynamicBatch=8]="DynamicBatch",i))(Fr||{});class Gs{static addMask(e,t){return e|t}static removeMask(e,t){return e&~t}static hasMask(e,t){return(e&t)!=0}}function kd(i,e){let t=i.__NonSerialize__;t||(t=i.__NonSerialize__={},t.__NonSerialize__=!0),t[e]=!0}function zd(i,e){let t;for(;i&&(i=i.__proto__,i&&(t=i.__NonSerialize__),!t););return t&&t[e]}function Vt(i,e,t,r,a){let s=i.__EditorInspector__;s||(s=i.__EditorInspector__=new Map);let o=s.get(i.constructor.name);o||(o=new Map,s.set(i.constructor.name,o)),o.set(e,{p1:t,p2:r,p3:a})}function Gd(i){let e,t=i,r=[];for(;t;){if(r.indexOf(t.constructor.name)!=-1){t=t.__proto__;continue}r.push(t.constructor.name),t=t.__proto__}for(r=r.reverse(),t=i;t&&(t=t.__proto__,t&&(e=t.__EditorInspector__),!e););let a=new Map;if(e)for(let s=0;s<r.length;s++){const o=r[s];let l=e.get(o);l&&l.forEach((h,u)=>{a.set(u,h)})}return a}function Qd(i,e,t,r,a){let s=window.__Component__;s||(s=window.__Component__={}),s[i.name]=i}var re=(i=>(i[i.COLOR=1]="COLOR",i[i.NORMAL=2]="NORMAL",i[i.POSITION=4]="POSITION",i[i.GRAPHIC=8]="GRAPHIC",i[i.GI=16]="GI",i[i.Cluster=32]="Cluster",i[i.SHADOW=64]="SHADOW",i[i.POINT_SHADOW=128]="POINT_SHADOW",i[i.POST=256]="POST",i[i.DEPTH=512]="DEPTH",i[i.REFLECTION=1024]="REFLECTION",i))(re||{});class le{}n(le,"GLTF_NODE_INDEX_PROPERTY"),n(le,"BASE_COLOR_UNIFORM","u_baseColorFactor"),n(le,"BASE_COLOR_TEXTURE_UNIFORM","u_baseColorSampler"),n(le,"METALROUGHNESS_UNIFORM","u_metallicRoughnessValues"),n(le,"METALROUGHNESS_TEXTURE_UNIFORM","u_metallicRoughnessSampler"),n(le,"NORMAL_TEXTURE_UNIFORM","u_normalSampler"),n(le,"NORMAL_SCALE_UNIFORM","u_normalScale"),n(le,"EMISSIVE_TEXTURE_UNIFORM","u_emissiveSampler"),n(le,"EMISSIVE_FACTOR_UNIFORM","u_emissiveFactor"),n(le,"OCCLUSION_TEXTURE_UNIFORM","u_occlusionSampler"),n(le,"OCCLUSION_FACTOR_UNIFORM","u_occlusionFactor"),n(le,"MAX_MORPH_TARGETS",8),n(le,"MORPH_POSITION_PREFIX","a_morphPositions_"),n(le,"MORPH_NORMAL_PREFIX","a_morphNormals_"),n(le,"MORPH_TANGENT_PREFIX","a_morphTangents_"),n(le,"MORPH_WEIGHT_UNIFORM","u_morphWeights"),n(le,"SCENE_ROOT_SKELETON","SCENE_ROOT"),n(le,"IDENTITY_INVERSE_BIND_MATRICES","IDENTITY_IBM"),n(le,"JOINT_MATRICES_UNIFORM","u_jointMatrix"),n(le,"ALPHA_CUTOFF_UNIFORM","u_alphaCutoff");class kr{static createGIPass(e,t){if(Bt.hasMask(e.rendererMask,Le.Sky)){let r=t.getPass(re.COLOR)[0],a=new Ef;a.setTexture("baseMap",r.getTexture("baseMap")),a.cullMode=r.cullMode,a.frontFace=r.frontFace,t.addPass(re.GI,a,0),a.preCompile(e.geometry)}else this.castGBufferPass(e,t)}static castGBufferPass(e,t){let r=t.getPass(re.COLOR);for(let a=0;a<r.length;a++){const s=r[a];let o=t.getPass(re.GI);if(!o||o.length<a){let l=new If;l.setTexture("baseMap",s.getTexture("baseMap")),l.setTexture("normalMap",s.getTexture("normalMap")),l.setTexture("emissiveMap",s.getTexture("emissiveMap")),l.setUniform("baseColor",s.getUniform("baseColor")),l.setUniform("envIntensity",s.getUniform("envIntensity")),l.setUniform("emissiveColor",s.getUniform("emissiveColor")),l.setUniform("emissiveIntensity",s.getUniform("emissiveIntensity")),l.setUniform("alphaCutoff",s.getUniform("alphaCutoff")),l.cullMode=s.cullMode,l.frontFace=s.frontFace,l.preCompile(e.geometry),t.addPass(re.GI,l)}}}static createShadowPass(e,t){let r=Bt.hasMask(e.rendererMask,Le.SkinnedMesh),a=e.geometry.hasAttribute("TANGENT"),s=e.geometry.hasAttribute(le.MORPH_POSITION_PREFIX+"0"),o=e.geometry.hasAttribute(le.MORPH_NORMAL_PREFIX+"0"),l=t.getPass(re.COLOR);for(let h=0;h<l.length;h++){const u=l[h];let c=t.getPass(re.SHADOW);if(!c||c.length<h){let g=new wf;g.setTexture("baseMap",u.getTexture("baseMap")),g.setUniform("alphaCutoff",u.getUniform("alphaCutoff")),a&&g.setDefine("USE_TANGENT",a),r&&g.setDefine("USE_SKELETON",r),s&&g.setDefine("USE_MORPHTARGETS",s),o&&g.setDefine("USE_MORPHNORMALS",o),u.cullMode=="none"?g.shaderState.cullMode="none":u.cullMode=="back"?g.shaderState.cullMode="front":u.cullMode=="front"&&(g.shaderState.cullMode="back"),g.preCompile(e.geometry),t.addPass(re.SHADOW,g)}if(!t.getPass(re.POINT_SHADOW)){let g=new bf;g.setTexture("baseMap",u.getTexture("baseMap")),g.setUniform("alphaCutoff",u.getUniform("alphaCutoff")),g.setDefine("USE_ALPHACUT",1);for(let m=0;m<1;m++)a&&g.setDefine("USE_TANGENT",a),r&&g.setDefine("USE_SKELETON",r),s&&g.setDefine("USE_MORPHTARGETS",s),o&&g.setDefine("USE_MORPHNORMALS",o),g.shaderState.cullMode="front",g.preCompile(e.geometry);t.addPass(re.POINT_SHADOW,g)}}}static createReflectionPass(e,t){}static createDepthPass(e,t){let r=t.getPass(re.COLOR),a=e.geometry.hasAttribute("TANGENT"),s=e.geometry.hasAttribute(le.MORPH_POSITION_PREFIX+"0"),o=e.geometry.hasAttribute(le.MORPH_NORMAL_PREFIX+"0"),l=Bt.hasMask(e.rendererMask,Le.SkinnedMesh);for(let h=0;h<r.length;h++){const u=r[h];let c=t.getPass(re.DEPTH);if(!c&&u.shaderState.useZ&&(!c||c.length<h)){let d=new Sf;d.setTexture("baseMap",u.getTexture("baseMap")),a||d.setDefine("USE_TANGENT",a),l&&d.setDefine("USE_SKELETON",l),s&&d.setDefine("USE_MORPHTARGETS",s),o&&d.setDefine("USE_MORPHNORMALS",o),d.cullMode=u.cullMode,d.frontFace=u.frontFace,d.preCompile(e.geometry),t.addPass(re.DEPTH,d)}}}}const El=class{constructor(){n(this,"reference")}static getInstance(){return this._ins||(this._ins=new El),this._ins}attached(i,e){this.reference||(this.reference=new Map);let t=this.reference.get(i);t||(t=new Map),t.set(e,i),this.reference.set(i,t)}detached(i,e){let t=this.reference.get(i);t&&t.delete(e)}hasReference(i){let e=this.reference.get(i);return e?e.size>0:!1}getReferenceCount(i){let e=this.reference.get(i);return e?e.size:0}getReference(i){let e=this.reference.get(i);return e||null}};let ae=El;n(ae,"_ins");const fi=class{static getMipmapPipeline(i){let e=i.format,t=I.device,r=fi.pipelineCache[i.format],a;if(!r){a=t.createShaderModule({code:fi.mipmapShader});let s=t.createBindGroupLayout({entries:[{binding:0,visibility:i.visibility,sampler:i.samplerBindingLayout},{binding:1,visibility:i.visibility,texture:i.textureBindingLayout}]}),o=I.device.createPipelineLayout({bindGroupLayouts:[s]});r=w.createPipeline({layout:o,vertex:{module:a,entryPoint:"vertexMain"},fragment:{module:a,entryPoint:"fragmentMain",targets:[{format:e}]}}),fi.pipelineCache[e]=r}return r}static webGPUGenerateMipmap(i){let e=I.device,t=i.textureDescriptor;if(!fi.pipeline){const o=e.createShaderModule({code:`
        var<private> pos : array<vec2<f32>, 4> = array<vec2<f32>, 4>(
          vec2<f32>(-1.0, 1.0), vec2<f32>(1.0, 1.0),
          vec2<f32>(-1.0, -1.0), vec2<f32>(1.0, -1.0));

        struct VertexOutput {
          @builtin(position) position : vec4<f32>,
          @location(0) texCoord : vec2<f32>
        };

        @vertex
        fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
          var output : VertexOutput;
          output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);
          output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);
          return output;
        }

        @binding(0) @group(0) var imgSampler : sampler;
        @binding(1) @group(0) var img : texture_2d<f32>;

        @fragment
        fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {
          var outColor: vec4<f32> = textureSample(img, imgSampler, texCoord);
          return outColor;
        }
      `});fi.pipeline=e.createRenderPipeline({layout:"auto",vertex:{module:o,entryPoint:"vertexMain"},fragment:{module:o,entryPoint:"fragmentMain",targets:[{format:t.format}]},primitive:{topology:"triangle-strip",stripIndexFormat:"uint32"}})}let r;i.format=="rgba16float"?r=e.createSampler({minFilter:"nearest",magFilter:"linear"}):r=e.createSampler({minFilter:"linear",magFilter:"linear"});let a=i.getGPUTexture().createView({baseMipLevel:0,mipLevelCount:1});const s=w.beginCommandEncoder();for(let o=1;o<t.mipLevelCount;++o){const l=i.getGPUTexture().createView({baseMipLevel:o,mipLevelCount:1}),h=s.beginRenderPass({colorAttachments:[{view:l,clearValue:[0,0,0,0],loadOp:"clear",storeOp:"store"}]}),u=e.createBindGroup({layout:fi.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:r},{binding:1,resource:a}]});h.setPipeline(fi.pipeline),h.setBindGroup(0,u),h.draw(4),h.end(),a=l}w.endCommandEncoder(s)}};let Ht=fi;n(Ht,"mipmapShader",`
    var<private> pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(
        vec2<f32>(-1.0, -1.0), vec2<f32>(-1.0, 3.0), vec2<f32>(3.0, -1.0));
      struct VertexOutput {
        @builtin(position) position : vec4<f32>;
        @location(0) texCoord : vec2<f32>;
      };
      @vertex
      fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
        var output : VertexOutput;
        output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);
        output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);
        return output;
      }
      @binding(0) @group(0) var imgSampler : sampler;
      @binding(1) @group(0) var img : texture_2d<f32>;
      @fragment
      fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {
        var outColor: vec4<f32> = textureSample(img, imgSampler, texCoord);
        return outColor ;
      }`),n(Ht,"pipelineCache",{}),n(Ht,"pipeline");class st{constructor(e=32,t=32,r=1){n(this,"name"),n(this,"url"),n(this,"gpuTexture"),n(this,"pid"),n(this,"view"),n(this,"gpuSampler"),n(this,"gpuSampler_comparison"),n(this,"format"),n(this,"usage"),n(this,"width",4),n(this,"height",4),n(this,"depthOrArrayLayers",1),n(this,"numberLayer",1),n(this,"viewDescriptor"),n(this,"textureDescriptor"),n(this,"visibility",GPUShaderStage.COMPUTE|GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT),n(this,"textureBindingLayout",{viewDimension:"2d",multisampled:!1}),n(this,"samplerBindingLayout",{type:"filtering"}),n(this,"sampler_comparisonBindingLayout",{type:"comparison"}),n(this,"flipY"),n(this,"isVideoTexture"),n(this,"isHDRTexture"),n(this,"_useMipmap",!1),n(this,"_sourceImageData"),n(this,"_addressModeU"),n(this,"_addressModeV"),n(this,"_addressModeW"),n(this,"_magFilter"),n(this,"_minFilter"),n(this,"_mipmapFilter"),n(this,"_lodMinClamp"),n(this,"_lodMaxClamp"),n(this,"_compare"),n(this,"_maxAnisotropy"),n(this,"mipmapCount",1),n(this,"_textureChange",!1),n(this,"_stateChangeRef",new Map),this.width=e,this.height=t,this.numberLayer=r,this.minFilter="linear",this.magFilter="linear",this.mipmapFilter="linear",this.addressModeU=Et.repeat,this.addressModeV=Et.repeat}init(){let e=this;return e.internalCreateBindingLayoutDesc&&e.internalCreateBindingLayoutDesc(),e.internalCreateTexture&&e.internalCreateTexture(),e.internalCreateView&&e.internalCreateView(),e.internalCreateSampler&&e.internalCreateSampler(),this}createTextureDescriptor(e,t,r,a,s=GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.STORAGE_BINDING,o=1,l=0){this.width=e,this.height=t,this.format=a,this.usage=s,this.textureDescriptor={size:[e,t,o],mipLevelCount:r,format:a,usage:s,label:`${this.name+this.width+this.height+this.format}`},l>0&&(this.textureDescriptor.sampleCount=l),o>1?this.viewDescriptor={dimension:"2d-array"}:this.viewDescriptor={dimension:this.textureBindingLayout.viewDimension}}generate(e){let t=32,r=32;"width"in e&&(t=e.width,r=e.height),(t<32||r<32)&&console.log(e.name+"Size must be greater than 32!"),this.width=t,this.height=r,this.createTexture(e)}createTexture(e){this._sourceImageData=e,this.updateTextureDescription(),this.updateGPUTexture();let t=I.device;this.gpuTexture instanceof GPUTexture&&t.queue.copyExternalImageToTexture({source:this._sourceImageData},{texture:this.gpuTexture},[this.width,this.height]),this.useMipmap&&Ht.webGPUGenerateMipmap(this)}get useMipmap(){return this._useMipmap}set useMipmap(e){if(e){if(this.samplerBindingLayout.type="filtering",this._useMipmap==!1&&this._sourceImageData){this._useMipmap=!0,this.updateTextureDescription(),this.updateGPUTexture();let t=I.device;this.gpuTexture instanceof GPUTexture&&t.queue.copyExternalImageToTexture({source:this._sourceImageData},{texture:this.gpuTexture},[this.width,this.height]),Ht.webGPUGenerateMipmap(this)}}else if(this.samplerBindingLayout.type="non-filtering",this._useMipmap==!0&&this._sourceImageData){this._useMipmap=!1,this.updateTextureDescription(),this.updateGPUTexture();let t=I.device;this.gpuTexture instanceof GPUTexture&&t.queue.copyExternalImageToTexture({source:this._sourceImageData},{texture:this.gpuTexture},[this.width,this.height])}this._textureChange=!0,this._useMipmap=e,this.noticeChange()}get sourceImageData(){return this._sourceImageData}updateTextureDescription(){this.mipmapCount=Math.floor(this.useMipmap?Math.log2(Math.min(this.width,this.height)):1),this.createTextureDescriptor(this.width,this.height,this.mipmapCount,this.format)}updateGPUTexture(){this.gpuTexture&&this.gpuTexture instanceof GPUTexture&&this.gpuTexture.destroy(),this.gpuTexture=null,this.view=null,this.gpuTexture=this.getGPUTexture()}getGPUTexture(){return this.gpuTexture||(this.gpuTexture=I.device.createTexture(this.textureDescriptor)),this.gpuTexture}getGPUView(e=0){return this.view||(this.gpuTexture=this.getGPUTexture(),this.gpuTexture instanceof GPUTexture&&(this.view=this.gpuTexture.createView(this.viewDescriptor),this.view.label=this.name)),this.view}bindStateChange(e,t){this._stateChangeRef.set(t,e)}unBindStateChange(e){this._stateChangeRef.delete(e)}noticeChange(){this.gpuSampler=I.device.createSampler(this),this._stateChangeRef.forEach((e,t)=>{e()})}destroy(e){e&&this.gpuTexture instanceof GPUTexture&&(this.gpuSampler=null,this.gpuSampler_comparison=null,this.textureBindingLayout=null,this.textureDescriptor=null,this.gpuTexture.destroy(),this.gpuTexture=null),this._stateChangeRef.clear()}get addressModeU(){return this._addressModeU}set addressModeU(e){this._addressModeU!=e&&(this._addressModeU=e,this.noticeChange())}get addressModeV(){return this._addressModeV}set addressModeV(e){this._addressModeV!=e&&(this._addressModeV=e,this.noticeChange())}get addressModeW(){return this._addressModeW}set addressModeW(e){this._addressModeW!=e&&(this._addressModeW=e,this.noticeChange())}get magFilter(){return this._magFilter}set magFilter(e){this._magFilter!=e&&(this._magFilter=e,this.noticeChange())}get minFilter(){return this._minFilter}set minFilter(e){this._minFilter!=e&&(this._minFilter=e,this.noticeChange())}get mipmapFilter(){return this._mipmapFilter}set mipmapFilter(e){this._mipmapFilter!=e&&(this._mipmapFilter=e,this.noticeChange())}get lodMinClamp(){return this._lodMinClamp}set lodMinClamp(e){this._lodMinClamp!=e&&(this._lodMinClamp=e,this.noticeChange())}get lodMaxClamp(){return this._lodMaxClamp}set lodMaxClamp(e){this._lodMaxClamp!=e&&(this._lodMaxClamp=e,this.noticeChange())}get compare(){return this._compare}set compare(e){this._compare!=e&&(this._compare=e,this.noticeChange())}get maxAnisotropy(){return this._maxAnisotropy}set maxAnisotropy(e){this._maxAnisotropy!=e&&(this._maxAnisotropy=e,this.noticeChange())}}class Bl extends st{constructor(e,t,r){super(e,t,r),n(this,"_bitmapTextures"),this.format=G.rgba8unorm,this.mipmapCount=1,this._bitmapTextures=[],this.init()}setTextures(e){this._bitmapTextures.length=0;for(let t=0;t<e.length;t++){const r=e[t];this.addTexture(r)}}addTexture(e){(e.width!=this.width||e.height!=this.height)&&console.error("bitmap texture muse match bitmapTextureArray size!"),this._bitmapTextures.indexOf(e)==-1&&(e.pid=this._bitmapTextures.length,this._bitmapTextures.push(e),this.updateTexture())}removeTexture(e){let t=this._bitmapTextures.indexOf(e);if(t!=-1){this._bitmapTextures.splice(t,1);for(let r=0;r<this._bitmapTextures.length;r++){const a=this._bitmapTextures[r];a.pid=r}}}updateTexture(){let e=w.beginCommandEncoder();for(let t=0;t<this._bitmapTextures.length;t++){let r=this._bitmapTextures[t];e.copyTextureToTexture({texture:r.getGPUTexture(),mipLevel:0,origin:{x:0,y:0,z:0}},{texture:this.getGPUTexture(),mipLevel:0,origin:{x:0,y:0,z:t}},{width:this.width,height:this.height,depthOrArrayLayers:1})}w.endCommandEncoder(e)}internalCreateBindingLayoutDesc(){this.textureBindingLayout.viewDimension="2d-array",this.samplerBindingLayout.type="filtering",this.minFilter=Br.linear,this.magFilter=Br.linear}internalCreateTexture(){this.textureDescriptor={format:this.format,size:{width:this.width,height:this.height,depthOrArrayLayers:this.numberLayer},dimension:"2d",usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING},this.gpuTexture=I.device.createTexture(this.textureDescriptor)}internalCreateView(){this.viewDescriptor={dimension:"2d-array"},this.view=this.gpuTexture.createView(this.viewDescriptor)}internalCreateSampler(){this.gpuSampler=I.device.createSampler(this)}}const Ei=class{constructor(){n(this,"_iesTexture"),n(this,"index",0)}generateIES(i){}set IESTexture(i){this._iesTexture=i,i.addressModeU=Et.repeat,i.addressModeV=Et.repeat,i.addressModeW=Et.repeat,Ei.ies_list.indexOf(this)==-1&&(this.index=Ei.ies_list.length,Ei.ies_list.push(this),Ei.iesTexture||Ei.create(i.width,i.height),Ei.iesTexture.addTexture(i))}get IESTexture(){return this._iesTexture}static create(i,e){let t=48;this.iesTexture=new Bl(i,e,t)}};let Bi=Ei;n(Bi,"use",!1),n(Bi,"iesTexture"),n(Bi,"ies_list",[]);class Tl{constructor(e){n(this,"renderer"),n(this,"owner"),n(this,"uuid"),this.renderer=e,this.uuid=e.object3D.instanceID}leaveNode(){this.owner&&(this.owner.entities.delete(this.uuid),this.owner=null)}enterNode(e){this.owner&&this.leaveNode(),this.owner=e,e.entities.set(this.uuid,this)}update(e){var t;return((t=this.owner)==null?void 0:t.tryInsertEntity(this))||(this.leaveNode(),e.tryInsertEntity(this)),this.owner}}var Vd=Object.defineProperty,Hd=Object.getOwnPropertyDescriptor,zr=(i,e,t,r)=>{for(var a=r>1?void 0:r?Hd(e,t):e,s=i.length-1,o;s>=0;s--)(o=i[s])&&(a=(r?o(e,t,a):o(a))||a);return r&&a&&Vd(e,t,a),a};class Jt extends Ee{constructor(){super(...arguments),n(this,"instanceCount",0),n(this,"lodLevel",0),n(this,"alwaysRender",!1),n(this,"instanceID"),n(this,"drawType",0),n(this,"_geometry"),n(this,"_materials",[]),n(this,"_castShadow",!0),n(this,"_castReflection",!1),n(this,"_castGI",!1),n(this,"_rendererMask",Le.Default),n(this,"_inRenderer",!1),n(this,"_readyPipeline",!1),n(this,"_combineShaderRefection"),n(this,"_ignoreEnvMap"),n(this,"_ignorePrefilterMap"),n(this,"__renderOrder",0),n(this,"_renderOrder",0),n(this,"isRenderOrderChange"),n(this,"needSortOnCameraZ"),n(this,"_octreeBinder"),n(this,"preInit",!1),n(this,"_renderLayer",Fr.None)}init(){this.renderOrder=0,this.rendererMask=Le.Default,this.instanceID=Ds().toString()}attachSceneOctree(e){this._octreeBinder={octree:e,entity:new Tl(this)},this.transform.eventDispatcher.addEventListener(Ue.LOCAL_ONCHANGE,this.updateOctreeEntity,this)}detachSceneOctree(){var e;this._octreeBinder&&((e=this._octreeBinder.entity)==null||e.leaveNode(),this.transform.eventDispatcher.removeEventListener(Ue.LOCAL_ONCHANGE,this.updateOctreeEntity,this),this._octreeBinder=null)}updateOctreeEntity(e){var t,r;(r=(t=this._octreeBinder)==null?void 0:t.entity)==null||r.update(this._octreeBinder.octree)}copyComponent(e){return super.copyComponent(e),this.geometry=e._geometry,this.materials=e._materials.slice(),this.drawType=e.drawType,this.alwaysRender=e.alwaysRender,this.needSortOnCameraZ=e.needSortOnCameraZ,this.isRenderOrderChange=e.isRenderOrderChange,this.castShadow=e.castShadow,this.castGI=e.castGI,this.rendererMask=e.rendererMask,this}get renderLayer(){return this._renderLayer}set renderLayer(e){this._renderLayer=e}get geometry(){return this._geometry}set geometry(e){this._geometry!=e&&(this._geometry&&ae.getInstance().detached(this._geometry,this),ae.getInstance().attached(e,this)),this._geometry=e}addMask(e){this._rendererMask=Bt.addMask(this.rendererMask,e)}removeMask(e){this._rendererMask=Bt.removeMask(this.rendererMask,e)}hasMask(e){return Bt.hasMask(this.rendererMask,e)}get rendererMask(){return this._rendererMask}set rendererMask(e){this._rendererMask=e}get renderOrder(){return this._renderOrder}set renderOrder(e){e!=this._renderOrder&&(this.isRenderOrderChange=!0,this.__renderOrder=e),this._renderOrder=e}get materials(){return this._materials}set materials(e){this._readyPipeline=!1;for(let r=0;r<this._materials.length;r++){let a=this._materials[r];ae.getInstance().detached(a,this)}for(let r=0;r<e.length;r++){let a=e[r];ae.getInstance().attached(a,this)}this._materials=e;let t=0;for(let r=0;r<e.length;r++){const o=e[r].getPass(re.COLOR)[0];o.shaderState.transparent&&(t=t>o.renderOrder?t:o.renderOrder)}this.renderOrder=t,this._readyPipeline||this.initPipeline()}addRendererMask(e){this._rendererMask=Bt.addMask(this._rendererMask,e)}removeRendererMask(e){this._rendererMask=Bt.removeMask(this._rendererMask,e)}onEnable(){this._readyPipeline||this.initPipeline(),Q.instance.addRenderNode(this.transform.scene3D,this),this.updateOctreeEntity()}onDisable(){Q.instance.removeRenderNode(this.transform.scene3D,this)}selfCloneMaterials(e){let t=[];for(let r=0,a=this.materials.length;r<a;r++){const s=this.materials[r].clone();t.push(s)}return this.materials=t,this._readyPipeline=!1,this.initPipeline(),this}initPipeline(){if(this._geometry&&this._materials.length>0){for(let t=0;t<this._materials.length;t++){let a=this._materials[t].getPass(re.COLOR);for(let s=0;s<a.length;s++){const o=a[s];o.shaderReflection||o.preCompile(this._geometry),this._geometry.generate(o.shaderReflection)}this.object3D.bound=this._geometry.bounds.clone()}this._readyPipeline=!0;let e=0;for(let t=0;t<this.materials.length;t++){const s=this.materials[t].getPass(re.COLOR)[0];s.renderOrder>=3e3?e=e>s.renderOrder?e:s.renderOrder:e=Math.max(e-3e3,0),this.castNeedPass()}this.renderOrder=e,this.enable&&this.transform&&this.transform.scene3D&&Q.instance.addRenderNode(this.transform.scene3D,this)}}castNeedPass(){if(this.castGI)for(let t=0;t<this.materials.length;t++){const r=this.materials[t];kr.createGIPass(this,r)}for(let t=0;t<this.materials.length;t++){const r=this.materials[t];r.castShadow&&kr.createShadowPass(this,r)}if(this.castReflection)for(let t=0;t<this.materials.length;t++){const r=this.materials[t];r.castShadow&&kr.createShadowPass(this,r)}if(!Bt.hasMask(this.rendererMask,Le.IgnoreDepthPass)&&_.setting.render.zPrePass)for(let t=0;t<this.materials.length;t++){const r=this.materials[t];kr.createDepthPass(this,r)}else for(let t=0;t<this.materials.length;t++)this.materials[t].removePass(re.DEPTH,0)}get castShadow(){return this._castShadow}set castShadow(e){this._castShadow=e}get castGI(){return this._castGI}set castGI(e){this._castGI=e}get castReflection(){return this._castReflection}set castReflection(e){this._castReflection=e}renderPass(e,t,r){let a=this,s=a.transform._worldMatrix;for(let o=0;o<a.materials.length;o++){const l=a.materials[o];if(!l||!l.enable)continue;let h=l.getPass(t);if(!(!h||h.length==0)){w.bindGeometryBuffer(r.encoder,a._geometry);for(let u=0;u<h.length;u++){if(!h||h.length==0)continue;const d=h[u];if(d.pipeline){d.shaderState.splitTexture&&(r.endRenderPass(),Ne.WriteSplitColorTexture(a.instanceID),r.beginRenderPass(),w.bindCamera(r.encoder,e.camera),w.bindGeometryBuffer(r.encoder,a._geometry)),w.bindPipeline(r.encoder,d);let v=a._geometry.subGeometries[o].lodLevels[a.lodLevel];a.instanceCount>0?w.drawIndexed(r.encoder,v.indexCount,a.instanceCount,v.indexStart,0,0):w.drawIndexed(r.encoder,v.indexCount,1,v.indexStart,0,s.index)}}}}}renderPass2(e,t,r,a,s,o=!1){if(!this.enable)return;let l=this,h=l.object3D.transform._worldMatrix;for(let u=0;u<this.materials.length;u++){let d=this.materials[u].getPass(t);if(!d||d.length==0)return;if(this.drawType==2)for(let g of d)g.pipeline&&(w.bindPipeline(s,g),w.draw(s,6,1,0,h.index));else{w.bindGeometryBuffer(s,l._geometry);for(let g of d)if(g.pipeline){w.bindPipeline(s,g);let y=l._geometry.subGeometries[u].lodLevels[l.lodLevel];w.drawIndexed(s,y.indexCount,1,y.indexStart,0,h.index)}}}}recordRenderPass2(e,t,r,a,s,o=!1){if(!this.enable)return;let l=this;for(let h=0;h<this.materials.length;h++){let c=this.materials[h].getPass(t);if(!c||c.length==0)return;let d=l.object3D.transform._worldMatrix;for(let g=0;g<c.length;g++){const m=c[g];w.bindPipeline(s,m);let C=l._geometry.subGeometries[h].lodLevels[l.lodLevel];w.drawIndexed(s,C.indexCount,1,C.indexStart,0,d.index)}}}noticeShaderChange(){this.enable&&(this.onEnable(),this.preInit=!1)}nodeUpdate(e,t,r,a){this.preInit=!0;let s=this,o=e.scene.envMap;for(let l=0;l<s.materials.length;l++){let u=s.materials[l].getPass(t);if(u)for(let c=0;c<u.length;c++){const g=u[c];if(g.shaderState.splitTexture){let S=Ne.CreateSplitTexture(s.instanceID);g.setTexture("splitTexture_Map",S)}if(!s._ignoreEnvMap&&g.envMap!=o&&g.setTexture("envMap",o),g.setTexture("prefilterMap",o),g.pipeline){g.apply(s._geometry,r,()=>s.noticeShaderChange());continue}let m=_.res.getTexture("BRDFLUT");g.setTexture("brdflutMap",m);let A=_.getRenderJob(e).shadowMapPassRenderer;A&&A.depth2DArrayTexture&&(g.setTexture("shadowMap",_.getRenderJob(e).shadowMapPassRenderer.depth2DArrayTexture),g.setStorageBuffer("shadowBuffer",Ge.shadowBuffer.get(e.scene)));let v=_.getRenderJob(e).pointLightShadowRenderer;v&&v.cubeArrayTexture&&g.setTexture("pointShadowMap",v.cubeArrayTexture);let y=Bi.iesTexture;y&&g.setTexture("iesTextureArrayMap",y),r.irradianceBuffer&&r.irradianceBuffer.length>0&&(g.setTexture("irradianceMap",r.irradianceBuffer[0]),g.setTexture("irradianceDepthMap",r.irradianceBuffer[1]));let C=de.getLightEntries(e.scene);C&&(g.setStorageBuffer("lightBuffer",C.storageGPUBuffer),C.irradianceVolume&&g.setStructStorageBuffer("irradianceData",C.irradianceVolume.irradianceVolumeBuffer)),a&&(g.setStorageBuffer("clustersUniform",a.clustersUniformBuffer),g.setStorageBuffer("lightAssignBuffer",a.lightAssignBuffer),g.setStorageBuffer("assignTable",a.assignTableBuffer),g.setStorageBuffer("clusterBuffer",a.clusterBuffer)),g.apply(s._geometry,r)}}}beforeDestroy(e){ae.getInstance().detached(this._geometry,this),ae.getInstance().hasReference(this._geometry)||this._geometry.destroy(e);for(let t=0;t<this._materials.length;t++){const r=this._materials[t];ae.getInstance().detached(r,this),ae.getInstance().hasReference(r)||r.destroy(e)}super.beforeDestroy(e)}destroy(e){super.destroy(e),this._geometry=null,this._materials=null,this._combineShaderRefection=null}}zr([Vt],Jt.prototype,"materials",1),zr([Vt],Jt.prototype,"castShadow",1),zr([Vt],Jt.prototype,"castShadow",1),zr([Vt],Jt.prototype,"castGI",1),zr([Vt],Jt.prototype,"castGI",1);var ve=(i=>(i[i.NONE=0]="NONE",i[i.ABOVE=1]="ABOVE",i[i.ALPHA=2]="ALPHA",i[i.NORMAL=3]="NORMAL",i[i.ADD=4]="ADD",i[i.BELOW=5]="BELOW",i[i.ERASE=6]="ERASE",i[i.MUL=7]="MUL",i[i.SCREEN=8]="SCREEN",i[i.DIVD=9]="DIVD",i[i.SOFT_ADD=10]="SOFT_ADD",i))(ve||{}),Dl=(i=>(i[i.src_a=0]="src_a",i[i.dest_a=1]="dest_a",i))(Dl||{});class Qs{static getBlend(e){let t={color:{srcFactor:"src-alpha",dstFactor:"one"},alpha:{srcFactor:"one",dstFactor:"one"}};switch(e){case 0:t.color.srcFactor="one",t.color.dstFactor="zero",t.color.operation="add";break;case 1:t.color.srcFactor="one-minus-src-alpha",t.color.dstFactor="dst-alpha",t.color.operation="add";break;case 4:t.color.srcFactor="one",t.color.dstFactor="one",t.color.operation="add",t.alpha.srcFactor="one",t.alpha.dstFactor="one",t.alpha.operation="add";break;case 2:t.color.srcFactor="src-alpha",t.color.dstFactor="one-minus-src-alpha";break;case 5:t.color.srcFactor="one-minus-src-alpha",t.color.dstFactor="one",t.color.operation="add";break;case 6:t.color.srcFactor="zero",t.color.dstFactor="one-minus-src-alpha",t.color.operation="add";break;case 7:t.color.srcFactor="dst",t.color.dstFactor="one-minus-src-alpha",t.color.operation="add";break;case 3:t.color.srcFactor="one",t.color.dstFactor="one-minus-src-alpha",t.color.operation="add";break;case 10:t.color.srcFactor="one",t.color.dstFactor="one",t.color.operation="max",t.alpha.srcFactor="one",t.alpha.dstFactor="one",t.alpha.operation="add";break;case 8:t.color.srcFactor="one",t.color.dstFactor="one-minus-src",t.color.operation="add";break}return t}}let Ml=`
    #include "WorldMatrixUniform"
    #include "GlobalUniform"

    struct VertexAttributes {
        @location(0) position: vec4<f32>,
        @location(1) color: vec4<f32>,
    }

    struct VertexOutput {
        @location(0) varying_WPos: vec4<f32>,
        @location(1) varying_Color: vec4<f32>,
        @builtin(position) member: vec4<f32>
    };

    @vertex
    fn main( vertex:VertexAttributes ) -> VertexOutput {
        var worldMatrix = models.matrix[u32(vertex.position.w)];
        var worldPos = (worldMatrix * vec4<f32>(vertex.position.xyz, 1.0));
        var viewPosition = ((globalUniform.viewMat) * worldPos);
        var clipPosition = globalUniform.projMat * viewPosition;

        var ORI_VertexOut: VertexOutput; 
        ORI_VertexOut.varying_WPos = worldPos;
        ORI_VertexOut.varying_Color = vertex.color;
        ORI_VertexOut.member = clipPosition;
        return ORI_VertexOut;
    }
`,Pl=`
    struct FragmentOutput {
        @location(0) color: vec4<f32>,
        // #if USE_WORLDPOS
            @location(1) worldPos: vec4<f32>,
        // #endif
        // #if USEGBUFFER
            @location(2) worldNormal: vec4<f32>,
            @location(3) material: vec4<f32>,
        // #endif
        @builtin(frag_depth) out_depth: f32
    };

    @fragment
    fn main(  
        @location(0) vWorldPos: vec4<f32>,
        @location(1) varying_Color: vec4<f32>,
    ) -> FragmentOutput {
        var result: FragmentOutput;

        // #if USE_WORLDPOS
            result.worldPos = vWorldPos;
        // #endif

        // #if USEGBUFFER
            // result.worldNormal = vec4<f32>(0.0, 0.0, 0.0, 1.0); 
            result.material = vec4<f32>(0.0, 1.0, 0.0, 0.0);
        // #endif

        result.color = varying_Color;

        // let n = globalUniform.near ;
        // let f = globalUniform.far ;
        // let z = ORI_VertexVarying.fragCoord.z ;
        // let pt = pow((f / n),z);
        // let ratio = n * pt / (f / n);
        // result.out_depth =  ratio ;
        return result;
    }
`;class Rl{constructor(e,t){n(this,"mCount"),n(this,"mBatchSize"),n(this,"mBatchCount"),n(this,"mMinIndexCount"),n(this,"mOffset"),n(this,"mIndexBuffer"),n(this,"mDataBuffer"),n(this,"mBatchBuffers"),n(this,"mVertexShader"),n(this,"mFragmentShader"),n(this,"mRenderPipeline"),n(this,"mRenderPipelineLayout"),n(this,"mVertexBufferLayout"),n(this,"mGPUPrimitiveTopology"),this.mMinIndexCount=e,this.mGPUPrimitiveTopology=t,this.mBatchSize=Math.trunc(65536/this.mMinIndexCount),this.init()}reset(){this.mCount=0,this.mOffset=0,this.mBatchCount=0}addShapeData(e){let t=e.shapeData;for(;t.length>0;){if(this.mOffset>=this.mDataBuffer.length&&this.flush(),this.mOffset+t.length<=this.mDataBuffer.length){this.mDataBuffer.set(t,this.mOffset),this.mOffset+=t.length;break}let r=this.mDataBuffer.length-this.mOffset;this.mDataBuffer.set(t.slice(0,r),this.mOffset),this.mOffset+=r,t=t.slice(r)}}flush(){if(this.mOffset>0){let e;this.mBatchCount<this.mBatchBuffers.length?e=this.mBatchBuffers[this.mBatchCount]:(e=I.device.createBuffer({size:this.mDataBuffer.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST}),this.mBatchBuffers.push(e)),I.device.queue.writeBuffer(e,0,this.mDataBuffer,0,this.mOffset),this.mCount+=this.mOffset/8,this.mBatchCount++,this.mOffset=0}}render(e,t){const r=I.device;if(!this.mRenderPipeline){let a=e.outAttachments;if(e.outColor!=-1){let o=a[e.outColor];o.blend=Qs.getBlend(ve.NONE)}this.mRenderPipelineLayout=r.createPipelineLayout({bindGroupLayouts:[Nr.getGlobalDataBindGroupLayout()]});let s={label:"Graphic3DFixedRenderPipeline",layout:this.mRenderPipelineLayout,vertex:{module:this.mVertexShader,entryPoint:"main",buffers:[this.mVertexBufferLayout]},fragment:{module:this.mFragmentShader,entryPoint:"main",targets:a},primitive:{topology:this.mGPUPrimitiveTopology,cullMode:ui.back,frontFace:"ccw"}};e.depthTexture&&(s.depthStencil={depthWriteEnabled:!0,depthCompare:_t.less_equal,format:e.depthTexture.format}),this.mRenderPipeline=w.createPipeline(s)}if(this.flush(),this.mBatchCount>0){t.setPipeline(this.mRenderPipeline),t.setIndexBuffer(this.mIndexBuffer,"uint16");let a=this.mCount/this.mMinIndexCount;for(let s=Math.trunc(a/this.mBatchSize)-1;s>=0;s--)t.setVertexBuffer(0,this.mBatchBuffers[s]),t.drawIndexed(this.mMinIndexCount*this.mBatchSize,1,0,0,0);a=a%this.mBatchSize,a!=0&&(t.setVertexBuffer(0,this.mBatchBuffers[this.mBatchCount-1]),t.drawIndexed(this.mMinIndexCount*a,1,0,0,0))}}init(){const e=I.device;let t=new Uint16Array((Math.trunc(this.mMinIndexCount*this.mBatchSize/4)+1)*4);for(let r=0;r<t.length;r++)t[r]=r;this.mIndexBuffer=e.createBuffer({size:t.byteLength,usage:GPUBufferUsage.INDEX|GPUBufferUsage.COPY_DST}),e.queue.writeBuffer(this.mIndexBuffer,0,t),this.mVertexBufferLayout={arrayStride:(4+4)*4,stepMode:"vertex",attributes:[{shaderLocation:0,offset:0,format:"float32x4"},{shaderLocation:1,offset:16,format:"float32x4"}]},this.mBatchBuffers=[],this.mDataBuffer=new Float32Array((4+4)*t.length),this.mBatchBuffers.push(e.createBuffer({size:this.mDataBuffer.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST})),this.mVertexShader=this.createShaderModule("Graphic3DFixedRenderPipeline.vs",ut.parse(Ml,{})),this.mFragmentShader=this.createShaderModule("Graphic3DFixedRenderPipeline.fs",ut.parse(Pl,{})),this.reset()}createShaderModule(e,t){let r=I.device.createShaderModule({label:e,code:t});return r.getCompilationInfo().then(a=>{a.messages.length>0&&(console.log(t),console.log(a))}),r}}class Zt{}n(Zt,"ShapeVertexSize",8);class Vs{constructor(e){n(this,"uuid"),n(this,"type"),n(this,"color"),n(this,"count",0),n(this,"shapeData"),n(this,"dirtyData",!1),n(this,"memoryDataIndex",-1),n(this,"transformIndex"),this.transformIndex=e}buildAxis(e=new p(0,0,0),t=10){this.buildLines([e,new p(e.x+t,e.y,e.z)],z.hexRGBColor(z.RED)),this.buildLines([e,new p(e.x,e.y+t,e.z)],z.hexRGBColor(z.GREEN)),this.buildLines([e,new p(e.x,e.y,e.z+t)],z.hexRGBColor(z.BLUE))}buildLines(e,t=z.COLOR_WHITE){if(!(e.length<2)){if(e.length==2){this.fillShapeData(e,t);return}var r=new Array(e.length+e.length-2);for(let a=1,s=0;a<e.length;++a)r[s++]=e[a-1],r[s++]=e[a];this.fillShapeData(r,t)}}buildArcLine(e,t,r,a,s=16,o=p.Y_AXIS,l=z.COLOR_WHITE){const h=(a-r)*_e;r*=_e;var u=[];for(let m=0;m<=s;++m){m>1&&u.push(u[u.length-1]);var c=h*(m/s)+r,d=t*Math.cos(c),g=t*Math.sin(c);switch(o){case p.X_AXIS:u.push(e.add(new p(0,d,g)));break;case p.Y_AXIS:u.push(e.add(new p(d,0,g)));break;case p.Z_AXIS:u.push(e.add(new p(d,g,0)));break;default:u.push(e.add(new p(d,g,0)));break}}this.fillShapeData(u,l)}buildCircle(e,t,r=32,a=p.Y_AXIS,s=z.COLOR_WHITE){var o=[];for(let c=0;c<=r;++c){var l=2*Math.PI*c/r,h=t*Math.cos(l),u=t*Math.sin(l);switch(a){case p.X_AXIS:o.push(e.add(new p(0,h,u)));break;case p.Y_AXIS:o.push(e.add(new p(h,0,u)));break;case p.Z_AXIS:o.push(e.add(new p(h,u,0)));break;default:o.push(e.add(new p(h,u,0)));break}c>0&&o.push(o[o.length-1])}o.push(o[0]),this.fillShapeData(o,s)}fillShapeData(e,t){if(!this.shapeData)this.shapeData=new Float32Array(Zt.ShapeVertexSize*e.length);else if(this.count+Zt.ShapeVertexSize*e.length>=this.shapeData.length){let a=new Float32Array(this.shapeData.length+Zt.ShapeVertexSize*e.length);a.set(this.shapeData),this.shapeData=a}const r=this.shapeData;for(let a=0;a<e.length;++a){const s=e[a];if(r[this.count++]=s.x,r[this.count++]=s.y,r[this.count++]=s.z,r[this.count++]=this.transformIndex,t instanceof z)r[this.count++]=t.r,r[this.count++]=t.g,r[this.count++]=t.b,r[this.count++]=t.a;else{const o=t[a];r[this.count++]=o.r,r[this.count++]=o.g,r[this.count++]=o.b,r[this.count++]=o.a}}this.dirtyData=!0}reset(){this.count=0}}class Ua extends Jt{constructor(e,t){super(),n(this,"shapes"),n(this,"mDirtyData",!1),n(this,"mMinIndexCount"),n(this,"mGPUPrimitiveTopology"),n(this,"mRenderPipeline"),this.alwaysRender=!0,this.mMinIndexCount=e,this.mGPUPrimitiveTopology=t,this.shapes=new Map,this.addRendererMask(Le.Particle)}fillShapeData(e,t,r,a){this.mDirtyData=!0;var s;this.shapes.has(e)?(s=this.shapes.get(e),s.shapeData.length<Zt.ShapeVertexSize*a.length&&(s.shapeData=new Float32Array(Zt.ShapeVertexSize*a.length))):(s=new Vs(this.transform._worldMatrix.index),s.type=t,s.color=r,s.shapeData=new Float32Array(Zt.ShapeVertexSize*a.length));const o=s.shapeData,l=this.transform._worldMatrix.index;for(let h=0,u=0;h<a.length;++h){const c=a[h];o[u++]=c.x,o[u++]=c.y,o[u++]=c.z,o[u++]=l,o[u++]=r.r,o[u++]=r.g,o[u++]=r.b,o[u++]=r.a}this.shapes.set(e,s)}init(){super.init(),this.castGI=!1,this.castShadow=!1,this.mRenderPipeline=new Rl(this.mMinIndexCount,this.mGPUPrimitiveTopology)}removeShape(e){this.shapes.has(e)&&(this.mDirtyData=!0,this.shapes.delete(e))}initPipeline(){this.object3D.bound=new Be(p.ZERO,p.MAX),this._readyPipeline=!0}nodeUpdate(e,t,r,a){this.mDirtyData&&(this.mRenderPipeline.reset(),this.shapes.forEach((s,o)=>{this.mRenderPipeline.addShapeData(s)}),this.mDirtyData=!1)}renderPass2(e,t,r,a,s,o=!1){this.mRenderPipeline.render(r,s)}allocGraphics3DShape(e,t){let r;return this.shapes.has(e)?(r=this.shapes.get(e),r.reset()):(r=new Vs(t),r.uuid=e,r.type="line",r.color=z.COLOR_WHITE,this.shapes.set(r.uuid,r)),this.mDirtyData=!0,r}}class Ll{constructor(){n(this,"opaqueList",[]),n(this,"transparentList",[]),n(this,"sky")}clean(){this.opaqueList.length=0,this.transparentList.length=0}}class Ul{constructor(){n(this,"renderGroup"),this.renderGroup=new Map}collect_add(e){let t="",r="";t+=e.geometry.instanceID;for(let s=0;s<e.materials.length;s++){const o=e.materials[s];r+=o.defaultPass.shaderVariant}let a=t+r;this.renderGroup.has(a)||this.renderGroup.set(a,{bundleMap:new Map,key:a,renderNodes:[]}),this.renderGroup.get(a).renderNodes.indexOf(e)==-1&&this.renderGroup.get(a).renderNodes.push(e)}}class Ol{constructor(){n(this,"renderShaderUpdateList",new Map),n(this,"renderNodeList",new Map)}collect_add(e){let t=e.transform.view3D;t&&e.materials&&e.materials.forEach(r=>{let a=this.renderShaderUpdateList.get(t);a||(a=new Map,this.renderShaderUpdateList.set(t,a));let s=this.renderNodeList.get(t);s||(s=new Map,this.renderNodeList.set(t,s)),s.set(e.instanceID,e);let o=r.getAllPass();for(let l=0;l<o.length;l++){const h=o[l];let u=`${e.geometry.instanceID+h.instanceID}`,c=a.get(u);c||(c=new Map,a.set(u,c)),c.set(e.instanceID,e)}})}collect_remove(e){let t=e.transform.view3D;if(t&&e.materials){let r=this.renderShaderUpdateList.get(t);r&&e.materials.forEach(a=>{let s=a.getAllPass();for(let o=0;o<s.length;o++){const l=s[o];let h=`${e.geometry.instanceID+l.instanceID}`;r.delete(h)}})}}}const Nl=class{constructor(){n(this,"_sceneLights"),n(this,"_sceneGIProbes"),n(this,"_op_RenderNodes"),n(this,"_tr_RenderNodes"),n(this,"_octreeRenderNodes"),n(this,"_graphics"),n(this,"_op_renderGroup"),n(this,"_tr_renderGroup"),n(this,"_renderShaderCollect"),n(this,"state",{giLightingChange:!0}),n(this,"sky"),n(this,"_collectInfo"),n(this,"rendererOctree"),this._sceneLights=new Map,this._sceneGIProbes=new Map,this._op_RenderNodes=new Map,this._tr_RenderNodes=new Map,this._graphics=[],this._op_renderGroup=new Map,this._tr_renderGroup=new Map,this._collectInfo=new Ll,this._renderShaderCollect=new Ol,this._octreeRenderNodes=new Map}static get instance(){return this._instance||(this._instance=new Nl),this._instance}getPashList(i,e){if(e.renderOrder<3e3)return this._op_RenderNodes.get(i);if(e.renderOrder>=3e3)return this._tr_RenderNodes.get(i)}sortRenderNode(i,e){for(let t=i.length-1;t>0;t--)if(i[t].renderOrder<e.renderOrder){i.push(e);return}i.push(e)}addRenderNode(i,e){if(!i)return;let t=e.renderOrder>=3e3;if(e.hasMask(Le.Sky))this.sky=e;else if(e instanceof Ua)this._graphics.indexOf(e)==-1&&this._graphics.push(e);else if(Gs.hasMask(e.renderLayer,Fr.None)){this.removeRenderNode(i,e);let r=t?this._tr_RenderNodes:this._op_RenderNodes;r.has(i)||r.set(i,[]),r.get(i).push(e),_.setting.occlusionQuery.octree&&e.attachSceneOctree(this.getOctree(i));let a=this.getPashList(i,e);a.indexOf(e)==-1&&this.sortRenderNode(a,e)}else{this.removeRenderNode(i,e);let r=t?this._tr_renderGroup:this._op_renderGroup;r.has(i)||r.set(i,new Ul),r.get(i).collect_add(e)}e.object3D.renderNode=e,this._renderShaderCollect.collect_add(e)}getOctree(i){let e,t=_.setting.occlusionQuery.octree;if(t&&(e=this._octreeRenderNodes.get(i),!e)){let r=new p(t.x,t.y,t.z),a=new p(t.width,t.height,t.depth),s=new Be(r,a);e=new er(s),this._octreeRenderNodes.set(i,e)}return e}removeRenderNode(i,e){if(e.detachSceneOctree(),e.hasMask(Le.Sky))this.sky=null;else if(Gs.hasMask(e.renderLayer,Fr.None)){let t=this.getPashList(i,e);if(t){let r=t.indexOf(e);r!=-1&&t.splice(r,1)}}this._renderShaderCollect.collect_remove(e)}addLight(i,e){if(!this._sceneLights.has(i))this._sceneLights.set(i,[e]);else{let t=this._sceneLights.get(i);if(t.length>=_.setting.light.maxLight){console.warn("Alreay meet maxmium light number:",_.setting.light.maxLight);return}t.indexOf(e)!=-1||t.push(e)}}removeLight(i,e){if(this._sceneLights.has(i)){let t=this._sceneLights.get(i),r=t.indexOf(e);r!=-1&&t.splice(r,1)}}getLights(i){let e=this._sceneLights.get(i);return e||[]}addGIProbe(i,e){this._sceneGIProbes.has(i)?this._sceneGIProbes.get(i).push(e):this._sceneGIProbes.set(i,[e])}removeGIProbe(i,e){if(this._sceneGIProbes.has(i)){let t=this._sceneGIProbes.get(i),r=t.indexOf(e);r!=-1&&t.splice(r,1)}}getProbes(i){let e=this._sceneGIProbes.get(i);return e||[]}autoSortRenderNodes(i){let e=this._tr_RenderNodes.get(i);if(!e)return;let t=!1;for(const r of e)if(r.isRenderOrderChange||r.needSortOnCameraZ){t=!0;break}if(t){for(const r of e){let a=r.renderOrder;if(r.needSortOnCameraZ){let s=Il.worldToCameraDepth(r.object3D);s=1-Math.max(0,Math.min(1,s)),a+=s}r.__renderOrder=a,r.isRenderOrderChange=!1}e.sort((r,a)=>r.__renderOrder>a.__renderOrder?1:-1)}return this}getRenderNodes(i,e){if(this._collectInfo.clean(),this._collectInfo.sky=this.sky,_.setting.occlusionQuery.octree)this.rendererOctree=this.getOctree(i),this.rendererOctree.getRenderNode(e.frustum,this._collectInfo);else{let t=this._op_RenderNodes.get(i);t&&(this._collectInfo.opaqueList=t.concat());let r=this._tr_RenderNodes.get(i);r&&(this._collectInfo.transparentList=r.concat())}return this._collectInfo}getOpRenderGroup(i){return this._op_renderGroup.get(i)}getTrRenderGroup(i){return this._tr_renderGroup.get(i)}getGraphicList(){return this._graphics}getRenderShaderCollect(i){return this._renderShaderCollect.renderShaderUpdateList.get(i)||[]}};let Q=Nl;n(Q,"_instance");class Fl{constructor(){n(this,"setting"),n(this,"probesBufferData"),n(this,"probesBuffer"),n(this,"isVolumeFrameChange",!0),n(this,"randomOrientation"),n(this,"startPosition",new p),n(this,"isVolumeChange",!0),n(this,"irradianceVolumeBuffer"),n(this,"directionDistance",20),n(this,"randomSeedCount",3),n(this,"useRandomIndex",0),n(this,"centerDirection",new p(0,0,this.directionDistance).normalize(1)),n(this,"arroundPositions",[]),n(this,"debugX",0),n(this,"debugY",0),n(this,"debugZ",0)}updateOrientation(){return this.useRandomIndex++,this.useRandomIndex>=this.arroundPositions.length&&(this.useRandomIndex=0),H.fromToRotation(this.centerDirection,this.arroundPositions[this.useRandomIndex],this.randomOrientation),this.randomOrientation}init(e){this.setting=e,this.randomOrientation=new H(!1),this.randomOrientation.identity(),this.irradianceVolumeBuffer=new fe(80),this.createFramesBuffer(),this.arroundPositions.push(this.centerDirection.clone());for(let t=0;t<this.randomSeedCount;t++){let r=Math.PI*2*t/this.randomSeedCount,a=new p(Math.sin(r),Math.cos(r),this.directionDistance).normalize(1);this.arroundPositions.push(a)}}setVolumeDataChange(){this.isVolumeChange=!0}updateProbes(e){let t=this.probesBufferData;for(let r of e){let a=r.index*4;t[a+3]=r.drawCallFrame}}createFramesBuffer(){if(!this.probesBufferData){let e=this.setting.probeXCount*this.setting.probeYCount*this.setting.probeZCount;this.probesBufferData=new Float32Array(e*4),this.probesBufferData.fill(-1),this.probesBuffer=new fe(e*4,GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST)}}uploadBuffer(){this.isVolumeChange&&(this.fillIrradianceData(),this.isVolumeChange=!1,this.isVolumeFrameChange=!0),this.probesBuffer.setFloat32Array("uniformFramesBuffer",this.probesBufferData)}calcPosition(e,t,r,a){let s=this.setting,o=this.setting.probeSpace;return a=a||new p,a.x=e*o-o*(s.probeXCount-1)*.5+s.offsetX,a.y=t*o-o*(s.probeYCount-1)*.5+s.offsetY,a.z=r*o-o*(s.probeZCount-1)*.5+s.offsetZ,a}fillIrradianceData(){let e=this.setting,t=this.calcPosition(0,0,0,this.startPosition);this.irradianceVolumeBuffer.setFloat("orientationIndex",this.randomOrientation.index),this.irradianceVolumeBuffer.setFloat("hysteresis",e.hysteresis),this.irradianceVolumeBuffer.setFloat("OctRTSideSize",e.octRTSideSize),this.irradianceVolumeBuffer.setFloat("OctRTMaxSize",e.octRTMaxSize),this.irradianceVolumeBuffer.setFloat("startX",t.x),this.irradianceVolumeBuffer.setFloat("startY",t.y),this.irradianceVolumeBuffer.setFloat("startZ",t.z),this.irradianceVolumeBuffer.setFloat("ProbeSpace",e.probeSpace),this.irradianceVolumeBuffer.setFloat("probeXCount",e.probeXCount),this.irradianceVolumeBuffer.setFloat("probeYCount",e.probeYCount),this.irradianceVolumeBuffer.setFloat("probeZCount",e.probeZCount),this.irradianceVolumeBuffer.setFloat("maxDistance",e.probeSpace*1.732),this.irradianceVolumeBuffer.setFloat("depthSharpness",e.depthSharpness),this.irradianceVolumeBuffer.setFloat("ProbeSourceTextureSize",e.probeSourceTextureSize),this.irradianceVolumeBuffer.setFloat("ProbeSize",e.probeSize),this.irradianceVolumeBuffer.setFloat("bounceIntensity",e.bounceIntensity),this.irradianceVolumeBuffer.setFloat("probeRoughness",e.probeRoughness),this.irradianceVolumeBuffer.setFloat("normalBias",e.normalBias),this.irradianceVolumeBuffer.setFloat("irradianceChebyshevBias",e.irradianceChebyshevBias),this.irradianceVolumeBuffer.setFloat("rayNumber",e.rayNumber),this.irradianceVolumeBuffer.setFloat("irradianceDistanceBias",e.irradianceDistanceBias),this.irradianceVolumeBuffer.setFloat("indirectIntensity",e.indirectIntensity),this.irradianceVolumeBuffer.setFloat("ddgiGamma",e.ddgiGamma),this.irradianceVolumeBuffer.setFloat("lerpHysteresis",e.lerpHysteresis),this.irradianceVolumeBuffer.setFloat("debugX",this.debugX),this.irradianceVolumeBuffer.setFloat("debugY",this.debugY),this.irradianceVolumeBuffer.setFloat("debugZ",this.debugZ),this.irradianceVolumeBuffer.apply()}}class kl{constructor(){n(this,"storageGPUBuffer"),n(this,"irradianceVolume"),n(this,"_lightList",[]),this.storageGPUBuffer=new fe(Rr.lightSize*_.setting.light.maxLight,GPUBufferUsage.COPY_SRC),this.irradianceVolume=new Fl,this.irradianceVolume.init(_.setting.gi);for(let e=0;e<_.setting.light.maxLight;e++){let t=this.storageGPUBuffer.memory.allocation_node(Rr.lightSize*4);this._lightList.push(t)}this.storageGPUBuffer.visibility=GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE}update(e){this.storageGPUBuffer.clean();let t=Q.instance.getLights(e.scene);for(let r=0;r<t.length;r++){const a=t[r].lightData;a.index=r,this.writeLightBytes(a,this._lightList[r])}this.storageGPUBuffer.apply()}writeLightBytes(e,t){t.offset=0,t.writeFloat(e.index),t.writeInt32(e.lightType),t.writeFloat(e.radius),t.writeFloat(e.linear),t.writeVector3(e.lightPosition),t.writeFloat(e.lightMatrixIndex),t.writeVector3(e.direction),t.writeFloat(e.quadratic),t.writeRGBColor(e.lightColor),t.writeFloat(e.intensity),t.writeFloat(e.innerAngle),t.writeFloat(e.outerAngle),t.writeFloat(e.range),t.writeInt32(e.castShadowIndex),t.writeVector3(e.lightTangent),t.writeFloat(e.iesIndex)}}class zl{constructor(){n(this,"gpuBuffer"),n(this,"probes"),n(this,"memoryDo"),n(this,"_probeInfoList")}initDataUniform(e){this.memoryDo=new Mr,this.probes=e,this._probeInfoList=[],this.memoryDo.destroy(),this.memoryDo.allocation(e.length*17*4);for(let r=0;r<e.length;r++){var t=17;let a=this.memoryDo.allocation_node(t*4);this._probeInfoList.push(a);let s=e[r].transform.worldPosition;a.setArray(0,[s.x,s.y,s.z])}this.gpuBuffer=I.device.createBuffer({size:this.memoryDo.shareDataBuffer.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.STORAGE,label:"ProbeBuffer",mappedAtCreation:!1})}updateGPUBuffer(){const e=this.memoryDo.shareDataBuffer;let t=this.memoryDo.shareDataBuffer.byteLength,r=0;const a=5e3*64;for(;r<t;)I.device.queue.writeBuffer(this.gpuBuffer,r,e,r,Math.floor(Math.min(a,t-r))),r+=a}}class Gl extends qt{constructor(e,t=0,r){super(),n(this,"size"),this.bufferType=Tt.StorageGPUBuffer,this.size=e,this.createBuffer(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|t,e,r)}writeBufferByHeap(e,t){let r=I.device;if(e.length>0){let a=null;for(;this.mapAsyncReady.length&&(a=this.mapAsyncReady.shift(),a.usedSize!=e.byteLength);)a.destroy(),this.mapAsyncBuffersOutstanding--,a=null;a||(a=r.createBuffer({size:e.byteLength,usage:GPUBufferUsage.COPY_SRC|GPUBufferUsage.MAP_WRITE,mappedAtCreation:!0}),a.usedSize=e.byteLength,this.mapAsyncBuffersOutstanding++,this.mapAsyncBuffersOutstanding>10&&console.warn(` Warning: mapAsync requests from ${this.mapAsyncBuffersOutstanding} frames ago have not resolved yet.  MB of staging buffers allocated.`));let s=new Float32Array(e.buffer,e.byteOffset,t);new Float32Array(a.getMappedRange(0,t*4)).set(s),a.unmap();const l=r.createCommandEncoder();l.copyBufferToBuffer(a,0,this.buffer,0,t*4),r.queue.submit([l.finish()]),a.mapAsync(GPUMapMode.WRITE).then(()=>this.mapAsyncReady.push(a))}}}class Ql{constructor(){n(this,"uuid"),n(this,"index"),n(this,"usage"),n(this,"groupBufferSize"),n(this,"matrixBufferDst"),this.uuid=Mt(),this.groupBufferSize=0,this.usage=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,this.cacheWorldMatrix()}cacheWorldMatrix(){this.groupBufferSize=H.maxCount*H.blockBytes,this.matrixBufferDst=new Gl(this.groupBufferSize/4),this.matrixBufferDst.visibility=GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,this.matrixBufferDst.buffer.label=this.groupBufferSize.toString()}writeBuffer(e){const t=H.dynamicMatrixBytes;this.matrixBufferDst.mapAsyncWrite(t,e)}}class de{static init(){this.modelMatrixBindGroup=new Ql,this._cameraBindGroups=new Map,this._lightEntriesMap=new Map}static getCameraGroup(e){let t=this._cameraBindGroups.get(e);return t||(t=new wl(this.modelMatrixBindGroup),this._cameraBindGroups.set(e,t)),e.isShadowCamera?t.setShadowCamera(e):t.setCamera(e),t}static getLightEntries(e){e||console.log("getLightEntries scene is null");let t=this._lightEntriesMap.get(e);return t||(t=new kl,this._lightEntriesMap.set(e,t)),this._lightEntriesMap.get(e)}static updateProbes(e){this._probeEntries||(this._probeEntries=new zl,this._probeEntries.initDataUniform(e))}}n(de,"_cameraBindGroups"),n(de,"_lightEntriesMap"),n(de,"_probeEntries"),n(de,"modelMatrixBindGroup");const Gr=class{static bindPipeline(i,e){if(Gr.lastShader!=e)Gr.lastShader=e;else return;Gr.lastPipeline!=e.pipeline&&(Gr.lastPipeline=e.pipeline,i.setPipeline(e.pipeline));for(let t=1;t<e.bindGroups.length;t++){const r=e.bindGroups[t];r&&i.setBindGroup(t,r)}}static bindCamera(i,e){let t=de.getCameraGroup(e);i.setBindGroup(0,t.globalBindGroup)}static bindGeometryBuffer(i,e){if(this.lastGeometry!=e){this.lastGeometry=e,e.indicesBuffer&&i.setIndexBuffer(e.indicesBuffer.indicesGPUBuffer.buffer,e.indicesBuffer.indicesFormat);let t=e.vertexBuffer.vertexGPUBuffer,r=e.vertexBuffer.vertexBufferLayouts;for(let a=0;a<r.length;a++){const s=r[a];i.setVertexBuffer(a,t.buffer,s.offset,s.size)}}}static cleanCache(){this.lastGeometry=null,this.lastPipeline=null,this.lastShader=null}static createPipeline(i){return ft.countStart("GPUContext","pipeline"),I.device.createRenderPipeline(i)}static beginCommandEncoder(){return ft.countStart("GPUContext","beginCommandEncoder"),this.LastCommand&&I.device.queue.submit([this.LastCommand.finish()]),this.LastCommand=I.device.createCommandEncoder(),this.LastCommand}static endCommandEncoder(i){this.LastCommand==i&&(I.device.queue.submit([this.LastCommand.finish()]),this.LastCommand=null,ft.countStart("GPUContext","endCommandEncoder"))}static recordBundleEncoder(i){return I.device.createRenderBundleEncoder(i)}static beginRenderPass(i,e){if(this.cleanCache(),this.renderPassCount++,this.lastRenderPassState=e,e.renderTargets&&e.renderTargets.length>0){for(let t=0;t<e.renderTargets.length;++t){const r=e.renderTargets[t];let a=e.renderPassDescriptor.colorAttachments[t];e.multisample>0&&e.renderTargets.length==1?(a.view=e.multiTexture.createView(),a.resolveTarget=r.getGPUView()):a.view=r.getGPUTexture().createView()}return i.beginRenderPass(e.renderPassDescriptor)}else{let t=e.renderPassDescriptor.colorAttachments[0];return t&&(e.multisample>0?(t.view=e.multiTexture.createView(),t.resolveTarget=I.context.getCurrentTexture().createView()):t.view=I.context.getCurrentTexture().createView()),i.beginRenderPass(e.renderPassDescriptor)}}static drawIndexed(i,e,t,r,a,s){i.drawIndexed(e,t,r,a,s),this.drawCount++}static draw(i,e,t,r,a){i.draw(e,t,r,a),this.drawCount++}static endPass(i){i.insertDebugMarker("end"),i.end()}static computeCommand(i,e){let t=i.beginComputePass();for(let r=0;r<e.length;r++)e[r].compute(t);t.end()}};let w=Gr;n(w,"lastGeometry"),n(w,"lastPipeline"),n(w,"lastShader"),n(w,"drawCount",0),n(w,"renderPassCount",0),n(w,"geometryCount",0),n(w,"pipelineCount",0),n(w,"matrixCount",0),n(w,"lastRenderPassState"),n(w,"LastCommand");class Vl{constructor(){n(this,"source"),n(this,"input"),n(this,"output")}reset(e){this.input&&this.input.destroy(),this.output&&this.output.destroy(),this.input=this.output=null,this.source=e}apply(e){if(this.source){if(!this.input){let t=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST;this.input=new fe(this.source.length,t,this.source),this.input.apply()}if(!this.output){let t=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC;this.output=new fe(e*3,t),this.output.apply()}}}}class Hl{constructor(){n(this,"enable"),n(this,"morphTargetsRelative"),n(this,"MaxMorphTargetCount",64),n(this,"_computeConfigArray"),n(this,"_computeConfigBuffer"),n(this,"_morphInfluenceArray"),n(this,"_morphInfluenceBuffer"),n(this,"_positionAttrDataGroup"),n(this,"_normalAttrDataGroup"),n(this,"_isInfluenceDirty"),n(this,"_morphTargetCount"),n(this,"_totalVertexCount"),n(this,"_computeShader"),n(this,"_computeShaders"),n(this,"_computeWorkGroupXY",1),n(this,"_collectMorphTargetData"),this._isInfluenceDirty=!0,this.generateGPUBuffer(),this._positionAttrDataGroup=new Vl,this._normalAttrDataGroup=new Vl}initMorphTarget(e){this._collectMorphTargetData=this.collectMorphTargetList(e),this._computeShader&&this._computeShader.destroy();let t=Re.CsMain;this._computeShader=new be(t),this._collectMorphTargetData.mergedNormal?this._computeShader.setDefine("USE_MORPHNORMALS",!0):this._computeShader.deleteDefine("USE_MORPHNORMALS"),this._computeShaders=[this._computeShader],this._isInfluenceDirty=!0,this._morphTargetCount=this._collectMorphTargetData.mtCount,this._totalVertexCount=this._collectMorphTargetData.vCount,this._morphInfluenceArray.fill(0),this._computeWorkGroupXY=this.calcWorkGroup(this._totalVertexCount),this._positionAttrDataGroup.reset(this._collectMorphTargetData.mergedPos),this._normalAttrDataGroup.reset(this._collectMorphTargetData.mergedNormal)}applyRenderShader(e){this.uploadMorphTargetBuffer(),this.uploadConfigGBuffer(),e.setUniformBuffer("morphTargetConfig",this._computeConfigBuffer),e.setStorageBuffer("morphTargetOpPositions",this._positionAttrDataGroup.output),this._collectMorphTargetData.mergedNormal&&e.setStorageBuffer("morphTargetOpNormals",this._normalAttrDataGroup.output)}computeMorphTarget(e){this.uploadConfigGBuffer(),this.uploadMorphTargetBuffer(),this._computeShader.setUniformBuffer("morphTargetConfig",this._computeConfigBuffer),this._computeShader.setStorageBuffer("morphTargetInfluence",this._morphInfluenceBuffer),this._computeShader.setStorageBuffer("morphTargetPositions",this._positionAttrDataGroup.input),this._computeShader.setStorageBuffer("morphTargetOpPositions",this._positionAttrDataGroup.output),this._collectMorphTargetData.mergedNormal&&(this._computeShader.setStorageBuffer("morphTargetNormals",this._normalAttrDataGroup.input),this._computeShader.setStorageBuffer("morphTargetOpNormals",this._normalAttrDataGroup.output)),this._computeShader.workerSizeX=this._computeWorkGroupXY,this._computeShader.workerSizeY=this._computeWorkGroupXY,this._computeShader.workerSizeZ=1,w.computeCommand(e,this._computeShaders)}updateInfluence(e,t){this._isInfluenceDirty=!0,this._morphInfluenceArray[e]=t}collectMorphTargetList(e){let t=this.collectAttribute("a_morphPositions_",e),r=t.length,a=t[0].data.length/3,s=new Float32Array(a*r*3);{let h=0;for(let u=0;u<r;u++){let c=t[u];s.set(c.data,h),h+=c.data.length}}let o=this.collectAttribute("a_morphNormals_",e),l;if(o&&o.length>0){let h=0;l=new Float32Array(a*r*3);for(let u=0;u<r;u++){let c=o[u];l.set(c.data,h),h+=c.data.length}}return{mtCount:r,vCount:a,mergedPos:s,mergedNormal:l}}collectAttribute(e,t){let r=[];for(let a=0;a<this.MaxMorphTargetCount;a++){let s=e+a,o=t.getAttribute(s);if(o)r[a]=o;else break}return r}uploadConfigGBuffer(){if(this._isInfluenceDirty){let e=0;for(let t=0;t<this._morphTargetCount;t++)e+=this._morphInfluenceArray[t];this._morphInfluenceBuffer.setFloat32Array("data",this._morphInfluenceArray),this._morphInfluenceBuffer.apply(),this._computeConfigArray[0]=this.morphTargetsRelative?1:1-e,this._computeConfigArray[1]=this._morphTargetCount,this._computeConfigArray[2]=this._totalVertexCount,this._computeConfigArray[3]=this._computeWorkGroupXY,this._computeConfigBuffer.setFloat32Array("data",this._computeConfigArray),this._computeConfigBuffer.apply(),this._isInfluenceDirty=!1}}calcWorkGroup(e){let t=Math.ceil(Math.sqrt(e)),r=Math.ceil(Math.log2(t));return t=Math.pow(2,r),t}uploadMorphTargetBuffer(){this._positionAttrDataGroup.output||this._positionAttrDataGroup.apply(this._totalVertexCount),this._normalAttrDataGroup.output||this._normalAttrDataGroup.apply(this._totalVertexCount)}generateGPUBuffer(){this._computeConfigArray=new Float32Array(4),this._computeConfigBuffer=new Dt(4),this._morphInfluenceArray=new Float32Array(this.MaxMorphTargetCount);let e=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST;this._morphInfluenceBuffer=new fe(this.MaxMorphTargetCount,e)}}var Yd=Object.defineProperty,Xd=Object.getOwnPropertyDescriptor,Oa=(i,e,t,r)=>{for(var a=r>1?void 0:r?Xd(e,t):e,s=i.length-1,o;s>=0;s--)(o=i[s])&&(a=(r?o(e,t,a):o(a))||a);return r&&a&&Yd(e,t,a),a};const Yl=class extends Jt{constructor(){super(),n(this,"receiveShadow"),n(this,"morphData")}onEnable(){super.onEnable()}onDisable(){super.onDisable()}cloneTo(i){i.addComponent(Yl).copyComponent(this)}copyComponent(i){return super.copyComponent(i),this.receiveShadow=i.receiveShadow,this}get geometry(){return this._geometry}set geometry(i){super.geometry=i;let e=i.morphTargetDictionary!=null;e&&(this.morphData||(this.morphData=new Hl),this.morphData.morphTargetsRelative=i.morphTargetsRelative,this.morphData.initMorphTarget(i)),this.morphData&&(this.morphData.enable=e),this.morphData&&this.morphData.enable?this.addRendererMask(Le.MorphTarget):this.removeRendererMask(Le.MorphTarget),this.object3D.bound=this._geometry.bounds.clone(),this._readyPipeline&&this.initPipeline()}get material(){return this._materials[0]}set material(i){this.materials=[i]}setMorphInfluence(i,e){if(this.morphData&&this.morphData.enable){let t=this._geometry.morphTargetDictionary[i];t>=0&&this.morphData.updateInfluence(t,e)}}setMorphInfluenceIndex(i,e){this.morphData&&this.morphData.enable&&i>=0&&this.morphData.updateInfluence(i,e)}onCompute(i,e){this.morphData&&this.morphData.enable&&this.morphData.computeMorphTarget(e)}nodeUpdate(i,e,t,r){if(this.morphData&&this.morphData.enable)for(let a=0;a<this.materials.length;a++){let o=this.materials[a].getPass(e);if(o)for(let l=0;l<o.length;l++)this.morphData.applyRenderShader(o[l])}super.nodeUpdate(i,e,t,r)}destroy(i){super.destroy(i)}};let ue=Yl;Oa([Vt],ue.prototype,"geometry",1),Oa([Vt],ue.prototype,"geometry",1),Oa([Vt],ue.prototype,"material",1),Oa([Vt],ue.prototype,"material",1);class Xl{constructor(){n(this,"label",""),n(this,"customSize",!1),n(this,"zPreTexture",null),n(this,"depthTexture",null),n(this,"outAttachments"),n(this,"outColor",-1),n(this,"renderTargets"),n(this,"rtTextureDescripts"),n(this,"irradianceBuffer"),n(this,"multisample",0),n(this,"multiTexture"),n(this,"depthViewIndex",0),n(this,"depthCleanValue",0),n(this,"isOutTarget",!0),n(this,"camera3D"),n(this,"rtFrame"),n(this,"renderPassDescriptor"),n(this,"renderBundleEncoderDescriptor"),n(this,"depthLoadOp")}getLastRenderTexture(){return this.renderTargets&&this.renderTargets.length>0?this.renderTargets[0]:_.res.redTexture}}const Qr=class{static createRendererPassState(i,e=null){let t=new Xl;if(t.label=i.label,t.customSize=i.customSize,t.rtFrame=i,t.zPreTexture=i.zPreTexture,t.depthTexture=i.depthTexture,t.depthViewIndex=i.depthViewIndex,t.isOutTarget=i.isOutTarget,t.depthCleanValue=i.depthCleanValue,t.depthLoadOp=i.depthLoadOp,i&&i.attachments.length>0){t.renderTargets=i.attachments,t.rtTextureDescripts=i.rtDescriptors,t.renderPassDescriptor=Qr.getRenderPassDescriptor(t),t.renderBundleEncoderDescriptor=Qr.getRenderBundleDescriptor(t),t.outAttachments=[];for(let r=0;r<i.attachments.length;r++){const a=i.attachments[r];t.outAttachments[r]={format:a.format},a.name.indexOf(Ae.colorBufferTex_NAME)!=-1&&(t.outColor=r)}}else t.renderPassDescriptor=Qr.getRenderPassDescriptor(t,e),t.renderBundleEncoderDescriptor=Qr.getRenderBundleDescriptor(t),t.outAttachments=[{format:I.presentationFormat}],t.outColor=0;return t}static getRenderPassDescriptor(i,e=null){I.device,I.presentationSize;let t=[];if(i.renderTargets&&i.renderTargets.length>0){i.renderTargets[0].width,i.renderTargets[0].height;for(let a=0;a<i.renderTargets.length;a++){const s=i.renderTargets[a],o=i.rtTextureDescripts[a];t.push({view:s.getGPUView(),resolveTarget:void 0,loadOp:o.loadOp,clearValue:o.clearValue,storeOp:o.storeOp})}}else if(!i.customSize){let a=I.canvasConfig&&I.canvasConfig.alpha?[1,1,1,0]:[0,0,0,1];i.isOutTarget==!0&&t.push({view:void 0,resolveTarget:void 0,loadOp:I.canvasConfig&&I.canvasConfig.alpha||e!=null?"load":"clear",clearValue:a,storeOp:"store"})}let r=null;return i.depthTexture||i.zPreTexture?(i.zPreTexture&&(i.depthTexture=i.zPreTexture),r={label:`${i.label} renderPassDescriptor zPreTexture${i.zPreTexture?"load":"clear"}`,colorAttachments:t,depthStencilAttachment:{view:i.depthTexture.getGPUView(),depthLoadOp:i.zPreTexture?"load":i.depthLoadOp,depthClearValue:i.zPreTexture?1:i.depthCleanValue,depthStoreOp:"store"}}):r={colorAttachments:t,label:"renderPassDescriptor not writeDepth"},this.renderPassDescriptorCount++,r}static getRenderBundleDescriptor(i){I.presentationSize;let e=[];if(i.renderTargets&&i.renderTargets.length>0){i.renderTargets[0].width,i.renderTargets[0].height;for(let r=0;r<i.renderTargets.length;r++){const a=i.renderTargets[r];e.push(a.format)}}let t=null;return i.depthTexture?t={colorFormats:e,depthStencilFormat:i.depthTexture.format}:t={colorFormats:e},this.renderPassDescriptorCount++,t}};let Qe=Qr;n(Qe,"bindGroupDescriptorCount",0),n(Qe,"bindTextureDescriptorCount",0),n(Qe,"renderPassDescriptorCount",0),n(Qe,"pipelineDescriptorCount",0);var X=(i=>(i.position="position",i.normal="normal",i.uv="uv",i.TANGENT="TANGENT",i.TEXCOORD_1="TEXCOORD_1",i.TEXCOORD_2="TEXCOORD_2",i.color="color",i.joints0="joints0",i.joints1="joints1",i.weights0="weights0",i.weights1="weights1",i.weight="weight",i.indices="indices",i.vIndex="vIndex",i.a_morphPositions_0="a_morphPositions_0",i))(X||{});class Hs extends qt{constructor(e){super(),n(this,"node"),this.bufferType=Tt.VertexGPUBuffer,this.createVertexBuffer(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.VERTEX,e)}createVertexBuffer(e,t){let r=I.device;this.byteSize=t*Float32Array.BYTES_PER_ELEMENT,this.usage=e,this.buffer&&this.destroy(),this.buffer=r.createBuffer({size:this.byteSize,usage:e,mappedAtCreation:!1}),this.memory.allocation(this.byteSize),this.node=this.memory.allocation_node(this.byteSize)}}var $t=(i=>(i[i.split=0]="split",i[i.compose=1]="compose",i))($t||{});class Wl{constructor(){n(this,"vertexCount",0),n(this,"vertexGPUBuffer"),n(this,"geometryType",$t.compose),n(this,"_vertexBufferLayouts"),n(this,"_attributeSlotLayouts"),n(this,"_attributeLocation"),this._vertexBufferLayouts=[],this._attributeLocation={},this._attributeSlotLayouts=[]}get vertexBufferLayouts(){return this._vertexBufferLayouts}createVertexBuffer(e,t){switch(this.geometryType){case $t.split:this.createSplitVertexBuffer(e,t);break;case $t.compose:this.createComposeVertexBuffer(e,t);break}}createSplitVertexBuffer(e,t){let r=0;for(let a=0;a<t.attributes.length;a++){const s=t.attributes[a];if(s.name=="index")continue;this._attributeLocation[s.name]=s.location;let o={name:s.name,format:s.format,offset:0,shaderLocation:s.location,stride:wi[s.format]};this._attributeSlotLayouts[s.location]=[o];let l=e.get(s.name);l||(l={attribute:s.name,data:new Float32Array(s.size*this.vertexCount)},e.set(s.name,l));let h=l.data.length/o.stride;this.vertexCount!=0&&this.vertexCount!=h&&console.error(" vertex count not match attribute count"),this.vertexCount=h,this._vertexBufferLayouts[s.location]={name:s.name,arrayStride:s.size*4,stepMode:"vertex",attributes:this._attributeSlotLayouts[s.location],offset:r*4,size:this.vertexCount*s.size*4},r+=this.vertexCount*s.size}this.vertexGPUBuffer=new Hs(r)}createComposeVertexBuffer(e,t){this._attributeSlotLayouts[0]=[];let r=0;for(let a=0;a<t.attributes.length;a++){const s=t.attributes[a];if(s.name=="index"||s.type=="builtin")continue;this._attributeLocation[s.name]=s.location;let o={name:s.name,format:s.format,offset:r*4,shaderLocation:s.location,stride:wi[s.format]};this._attributeSlotLayouts[0][s.location]=o;let l=e.get(s.name);l||(l={attribute:s.name,data:new Float32Array(s.size*this.vertexCount)},e.set(s.name,l));let h=l.data.length/o.stride;this.vertexCount!=0&&this.vertexCount!=h&&console.error(" vertex count not match attribute count"),this.vertexCount=h,r+=s.size}this._vertexBufferLayouts[0]={name:"composeStruct",arrayStride:r*4,stepMode:"vertex",attributes:this._attributeSlotLayouts[0],offset:0,size:this.vertexCount*r*4},this.vertexGPUBuffer=new Hs(this.vertexCount*r)}upload(e,t){var r;if(this.vertexGPUBuffer){switch(this.geometryType){case $t.split:{let a=this._attributeLocation[e],s=this._vertexBufferLayouts[a];this.vertexGPUBuffer.node.setFloat32Array(s.offset/4,t.data)}break;case $t.compose:for(let a=0;a<this.vertexCount;a++){const s=this._attributeSlotLayouts[0][this._attributeLocation[e]];for(let o=0;o<s.stride;o++){let l=t.data[a*s.stride+o],h=a*(this._vertexBufferLayouts[0].arrayStride/4)+s.offset/4+o;this.vertexGPUBuffer.node.setFloat(l,h)}}break}(r=this.vertexGPUBuffer)==null||r.apply()}}updateAttributes(e){switch(this.geometryType){case $t.split:for(let t=0;t<this._vertexBufferLayouts.length;t++){const r=this._vertexBufferLayouts[t];let a=e.get(r.name);this.vertexGPUBuffer.node.setFloat32Array(r.offset/4,a.data)}break;case $t.compose:for(let t=0;t<this.vertexCount;t++)this._attributeSlotLayouts.forEach(r=>{for(let a=0;a<r.length;a++){const s=r[a];let o=e.get(s.name);for(let l=0;l<s.stride;l++){let h=o.data[t*s.stride+l],u=t*(this._vertexBufferLayouts[0].arrayStride/4)+s.offset/4+l;this.vertexGPUBuffer.node.setFloat(h,u)}}});break}this.vertexGPUBuffer.apply()}compute(){}destroy(e){this.vertexCount=null,this.geometryType=null,this._vertexBufferLayouts=null,this._attributeSlotLayouts=null,this._attributeLocation=null,this.vertexGPUBuffer&&this.vertexGPUBuffer.destroy(e),this.vertexGPUBuffer=null}}class jl extends qt{constructor(e){super(),n(this,"indicesNode"),this.bufferType=Tt.IndicesGPUBuffer,this.createIndicesBuffer(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.INDEX|GPUBufferUsage.INDIRECT,e)}createIndicesBuffer(e,t){let r=I.device;this.byteSize=t.length*4,this.usage=e,this.buffer&&this.destroy(),this.buffer=r.createBuffer({size:this.byteSize,usage:e,mappedAtCreation:!1}),this.memory.allocation(this.byteSize),t&&(this.indicesNode=this.memory.allocation_node(t.length*4),this.indicesNode.setArrayBuffer(0,t),this.apply())}}class ql{constructor(){n(this,"uuid",""),n(this,"name"),n(this,"indicesGPUBuffer"),n(this,"indicesFormat","uint16"),n(this,"indicesCount",0)}createIndicesBuffer(e){e.data instanceof Uint16Array?this.indicesFormat="uint16":e.data instanceof Uint32Array&&(this.indicesFormat="uint32"),this.indicesCount=e.data.length,this.indicesGPUBuffer=new jl(e.data)}upload(e){this.indicesGPUBuffer.indicesNode.setArrayBuffer(0,e),this.indicesGPUBuffer.apply()}compute(){}destroy(){this.uuid=null,this.name=null,this.indicesFormat=null,this.indicesCount=null,this.indicesGPUBuffer.destroy(),this.indicesGPUBuffer=null}}class Kl{constructor(){n(this,"lodLevels")}}const Ti=class{constructor(){n(this,"instanceID"),n(this,"name"),n(this,"subGeometries",[]),n(this,"morphTargetsRelative"),n(this,"morphTargetDictionary"),n(this,"_bounds"),n(this,"_attributeMap"),n(this,"_attributes"),n(this,"_indicesBuffer"),n(this,"_vertexBuffer"),n(this,"_onChange",!0),this.instanceID=Mt(),this._attributeMap=new Map,this._attributes=[],this._vertexBuffer=new Wl}get indicesBuffer(){return this._indicesBuffer}get vertexBuffer(){return this._vertexBuffer}get vertexAttributes(){return this._attributes}get vertexAttributeMap(){return this._attributeMap}get geometryType(){return this._vertexBuffer.geometryType}set geometryType(i){this._vertexBuffer.geometryType=i}get bounds(){if(!this._bounds){this._bounds=new Be(new p,new p(1,1,1)),this._bounds.min.x=Number.MAX_VALUE,this._bounds.min.y=Number.MAX_VALUE,this._bounds.min.z=Number.MAX_VALUE,this._bounds.max.x=-Number.MAX_VALUE,this._bounds.max.y=-Number.MAX_VALUE,this._bounds.max.z=-Number.MAX_VALUE;let i=this.getAttribute(X.position);if(i)for(let e=0;e<i.data.length/3;e++){const t=i.data[e*3+0],r=i.data[e*3+1],a=i.data[e*3+2];this._bounds.min.x>t&&(this._bounds.min.x=t),this._bounds.min.y>r&&(this._bounds.min.y=r),this._bounds.min.z>a&&(this._bounds.min.z=a),this._bounds.max.x<t&&(this._bounds.max.x=t),this._bounds.max.y<r&&(this._bounds.max.y=r),this._bounds.max.z<a&&(this._bounds.max.z=a)}this._bounds.setFromMinMax(this._bounds.min,this._bounds.max)}return this._bounds}set bounds(i){this._bounds=i}addSubGeometry(...i){let e=new Kl;e.lodLevels=i,this.subGeometries.push(e)}generate(i){this._onChange&&(this._onChange=!1,this._indicesBuffer.upload(this.getAttribute(X.indices).data),this._vertexBuffer.createVertexBuffer(this._attributeMap,i),this._vertexBuffer.updateAttributes(this._attributeMap))}setIndices(i){if(!this._attributeMap.has(X.indices)){let e={attribute:X.indices,data:i};this._attributeMap.set(X.indices,e),this._indicesBuffer=new ql,this._indicesBuffer.createIndicesBuffer(e)}}setAttribute(i,e){if(i==X.indices)this.setIndices(e);else{let t={attribute:i,data:e};this._attributeMap.set(i,t),this._attributes.push(i)}}getAttribute(i){return this._attributeMap.get(i)}hasAttribute(i){return this._attributeMap.has(i)}genWireframe(){let i=this.getAttribute("position"),e=this.getAttribute("indices");if(e&&i&&e.data.length>0){let t=i.data,r=[];for(let a=0;a<e.data.length/3;a++){const s=e.data[a*3+0],o=e.data[a*3+1],l=e.data[a*3+2];let h=new p(t[s*3+0],t[s*3+1],t[s*3+2]),u=new p(t[o*3+0],t[o*3+1],t[o*3+2]),c=new p(t[l*3+0],t[l*3+1],t[l*3+2]);r.push(h,u),r.push(u,c),r.push(c,h)}return r}return null}compute(){this._indicesBuffer&&this._indicesBuffer.compute(),this._vertexBuffer&&this._vertexBuffer.compute()}computeNormals(){let i=this.getAttribute(X.position),e=this.getAttribute(X.normal),t=this.getAttribute(X.indices);if(!i||!e||!t)return this;let r=t.data.length/3,a=Ti.point1,s=Ti.point2,o=Ti.point3,l=Ti.crossA,h=Ti.crossB,u=Ti.crossRet;for(let c=0;c<r;c++){let d=t.data[c*3],g=t.data[c*3+1],m=t.data[c*3+2];a.set(i.data[d*3],i.data[d*3+1],i.data[d*3+2]),s.set(i.data[g*3],i.data[g*3+1],i.data[g*3+2]),o.set(i.data[m*3],i.data[m*3+1],i.data[m*3+2]),p.sub(a,s,l).normalize(),p.sub(a,o,h).normalize();let A=l.crossProduct(h,u).normalize();e.data[d*3]=e.data[g*3]=e.data[m*3]=A.x,e.data[d*3+1]=e.data[g*3+1]=e.data[m*3+1]=A.y,e.data[d*3+2]=e.data[g*3+2]=e.data[m*3+2]=A.z}return this._vertexBuffer.upload(X.normal,e),this}isPrimitive(){return!1}destroy(i){this.instanceID=null,this.name=null,this.subGeometries=null,this.morphTargetDictionary=null,this._bounds.destroy(),this._bounds=null,this._attributeMap=null,this._attributes=null,this._indicesBuffer.destroy(),this._vertexBuffer.destroy(),this._indicesBuffer=null,this._vertexBuffer=null}};let it=Ti;n(it,"crossA",p.UP.clone()),n(it,"crossB",p.UP.clone()),n(it,"crossRet",p.UP.clone()),n(it,"point1",p.UP.clone()),n(it,"point2",p.UP.clone()),n(it,"point3",p.UP.clone());class Jl extends it{constructor(e,t,r=1,a=1,s=p.Y_AXIS){super(),n(this,"width"),n(this,"height"),n(this,"segmentW"),n(this,"segmentH"),n(this,"up"),this.width=e,this.height=t,this.segmentW=r,this.segmentH=a,this.up=s,this.buildGeometry(this.up)}buildGeometry(e){var t,r,a,s,o=this.segmentW+1;(this.segmentH+1)*o,this.bounds=new Be(p.ZERO.clone(),new p(this.width,1,this.height)),a=this.segmentH*this.segmentW*6;let l=(this.segmentW+1)*(this.segmentH+1),h=new Float32Array(l*3),u=new Float32Array(l*3),c=new Float32Array(l*2),d;this.segmentW*this.segmentH*2*3>=Uint16Array.length?d=new Uint32Array(this.segmentW*this.segmentH*2*3):d=new Uint16Array(this.segmentW*this.segmentH*2*3),a=0;for(var m=0,A=0,v=0,y=0;y<=this.segmentH;++y)for(var C=0;C<=this.segmentW;++C){switch(t=(C/this.segmentW-.5)*this.width,r=(y/this.segmentH-.5)*this.height,e){case p.Y_AXIS:h[m++]=t,h[m++]=0,h[m++]=r,u[A++]=0,u[A++]=1,u[A++]=0;break;case p.Z_AXIS:h[m++]=t,h[m++]=-r,h[m++]=0,u[A++]=0,u[A++]=0,u[A++]=1;break;case p.X_AXIS:h[m++]=0,h[m++]=t,h[m++]=r,u[A++]=1,u[A++]=0,u[A++]=0;break;default:h[m++]=t,h[m++]=0,h[m++]=r,u[A++]=0,u[A++]=1,u[A++]=0;break}c[v++]=C/this.segmentW,c[v++]=y/this.segmentH,C!=this.segmentW&&y!=this.segmentH&&(s=C+y*o,d[a++]=s+1,d[a++]=s,d[a++]=s+o,d[a++]=s+1,d[a++]=s+o,d[a++]=s+o+1)}this.setIndices(d),this.setAttribute(X.position,h),this.setAttribute(X.normal,u),this.setAttribute(X.uv,c),this.setAttribute(X.TEXCOORD_1,c),this.addSubGeometry({indexStart:0,indexCount:d.length,vertexStart:0,index:0})}}class Na extends f.Object3D{constructor(e="QuadGlsl_vs",t="QuadGlsl_fs",r,a,s=0,o=!1){super(),n(this,"width",128),n(this,"height",128),n(this,"quadRenderer"),n(this,"material"),n(this,"uniforms"),n(this,"rendererPassState"),n(this,"pass");let l=r?r.attachments:[];this.material=new vi,this.pass=new He(e,t),this.material.addPass(re.COLOR,this.pass),this.pass.blendMode=ve.NONE;let h=this.pass.shaderState;h.frontFace="cw",h.depthWriteEnabled=!1,h.depthCompare=_t.always,h.multisample=s,this.uniforms=this.pass.uniforms=a||{color:new ee(new z)},this.quadRenderer=this.addComponent(ue),this.quadRenderer.material=this.material,this.quadRenderer.castGI=!1,this.quadRenderer.castShadow=!1,this.quadRenderer.drawType=o?2:0,this.quadRenderer.geometry=new Jl(100,100,1,1),this.colorTexture=_.res.blackTexture,this.pass.setUniformFloat("x",0),this.pass.setUniformFloat("y",0),this.pass.setUniformFloat("width",100),this.pass.setUniformFloat("height",100),this.quadRenderer.material=this.material,this.quadRenderer.__start(),this.quadRenderer._enable=!0,this.quadRenderer.onEnable(),this.rendererPassState=Qe.createRendererPassState(r,"load"),h.multisample>0&&(this.rendererPassState.multisample=h.multisample,this.rendererPassState.multiTexture=I.device.createTexture({size:{width:I.presentationSize[0],height:I.presentationSize[1]},sampleCount:h.multisample,format:l.length>0?l[0].format:I.presentationFormat,usage:GPUTextureUsage.RENDER_ATTACHMENT}))}set colorTexture(e){this.material.getPass(re.COLOR)[0].setTexture("baseMap",e)}renderTarget(e,t,r){let a=e.camera,s=w.beginRenderPass(r,t.rendererPassState);w.bindCamera(s,a),t.quadRenderer.nodeUpdate(e,re.COLOR,t.rendererPassState,null),t.quadRenderer.renderPass2(e,re.COLOR,t.rendererPassState,null,s),w.endPass(s)}renderToViewQuad(e,t,r,a){let s=e.camera;t.colorTexture=a;let o=w.beginRenderPass(r,t.rendererPassState);w.bindCamera(o,s),t.quadRenderer.nodeUpdate(e,re.COLOR,t.rendererPassState,null),t.quadRenderer.renderPass2(e,re.COLOR,t.rendererPassState,null,o),w.endPass(o)}}class ne extends st{constructor(e,t,r=G.rgba8unorm,a=!1,s,o=1,l=0,h=!0){super(e,t,o),n(this,"resolveTarget");let u=I.device;this.name=Mt(),s!=null?this.usage=s:this.usage=GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST,this.createTextureDescriptor(e,t,1,r,this.usage,o,l),this.useMipmap=!1,this.visibility=GPUShaderStage.COMPUTE|GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,r==G.rgba32float?(this.samplerBindingLayout.type="non-filtering",this.textureBindingLayout.sampleType="unfilterable-float",this.gpuSampler=u.createSampler({})):r==G.depth32float?(this.samplerBindingLayout.type="filtering",this.sampler_comparisonBindingLayout.type="comparison",this.textureBindingLayout.sampleType="depth",this.gpuSampler=I.device.createSampler({}),this.gpuSampler_comparison=I.device.createSampler({compare:"less",label:"sampler_comparison"})):r==G.depth24plus?(this.samplerBindingLayout={type:"filtering"},this.sampler_comparisonBindingLayout={type:"comparison"},this.textureBindingLayout.sampleType="depth",this.gpuSampler=I.device.createSampler({}),this.gpuSampler_comparison=I.device.createSampler({compare:"less",label:"sampler_comparison"})):(this.samplerBindingLayout.type="filtering",this.textureBindingLayout.sampleType="float",l>0&&(this.textureBindingLayout.multisampled=!0),this.minFilter="linear",this.magFilter="linear",this.mipmapFilter="linear",this.maxAnisotropy=16,this.addressModeU=Et.clamp_to_edge,this.addressModeV=Et.clamp_to_edge,this.gpuSampler=u.createSampler(this))}create(e,t,r=!0){let a=I.device;const s=e*4;let o=new Float32Array(e*t*4);const l=a.createBuffer({size:o.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC});a.queue.writeBuffer(l,0,o);const h=w.beginCommandEncoder();h.copyBufferToTexture({buffer:l,bytesPerRow:s},{texture:this.getGPUTexture()},{width:e,height:t,depthOrArrayLayers:1}),w.endCommandEncoder(h)}readTextureToImage(){let e=I.device,t=I.windowWidth,r=I.windowHeight,a=new Float32Array(t*r*4);const s=e.createBuffer({size:a.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC});return w.beginCommandEncoder().copyTextureToBuffer({texture:this.getGPUTexture()},{buffer:s},[t,r]),s.getMappedRange(0,a.byteLength)}}class Ce{constructor(){n(this,"storeOp","store"),n(this,"loadOp","clear"),n(this,"clearValue",[0,0,0,0])}}class Ke{constructor(e,t,r,a,s=!0){n(this,"label"),n(this,"customSize",!1),n(this,"attachments"),n(this,"rtDescriptors"),n(this,"zPreTexture"),n(this,"depthTexture"),n(this,"depthViewIndex",0),n(this,"depthCleanValue",1),n(this,"depthLoadOp","clear"),n(this,"isOutTarget",!0),this.attachments=e,this.rtDescriptors=t,this.depthTexture=r,this.zPreTexture=a,this.isOutTarget=s}clone2Frame(e){e.attachments.push(...this.attachments.concat());for(let t=0;t<this.rtDescriptors.length;t++){const r=this.rtDescriptors[t];let a=new Ce;a.loadOp=r.loadOp,a.storeOp=r.storeOp,a.clearValue=r.clearValue,e.rtDescriptors.push(a)}e.depthTexture=this.depthTexture,e.zPreTexture=this.zPreTexture,e.customSize=this.customSize}clone(){let e=new Ke([],[]);return this.clone2Frame(e),e}}const Fa=class{static init(){this.rtTextureMap=new Map,this.rtViewQuad=new Map}static createRTTexture(i,e,t,r,a=!1,s=0){let o=this.rtTextureMap.get(i);return o||(i==Ae.colorBufferTex_NAME?o=new ne(e,t,r,a,void 0,1,s,!1):o=new ne(e,t,r,a,void 0,1,s,!0),o.name=i,Fa.rtTextureMap.set(i,o)),o}static createRTTextureArray(i,e,t,r,a=1,s=!1,o=0){let l=this.rtTextureMap.get(i);return l||(l=new ne(e,t,r,s,void 0,a,o),l.name=i,Fa.rtTextureMap.set(i,l)),l}static createViewQuad(i,e,t,r,a,s=0){let o=new Ke([r],[new Ce]),l=new Na(e,t,o,a,s);return Fa.rtViewQuad.set(i,l),l}static getTexture(i){return this.rtTextureMap.get(i)}static CreateSplitTexture(i){let e=this.getTexture(Ae.colorBufferTex_NAME),t=this.getTexture(i+"_split");return t||(t=this.createRTTexture(i+"_split",e.width,e.height,e.format,!1)),t}static WriteSplitColorTexture(i){let e=this.getTexture(Ae.colorBufferTex_NAME),t=this.getTexture(i+"_split");const r=w.beginCommandEncoder();r.copyTextureToTexture({texture:e.getGPUTexture(),mipLevel:0,origin:{x:0,y:0,z:0}},{texture:t.getGPUTexture(),mipLevel:0,origin:{x:0,y:0,z:0}},{width:t.width,height:t.height,depthOrArrayLayers:1}),w.endCommandEncoder(r)}};let Ne=Fa;n(Ne,"rtTextureMap"),n(Ne,"rtViewQuad");class xt{constructor(){n(this,"enable",!0),n(this,"postRenderer"),n(this,"rtViewQuad"),n(this,"virtualTexture"),this.rtViewQuad=new Map,this.virtualTexture=new Map}createRTTexture(e,t,r,a,s=!1,o=0){let l=Ne.createRTTexture(e,t,r,a,s,o);return l.name=e,this.virtualTexture.set(e,l),ae.getInstance().attached(l,this),l}createViewQuad(e,t,r,a,s=0){let o=Ne.createViewQuad(e,"Quad_vert_wgsl",t,r,a,s);return this.rtViewQuad.set(e,o),o}getOutTexture(){let e,t=w.lastRenderPassState.renderTargets;return t.length>0?e=t[0]:e=Ne.getTexture(Ae.colorBufferTex_NAME),e}autoSetColorTexture(e,t){let r=this.getOutTexture();t.setSamplerTexture(e,r)}compute(e){}onAttach(e){}onDetach(e){}render(e,t){this.compute(e),this.rtViewQuad.forEach((r,a)=>{let s=w.lastRenderPassState.getLastRenderTexture();r.renderToViewQuad(e,r,t,s)})}destroy(e){this.postRenderer=null;for(let t=0;t<this.rtViewQuad.size;t++)this.rtViewQuad.values[t].destroy(e);this.rtViewQuad.clear(),this.rtViewQuad=null;for(let t=0;t<this.virtualTexture.size;t++){const r=this.virtualTexture.values[t];ae.getInstance().detached(r,this),r.destroy(e)}}}class Ys extends xt{constructor(){super();let e=I.presentationSize;Ne.createRTTexture(Ae.colorBufferTex_NAME,e[0],e[1],G.rgba16float,!1),N.register("FXAA_Shader",Sc);let t={u_texel:new ee(new $(1/e[0],1/e[1])),u_strength:new ee(4)},r=this.createRTTexture("FXAAPost",e[0],e[1],G.rgba16float);this.createViewQuad("fxaa","FXAA_Shader",r,t)}onAttach(e){_.setting.render.postProcessing.fxaa.enable=!0}onDetach(e){_.setting.render.postProcessing.fxaa.enable=!1}}class Zl{constructor(e){n(this,"command"),n(this,"encoder"),n(this,"rendererPassStates"),n(this,"rtFrame"),this.rtFrame=e,this.rendererPassStates=[]}clean(){this.rendererPassStates.length=0,w.cleanCache()}beginContinueRendererPassState(){if(this.rendererPassStates.length>0){let e=this.rtFrame.clone();for(const r of e.rtDescriptors)r.loadOp="load";e.depthLoadOp="load";let t=Qe.createRendererPassState(e);return this.rendererPassStates.push(t),t}else{let e=Qe.createRendererPassState(this.rtFrame);return this.rendererPassStates.push(e),e}}get rendererPassState(){return this.rendererPassStates[this.rendererPassStates.length-1]}beginRenderPass(){this.beginContinueRendererPassState(),this.begineNewCommand(),this.beginNewEncoder()}endRenderPass(){this.endEncoder(),this.endCommand()}begineNewCommand(){return this.command=w.beginCommandEncoder(),this.command}endCommand(){w.endCommandEncoder(this.command),this.command=null}beginNewEncoder(){return this.encoder=w.beginRenderPass(this.command,this.rendererPassState),this.encoder}endEncoder(){w.endPass(this.encoder),this.encoder=null}}class di extends hi{constructor(){super(),n(this,"rendererPassState"),n(this,"splitRendererPassState"),n(this,"useRenderBundle",!1),n(this,"debugViewQuads"),n(this,"debugTextures"),n(this,"renderContext"),n(this,"_rendererType"),n(this,"_rtFrame"),this.debugTextures=[],this.debugViewQuads=[]}get passType(){return this._rendererType}set passType(e){this._rendererType=e}setRenderStates(e){if(this._rtFrame=e,e){this.rendererPassState=Qe.createRendererPassState(e);let t=e.clone();t.depthLoadOp="load";for(const r of t.rtDescriptors)r.loadOp="load";this.splitRendererPassState=Qe.createRendererPassState(t)}this.renderContext=new Zl(e)}setIrradiance(e,t){this.rendererPassState.irradianceBuffer=[e,t]}compute(e,t){}render(e,t,r,a=!1){w.cleanCache();let s=e.camera,o=e.scene;this.rendererPassState.camera3D=s;let l=Q.instance.getRenderNodes(o,s),h=this.renderBundleOp(e,l,t,r),u=a?[]:this.renderBundleTr(e,l,t,r);{let c=w.beginCommandEncoder(),d=w.beginRenderPass(c,this.rendererPassState);h.length>0&&d.executeBundles(h),!a&&Q.instance.sky&&(w.bindCamera(d,s),Q.instance.sky.renderPass2(e,this._rendererType,this.rendererPassState,r,d)),this.drawRenderNodes(e,d,c,l.opaqueList,t),w.endPass(d),w.endCommandEncoder(c)}{let c=w.beginCommandEncoder(),d=w.beginRenderPass(c,this.rendererPassState);u.length>0&&d.executeBundles(u),a||(w.bindCamera(d,s),this.drawRenderNodes(e,d,c,l.transparentList,t)),w.endPass(d),w.endCommandEncoder(c)}}nodeUpload(e,t,r){}occlusionRenderNodeTest(e,t,r){return r?r.occlusionRenderNodeTest(e)>0:!0}renderOp(e,t,r,a,s){}renderTr(e,t,r,a,s){}renderBundleOp(e,t,r,a){let s=Q.instance.getOpRenderGroup(e.scene);if(s){let o=[];return s.renderGroup.forEach(l=>{if(l.bundleMap.has(this._rendererType))o.push(l.bundleMap.get(this._rendererType));else{let h=w.recordBundleEncoder(this.rendererPassState.renderBundleEncoderDescriptor);this.recordRenderBundleNode(e,h,l.renderNodes,a);let u=h.finish();l.bundleMap.set(this._rendererType,u),o.push(u)}}),o}return[]}renderBundleTr(e,t,r,a){let s=Q.instance.getTrRenderGroup(e.scene);if(s){let o=[];return s.renderGroup.forEach(l=>{if(l.bundleMap.has(this._rendererType))o.push(l.bundleMap.get(this._rendererType));else{let h=w.recordBundleEncoder(this.rendererPassState.renderBundleEncoderDescriptor);this.recordRenderBundleNode(e,h,l.renderNodes,a);let u=h.finish();l.bundleMap.set(this._rendererType,u),o.push(u)}}),o}return[]}recordRenderBundleNode(e,t,r,a){w.bindCamera(t,e.camera),w.bindGeometryBuffer(t,r[0].geometry);for(let s=0;s<r.length;++s){let o=r[s];o.transform.worldMatrix.index,o.transform.enable&&o.recordRenderPass2(e,this._rendererType,this.rendererPassState,a,t)}}drawRenderNodes(e,t,r,a,s,o){w.bindCamera(t,e.camera);for(let l=_.setting.render.drawOpMin;l<Math.min(a.length,_.setting.render.drawOpMax);++l){let h=a[l];h.transform.enable&&h.enable&&h.renderPass2(e,this._rendererType,this.rendererPassState,o,t)}}setDebugTexture(e){for(let t=0;t<e.length;t++){let r=e[t],a="Quad_vert_wgsl",s="Quad_frag_wgsl";switch(r.format){case G.rgba8sint:case G.rgba8uint:case G.rgba8unorm:case G.rgba16float:case G.rgba32float:s="Quad_frag_wgsl";break;case G.depth24plus:case G.depth32float:s="Quad_depth2d_frag_wgsl",r.textureBindingLayout.viewDimension=="cube"&&(s="Quad_depthCube_frag_wgsl");break}let o=new Na(a,s,new Ke([],[]));this.debugTextures.push(e[t]),this.debugViewQuads.push(o)}}}class $l extends di{constructor(){super(),this.passType=re.COLOR}render(e,t,r,a=!1){this.renderContext.clean();let s=e.scene,o=e.camera;this.rendererPassState.camera3D=o;let l=Q.instance.getRenderNodes(s,o),h=this.renderBundleOp(e,l,t,r),u=a?[]:this.renderBundleTr(e,l,t,r);ft.start("colorPass Renderer");{ft.start("ColorPass Draw Opaque"),this.renderContext.beginRenderPass(),this.renderContext.command;let c=this.renderContext.encoder;w.bindCamera(c,o),h.length>0&&(Q.instance.getOpRenderGroup(s),c.executeBundles(h)),!a&&Q.instance.sky&&(w.bindCamera(c,o),Q.instance.sky.preInit||Q.instance.sky.nodeUpdate(e,this._rendererType,this.rendererPassState,r),Q.instance.sky.renderPass2(e,this._rendererType,this.rendererPassState,r,c)),l.opaqueList&&(w.bindCamera(c,o),this.drawNodes(e,this.renderContext,l.opaqueList,t,r),this.renderContext.endRenderPass(),ft.end("ColorPass Draw Opaque"))}{ft.start("ColorPass Draw Transparent"),this.renderContext.beginRenderPass(),this.renderContext.command;let c=this.renderContext.encoder;u.length>0&&c.executeBundles(u),!a&&l.transparentList&&(w.bindCamera(c,o),this.drawNodes(e,this.renderContext,l.transparentList,t,r));let d=Q.instance.getGraphicList();for(let g=0;g<d.length;g++){const m=d[g];m.transform.worldMatrix.index,m.nodeUpdate(e,this._rendererType,this.splitRendererPassState,r),m.renderPass2(e,this._rendererType,this.splitRendererPassState,r,c)}this.renderContext.endRenderPass(),ft.end("ColorPass Draw Transparent")}ft.end("colorPass Renderer")}drawNodes(e,t,r,a,s){{let o=Q.instance.getRenderShaderCollect(e);for(const l of o){let h=l[1];for(const u of h){let c=u[1];if(c.preInit){c.nodeUpdate(e,this._rendererType,this.rendererPassState,s);break}}}for(let l=_.setting.render.drawOpMin;l<Math.min(r.length,_.setting.render.drawOpMax);++l){let h=r[l];h.transform.enable&&h.enable&&(h.preInit||h.nodeUpdate(e,this._rendererType,this.rendererPassState,s),h.renderPass(e,this.passType,this.renderContext))}}}occlusionRenderNodeTest(e,t,r){return r.zDepthRenderNodeTest(t)>0}}const tr=class extends Ke{constructor(){super([],[])}crateGBuffer(i,e,t){let r=this.attachments,a=this.rtDescriptors,s=Ne.createRTTexture(i+Ae.colorBufferTex_NAME,e,t,G.rgba16float,!1),o=Ne.createRTTexture(i+Ae.positionBufferTex_NAME,e,t,G.rgba16float,!1),l=Ne.createRTTexture(i+Ae.normalBufferTex_NAME,e,t,G.rgba8unorm,!1),h=Ne.createRTTexture(i+Ae.materialBufferTex_NAME,e,t,G.rgba8unorm,!1);r.push(s),r.push(o),r.push(l),r.push(h);let u=new Ce;u.loadOp="clear";let c=new ne(e,t,G.depth32float,!1);c.name="depthTexture";let d=new Ce;d.loadOp="load",this.depthTexture=c,a.push(u),a.push(new Ce),a.push(new Ce),a.push(new Ce)}getColorMap(){return this.attachments[0]}getPositionMap(){return this.attachments[1]}getNormalMap(){return this.attachments[2]}getMaterialMap(){return this.attachments[3]}static getGBufferFrame(i){let e;if(tr.gBufferMap.has(i))e=tr.gBufferMap.get(i);else{e=new tr;let t=I.presentationSize;e.crateGBuffer(i,t[0],t[1]),tr.gBufferMap.set(i,e)}return e}clone(){let i=new tr;return this.clone2Frame(i),i}};let yt=tr;n(yt,"gBufferMap",new Map);class ka{constructor(){n(this,"frustumCullingList"),n(this,"zVisibleList"),n(this,"_renderList"),this._renderList=new Map}occlusionRenderNodeTest(e){return _.setting.occlusionQuery.enable?this.frustumCullingList?this.frustumCullingList[e]:0:1}zDepthRenderNodeTest(e){return this.zVisibleList?this.zVisibleList[e]:0}update(e,t){}collect(e,t){}renderCommitTesting(e,t){return!0}}n(ka,"enable",!0);class ir extends qt{constructor(e,t){super(),this.bufferType=Tt.ComputeGPUBuffer,this.createBuffer(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST,e,t)}}class eh{constructor(e,t){n(this,"clusterBuffer"),n(this,"lightAssignBuffer"),n(this,"assignTableBuffer"),n(this,"clustersUniformBuffer"),this.clusterBuffer=new ir(e*2*4),this.clustersUniformBuffer=new Dt(10),this.clustersUniformBuffer.visibility=GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,this.lightAssignBuffer=new ir(e*t),this.lightAssignBuffer.visibility=GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,this.assignTableBuffer=new ir(e*4),this.assignTableBuffer.visibility=GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE}update(e,t,r,a,s,o,l,h,u,c){this.clustersUniformBuffer.setFloat("clusterTileX",a),this.clustersUniformBuffer.setFloat("clusterTileY",s),this.clustersUniformBuffer.setFloat("clusterTileZ",o),this.clustersUniformBuffer.setFloat("numLights",l),this.clustersUniformBuffer.setFloat("maxNumLightsPerCluster",h),this.clustersUniformBuffer.setFloat("near",u),this.clustersUniformBuffer.setFloat("far",c),this.clustersUniformBuffer.setFloat("screenWidth",e),this.clustersUniformBuffer.setFloat("screenHeight",t),this.clustersUniformBuffer.setFloat("clusterPix",r),this.clustersUniformBuffer.apply()}}class Fe{}n(Fe,"clusterTileX",16),n(Fe,"clusterTileY",16),n(Fe,"clusterTileZ",32);let th=`
  #include "GlobalUniform"

        struct ClusterBox{
            minPoint:vec4<f32>,
            maxPoint:vec4<f32>
        }

        struct ClustersUniform{
            clusterTileX:f32,
            clusterTileY:f32,
            clusterTileZ:f32,
            numLights:f32,
            maxNumLightsPerCluster:f32,
            near:f32,
            far:f32,
            screenWidth:f32,
            screenHeight:f32,
            clusterPix:f32
        }
     
        @group(0) @binding(1) var<uniform> clustersUniform : ClustersUniform;
        @group(0) @binding(2) var<storage,read_write> clusterBuffer : array<ClusterBox>;


        var<private> clusterTileX:f32 ;
        var<private> clusterTileY:f32 ;
        var<private> clusterTileZ:f32 ;
        fn convertNDCToView( v4:vec4<f32> ) -> vec4<f32> {
            var v = globalUniform.pvMatrixInv * v4 ;
            v = v / v.w ;
            return v ;
        }

        fn gridToIndex(i:vec3<u32>) -> u32{
            return i.z * u32(clusterTileX) * u32(clusterTileY) + i.y * u32(clusterTileX) + i.x ;
        }

        fn ScreenToView(screen : vec4<f32>) -> vec4<f32> {
            let texCoord = screen.xy / vec2<f32>(clustersUniform.screenWidth, clustersUniform.screenHeight);
            let clip = vec4<f32>(vec2<f32>(texCoord.x, 1.0 - texCoord.y) * 2.0 - vec2<f32>(1.0, 1.0), screen.z, screen.w);
            return convertNDCToView(clip);
          }

        fn LineIntersectionToZPlane( eye:vec3<f32> , ndcPoint :vec3<f32> , z:f32) -> vec3<f32>
        {
            var normal = vec3<f32>(0.0, 0.0, 1.0);
            var dir = ndcPoint - eye;
            var t = (z - dot(normal, eye)) / dot(normal, dir);
            var result = eye + t * dir;
            return result;
        }

        @compute @workgroup_size(${Fe.clusterTileX},${Fe.clusterTileY},1)
        fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(local_invocation_id) local_invocation_id : vec3<u32> ){

            let i = local_invocation_id.x ;
            let j = local_invocation_id.y ;
            let k = workgroup_id.x ;

            clusterTileX = clustersUniform.clusterTileX;
            clusterTileY = clustersUniform.clusterTileY;
            clusterTileZ = clustersUniform.clusterTileZ;

            let clusterGrid = vec3<u32>(i,j,k);
            let tileIndex = gridToIndex(clusterGrid);
            let eyePos = vec3<f32>(0.0, 0.0, 0.0);

            let tx = clusterTileX;
            let ty = clusterTileY;
            let tz = clusterTileZ ;
            let near = clustersUniform.near ;
            let far = clustersUniform.far ;

            let titleSize = vec2<f32>( globalUniform.windowWidth / tx , globalUniform.windowHeight / ty ) ;

            var maxPointSs = vec4<f32>(vec2<f32>(f32(i) + 1.0, f32(j) + 1.0) * titleSize, 0.0, 1.0);
	        var minPointSs = vec4<f32>(vec2<f32>(f32(i) , f32(j)) * titleSize, 0.0, 1.0);

            var maxPointVs = ScreenToView(maxPointSs).xyz;
	        var minPointVs = ScreenToView(minPointSs).xyz;
 
            var tileNear = clustersUniform.near * pow(clustersUniform.far / clustersUniform.near, f32(k) / clustersUniform.clusterTileZ);
	        var tileFar = clustersUniform.near * pow(clustersUniform.far / clustersUniform.near, (f32(k) + 1.0) / clustersUniform.clusterTileZ);

            var minPointNear = LineIntersectionToZPlane(eyePos, minPointVs, tileNear);
            var minPointFar = LineIntersectionToZPlane(eyePos, minPointVs, tileFar);
            var maxPointNear = LineIntersectionToZPlane(eyePos, maxPointVs, tileNear);
            var maxPointFar = LineIntersectionToZPlane(eyePos, maxPointVs, tileFar);

            var minPointAABB = min(min(minPointNear, minPointFar), min(maxPointNear, maxPointFar));
            var maxPointAABB = max(max(minPointNear, minPointFar), max(maxPointNear, maxPointFar));

            var clusterBox : ClusterBox ;
            clusterBox.minPoint = vec4<f32>(minPointAABB,f32(tileIndex)) ;
            clusterBox.maxPoint = vec4<f32>(maxPointAABB,f32(tileIndex)) ;
            clusterBuffer[tileIndex] = clusterBox;
        }
`,ih=`
#include "GlobalUniform"

struct ClusterBox{
    min:vec4<f32>,
    max:vec4<f32>
}

struct Light {
    index:f32,
    lightType:i32,
    radius:f32,
    linear:f32,

    position:vec3<f32>,
    lightMatrixIndex:f32,

    direction:vec3<f32>,
    quadratic:f32,

    lightColor:vec3<f32>,
    intensity:f32,

    innerCutOff :f32,
    outerCutOff:f32,
    range :f32,
    castShadow:f32,

    lightTangent:vec3<f32>,
    ies:f32,
};

struct LightIndex
{
    count:f32,
    start:f32,
    empty0:f32,
    empty1:f32,
};

struct ClustersUniform{
    clusterTileX:f32,
    clusterTileY:f32,
    clusterTileZ:f32,
    numLights:f32,
    maxNumLightsPerCluster:f32,
    near:f32,
    far:f32,
    screenWidth:f32,
    screenHeight:f32,
    clusterPix:f32, 
}

var<private> clusterTileX:f32 ;
var<private> clusterTileY:f32 ;
var<private> clusterTileZ:f32 ;

// @group(0) @binding(1) var<storage, read> models : Uniforms;
@group(0) @binding(1) var<uniform> clustersUniform : ClustersUniform;
@group(0) @binding(2) var<storage,read> clusterBuffer : array<ClusterBox>;
@group(0) @binding(3) var<storage,read> lightBuffer : array<Light>; 
@group(0) @binding(4) var<storage,read_write> lightAssignBuffer : array<f32>;
@group(0) @binding(5) var<storage,read_write> assignTable : array<LightIndex>;

fn gridToIndex(i:vec3<u32>) -> u32{
    return i.z * u32(clusterTileX) * u32(clusterTileY) + i.y * u32(clusterTileX) + i.x ;
}

fn GetSqdisPointAABB( pos:vec3<f32>,  cluster:ClusterBox  ) -> f32
{
    var sqDistance = 0.0;
    for (var i = 0u; i < 3u; i+=1u)
    {
        var v = pos[i];
        if (v < cluster.min[i])
        {
            let diff = cluster.min[i] - v;
            sqDistance += diff * diff;
        }

        if (v > cluster.max[i])
        {
            let diff =  v - cluster.max[i];
            sqDistance += diff * diff;
        }
    }
    return sqDistance;
}

fn TestSphereAABB( box:ClusterBox ,light:Light ) -> bool
{
    let lightPos = light.position.xyz;
    var radius = light.range * 2.0 ;
    var spherePos = globalUniform.viewMat * vec4<f32>(lightPos.xyz, 1.0) ;
    spherePos = spherePos / spherePos.w ;
    let sqDistance = GetSqdisPointAABB(spherePos.xyz , box);
    return sqDistance <= (radius*radius);
}

@compute @workgroup_size(${Fe.clusterTileX},${Fe.clusterTileY},1)
fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(local_invocation_id) local_invocation_id : vec3<u32> ){
    // cluster ID 
    let i = local_invocation_id.x ;
    let j = local_invocation_id.y ;
    let k = workgroup_id.x ;

    clusterTileX = clustersUniform.clusterTileX;
    clusterTileY = clustersUniform.clusterTileY;
    clusterTileZ = clustersUniform.clusterTileZ;

    var clusterId_3D = vec3<u32>(i,j,k);
    var clusterId_1D = gridToIndex(clusterId_3D);

    var box:ClusterBox = clusterBuffer[clusterId_1D];

    var startIndex = i32(clusterId_1D) * i32(clustersUniform.maxNumLightsPerCluster) ;
    var endIndex = startIndex;

    for(var lightID = 0 ; lightID < i32(clustersUniform.numLights) ; lightID+=1)
    {
        let li:Light = lightBuffer[lightID];
        if(!TestSphereAABB(box, li)) {
            continue;
        }
        lightAssignBuffer[endIndex] = f32(lightID);
        endIndex++;
    }

    var idx: LightIndex;
    idx.count = f32(endIndex-startIndex);
    idx.start = f32(startIndex);
    idx.empty0 = f32(clusterId_1D);
    idx.empty1 = f32(clustersUniform.maxNumLightsPerCluster);
    assignTable[clusterId_1D] = idx;
}
`;function Wd(i){if(i&&!(typeof window>"u")){var e=document.createElement("style");return e.setAttribute("type","text/css"),e.innerHTML=i,document.head.appendChild(e),i}}function rr(i,e){var t=i.__state.conversionName.toString(),r=Math.round(i.r),a=Math.round(i.g),s=Math.round(i.b),o=i.a,l=Math.round(i.h),h=i.s.toFixed(1),u=i.v.toFixed(1);if(e||t==="THREE_CHAR_HEX"||t==="SIX_CHAR_HEX"){for(var c=i.hex.toString(16);c.length<6;)c="0"+c;return"#"+c}else{if(t==="CSS_RGB")return"rgb("+r+","+a+","+s+")";if(t==="CSS_RGBA")return"rgba("+r+","+a+","+s+","+o+")";if(t==="HEX")return"0x"+i.hex.toString(16);if(t==="RGB_ARRAY")return"["+r+","+a+","+s+"]";if(t==="RGBA_ARRAY")return"["+r+","+a+","+s+","+o+"]";if(t==="RGB_OBJ")return"{r:"+r+",g:"+a+",b:"+s+"}";if(t==="RGBA_OBJ")return"{r:"+r+",g:"+a+",b:"+s+",a:"+o+"}";if(t==="HSV_OBJ")return"{h:"+l+",s:"+h+",v:"+u+"}";if(t==="HSVA_OBJ")return"{h:"+l+",s:"+h+",v:"+u+",a:"+o+"}"}return"unknown format"}var rh=Array.prototype.forEach,Vr=Array.prototype.slice,O={BREAK:{},extend:function(e){return this.each(Vr.call(arguments,1),function(t){var r=this.isObject(t)?Object.keys(t):[];r.forEach(function(a){this.isUndefined(t[a])||(e[a]=t[a])}.bind(this))},this),e},defaults:function(e){return this.each(Vr.call(arguments,1),function(t){var r=this.isObject(t)?Object.keys(t):[];r.forEach(function(a){this.isUndefined(e[a])&&(e[a]=t[a])}.bind(this))},this),e},compose:function(){var e=Vr.call(arguments);return function(){for(var t=Vr.call(arguments),r=e.length-1;r>=0;r--)t=[e[r].apply(this,t)];return t[0]}},each:function(e,t,r){if(e){if(rh&&e.forEach&&e.forEach===rh)e.forEach(t,r);else if(e.length===e.length+0){var a=void 0,s=void 0;for(a=0,s=e.length;a<s;a++)if(a in e&&t.call(r,e[a],a)===this.BREAK)return}else for(var o in e)if(t.call(r,e[o],o)===this.BREAK)return}},defer:function(e){setTimeout(e,0)},debounce:function(e,t,r){var a=void 0;return function(){var s=this,o=arguments;function l(){a=null,r||e.apply(s,o)}var h=r||!a;clearTimeout(a),a=setTimeout(l,t),h&&e.apply(s,o)}},toArray:function(e){return e.toArray?e.toArray():Vr.call(e)},isUndefined:function(e){return e===void 0},isNull:function(e){return e===null},isNaN:function(i){function e(t){return i.apply(this,arguments)}return e.toString=function(){return i.toString()},e}(function(i){return isNaN(i)}),isArray:Array.isArray||function(i){return i.constructor===Array},isObject:function(e){return e===Object(e)},isNumber:function(e){return e===e+0},isString:function(e){return e===e+""},isBoolean:function(e){return e===!1||e===!0},isFunction:function(e){return e instanceof Function}},jd=[{litmus:O.isString,conversions:{THREE_CHAR_HEX:{read:function(e){var t=e.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);return t===null?!1:{space:"HEX",hex:parseInt("0x"+t[1].toString()+t[1].toString()+t[2].toString()+t[2].toString()+t[3].toString()+t[3].toString(),0)}},write:rr},SIX_CHAR_HEX:{read:function(e){var t=e.match(/^#([A-F0-9]{6})$/i);return t===null?!1:{space:"HEX",hex:parseInt("0x"+t[1].toString(),0)}},write:rr},CSS_RGB:{read:function(e){var t=e.match(/^rgb\(\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*\)/);return t===null?!1:{space:"RGB",r:parseFloat(t[1]),g:parseFloat(t[2]),b:parseFloat(t[3])}},write:rr},CSS_RGBA:{read:function(e){var t=e.match(/^rgba\(\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*\)/);return t===null?!1:{space:"RGB",r:parseFloat(t[1]),g:parseFloat(t[2]),b:parseFloat(t[3]),a:parseFloat(t[4])}},write:rr}}},{litmus:O.isNumber,conversions:{HEX:{read:function(e){return{space:"HEX",hex:e,conversionName:"HEX"}},write:function(e){return e.hex}}}},{litmus:O.isArray,conversions:{RGB_ARRAY:{read:function(e){return e.length!==3?!1:{space:"RGB",r:e[0],g:e[1],b:e[2]}},write:function(e){return[e.r,e.g,e.b]}},RGBA_ARRAY:{read:function(e){return e.length!==4?!1:{space:"RGB",r:e[0],g:e[1],b:e[2],a:e[3]}},write:function(e){return[e.r,e.g,e.b,e.a]}}}},{litmus:O.isObject,conversions:{RGBA_OBJ:{read:function(e){return O.isNumber(e.r)&&O.isNumber(e.g)&&O.isNumber(e.b)&&O.isNumber(e.a)?{space:"RGB",r:e.r,g:e.g,b:e.b,a:e.a}:!1},write:function(e){return{r:e.r,g:e.g,b:e.b,a:e.a}}},RGB_OBJ:{read:function(e){return O.isNumber(e.r)&&O.isNumber(e.g)&&O.isNumber(e.b)?{space:"RGB",r:e.r,g:e.g,b:e.b}:!1},write:function(e){return{r:e.r,g:e.g,b:e.b}}},HSVA_OBJ:{read:function(e){return O.isNumber(e.h)&&O.isNumber(e.s)&&O.isNumber(e.v)&&O.isNumber(e.a)?{space:"HSV",h:e.h,s:e.s,v:e.v,a:e.a}:!1},write:function(e){return{h:e.h,s:e.s,v:e.v,a:e.a}}},HSV_OBJ:{read:function(e){return O.isNumber(e.h)&&O.isNumber(e.s)&&O.isNumber(e.v)?{space:"HSV",h:e.h,s:e.s,v:e.v}:!1},write:function(e){return{h:e.h,s:e.s,v:e.v}}}}}],Hr=void 0,za=void 0,Xs=function(){za=!1;var e=arguments.length>1?O.toArray(arguments):arguments[0];return O.each(jd,function(t){if(t.litmus(e))return O.each(t.conversions,function(r,a){if(Hr=r.read(e),za===!1&&Hr!==!1)return za=Hr,Hr.conversionName=a,Hr.conversion=r,O.BREAK}),O.BREAK}),za},ah=void 0,Ga={hsv_to_rgb:function(e,t,r){var a=Math.floor(e/60)%6,s=e/60-Math.floor(e/60),o=r*(1-t),l=r*(1-s*t),h=r*(1-(1-s)*t),u=[[r,h,o],[l,r,o],[o,r,h],[o,l,r],[h,o,r],[r,o,l]][a];return{r:u[0]*255,g:u[1]*255,b:u[2]*255}},rgb_to_hsv:function(e,t,r){var a=Math.min(e,t,r),s=Math.max(e,t,r),o=s-a,l=void 0,h=void 0;if(s!==0)h=o/s;else return{h:NaN,s:0,v:0};return e===s?l=(t-r)/o:t===s?l=2+(r-e)/o:l=4+(e-t)/o,l/=6,l<0&&(l+=1),{h:l*360,s:h,v:s/255}},rgb_to_hex:function(e,t,r){var a=this.hex_with_component(0,2,e);return a=this.hex_with_component(a,1,t),a=this.hex_with_component(a,0,r),a},component_from_hex:function(e,t){return e>>t*8&255},hex_with_component:function(e,t,r){return r<<(ah=t*8)|e&~(255<<ah)}},qd=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(i){return typeof i}:function(i){return i&&typeof Symbol=="function"&&i.constructor===Symbol&&i!==Symbol.prototype?"symbol":typeof i},Pt=function(i,e){if(!(i instanceof e))throw new TypeError("Cannot call a class as a function")},Rt=function(){function i(e,t){for(var r=0;r<t.length;r++){var a=t[r];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(e,a.key,a)}}return function(e,t,r){return t&&i(e.prototype,t),r&&i(e,r),e}}(),gi=function i(e,t,r){e===null&&(e=Function.prototype);var a=Object.getOwnPropertyDescriptor(e,t);if(a===void 0){var s=Object.getPrototypeOf(e);return s===null?void 0:i(s,t,r)}else{if("value"in a)return a.value;var o=a.get;return o===void 0?void 0:o.call(r)}},pi=function(i,e){if(typeof e!="function"&&e!==null)throw new TypeError("Super expression must either be null or a function, not "+typeof e);i.prototype=Object.create(e&&e.prototype,{constructor:{value:i,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(i,e):i.__proto__=e)},mi=function(i,e){if(!i)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e&&(typeof e=="object"||typeof e=="function")?e:i},Ve=function(){function i(){if(Pt(this,i),this.__state=Xs.apply(this,arguments),this.__state===!1)throw new Error("Failed to interpret color arguments");this.__state.a=this.__state.a||1}return Rt(i,[{key:"toString",value:function(){return rr(this)}},{key:"toHexString",value:function(){return rr(this,!0)}},{key:"toOriginal",value:function(){return this.__state.conversion.write(this)}}]),i}();function Ws(i,e,t){Object.defineProperty(i,e,{get:function(){return this.__state.space==="RGB"?this.__state[e]:(Ve.recalculateRGB(this,e,t),this.__state[e])},set:function(a){this.__state.space!=="RGB"&&(Ve.recalculateRGB(this,e,t),this.__state.space="RGB"),this.__state[e]=a}})}function js(i,e){Object.defineProperty(i,e,{get:function(){return this.__state.space==="HSV"?this.__state[e]:(Ve.recalculateHSV(this),this.__state[e])},set:function(r){this.__state.space!=="HSV"&&(Ve.recalculateHSV(this),this.__state.space="HSV"),this.__state[e]=r}})}Ve.recalculateRGB=function(i,e,t){if(i.__state.space==="HEX")i.__state[e]=Ga.component_from_hex(i.__state.hex,t);else if(i.__state.space==="HSV")O.extend(i.__state,Ga.hsv_to_rgb(i.__state.h,i.__state.s,i.__state.v));else throw new Error("Corrupted color state")},Ve.recalculateHSV=function(i){var e=Ga.rgb_to_hsv(i.r,i.g,i.b);O.extend(i.__state,{s:e.s,v:e.v}),O.isNaN(e.h)?O.isUndefined(i.__state.h)&&(i.__state.h=0):i.__state.h=e.h},Ve.COMPONENTS=["r","g","b","h","s","v","hex","a"],Ws(Ve.prototype,"r",2),Ws(Ve.prototype,"g",1),Ws(Ve.prototype,"b",0),js(Ve.prototype,"h"),js(Ve.prototype,"s"),js(Ve.prototype,"v"),Object.defineProperty(Ve.prototype,"a",{get:function(){return this.__state.a},set:function(e){this.__state.a=e}}),Object.defineProperty(Ve.prototype,"hex",{get:function(){return this.__state.space!=="HEX"&&(this.__state.hex=Ga.rgb_to_hex(this.r,this.g,this.b),this.__state.space="HEX"),this.__state.hex},set:function(e){this.__state.space="HEX",this.__state.hex=e}});var Di=function(){function i(e,t){Pt(this,i),this.initialValue=e[t],this.domElement=document.createElement("div"),this.object=e,this.property=t,this.__onChange=void 0,this.__onFinishChange=void 0}return Rt(i,[{key:"onChange",value:function(t){return this.__onChange=t,this}},{key:"onFinishChange",value:function(t){return this.__onFinishChange=t,this}},{key:"setValue",value:function(t){return this.object[this.property]=t,this.__onChange&&this.__onChange.call(this,t),this.updateDisplay(),this}},{key:"getValue",value:function(){return this.object[this.property]}},{key:"updateDisplay",value:function(){return this}},{key:"isModified",value:function(){return this.initialValue!==this.getValue()}}]),i}(),Kd={HTMLEvents:["change"],MouseEvents:["click","mousemove","mousedown","mouseup","mouseover"],KeyboardEvents:["keydown"]},sh={};O.each(Kd,function(i,e){O.each(i,function(t){sh[t]=e})});var Jd=/(\d+(\.\d+)?)px/;function Yt(i){if(i==="0"||O.isUndefined(i))return 0;var e=i.match(Jd);return O.isNull(e)?0:parseFloat(e[1])}var B={makeSelectable:function(e,t){e===void 0||e.style===void 0||(e.onselectstart=t?function(){return!1}:function(){},e.style.MozUserSelect=t?"auto":"none",e.style.KhtmlUserSelect=t?"auto":"none",e.unselectable=t?"on":"off")},makeFullscreen:function(e,t,r){var a=r,s=t;O.isUndefined(s)&&(s=!0),O.isUndefined(a)&&(a=!0),e.style.position="absolute",s&&(e.style.left=0,e.style.right=0),a&&(e.style.top=0,e.style.bottom=0)},fakeEvent:function(e,t,r,a){var s=r||{},o=sh[t];if(!o)throw new Error("Event type "+t+" not supported.");var l=document.createEvent(o);switch(o){case"MouseEvents":{var h=s.x||s.clientX||0,u=s.y||s.clientY||0;l.initMouseEvent(t,s.bubbles||!1,s.cancelable||!0,window,s.clickCount||1,0,0,h,u,!1,!1,!1,!1,0,null);break}case"KeyboardEvents":{var c=l.initKeyboardEvent||l.initKeyEvent;O.defaults(s,{cancelable:!0,ctrlKey:!1,altKey:!1,shiftKey:!1,metaKey:!1,keyCode:void 0,charCode:void 0}),c(t,s.bubbles||!1,s.cancelable,window,s.ctrlKey,s.altKey,s.shiftKey,s.metaKey,s.keyCode,s.charCode);break}default:{l.initEvent(t,s.bubbles||!1,s.cancelable||!0);break}}O.defaults(l,a),e.dispatchEvent(l)},bind:function(e,t,r,a){var s=a||!1;return e.addEventListener?e.addEventListener(t,r,s):e.attachEvent&&e.attachEvent("on"+t,r),B},unbind:function(e,t,r,a){var s=a||!1;return e.removeEventListener?e.removeEventListener(t,r,s):e.detachEvent&&e.detachEvent("on"+t,r),B},addClass:function(e,t){if(e.className===void 0)e.className=t;else if(e.className!==t){var r=e.className.split(/ +/);r.indexOf(t)===-1&&(r.push(t),e.className=r.join(" ").replace(/^\s+/,"").replace(/\s+$/,""))}return B},removeClass:function(e,t){if(t)if(e.className===t)e.removeAttribute("class");else{var r=e.className.split(/ +/),a=r.indexOf(t);a!==-1&&(r.splice(a,1),e.className=r.join(" "))}else e.className=void 0;return B},hasClass:function(e,t){return new RegExp("(?:^|\\s+)"+t+"(?:\\s+|$)").test(e.className)||!1},getWidth:function(e){var t=getComputedStyle(e);return Yt(t["border-left-width"])+Yt(t["border-right-width"])+Yt(t["padding-left"])+Yt(t["padding-right"])+Yt(t.width)},getHeight:function(e){var t=getComputedStyle(e);return Yt(t["border-top-width"])+Yt(t["border-bottom-width"])+Yt(t["padding-top"])+Yt(t["padding-bottom"])+Yt(t.height)},getOffset:function(e){var t=e,r={left:0,top:0};if(t.offsetParent)do r.left+=t.offsetLeft,r.top+=t.offsetTop,t=t.offsetParent;while(t);return r},isActive:function(e){return e===document.activeElement&&(e.type||e.href)}},nh=function(i){pi(e,i);function e(t,r){Pt(this,e);var a=mi(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t,r)),s=a;a.__prev=a.getValue(),a.__checkbox=document.createElement("input"),a.__checkbox.setAttribute("type","checkbox");function o(){s.setValue(!s.__prev)}return B.bind(a.__checkbox,"change",o,!1),a.domElement.appendChild(a.__checkbox),a.updateDisplay(),a}return Rt(e,[{key:"setValue",value:function(r){var a=gi(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"setValue",this).call(this,r);return this.__onFinishChange&&this.__onFinishChange.call(this,this.getValue()),this.__prev=this.getValue(),a}},{key:"updateDisplay",value:function(){return this.getValue()===!0?(this.__checkbox.setAttribute("checked","checked"),this.__checkbox.checked=!0,this.__prev=!0):(this.__checkbox.checked=!1,this.__prev=!1),gi(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"updateDisplay",this).call(this)}}]),e}(Di),Zd=function(i){pi(e,i);function e(t,r,a){Pt(this,e);var s=mi(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t,r)),o=a,l=s;if(s.__select=document.createElement("select"),O.isArray(o)){var h={};O.each(o,function(u){h[u]=u}),o=h}return O.each(o,function(u,c){var d=document.createElement("option");d.innerHTML=c,d.setAttribute("value",u),l.__select.appendChild(d)}),s.updateDisplay(),B.bind(s.__select,"change",function(){var u=this.options[this.selectedIndex].value;l.setValue(u)}),s.domElement.appendChild(s.__select),s}return Rt(e,[{key:"setValue",value:function(r){var a=gi(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"setValue",this).call(this,r);return this.__onFinishChange&&this.__onFinishChange.call(this,this.getValue()),a}},{key:"updateDisplay",value:function(){return B.isActive(this.__select)?this:(this.__select.value=this.getValue(),gi(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"updateDisplay",this).call(this))}}]),e}(Di),$d=function(i){pi(e,i);function e(t,r){Pt(this,e);var a=mi(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t,r)),s=a;function o(){s.setValue(s.__input.value)}function l(){s.__onFinishChange&&s.__onFinishChange.call(s,s.getValue())}return a.__input=document.createElement("input"),a.__input.setAttribute("type","text"),B.bind(a.__input,"keyup",o),B.bind(a.__input,"change",o),B.bind(a.__input,"blur",l),B.bind(a.__input,"keydown",function(h){h.keyCode===13&&this.blur()}),a.updateDisplay(),a.domElement.appendChild(a.__input),a}return Rt(e,[{key:"updateDisplay",value:function(){return B.isActive(this.__input)||(this.__input.value=this.getValue()),gi(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"updateDisplay",this).call(this)}}]),e}(Di);function oh(i){var e=i.toString();return e.indexOf(".")>-1?e.length-e.indexOf(".")-1:0}var lh=function(i){pi(e,i);function e(t,r,a){Pt(this,e);var s=mi(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t,r)),o=a||{};return s.__min=o.min,s.__max=o.max,s.__step=o.step,O.isUndefined(s.__step)?s.initialValue===0?s.__impliedStep=1:s.__impliedStep=Math.pow(10,Math.floor(Math.log(Math.abs(s.initialValue))/Math.LN10))/10:s.__impliedStep=s.__step,s.__precision=oh(s.__impliedStep),s}return Rt(e,[{key:"setValue",value:function(r){var a=r;return this.__min!==void 0&&a<this.__min?a=this.__min:this.__max!==void 0&&a>this.__max&&(a=this.__max),this.__step!==void 0&&a%this.__step!==0&&(a=Math.round(a/this.__step)*this.__step),gi(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"setValue",this).call(this,a)}},{key:"min",value:function(r){return this.__min=r,this}},{key:"max",value:function(r){return this.__max=r,this}},{key:"step",value:function(r){return this.__step=r,this.__impliedStep=r,this.__precision=oh(r),this}}]),e}(Di);function eg(i,e){var t=Math.pow(10,e);return Math.round(i*t)/t}var Qa=function(i){pi(e,i);function e(t,r,a){Pt(this,e);var s=mi(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t,r,a));s.__truncationSuspended=!1;var o=s,l=void 0;function h(){var A=parseFloat(o.__input.value);O.isNaN(A)||o.setValue(A)}function u(){o.__onFinishChange&&o.__onFinishChange.call(o,o.getValue())}function c(){u()}function d(A){var v=l-A.clientY;o.setValue(o.getValue()+v*o.__impliedStep),l=A.clientY}function g(){B.unbind(window,"mousemove",d),B.unbind(window,"mouseup",g),u()}function m(A){B.bind(window,"mousemove",d),B.bind(window,"mouseup",g),l=A.clientY}return s.__input=document.createElement("input"),s.__input.setAttribute("type","text"),B.bind(s.__input,"change",h),B.bind(s.__input,"blur",c),B.bind(s.__input,"mousedown",m),B.bind(s.__input,"keydown",function(A){A.keyCode===13&&(o.__truncationSuspended=!0,this.blur(),o.__truncationSuspended=!1,u())}),s.updateDisplay(),s.domElement.appendChild(s.__input),s}return Rt(e,[{key:"updateDisplay",value:function(){return this.__input.value=this.__truncationSuspended?this.getValue():eg(this.getValue(),this.__precision),gi(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"updateDisplay",this).call(this)}}]),e}(lh);function hh(i,e,t,r,a){return r+(a-r)*((i-e)/(t-e))}var qs=function(i){pi(e,i);function e(t,r,a,s,o){Pt(this,e);var l=mi(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t,r,{min:a,max:s,step:o})),h=l;l.__background=document.createElement("div"),l.__foreground=document.createElement("div"),B.bind(l.__background,"mousedown",u),B.bind(l.__background,"touchstart",g),B.addClass(l.__background,"slider"),B.addClass(l.__foreground,"slider-fg");function u(v){document.activeElement.blur(),B.bind(window,"mousemove",c),B.bind(window,"mouseup",d),c(v)}function c(v){v.preventDefault();var y=h.__background.getBoundingClientRect();return h.setValue(hh(v.clientX,y.left,y.right,h.__min,h.__max)),!1}function d(){B.unbind(window,"mousemove",c),B.unbind(window,"mouseup",d),h.__onFinishChange&&h.__onFinishChange.call(h,h.getValue())}function g(v){v.touches.length===1&&(B.bind(window,"touchmove",m),B.bind(window,"touchend",A),m(v))}function m(v){var y=v.touches[0].clientX,C=h.__background.getBoundingClientRect();h.setValue(hh(y,C.left,C.right,h.__min,h.__max))}function A(){B.unbind(window,"touchmove",m),B.unbind(window,"touchend",A),h.__onFinishChange&&h.__onFinishChange.call(h,h.getValue())}return l.updateDisplay(),l.__background.appendChild(l.__foreground),l.domElement.appendChild(l.__background),l}return Rt(e,[{key:"updateDisplay",value:function(){var r=(this.getValue()-this.__min)/(this.__max-this.__min);return this.__foreground.style.width=r*100+"%",gi(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"updateDisplay",this).call(this)}}]),e}(lh),uh=function(i){pi(e,i);function e(t,r,a){Pt(this,e);var s=mi(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t,r)),o=s;return s.__button=document.createElement("div"),s.__button.innerHTML=a===void 0?"Fire":a,B.bind(s.__button,"click",function(l){return l.preventDefault(),o.fire(),!1}),B.addClass(s.__button,"button"),s.domElement.appendChild(s.__button),s}return Rt(e,[{key:"fire",value:function(){this.__onChange&&this.__onChange.call(this),this.getValue().call(this.object),this.__onFinishChange&&this.__onFinishChange.call(this,this.getValue())}}]),e}(Di),Ks=function(i){pi(e,i);function e(t,r){Pt(this,e);var a=mi(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t,r));a.__color=new Ve(a.getValue()),a.__temp=new Ve(0);var s=a;a.domElement=document.createElement("div"),B.makeSelectable(a.domElement,!1),a.__selector=document.createElement("div"),a.__selector.className="selector",a.__saturation_field=document.createElement("div"),a.__saturation_field.className="saturation-field",a.__field_knob=document.createElement("div"),a.__field_knob.className="field-knob",a.__field_knob_border="2px solid ",a.__hue_knob=document.createElement("div"),a.__hue_knob.className="hue-knob",a.__hue_field=document.createElement("div"),a.__hue_field.className="hue-field",a.__input=document.createElement("input"),a.__input.type="text",a.__input_textShadow="0 1px 1px ",B.bind(a.__input,"keydown",function(v){v.keyCode===13&&d.call(this)}),B.bind(a.__input,"blur",d),B.bind(a.__selector,"mousedown",function(){B.addClass(this,"drag").bind(window,"mouseup",function(){B.removeClass(s.__selector,"drag")})}),B.bind(a.__selector,"touchstart",function(){B.addClass(this,"drag").bind(window,"touchend",function(){B.removeClass(s.__selector,"drag")})});var o=document.createElement("div");O.extend(a.__selector.style,{width:"122px",height:"102px",padding:"3px",backgroundColor:"#222",boxShadow:"0px 1px 3px rgba(0,0,0,0.3)"}),O.extend(a.__field_knob.style,{position:"absolute",width:"12px",height:"12px",border:a.__field_knob_border+(a.__color.v<.5?"#fff":"#000"),boxShadow:"0px 1px 3px rgba(0,0,0,0.5)",borderRadius:"12px",zIndex:1}),O.extend(a.__hue_knob.style,{position:"absolute",width:"15px",height:"2px",borderRight:"4px solid #fff",zIndex:1}),O.extend(a.__saturation_field.style,{width:"100px",height:"100px",border:"1px solid #555",marginRight:"3px",display:"inline-block",cursor:"pointer"}),O.extend(o.style,{width:"100%",height:"100%",background:"none"}),ch(o,"top","rgba(0,0,0,0)","#000"),O.extend(a.__hue_field.style,{width:"15px",height:"100px",border:"1px solid #555",cursor:"ns-resize",position:"absolute",top:"3px",right:"3px"}),ig(a.__hue_field),O.extend(a.__input.style,{outline:"none",textAlign:"center",color:"#fff",border:0,fontWeight:"bold",textShadow:a.__input_textShadow+"rgba(0,0,0,0.7)"}),B.bind(a.__saturation_field,"mousedown",l),B.bind(a.__saturation_field,"touchstart",l),B.bind(a.__field_knob,"mousedown",l),B.bind(a.__field_knob,"touchstart",l),B.bind(a.__hue_field,"mousedown",h),B.bind(a.__hue_field,"touchstart",h);function l(v){m(v),B.bind(window,"mousemove",m),B.bind(window,"touchmove",m),B.bind(window,"mouseup",u),B.bind(window,"touchend",u)}function h(v){A(v),B.bind(window,"mousemove",A),B.bind(window,"touchmove",A),B.bind(window,"mouseup",c),B.bind(window,"touchend",c)}function u(){B.unbind(window,"mousemove",m),B.unbind(window,"touchmove",m),B.unbind(window,"mouseup",u),B.unbind(window,"touchend",u),g()}function c(){B.unbind(window,"mousemove",A),B.unbind(window,"touchmove",A),B.unbind(window,"mouseup",c),B.unbind(window,"touchend",c),g()}function d(){var v=Xs(this.value);v!==!1?(s.__color.__state=v,s.setValue(s.__color.toOriginal())):this.value=s.__color.toString()}function g(){s.__onFinishChange&&s.__onFinishChange.call(s,s.__color.toOriginal())}a.__saturation_field.appendChild(o),a.__selector.appendChild(a.__field_knob),a.__selector.appendChild(a.__saturation_field),a.__selector.appendChild(a.__hue_field),a.__hue_field.appendChild(a.__hue_knob),a.domElement.appendChild(a.__input),a.domElement.appendChild(a.__selector),a.updateDisplay();function m(v){v.type.indexOf("touch")===-1&&v.preventDefault();var y=s.__saturation_field.getBoundingClientRect(),C=v.touches&&v.touches[0]||v,S=C.clientX,T=C.clientY,D=(S-y.left)/(y.right-y.left),M=1-(T-y.top)/(y.bottom-y.top);return M>1?M=1:M<0&&(M=0),D>1?D=1:D<0&&(D=0),s.__color.v=M,s.__color.s=D,s.setValue(s.__color.toOriginal()),!1}function A(v){v.type.indexOf("touch")===-1&&v.preventDefault();var y=s.__hue_field.getBoundingClientRect(),C=v.touches&&v.touches[0]||v,S=C.clientY,T=1-(S-y.top)/(y.bottom-y.top);return T>1?T=1:T<0&&(T=0),s.__color.h=T*360,s.setValue(s.__color.toOriginal()),!1}return a}return Rt(e,[{key:"updateDisplay",value:function(){var r=Xs(this.getValue());if(r!==!1){var a=!1;O.each(Ve.COMPONENTS,function(l){if(!O.isUndefined(r[l])&&!O.isUndefined(this.__color.__state[l])&&r[l]!==this.__color.__state[l])return a=!0,{}},this),a&&O.extend(this.__color.__state,r)}O.extend(this.__temp.__state,this.__color.__state),this.__temp.a=1;var s=this.__color.v<.5||this.__color.s>.5?255:0,o=255-s;O.extend(this.__field_knob.style,{marginLeft:100*this.__color.s-7+"px",marginTop:100*(1-this.__color.v)-7+"px",backgroundColor:this.__temp.toHexString(),border:this.__field_knob_border+"rgb("+s+","+s+","+s+")"}),this.__hue_knob.style.marginTop=(1-this.__color.h/360)*100+"px",this.__temp.s=1,this.__temp.v=1,ch(this.__saturation_field,"left","#fff",this.__temp.toHexString()),this.__input.value=this.__color.toString(),O.extend(this.__input.style,{backgroundColor:this.__color.toHexString(),color:"rgb("+s+","+s+","+s+")",textShadow:this.__input_textShadow+"rgba("+o+","+o+","+o+",.7)"})}}]),e}(Di),tg=["-moz-","-o-","-webkit-","-ms-",""];function ch(i,e,t,r){i.style.background="",O.each(tg,function(a){i.style.cssText+="background: "+a+"linear-gradient("+e+", "+t+" 0%, "+r+" 100%); "})}function ig(i){i.style.background="",i.style.cssText+="background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);",i.style.cssText+="background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);",i.style.cssText+="background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);",i.style.cssText+="background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);",i.style.cssText+="background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);"}var rg={load:function(e,t){var r=t||document,a=r.createElement("link");a.type="text/css",a.rel="stylesheet",a.href=e,r.getElementsByTagName("head")[0].appendChild(a)},inject:function(e,t){var r=t||document,a=document.createElement("style");a.type="text/css",a.innerHTML=e;var s=r.getElementsByTagName("head")[0];try{s.appendChild(a)}catch{}}},ag=`<div id="dg-save" class="dg dialogue">

  Here's the new load parameter for your <code>GUI</code>'s constructor:

  <textarea id="dg-new-constructor"></textarea>

  <div id="dg-save-locally">

    <input id="dg-local-storage" type="checkbox"/> Automatically save
    values to <code>localStorage</code> on exit.

    <div id="dg-local-explain">The values saved to <code>localStorage</code> will
      override those passed to <code>dat.GUI</code>'s constructor. This makes it
      easier to work incrementally, but <code>localStorage</code> is fragile,
      and your friends may not see the same values you do.

    </div>

  </div>

</div>`,sg=function(e,t){var r=e[t];return O.isArray(arguments[2])||O.isObject(arguments[2])?new Zd(e,t,arguments[2]):O.isNumber(r)?O.isNumber(arguments[2])&&O.isNumber(arguments[3])?O.isNumber(arguments[4])?new qs(e,t,arguments[2],arguments[3],arguments[4]):new qs(e,t,arguments[2],arguments[3]):O.isNumber(arguments[4])?new Qa(e,t,{min:arguments[2],max:arguments[3],step:arguments[4]}):new Qa(e,t,{min:arguments[2],max:arguments[3]}):O.isString(r)?new $d(e,t):O.isFunction(r)?new uh(e,t,""):O.isBoolean(r)?new nh(e,t):null};function ng(i){setTimeout(i,1e3/60)}var og=window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame||ng,lg=function(){function i(){Pt(this,i),this.backgroundElement=document.createElement("div"),O.extend(this.backgroundElement.style,{backgroundColor:"rgba(0,0,0,0.8)",top:0,left:0,display:"none",zIndex:"1000",opacity:0,WebkitTransition:"opacity 0.2s linear",transition:"opacity 0.2s linear"}),B.makeFullscreen(this.backgroundElement),this.backgroundElement.style.position="fixed",this.domElement=document.createElement("div"),O.extend(this.domElement.style,{position:"fixed",display:"none",zIndex:"1001",opacity:0,WebkitTransition:"-webkit-transform 0.2s ease-out, opacity 0.2s linear",transition:"transform 0.2s ease-out, opacity 0.2s linear"}),document.body.appendChild(this.backgroundElement),document.body.appendChild(this.domElement);var e=this;B.bind(this.backgroundElement,"click",function(){e.hide()})}return Rt(i,[{key:"show",value:function(){var t=this;this.backgroundElement.style.display="block",this.domElement.style.display="block",this.domElement.style.opacity=0,this.domElement.style.webkitTransform="scale(1.1)",this.layout(),O.defer(function(){t.backgroundElement.style.opacity=1,t.domElement.style.opacity=1,t.domElement.style.webkitTransform="scale(1)"})}},{key:"hide",value:function(){var t=this,r=function a(){t.domElement.style.display="none",t.backgroundElement.style.display="none",B.unbind(t.domElement,"webkitTransitionEnd",a),B.unbind(t.domElement,"transitionend",a),B.unbind(t.domElement,"oTransitionEnd",a)};B.bind(this.domElement,"webkitTransitionEnd",r),B.bind(this.domElement,"transitionend",r),B.bind(this.domElement,"oTransitionEnd",r),this.backgroundElement.style.opacity=0,this.domElement.style.opacity=0,this.domElement.style.webkitTransform="scale(1.1)"}},{key:"layout",value:function(){this.domElement.style.left=window.innerWidth/2-B.getWidth(this.domElement)/2+"px",this.domElement.style.top=window.innerHeight/2-B.getHeight(this.domElement)/2+"px"}}]),i}(),hg=Wd(`.dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear;border:0;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button.close-top{position:relative}.dg.main .close-button.close-bottom{position:absolute}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-y:visible}.dg.a.has-save>ul.close-top{margin-top:0}.dg.a.has-save>ul.close-bottom{margin-top:27px}.dg.a.has-save>ul.closed{margin-top:0}.dg.a .save-row{top:0;z-index:1002}.dg.a .save-row.close-top{position:relative}.dg.a .save-row.close-bottom{position:fixed}.dg li{-webkit-transition:height .1s ease-out;-o-transition:height .1s ease-out;-moz-transition:height .1s ease-out;transition:height .1s ease-out;-webkit-transition:overflow .1s linear;-o-transition:overflow .1s linear;-moz-transition:overflow .1s linear;transition:overflow .1s linear}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li>*{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px;overflow:hidden}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .cr.function .property-name{width:100%}.dg .c{float:left;width:60%;position:relative}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:7px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .cr.color{overflow:visible}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.color{border-left:3px solid}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2FA1D6}.dg .cr.number input[type=text]{color:#2FA1D6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2FA1D6;max-width:100%}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}
`);rg.inject(hg);var fh="dg",dh=72,gh=20,Yr="Default",Xr=function(){try{return!!window.localStorage}catch{return!1}}(),Wr=void 0,ph=!0,ar=void 0,Js=!1,mh=[],xe=function i(e){var t=this,r=e||{};this.domElement=document.createElement("div"),this.__ul=document.createElement("ul"),this.domElement.appendChild(this.__ul),B.addClass(this.domElement,fh),this.__folders={},this.__controllers=[],this.__rememberedObjects=[],this.__rememberedObjectIndecesToControllers=[],this.__listening=[],r=O.defaults(r,{closeOnTop:!1,autoPlace:!0,width:i.DEFAULT_WIDTH}),r=O.defaults(r,{resizable:r.autoPlace,hideable:r.autoPlace}),O.isUndefined(r.load)?r.load={preset:Yr}:r.preset&&(r.load.preset=r.preset),O.isUndefined(r.parent)&&r.hideable&&mh.push(this),r.resizable=O.isUndefined(r.parent)&&r.resizable,r.autoPlace&&O.isUndefined(r.scrollable)&&(r.scrollable=!0);var a=Xr&&localStorage.getItem(sr(this,"isLocal"))==="true",s=void 0,o=void 0;if(Object.defineProperties(this,{parent:{get:function(){return r.parent}},scrollable:{get:function(){return r.scrollable}},autoPlace:{get:function(){return r.autoPlace}},closeOnTop:{get:function(){return r.closeOnTop}},preset:{get:function(){return t.parent?t.getRoot().preset:r.load.preset},set:function(g){t.parent?t.getRoot().preset=g:r.load.preset=g,dg(this),t.revert()}},width:{get:function(){return r.width},set:function(g){r.width=g,tn(t,g)}},name:{get:function(){return r.name},set:function(g){r.name=g,o&&(o.innerHTML=r.name)}},closed:{get:function(){return r.closed},set:function(g){r.closed=g,r.closed?B.addClass(t.__ul,i.CLASS_CLOSED):B.removeClass(t.__ul,i.CLASS_CLOSED),this.onResize(),t.__closeButton&&(t.__closeButton.innerHTML=g?i.TEXT_OPEN:i.TEXT_CLOSED)}},load:{get:function(){return r.load}},useLocalStorage:{get:function(){return a},set:function(g){Xr&&(a=g,g?B.bind(window,"unload",s):B.unbind(window,"unload",s),localStorage.setItem(sr(t,"isLocal"),g))}}}),O.isUndefined(r.parent)){if(this.closed=r.closed||!1,B.addClass(this.domElement,i.CLASS_MAIN),B.makeSelectable(this.domElement,!1),Xr&&a){t.useLocalStorage=!0;var l=localStorage.getItem(sr(this,"gui"));l&&(r.load=JSON.parse(l))}this.__closeButton=document.createElement("div"),this.__closeButton.innerHTML=i.TEXT_CLOSED,B.addClass(this.__closeButton,i.CLASS_CLOSE_BUTTON),r.closeOnTop?(B.addClass(this.__closeButton,i.CLASS_CLOSE_TOP),this.domElement.insertBefore(this.__closeButton,this.domElement.childNodes[0])):(B.addClass(this.__closeButton,i.CLASS_CLOSE_BOTTOM),this.domElement.appendChild(this.__closeButton)),B.bind(this.__closeButton,"click",function(){t.closed=!t.closed})}else{r.closed===void 0&&(r.closed=!0);var h=document.createTextNode(r.name);B.addClass(h,"controller-name"),o=Zs(t,h);var u=function(g){return g.preventDefault(),t.closed=!t.closed,!1};B.addClass(this.__ul,i.CLASS_CLOSED),B.addClass(o,"title"),B.bind(o,"click",u),r.closed||(this.closed=!1)}r.autoPlace&&(O.isUndefined(r.parent)&&(ph&&(ar=document.createElement("div"),B.addClass(ar,fh),B.addClass(ar,i.CLASS_AUTO_PLACE_CONTAINER),document.body.appendChild(ar),ph=!1),ar.appendChild(this.domElement),B.addClass(this.domElement,i.CLASS_AUTO_PLACE)),this.parent||tn(t,r.width)),this.__resizeHandler=function(){t.onResizeDebounced()},B.bind(window,"resize",this.__resizeHandler),B.bind(this.__ul,"webkitTransitionEnd",this.__resizeHandler),B.bind(this.__ul,"transitionend",this.__resizeHandler),B.bind(this.__ul,"oTransitionEnd",this.__resizeHandler),this.onResize(),r.resizable&&fg(this),s=function(){Xr&&localStorage.getItem(sr(t,"isLocal"))==="true"&&localStorage.setItem(sr(t,"gui"),JSON.stringify(t.getSaveObject()))},this.saveToLocalStorageIfPossible=s;function c(){var d=t.getRoot();d.width+=1,O.defer(function(){d.width-=1})}r.parent||c()};xe.toggleHide=function(){Js=!Js,O.each(mh,function(i){i.domElement.style.display=Js?"none":""})},xe.CLASS_AUTO_PLACE="a",xe.CLASS_AUTO_PLACE_CONTAINER="ac",xe.CLASS_MAIN="main",xe.CLASS_CONTROLLER_ROW="cr",xe.CLASS_TOO_TALL="taller-than-window",xe.CLASS_CLOSED="closed",xe.CLASS_CLOSE_BUTTON="close-button",xe.CLASS_CLOSE_TOP="close-top",xe.CLASS_CLOSE_BOTTOM="close-bottom",xe.CLASS_DRAG="drag",xe.DEFAULT_WIDTH=245,xe.TEXT_CLOSED="Close Controls",xe.TEXT_OPEN="Open Controls",xe._keydownHandler=function(i){document.activeElement.type!=="text"&&(i.which===dh||i.keyCode===dh)&&xe.toggleHide()},B.bind(window,"keydown",xe._keydownHandler,!1),O.extend(xe.prototype,{add:function(e,t){return jr(this,e,t,{factoryArgs:Array.prototype.slice.call(arguments,2)})},addColor:function(e,t){return jr(this,e,t,{color:!0})},remove:function(e){this.__ul.removeChild(e.__li),this.__controllers.splice(this.__controllers.indexOf(e),1);var t=this;O.defer(function(){t.onResize()})},destroy:function(){if(this.parent)throw new Error("Only the root GUI should be removed with .destroy(). For subfolders, use gui.removeFolder(folder) instead.");this.autoPlace&&ar.removeChild(this.domElement);var e=this;O.each(this.__folders,function(t){e.removeFolder(t)}),B.unbind(window,"keydown",xe._keydownHandler,!1),Ah(this)},addFolder:function(e){if(this.__folders[e]!==void 0)throw new Error('You already have a folder in this GUI by the name "'+e+'"');var t={name:e,parent:this};t.autoPlace=this.autoPlace,this.load&&this.load.folders&&this.load.folders[e]&&(t.closed=this.load.folders[e].closed,t.load=this.load.folders[e]);var r=new xe(t);this.__folders[e]=r;var a=Zs(this,r.domElement);return B.addClass(a,"folder"),r},removeFolder:function(e){this.__ul.removeChild(e.domElement.parentElement),delete this.__folders[e.name],this.load&&this.load.folders&&this.load.folders[e.name]&&delete this.load.folders[e.name],Ah(e);var t=this;O.each(e.__folders,function(r){e.removeFolder(r)}),O.defer(function(){t.onResize()})},open:function(){this.closed=!1},close:function(){this.closed=!0},hide:function(){this.domElement.style.display="none"},show:function(){this.domElement.style.display=""},onResize:function(){var e=this.getRoot();if(e.scrollable){var t=B.getOffset(e.__ul).top,r=0;O.each(e.__ul.childNodes,function(a){e.autoPlace&&a===e.__save_row||(r+=B.getHeight(a))}),window.innerHeight-t-gh<r?(B.addClass(e.domElement,xe.CLASS_TOO_TALL),e.__ul.style.height=window.innerHeight-t-gh+"px"):(B.removeClass(e.domElement,xe.CLASS_TOO_TALL),e.__ul.style.height="auto")}e.__resize_handle&&O.defer(function(){e.__resize_handle.style.height=e.__ul.offsetHeight+"px"}),e.__closeButton&&(e.__closeButton.style.width=e.width+"px")},onResizeDebounced:O.debounce(function(){this.onResize()},50),remember:function(){if(O.isUndefined(Wr)&&(Wr=new lg,Wr.domElement.innerHTML=ag),this.parent)throw new Error("You can only call remember on a top level GUI.");var e=this;O.each(Array.prototype.slice.call(arguments),function(t){e.__rememberedObjects.length===0&&cg(e),e.__rememberedObjects.indexOf(t)===-1&&e.__rememberedObjects.push(t)}),this.autoPlace&&tn(this,this.width)},getRoot:function(){for(var e=this;e.parent;)e=e.parent;return e},getSaveObject:function(){var e=this.load;return e.closed=this.closed,this.__rememberedObjects.length>0&&(e.preset=this.preset,e.remembered||(e.remembered={}),e.remembered[this.preset]=Va(this)),e.folders={},O.each(this.__folders,function(t,r){e.folders[r]=t.getSaveObject()}),e},save:function(){this.load.remembered||(this.load.remembered={}),this.load.remembered[this.preset]=Va(this),$s(this,!1),this.saveToLocalStorageIfPossible()},saveAs:function(e){this.load.remembered||(this.load.remembered={},this.load.remembered[Yr]=Va(this,!0)),this.load.remembered[e]=Va(this),this.preset=e,en(this,e,!0),this.saveToLocalStorageIfPossible()},revert:function(e){O.each(this.__controllers,function(t){this.getRoot().load.remembered?_h(e||this.getRoot(),t):t.setValue(t.initialValue),t.__onFinishChange&&t.__onFinishChange.call(t,t.getValue())},this),O.each(this.__folders,function(t){t.revert(t)}),e||$s(this.getRoot(),!1)},listen:function(e){var t=this.__listening.length===0;this.__listening.push(e),t&&xh(this.__listening)},updateDisplay:function(){O.each(this.__controllers,function(e){e.updateDisplay()}),O.each(this.__folders,function(e){e.updateDisplay()})}});function Zs(i,e,t){var r=document.createElement("li");return e&&r.appendChild(e),t?i.__ul.insertBefore(r,t):i.__ul.appendChild(r),i.onResize(),r}function Ah(i){B.unbind(window,"resize",i.__resizeHandler),i.saveToLocalStorageIfPossible&&B.unbind(window,"unload",i.saveToLocalStorageIfPossible)}function $s(i,e){var t=i.__preset_select[i.__preset_select.selectedIndex];e?t.innerHTML=t.value+"*":t.innerHTML=t.value}function ug(i,e,t){if(t.__li=e,t.__gui=i,O.extend(t,{options:function(o){if(arguments.length>1){var l=t.__li.nextElementSibling;return t.remove(),jr(i,t.object,t.property,{before:l,factoryArgs:[O.toArray(arguments)]})}if(O.isArray(o)||O.isObject(o)){var h=t.__li.nextElementSibling;return t.remove(),jr(i,t.object,t.property,{before:h,factoryArgs:[o]})}},name:function(o){return t.__li.firstElementChild.firstElementChild.innerHTML=o,t},listen:function(){return t.__gui.listen(t),t},remove:function(){return t.__gui.remove(t),t}}),t instanceof qs){var r=new Qa(t.object,t.property,{min:t.__min,max:t.__max,step:t.__step});O.each(["updateDisplay","onChange","onFinishChange","step","min","max"],function(s){var o=t[s],l=r[s];t[s]=r[s]=function(){var h=Array.prototype.slice.call(arguments);return l.apply(r,h),o.apply(t,h)}}),B.addClass(e,"has-slider"),t.domElement.insertBefore(r.domElement,t.domElement.firstElementChild)}else if(t instanceof Qa){var a=function(o){if(O.isNumber(t.__min)&&O.isNumber(t.__max)){var l=t.__li.firstElementChild.firstElementChild.innerHTML,h=t.__gui.__listening.indexOf(t)>-1;t.remove();var u=jr(i,t.object,t.property,{before:t.__li.nextElementSibling,factoryArgs:[t.__min,t.__max,t.__step]});return u.name(l),h&&u.listen(),u}return o};t.min=O.compose(a,t.min),t.max=O.compose(a,t.max)}else t instanceof nh?(B.bind(e,"click",function(){B.fakeEvent(t.__checkbox,"click")}),B.bind(t.__checkbox,"click",function(s){s.stopPropagation()})):t instanceof uh?(B.bind(e,"click",function(){B.fakeEvent(t.__button,"click")}),B.bind(e,"mouseover",function(){B.addClass(t.__button,"hover")}),B.bind(e,"mouseout",function(){B.removeClass(t.__button,"hover")})):t instanceof Ks&&(B.addClass(e,"color"),t.updateDisplay=O.compose(function(s){return e.style.borderLeftColor=t.__color.toString(),s},t.updateDisplay),t.updateDisplay());t.setValue=O.compose(function(s){return i.getRoot().__preset_select&&t.isModified()&&$s(i.getRoot(),!0),s},t.setValue)}function _h(i,e){var t=i.getRoot(),r=t.__rememberedObjects.indexOf(e.object);if(r!==-1){var a=t.__rememberedObjectIndecesToControllers[r];if(a===void 0&&(a={},t.__rememberedObjectIndecesToControllers[r]=a),a[e.property]=e,t.load&&t.load.remembered){var s=t.load.remembered,o=void 0;if(s[i.preset])o=s[i.preset];else if(s[Yr])o=s[Yr];else return;if(o[r]&&o[r][e.property]!==void 0){var l=o[r][e.property];e.initialValue=l,e.setValue(l)}}}}function jr(i,e,t,r){if(e[t]===void 0)throw new Error('Object "'+e+'" has no property "'+t+'"');var a=void 0;if(r.color)a=new Ks(e,t);else{var s=[e,t].concat(r.factoryArgs);a=sg.apply(i,s)}r.before instanceof Di&&(r.before=r.before.__li),_h(i,a),B.addClass(a.domElement,"c");var o=document.createElement("span");B.addClass(o,"property-name"),o.innerHTML=a.property;var l=document.createElement("div");l.appendChild(o),l.appendChild(a.domElement);var h=Zs(i,l,r.before);return B.addClass(h,xe.CLASS_CONTROLLER_ROW),a instanceof Ks?B.addClass(h,"color"):B.addClass(h,qd(a.getValue())),ug(i,h,a),i.__controllers.push(a),a}function sr(i,e){return document.location.href+"."+e}function en(i,e,t){var r=document.createElement("option");r.innerHTML=e,r.value=e,i.__preset_select.appendChild(r),t&&(i.__preset_select.selectedIndex=i.__preset_select.length-1)}function vh(i,e){e.style.display=i.useLocalStorage?"block":"none"}function cg(i){var e=i.__save_row=document.createElement("li");B.addClass(i.domElement,"has-save"),i.__ul.insertBefore(e,i.__ul.firstChild),B.addClass(e,"save-row");var t=document.createElement("span");t.innerHTML="&nbsp;",B.addClass(t,"button gears");var r=document.createElement("span");r.innerHTML="Save",B.addClass(r,"button"),B.addClass(r,"save");var a=document.createElement("span");a.innerHTML="New",B.addClass(a,"button"),B.addClass(a,"save-as");var s=document.createElement("span");s.innerHTML="Revert",B.addClass(s,"button"),B.addClass(s,"revert");var o=i.__preset_select=document.createElement("select");if(i.load&&i.load.remembered?O.each(i.load.remembered,function(d,g){en(i,g,g===i.preset)}):en(i,Yr,!1),B.bind(o,"change",function(){for(var d=0;d<i.__preset_select.length;d++)i.__preset_select[d].innerHTML=i.__preset_select[d].value;i.preset=this.value}),e.appendChild(o),e.appendChild(t),e.appendChild(r),e.appendChild(a),e.appendChild(s),Xr){var l=document.getElementById("dg-local-explain"),h=document.getElementById("dg-local-storage"),u=document.getElementById("dg-save-locally");u.style.display="block",localStorage.getItem(sr(i,"isLocal"))==="true"&&h.setAttribute("checked","checked"),vh(i,l),B.bind(h,"change",function(){i.useLocalStorage=!i.useLocalStorage,vh(i,l)})}var c=document.getElementById("dg-new-constructor");B.bind(c,"keydown",function(d){d.metaKey&&(d.which===67||d.keyCode===67)&&Wr.hide()}),B.bind(t,"click",function(){c.innerHTML=JSON.stringify(i.getSaveObject(),void 0,2),Wr.show(),c.focus(),c.select()}),B.bind(r,"click",function(){i.save()}),B.bind(a,"click",function(){var d=prompt("Enter a new preset name.");d&&i.saveAs(d)}),B.bind(s,"click",function(){i.revert()})}function fg(i){var e=void 0;i.__resize_handle=document.createElement("div"),O.extend(i.__resize_handle.style,{width:"6px",marginLeft:"-3px",height:"200px",cursor:"ew-resize",position:"absolute"});function t(s){return s.preventDefault(),i.width+=e-s.clientX,i.onResize(),e=s.clientX,!1}function r(){B.removeClass(i.__closeButton,xe.CLASS_DRAG),B.unbind(window,"mousemove",t),B.unbind(window,"mouseup",r)}function a(s){return s.preventDefault(),e=s.clientX,B.addClass(i.__closeButton,xe.CLASS_DRAG),B.bind(window,"mousemove",t),B.bind(window,"mouseup",r),!1}B.bind(i.__resize_handle,"mousedown",a),B.bind(i.__closeButton,"mousedown",a),i.domElement.insertBefore(i.__resize_handle,i.domElement.firstElementChild)}function tn(i,e){i.domElement.style.width=e+"px",i.__save_row&&i.autoPlace&&(i.__save_row.style.width=e+"px"),i.__closeButton&&(i.__closeButton.style.width=e+"px")}function Va(i,e){var t={};return O.each(i.__rememberedObjects,function(r,a){var s={},o=i.__rememberedObjectIndecesToControllers[a];O.each(o,function(l,h){s[h]=e?l.initialValue:l.getValue()}),t[a]=s}),t}function dg(i){for(var e=0;e<i.__preset_select.length;e++)i.__preset_select[e].value===i.preset&&(i.__preset_select.selectedIndex=e)}function xh(i){i.length!==0&&og.call(window,function(){xh(i)}),O.each(i,function(e){e.updateDisplay()})}var yh=xe;class gg{constructor(){n(this,"debug",!1),n(this,"data"),n(this,"gui"),n(this,"bind"),n(this,"_current"),n(this,"_nullBind",{}),n(this,"folders",{}),this.data={},this.bind={},this._nullBind={},this._nullBind.onChange=()=>{}}init(e=10){this.debug=!0,this.gui=new yh,this.gui.domElement.style.zIndex=`${e}`,this.gui.domElement.parentElement.style.zIndex=`${e}`,this.addFolder("Orillusion")}addCustom(e,t,r,a,s,o){if(!this.debug)return this._nullBind;let l=this._current?this._current:this.gui,h={[e]:t[r]};l.add(h,e,a,s,o).onChange(u=>{t[r]=u})}add(e,t,r,a,s){return this.debug?(this._current?this._current:this.gui).add(e,t,r,a,s):this._nullBind}addLabel(e){if(!this.debug)return this._nullBind;Ct.add({label:e},"label")}addInfo(e,t){if(!this.debug)return this._nullBind;let r={};r[e]=t.toString(),Ct.add(r,e)}addColor(e,t){if(!this.debug)return this._nullBind;let a=(this._current?this._current:this.gui).addColor(e[t],"rgba").name(t);return a.onChange(s=>{console.log(s);let o=e[t];o.rgba=s,e[t]=o}),a}addButton(e,t){if(!this.debug)return this._nullBind;var r=new function(){this[e]=t};(this._current?this._current:this.gui).add(r,e)}open(){if(!this.debug)return this._nullBind;(this._current?this._current:this.gui).open()}close(){if(!this.debug)return this._nullBind;(this._current?this._current:this.gui).close()}addFolder(e){return this.debug?(this.folders[e]?this._current=this.folders[e]:(this._current=this.gui.addFolder(e),this.folders[e]=this._current),this._current):this._nullBind}removeFolder(e){if(!this.debug)return this._nullBind;let t=this.folders[e];t&&(this.gui.removeFolder(t),this._current=null,delete this.folders[e])}endFolder(){if(!this.debug)return this._nullBind;this._current=null}_creatPanel(){let e=new yh;return e.domElement.style.zIndex="10",e.domElement.parentElement.style.zIndex="10",e}_add(e,t,r,a,s,o){return e.add(t,r,a,s,o)}_addLabel(e,t){Ct._add(e,{label:t},"label")}_addButton(e,t,r){var a=new function(){this[t]=r};e.add(a,t)}_addColor(e,t,r){return e.addColor(t[r],"rgb").name(r)}_addFolder(e,t){e.Folder==null&&(e.Folder={});let r=e.addFolder(t);return e.Folder[t]=r,r}_removeFolder(e,t){e.Folder&&e.Folder[t]&&e.removeFolder(e.Folder[t])}}let Ct=new gg;class Ch extends di{constructor(e){super(),n(this,"maxNumLightsPerCluster",64),n(this,"clusterPix",1),n(this,"clusterLightingBuffer"),n(this,"_currentLightCount",0),n(this,"_clusterGenerateCompute"),n(this,"_clusterLightingCompute"),n(this,"_useCamera"),n(this,"resize",!1),this.passType=re.Cluster,this.initCompute(e)}initCompute(e){this._clusterGenerateCompute=new be(th),this._clusterLightingCompute=new be(ih);let t=I.presentationSize,r=Fe.clusterTileX*Fe.clusterTileY*Fe.clusterTileZ,a=e.camera,s=a.near,o=a.far;this.clusterLightingBuffer=new eh(r,this.maxNumLightsPerCluster),this.clusterLightingBuffer.update(t[0],t[1],this.clusterPix,Fe.clusterTileX,Fe.clusterTileY,Fe.clusterTileZ,0,this.maxNumLightsPerCluster,s,o),this._clusterGenerateCompute.setUniformBuffer("clustersUniform",this.clusterLightingBuffer.clustersUniformBuffer),this._clusterGenerateCompute.setStorageBuffer("clusterBuffer",this.clusterLightingBuffer.clusterBuffer);let l=de.getLightEntries(e.scene);this._clusterLightingCompute.setStorageBuffer("models",de.modelMatrixBindGroup.matrixBufferDst),this._clusterLightingCompute.setUniformBuffer("clustersUniform",this.clusterLightingBuffer.clustersUniformBuffer),this._clusterLightingCompute.setStorageBuffer("clusterBuffer",this.clusterLightingBuffer.clusterBuffer),this._clusterLightingCompute.setStorageBuffer("lightBuffer",l.storageGPUBuffer),this._clusterLightingCompute.setStorageBuffer("lightAssignBuffer",this.clusterLightingBuffer.lightAssignBuffer),this._clusterLightingCompute.setStorageBuffer("assignTable",this.clusterLightingBuffer.assignTableBuffer),this.resize=!0,Ct.addButton("clusterBuffer",()=>{let h=this.clusterLightingBuffer.clusterBuffer.readBuffer();console.log(h);let u=2*4;for(let c=0;c<r;c++){const d=new Float32Array(h.buffer,c*u*4,u);let g=new p(d[0],d[1],d[2],d[3]),m=new p(d[4],d[5],d[6],d[7]);e.graphic3D.drawBox(c+"-box",g,m,z.random())}}),Ct.addButton("assignTable",()=>{let h=this.clusterLightingBuffer.assignTableBuffer.readBuffer();for(let u=0;u<h.length/4;u++){const c=h[u*4+0],d=h[u*4+1],g=h[u*4+2],m=h[u*4+3];c>=1&&console.log(c),d+c>d+1&&console.log(c,d,g,m)}console.log(h)}),Ct.addButton("clustersUniformBuffer",()=>{let h=this.clusterLightingBuffer.clustersUniformBuffer.readBuffer();console.log(h)})}render(e,t){let r=e.scene,a=Q.instance.getLights(r);if(this._useCamera!=e.camera){this._useCamera=e.camera;let l=de.getCameraGroup(this._useCamera);this._clusterGenerateCompute.setUniformBuffer("globalUniform",l.uniformGPUBuffer),this._clusterLightingCompute.setUniformBuffer("globalUniform",l.uniformGPUBuffer)}this._currentLightCount!=a.length&&(this._currentLightCount=a.length,this.clusterLightingBuffer.clustersUniformBuffer.setFloat("numLights",a.length),this.clusterLightingBuffer.clustersUniformBuffer.apply(),this._clusterGenerateCompute.workerSizeX=Fe.clusterTileZ,this._clusterLightingCompute.workerSizeX=Fe.clusterTileZ);let s=I.presentationSize;this.clusterLightingBuffer.update(s[0],s[1],this.clusterPix,Fe.clusterTileX,Fe.clusterTileY,Fe.clusterTileZ,a.length,this.maxNumLightsPerCluster,e.camera.near,e.camera.far),this.resize=!1;let o=w.beginCommandEncoder();w.computeCommand(o,[this._clusterGenerateCompute,this._clusterLightingCompute]),w.endCommandEncoder(o)}}class bh extends f.Object3D{constructor(e=.001,t=1e4,r=90,a=!1){super(),n(this,"up_camera"),n(this,"down_camera"),n(this,"left_camera"),n(this,"right_camera"),n(this,"front_camera"),n(this,"back_camera"),this.initCubeCamera(e,t,r,a)}set label(e){this.up_camera.name=e+"up",this.down_camera.name=e+"down",this.left_camera.name=e+"left",this.right_camera.name=e+"right",this.front_camera.name=e+"front",this.back_camera.name=e+"back"}initCubeCamera(e,t,r=90,a=!1){this.up_camera=Oe.createCamera3DObject(this,"up"),this.down_camera=Oe.createCamera3DObject(this,"down"),this.left_camera=Oe.createCamera3DObject(this,"left"),this.right_camera=Oe.createCamera3DObject(this,"right"),this.front_camera=Oe.createCamera3DObject(this,"front"),this.back_camera=Oe.createCamera3DObject(this,"back"),this.up_camera.isShadowCamera=a,this.down_camera.isShadowCamera=a,this.left_camera.isShadowCamera=a,this.right_camera.isShadowCamera=a,this.front_camera.isShadowCamera=a,this.back_camera.isShadowCamera=a;let s=1;this.up_camera.perspective(r,s,e,t),this.up_camera.lookAt(p.ZERO,p.UP,p.DOWN),this.up_camera.object3D.scaleX=-1,this.up_camera.object3D.rotationY=180,this.down_camera.perspective(r,s,e,t),this.down_camera.lookAt(p.ZERO,p.DOWN,p.DOWN),this.down_camera.object3D.scaleX=-1,this.down_camera.object3D.rotationY=180,this.left_camera.perspective(r,s,e,t),this.left_camera.lookAt(p.ZERO,p.LEFT),this.left_camera.object3D.scaleX=-1,this.right_camera.perspective(r,s,e,t),this.right_camera.lookAt(p.ZERO,p.RIGHT),this.right_camera.object3D.scaleX=-1,this.front_camera.perspective(r,s,e,t),this.front_camera.lookAt(p.ZERO,p.FORWARD),this.front_camera.object3D.scaleX=-1,this.back_camera.perspective(r,s,e,t),this.back_camera.lookAt(p.ZERO,p.BACK),this.back_camera.object3D.scaleX=-1,this.up_camera.type=Ie.shadow,this.down_camera.type=Ie.shadow,this.left_camera.type=Ie.shadow,this.right_camera.type=Ie.shadow,this.front_camera.type=Ie.shadow,this.back_camera.type=Ie.shadow}}class wh extends st{constructor(e,t,r){super(e,t,r),this.format=G.depth32float,this.mipmapCount=1,this.init()}internalCreateBindingLayoutDesc(){this.textureBindingLayout.sampleType="depth",this.textureBindingLayout.viewDimension="cube-array",this.samplerBindingLayout.type="filtering",this.sampler_comparisonBindingLayout.type="comparison"}internalCreateTexture(){this.textureDescriptor={format:this.format,size:{width:this.width,height:this.height,depthOrArrayLayers:6*this.numberLayer},dimension:"2d",usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING},this.gpuTexture=I.device.createTexture(this.textureDescriptor)}internalCreateView(){this.viewDescriptor={dimension:"cube-array"},this.view=this.gpuTexture.createView(this.viewDescriptor)}internalCreateSampler(){this.gpuSampler=I.device.createSampler({minFilter:Br.linear,magFilter:Br.linear}),this.gpuSampler_comparison=I.device.createSampler({compare:"less",label:"sampler_comparison"})}}class Sh extends di{constructor(){super(),n(this,"shadowPassCount"),n(this,"_forceUpdate",!1),n(this,"_shadowCameraDic"),n(this,"shadowCamera"),n(this,"cubeArrayTexture"),n(this,"colorTexture"),n(this,"shadowSize",1024),this.passType=re.POINT_SHADOW,this._shadowCameraDic=new Map,this.cubeArrayTexture=new wh(this.shadowSize,this.shadowSize,8),this.colorTexture=new ne(this.shadowSize,this.shadowSize,G.bgra8unorm,!1),ae.getInstance().attached(this.cubeArrayTexture,this)}getShadowCamera(e,t){let r;if(this._shadowCameraDic.has(t))r=this._shadowCameraDic.get(t);else{let a=new bh(e.camera.near,e.camera.far,90,!0);a.label=t.name;let s=[],o=[];for(let l=0;l<6;l++){let h=new ne(this.shadowSize,this.shadowSize,this.cubeArrayTexture.format,!1),u=new Ke([this.colorTexture],[new Ce]);h.name="shadowDepthTexture_"+t.name+l+"_face",u.depthTexture=h,u.label="shadowRender",u.customSize=!0;let c=Qe.createRendererPassState(u);o[l]=c,s[l]=h,_.getRenderJob(e).postRenderer.setDebugTexture([h]),_.getRenderJob(e).debug()}r={cubeCamera:a,depthTexture:s,rendererPassState:o},this._shadowCameraDic.set(t,r)}return r}render(e,t){if(!_.setting.shadow.enable)return;this.shadowPassCount=0,e.camera;let r=e.scene,a=Ge.getPointShadowLightWhichScene(r),s=a.length;for(let o=0;o<s;o++){let l=a[o];if(l.lightData.lightType!=ze.DirectionLight&&l.lightData.castShadowIndex>-1&&(l.needUpdateShadow||this._forceUpdate||he.frame<5||l.realTimeShadow)){l.needUpdateShadow=!1;let h=this.getShadowCamera(e,l),u=l.transform.worldPosition;h.cubeCamera.x=u.x,h.cubeCamera.y=u.y,h.cubeCamera.z=u.z;let c;h.cubeCamera.transform.updateWorldMatrix(!0),t.update(h.cubeCamera.right_camera,r),c=Q.instance.getRenderNodes(r,h.cubeCamera.right_camera),this.renderSceneOnce(0,h,e,h.cubeCamera.right_camera,c,t),t.update(h.cubeCamera.left_camera,r),c=Q.instance.getRenderNodes(r,h.cubeCamera.left_camera),this.renderSceneOnce(1,h,e,h.cubeCamera.left_camera,c,t),t.update(h.cubeCamera.up_camera,r),c=Q.instance.getRenderNodes(r,h.cubeCamera.up_camera),this.renderSceneOnce(2,h,e,h.cubeCamera.up_camera,c,t),t.update(h.cubeCamera.down_camera,r),c=Q.instance.getRenderNodes(r,h.cubeCamera.down_camera),this.renderSceneOnce(3,h,e,h.cubeCamera.down_camera,c,t),t.update(h.cubeCamera.front_camera,r),c=Q.instance.getRenderNodes(r,h.cubeCamera.front_camera),this.renderSceneOnce(4,h,e,h.cubeCamera.front_camera,c,t),t.update(h.cubeCamera.back_camera,r),c=Q.instance.getRenderNodes(r,h.cubeCamera.back_camera),this.renderSceneOnce(5,h,e,h.cubeCamera.back_camera,c,t);let d=w.beginCommandEncoder();for(let g=0;g<6;g++)d.copyTextureToTexture({texture:h.depthTexture[g].getGPUTexture(),mipLevel:0,origin:{x:0,y:0,z:0}},{texture:this.cubeArrayTexture.getGPUTexture(),mipLevel:0,origin:{x:0,y:0,z:l.shadowIndex*6+g}},{width:this.shadowSize,height:this.shadowSize,depthOrArrayLayers:1});w.endCommandEncoder(d)}}this._forceUpdate=!1}renderSceneOnce(e,t,r,a,s,o){this.rendererPassState=t.rendererPassState[e];let l=w.beginCommandEncoder(),h=w.beginRenderPass(l,this.rendererPassState);h.setViewport(0,0,this.shadowSize,this.shadowSize,0,1),h.setScissorRect(0,0,this.shadowSize,this.shadowSize),a.onUpdate(),a.transform.updateWorldMatrix(!0);let u=Q.instance.getRenderShaderCollect(r);for(const c of u){let d=c[1];for(const g of d){let m=g[1];if(m.preInit){m.nodeUpdate(r,this._rendererType,this.rendererPassState,null);break}}}this.drawShadowRenderNodes(r,a,h,s.opaqueList,o),this.drawShadowRenderNodes(r,a,h,s.transparentList,o),w.endPass(h),w.endCommandEncoder(l)}drawShadowRenderNodes(e,t,r,a,s){if(w.bindCamera(r,t),a)for(let o=_.setting.render.drawOpMin;o<Math.min(a.length,_.setting.render.drawOpMax);++o){let l=a[o];if(l.transform.worldMatrix.index,!!l.transform.enable&&l.enable){l.preInit||l.nodeUpdate(e,this._rendererType,this.rendererPassState);for(let h of l.materials){let u=h.getPass(this._rendererType);if(!u||u.length==0)continue;w.bindGeometryBuffer(r,l.geometry);let c=l.object3D.transform._worldMatrix;for(let d of u){const g=d;if(g.pipeline){g.setUniformFloat("cameraFar",t.far),g.setUniformVector3("lightWorldPos",t.transform.worldPosition),g.materialDataUniformBuffer.apply(),w.bindPipeline(r,g);let m=l.geometry.subGeometries;for(const A of m){let y=A.lodLevels[l.lodLevel];w.drawIndexed(r,y.indexCount,1,y.indexStart,0,c.index)}}}}}}}}class Ih extends st{constructor(e,t,r=G.depth32float,a=4){super(e,t,a),this.format=r,this.mipmapCount=1,this.init()}internalCreateBindingLayoutDesc(){this.textureBindingLayout.sampleType="depth",this.textureBindingLayout.viewDimension="2d-array",this.samplerBindingLayout.type="filtering",this.sampler_comparisonBindingLayout.type="comparison"}internalCreateTexture(){this.textureDescriptor={format:this.format,size:{width:this.width,height:this.height,depthOrArrayLayers:this.numberLayer},dimension:"2d",usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING},this.gpuTexture=I.device.createTexture(this.textureDescriptor)}internalCreateView(){this.viewDescriptor={dimension:"2d-array"},this.view=this.gpuTexture.createView(this.viewDescriptor)}internalCreateSampler(){this.gpuSampler=I.device.createSampler({}),this.gpuSampler_comparison=I.device.createSampler({compare:"less",label:"sampler_comparison"})}}class Eh extends di{constructor(){super(),n(this,"shadowPassCount"),n(this,"depth2DArrayTexture"),n(this,"rendererPassStates"),n(this,"_forceUpdate",!1),n(this,"_shadowPos",new p),n(this,"_shadowCameraTarget",new p),this.setShadowMap(_.setting.shadow.shadowSize,nt.Cascades),this.passType=re.SHADOW}setShadowMap(e,t){this.rendererPassStates=[],this.depth2DArrayTexture=new Ih(e,e,G.depth32float,8),ae.getInstance().attached(this.depth2DArrayTexture,this);for(let r=0;r<8;r++){let a=new Ke([],[]);const s=new ne(e,e,G.depth32float,!1);s.name=`shadowDepthTexture_${r}`,a.depthTexture=s,a.label="shadowRender",a.customSize=!0,a.depthCleanValue=1;let o=Qe.createRendererPassState(a);this.rendererPassStates[r]=o}}render(e,t){let r=_.setting.shadow;if(!r.enable)return;let a=e.camera,s=e.scene;if(this.shadowPassCount=0,!r.needUpdate||he.frame%r.updateFrameRate!=0)return;let o=Ge.getDirectShadowLightWhichScene(s),l=r.shadowSize;const h=nt.Cascades;for(let u of o){const c=u;let d=c.shadowIndex;this.rendererPassState=this.rendererPassStates[d];let g=Q.instance.getRenderShaderCollect(e);for(const m of g){let A=m[1];for(const v of A){let y=v[1];if(y.preInit){y.nodeUpdate(e,this._rendererType,this.rendererPassState,null);break}}}if(c.castShadow&&c.needUpdateShadow||this._forceUpdate||c.castShadow&&r.autoUpdate)if(c.needUpdateShadow=!1,a.enableCSM&&d==0)for(let m=0;m<h;m++){this.rendererPassState=this.rendererPassStates[m];let A=a.csm.children[m],v=a.getCSMShadowWorldExtents(m);this.poseShadowCamera(a,c.direction,A.shadowCamera,v,A.bound.center),this.renderShadow(e,A.shadowCamera,t,this.rendererPassState),this.copyDepthTexture(this.rendererPassState.depthTexture,this.depth2DArrayTexture,m,l)}else{a.enableCSM&&(d+=h-1);let m=a.getShadowWorldExtents();this.rendererPassState=this.rendererPassStates[d],this.poseShadowCamera(a,c.direction,c.shadowCamera,m,a.lookTarget),this.renderShadow(e,c.shadowCamera,t,this.rendererPassState),this.copyDepthTexture(this.rendererPassState.depthTexture,this.depth2DArrayTexture,d,l)}}this._forceUpdate=!1}copyDepthTexture(e,t,r,a){let s=w.beginCommandEncoder();s.copyTextureToTexture({texture:e.getGPUTexture(),mipLevel:0,origin:{x:0,y:0,z:0}},{texture:t.getGPUTexture(),mipLevel:0,origin:{x:0,y:0,z:r}},{width:a,height:a,depthOrArrayLayers:1}),w.endCommandEncoder(s)}poseShadowCamera(e,t,r,a,s){this._shadowPos.copy(t).normalize(e.far),s.add(this._shadowPos,this._shadowCameraTarget),s.subtract(this._shadowPos,this._shadowPos),r.transform.lookAt(this._shadowPos,this._shadowCameraTarget),r.orthoOffCenter(-a,a,-a,a,e.near,e.far*2)}compute(){}renderShadow(e,t,r,a){let s=Q.instance.getRenderNodes(e.scene,t),o=w.beginCommandEncoder(),l=w.beginRenderPass(o,a);t.transform.updateWorldMatrix(),ka.enable&&(r.update(t,e.scene),r.collect(s,t)),w.bindCamera(l,t);let h=this.renderShadowBundleOp(e,t,a),u=this.renderShadowBundleTr(e,t,a);h.length>0&&l.executeBundles(h),this.drawShadowRenderNodes(e,t,l,s.opaqueList),u.length>0&&l.executeBundles(u),this.drawShadowRenderNodes(e,t,l,s.transparentList),w.endPass(l),w.endCommandEncoder(o)}renderShadowBundleOp(e,t,r){let a=Q.instance.getOpRenderGroup(e.scene);if(a){let s=[];return a.renderGroup.forEach(o=>{if(o.bundleMap.has(this._rendererType))s.push(o.bundleMap.get(this._rendererType));else{let l=w.recordBundleEncoder(r.renderBundleEncoderDescriptor);this.recordShadowRenderBundleNode(e,t,l,o.renderNodes);let h=l.finish();o.bundleMap.set(this._rendererType,h),s.push(h)}}),s}return[]}renderShadowBundleTr(e,t,r){let a=Q.instance.getTrRenderGroup(e.scene);if(a){let s=[];return a.renderGroup.forEach(o=>{if(o.bundleMap.has(this._rendererType))s.push(o.bundleMap.get(this._rendererType));else{let l=w.recordBundleEncoder(r.renderBundleEncoderDescriptor);this.recordShadowRenderBundleNode(e,t,l,o.renderNodes);let h=l.finish();o.bundleMap.set(this._rendererType,h),s.push(h)}}),s}return[]}recordShadowRenderBundleNode(e,t,r,a,s){if(w.bindCamera(r,t),a){w.bindGeometryBuffer(r,a[0].geometry);for(let o=0;o<a.length;++o){let l=a[o];l.transform.enable&&l.recordRenderPass2(e,this._rendererType,this.rendererPassState,s,r)}}}drawShadowRenderNodes(e,t,r,a,s){if(w.bindCamera(r,t),a)for(let o=_.setting.render.drawOpMin;o<Math.min(a.length,_.setting.render.drawOpMax);++o){let l=a[o];l.transform.enable&&l.enable&&l.renderPass2(e,this._rendererType,this.rendererPassState,s,r)}}}class Bh extends di{constructor(){super(),n(this,"zBufferTexture"),n(this,"useRenderBundle",!1),n(this,"shadowPassCount"),n(this,"zCullingCompute"),this.passType=re.DEPTH;let e=I.presentationSize,t=1;this.zBufferTexture=Ne.createRTTexture(Ae.zBufferTexture_NAME,Math.floor(e[0]*t),Math.floor(e[1]*t),G.rgba16float,!1);let r=new Ce;r.clearValue=[0,0,0,0],r.loadOp="clear";let a=new Ke([],[],Ne.createRTTexture(Ae.zPreDepthTexture_NAME,Math.floor(e[0]),Math.floor(e[1]),G.depth32float,!1),null,!1);this.setRenderStates(a)}render(e,t){let r=e.camera,a=e.scene;w.cleanCache(),ft.start("DepthPass Renderer");let s=a;this.rendererPassState.camera3D=r;let o=Q.instance.getRenderNodes(s,r);this.compute(e,t);let l=this.renderBundleOp(e,o,t),h=[],u=w.beginCommandEncoder(),c=w.beginRenderPass(u,this.rendererPassState);l.length>0&&c.executeBundles(l);let d=Q.instance.getRenderShaderCollect(e);for(const g of d){let m=g[1];for(const A of m){let v=A[1];if(v.preInit){v.nodeUpdate(e,this._rendererType,this.rendererPassState,null);break}}}this.drawRenderNodes(e,c,u,o.opaqueList,t),h.length>0&&c.executeBundles(h),w.endPass(c),w.endCommandEncoder(u),ft.end("DepthPass Renderer")}drawRenderNodes(e,t,r,a,s,o){w.bindCamera(t,e.camera);for(let l=_.setting.render.drawOpMin;l<Math.min(a.length,_.setting.render.drawOpMax);++l){let h=a[l];h.transform.enable&&h.enable&&(h.preInit||h.nodeUpdate(e,this._rendererType,this.rendererPassState),h.renderPass2(e,this._rendererType,this.rendererPassState,o,t))}}}class Th{constructor(){n(this,"map"),n(this,"passRendererList"),this.map=new Map,this.passRendererList=[]}addRenderer(e){this.map.has(e.passType)?console.error("same renderer pass repeat!"):(this.map.set(e.passType,e),e.passType<=8&&this.addPassRenderer(e))}getRenderer(e){return this.map.get(e)}addPassRenderer(e){this.passRendererList.push(e)}getAllRenderer(){return this.map}getAllPassRenderer(){return this.passRendererList}}class Dh extends di{constructor(){super(),n(this,"finalQuadView"),n(this,"postList"),this._rendererType=re.POST,this.postList=[],this.initRenderer()}initRenderer(){N.register("FullQuad_vert_wgsl",el),this.finalQuadView=new Na("Quad_vert_wgsl","Quad_frag_wgsl",new Ke([],[]),null,null,!1)}attachPost(e,t){t.postRenderer=this,this.postList.indexOf(t)!=-1||(this.postList.push(t),t.onAttach(e))}detachPost(e,t){let r=this.postList.indexOf(t);return r>=0&&(this.postList.splice(r,1),t.onDetach(e),t.postRenderer=null),r>=0}render(e){let t=w.beginCommandEncoder();for(let a=0;a<this.postList.length;a++){const s=this.postList[a];s.enable&&s.render(e,t)}let r=w.lastRenderPassState.getLastRenderTexture();if(this.finalQuadView.renderToViewQuad(e,this.finalQuadView,t,r),this.debugViewQuads.length){let a=_.setting.render.debugQuad;a>=0&&this.debugViewQuads[a].renderToViewQuad(e,this.debugViewQuads[a],t,this.debugTextures[a])}w.endCommandEncoder(t)}}class Mh{constructor(e){n(this,"rendererMap"),n(this,"shadowMapPassRenderer"),n(this,"pointLightShadowRenderer"),n(this,"ddgiProbeRenderer"),n(this,"postRenderer"),n(this,"clusterLightingRender"),n(this,"occlusionSystem"),n(this,"depthPassRenderer"),n(this,"colorPassRenderer"),n(this,"pauseRender",!1),n(this,"pickFire"),n(this,"_view"),this._view=e,this.rendererMap=new Th,this.occlusionSystem=new ka,this.clusterLightingRender=this.addRenderer(Ch,e),_.setting.render.zPrePass&&(this.depthPassRenderer=this.addRenderer(Bh)),this.shadowMapPassRenderer=new Eh,this.pointLightShadowRenderer=new Sh}addRenderer(e,t){let r;return t?r=new e(t):r=new e,this.rendererMap.addRenderer(r),r}get view(){return this._view}set view(e){this._view=e}start(){}stop(){}pause(){this.pauseRender=!0}resume(){this.pauseRender=!1}enablePost(e){this.postRenderer=this.addRenderer(Dh),this.postRenderer.setRenderStates(e)}addPost(e){return this.postRenderer||this.enablePost(yt.getGBufferFrame("ColorPassGBuffer")),e instanceof xt&&this.postRenderer.attachPost(this.view,e),e}removePost(e){if(e instanceof xt)this.postRenderer.detachPost(this.view,e);else for(let t=0;t<e.length;t++)this.postRenderer.detachPost(this.view,e[t])}renderFrame(){let e=this._view;de.getLightEntries(e.scene).update(e),this.occlusionSystem.update(e.camera,e.scene),this.clusterLightingRender.render(e,this.occlusionSystem),this.shadowMapPassRenderer&&(Ge.update(e.scene),this.shadowMapPassRenderer.render(e,this.occlusionSystem)),this.pointLightShadowRenderer&&this.pointLightShadowRenderer.render(e,this.occlusionSystem),this.depthPassRenderer&&(this.depthPassRenderer.compute(e,this.occlusionSystem),this.depthPassRenderer.render(e,this.occlusionSystem)),_.setting.gi.enable&&this.ddgiProbeRenderer&&(this.ddgiProbeRenderer.compute(e,this.occlusionSystem),this.ddgiProbeRenderer.render(e,this.occlusionSystem));let t=this.rendererMap.getAllPassRenderer();for(let r=0;r<t.length;r++){const a=t[r];a.compute(e,this.occlusionSystem),a.render(e,this.occlusionSystem,this.clusterLightingRender.clusterLightingBuffer)}this.postRenderer&&this.postRenderer.postList.length>0&&this.postRenderer.render(e)}debug(){}}class Ph extends f.Object3D{constructor(e=.001,t=1e4,r=90,a=!1){super(),n(this,"up_camera"),n(this,"down_camera"),n(this,"left_camera"),n(this,"right_camera"),n(this,"front_camera"),n(this,"back_camera"),this.initCubeCamera(e,t,r,a)}initCubeCamera(e,t,r=90,a=!1){this.up_camera=Oe.createCamera3DObject(this,"up"),this.down_camera=Oe.createCamera3DObject(this,"down"),this.left_camera=Oe.createCamera3DObject(this,"left"),this.right_camera=Oe.createCamera3DObject(this,"right"),this.front_camera=Oe.createCamera3DObject(this,"front"),this.back_camera=Oe.createCamera3DObject(this,"back"),this.up_camera.isShadowCamera=a,this.down_camera.isShadowCamera=a,this.left_camera.isShadowCamera=a,this.right_camera.isShadowCamera=a,this.front_camera.isShadowCamera=a,this.back_camera.isShadowCamera=a;let s=1;this.up_camera.perspective(r,s,e,t),this.up_camera.lookAt(p.ZERO,p.UP,p.DOWN),this.down_camera.perspective(r,s,e,t),this.down_camera.lookAt(p.ZERO,p.DOWN,p.DOWN),this.left_camera.perspective(r,s,e,t),this.left_camera.lookAt(p.ZERO,p.LEFT),this.right_camera.perspective(r,s,e,t),this.right_camera.lookAt(p.ZERO,p.RIGHT),this.front_camera.perspective(r,s,e,t),this.front_camera.lookAt(p.ZERO,p.FORWARD),this.back_camera.perspective(r,s,e,t),this.back_camera.lookAt(p.ZERO,p.BACK),this.up_camera.type=Ie.shadow,this.down_camera.type=Ie.shadow,this.left_camera.type=Ie.shadow,this.right_camera.type=Ie.shadow,this.front_camera.type=Ie.shadow,this.back_camera.type=Ie.shadow}}class Rh extends Ke{constructor(e,t){super([],[]),this.crateGBuffer(e,t)}crateGBuffer(e,t){let r=this.attachments,a=this.rtDescriptors,s=new ne(e,t,G.rgba16float,!1);s.name="positionMap";let o=new Ce;o.loadOp="load";let l=new ne(e,t,G.rgba16float,!1);l.name="normalMap";let h=new Ce;h.loadOp="load";let u=new ne(e,t,G.rgba16float,!1);u.name="colorMap";let c=new Ce;c.loadOp="load";let d=new ne(e,t,G.depth24plus,!1);d.name="depthTexture";let g=new Ce;g.loadOp="load",r.push(s),r.push(l),r.push(u),a.push(o),a.push(h),a.push(c),this.depthTexture=d}}let Lh=`
#include "GenerayRandomDir"
#include "MathShader"
#include "IrradianceVolumeData_frag"

struct ProbeData{
  offsetX:f32,
  offsetY:f32,
  offsetZ:f32,
  frame:f32,
}

 struct Uniforms {
     matrix : array<mat4x4<f32>>
 };

struct RayProbeBuffer{
  WPosition: vec3<f32>,
  WNormal:vec3<f32>,
  WRadiance:vec4<f32>,
}

struct CacheHitData{
  color:vec4<f32>,
  depth:vec4<f32>,
}

//  struct RayInfo{
//   rays:array<vec4<f32>,4096>
//  }

@group(0) @binding(0) var<storage, read> probes : array<ProbeData>;
@group(0) @binding(1) var<storage, read_write> irradianceBuffer : array<vec4<f32>>;
@group(0) @binding(2) var<storage, read_write> depthBuffer : array<vec4<f32>>;
@group(0) @binding(3) var<storage, read> uniformData : IrradianceVolumeData ;
@group(0) @binding(4) var probeIrradianceMap : texture_storage_2d<rgba16float, write>;
@group(0) @binding(5) var probeDepthMap : texture_storage_2d<rgba16float, write>;
@group(0) @binding(6) var<storage, read_write> depthRaysBuffer : array<vec4<f32>>;

@group(1) @binding(0) var positionMap : texture_2d<f32>;
@group(1) @binding(1) var normalMap : texture_2d<f32>;
@group(1) @binding(2) var colorMap : texture_2d<f32>;

@group(2) @binding(0)
var<storage, read> models : Uniforms;

var<private> probeID: u32 ;
var<private> workgroup_idx: u32 ;
var<private> workgroup_idy: u32 ;
var<private> hysteresis: f32 = 0.98 ;
var<private> epsilon: f32 = 1e-6 ;
var<private> probeLocation:vec3<f32> = vec3<f32>(0.0);
var<private> energyConservation: f32 = 0.85 ;
var<private> resultIrradiance: vec4<f32> ;
var<private> resultDepth: vec4<f32> ;
var<private> RAYS_PER_PROBE: f32 = 144.0 ;
var<private> OCT_RT_SIZE: u32;
var<private> PROBE_OCT_RT_SIZE: u32;
var<private> OCT_SIDE_SIZE_u32: u32;
var<private> OCT_SIDE_SIZE_f32: f32;
var<private> OCT_RT_SIZE_f32: f32;
var<private> PROBE_SOURCESIZE: f32;
var<private> PROBEMAP_SOURCESIZE: f32;
var<private> quaternion:vec4<f32> = vec4<f32>(0.0, -0.7071067811865475, 0.7071067811865475, 0.0);
var<private> randomMatrix:mat4x4<f32>;

@compute @workgroup_size( 8 , 8 , 1 )
fn CsMain(@builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
{
   RAYS_PER_PROBE = f32(i32(uniformData.rayNumber));
   OCT_RT_SIZE = u32(uniformData.OctRTMaxSize);
   OCT_RT_SIZE_f32 = f32(uniformData.OctRTMaxSize);
   OCT_SIDE_SIZE_u32 = u32(uniformData.OctRTSideSize);
   OCT_SIDE_SIZE_f32 = f32(uniformData.OctRTSideSize);
   PROBE_SOURCESIZE = f32(uniformData.ProbeSize);
   PROBEMAP_SOURCESIZE = f32(uniformData.ProbeSourceTextureSize);
   hysteresis = uniformData.hysteresis;
    // probe index
    probeID = globalInvocation_id.z ;
    // pixel coord
    workgroup_idx = globalInvocation_id.x ;
    workgroup_idy = globalInvocation_id.y;

    probeLocation = calcProbePosition(probeID);

    resultIrradiance = vec4<f32>(0.0);
    resultDepth = vec4<f32>(0.0,0.0,0.0,0.0);

    var tdr = normalize(getCurrentDir());
    let orientationIndex = u32(uniformData.orientationIndex);
    randomMatrix = models.matrix[orientationIndex];

    var distancePprobeUV = getSampleProbeUV(tdr.xyz);
    var rayUv:vec2<i32> = vec2<i32>(distancePprobeUV.xy * f32(PROBEMAP_SOURCESIZE - 1.0));
    let rayHitPosition = textureLoad(positionMap, rayUv, 0).xyz ;
    
    for(var i:f32 = 0.0; i < RAYS_PER_PROBE ; i = i + 1.0 ){
      radianceProbeOnce(i, tdr);
    }

    if (resultIrradiance.w > epsilon) {
      var color = vec3<f32>(resultIrradiance.xyz/(2.0*resultIrradiance.w)) ;
      color = pow(color.rgb, vec3<f32>(1.0 / uniformData.ddgiGamma));
      resultIrradiance = vec4<f32>(color,1.0-hysteresis);
    }

    // if nonzero
    if (resultDepth.w > epsilon) {
      resultDepth = vec4<f32>(resultDepth.xyz/(2.0*resultDepth.w),1.0-hysteresis) ;
    }

   let pixelCoord = getWriteOctUVByID();

   var lerpDataResult:CacheHitData;

   lerpDataResult.color = resultIrradiance;

   lerpDataResult.depth = resultDepth;

   lerpDataResult = lerpHitData(lerpDataResult, pixelCoord);

   writeRayHitData(pixelCoord, lerpDataResult);

   storePixelAtCoord(probeIrradianceMap, pixelCoord , vec4<f32>(lerpDataResult.color.xyz, 1.0), true);

   storePixelAtCoord(probeDepthMap, pixelCoord , vec4<f32>(resultDepth.xy, 0.0, 1.0), false);
}

fn lerpHitData(data:CacheHitData, coord:vec2<i32>) -> CacheHitData{
   let frameIndex = probes[probeID].frame;
   var newData:CacheHitData = data;

   //if(frameIndex > 1.0){
      var oldData = readRayHitData(coord);
      newData.color = mix(oldData.color, newData.color, uniformData.lerpHysteresis);
      newData.depth = mix(oldData.depth, newData.depth, uniformData.lerpHysteresis);
   //}
   return newData;
}

fn square(v:vec3<f32>) -> vec3<f32>{
   var v3 = v;
   v3.x = v3.x * v3.x;
   v3.y = v3.y * v3.y;
   v3.z = v3.z * v3.z;
   return v3;
}

 fn testSample() ->vec4<f32>{
   var ux = f32(workgroup_idx) / OCT_SIDE_SIZE_f32;
   var uy = f32(workgroup_idy) / OCT_SIDE_SIZE_f32;
   var uv = vec2<f32>(ux,uy) * 2.0 - 1.0 ;
   var dir = octDecode(uv);
   var probeUV = getSampleProbeUV(dir.xyz);
   var rayProbeBuffer = getCurrentRayHitBuffer(probeUV);
   return rayProbeBuffer.WRadiance;
 }

 fn gridCoordToProbeIndex(grid:vec3<i32>) -> i32
 {
     return grid.x + grid.z * i32(uniformData.gridXCount) + grid.y * i32(uniformData.gridXCount * uniformData.gridZCount);
 }

fn storePixelAtCoord(texture:texture_storage_2d<rgba16float, write>, coord:vec2<i32>, color:vec4<f32>, isColor:bool){
   let sideCnt = i32(OCT_SIDE_SIZE_u32);
   let sideBorderCnt = sideCnt + 2;
   let indexXY = coord / sideCnt;
   let modeXY = coord % sideCnt;

   var newCoord = indexXY * sideBorderCnt + modeXY;
   textureStore(texture, newCoord + 1, color);

   var borderCoord = vec2<i32>(-1);
   //\u5DE6\u53F3
   if(modeXY.x % (sideCnt - 1) == 0){
     borderCoord = modeXY;
     borderCoord.y = sideCnt - borderCoord.y;
     if(modeXY.x == sideCnt - 1){
       borderCoord.x = sideBorderCnt - 1;
     }
     borderCoord = indexXY * sideBorderCnt + borderCoord;
     textureStore(texture, borderCoord, color);
   }
   //\u4E0A\u4E0B
   if(modeXY.y % (sideCnt - 1) == 0){
     borderCoord = modeXY;
     borderCoord.x = sideCnt - borderCoord.x;
     if(modeXY.y == sideCnt - 1){
         borderCoord.y = sideBorderCnt - 1;
     }
     borderCoord = indexXY * sideBorderCnt + borderCoord;
     textureStore(texture, borderCoord, color);
   }
   //\u8865\u89D2
   if(modeXY.x % (sideCnt - 1) == 0 && modeXY.y % (sideCnt - 1) == 0){
      var cornerCoord = modeXY;
      if(modeXY.x == 0){
         cornerCoord.x = sideBorderCnt - 1;
      }else{
         cornerCoord.x = 0;
      }
       if(modeXY.y == 0){
         cornerCoord.y = sideBorderCnt - 1;
      }else{
         cornerCoord.y = 0;
      }
      cornerCoord = indexXY * sideBorderCnt + cornerCoord;
      textureStore(texture, cornerCoord, color);
   }
}

fn calcProbePosition(id:u32) -> vec3<f32>{
   var probeLocation = vec3<f32>(0.0);
   var blockCount = u32(uniformData.gridXCount * uniformData.gridZCount) ;
   var grid = vec3<u32>(0u);
   grid.x = (id % blockCount) % u32(uniformData.gridXCount);
   grid.y = id / blockCount;
   grid.z = (id % blockCount) / u32(uniformData.gridXCount);
   probeLocation.x = f32(grid.x) * uniformData.ProbeSpace + uniformData.startX;
   probeLocation.y = f32(grid.y) * uniformData.ProbeSpace + uniformData.startY;
   probeLocation.z = f32(grid.z) * uniformData.ProbeSpace + uniformData.startZ;
   return probeLocation;
}

fn getWriteOctUVByID() -> vec2<i32>
{
   var blockCount = u32(uniformData.gridXCount * uniformData.gridZCount) ;
   var offsetX = (probeID % blockCount) % u32(uniformData.gridXCount) ;
   var offsetY = u32(uniformData.gridZCount - 1.0) - (probeID % blockCount) / u32(uniformData.gridXCount) ;
   var offsetZ = probeID / blockCount ;
   var pixelCoord = vec2<i32>(i32(workgroup_idx), i32(workgroup_idy));
   pixelCoord.x = pixelCoord.x + i32(offsetX * OCT_SIDE_SIZE_u32);
   pixelCoord.y = pixelCoord.y + i32(offsetY * OCT_SIDE_SIZE_u32 + offsetZ * u32(uniformData.gridZCount) * OCT_SIDE_SIZE_u32);

   pixelCoord = offsetByCol(pixelCoord, OCT_SIDE_SIZE_f32, OCT_RT_SIZE, vec3<f32>(uniformData.gridXCount, uniformData.gridYCount, uniformData.gridZCount));
   return pixelCoord;
}

fn offsetByCol(pixelCoord0:vec2<i32>, octSideSize:f32, mapHeight:u32, counts:vec3<f32>) -> vec2<i32>
{
 var pixelCoord = pixelCoord0;
 let blockSize:vec2<i32> = vec2<i32>(i32(octSideSize * counts.x),  i32(octSideSize * counts.z));
 let blockSizeYBorder:i32 = i32((octSideSize + 2.0) * counts.z);
 let blockMaxRowBorder:i32 = i32(mapHeight) / blockSizeYBorder;
 let pixelCountYMax:i32 = blockMaxRowBorder * i32(octSideSize * counts.z);
 let col:i32 = pixelCoord.y / pixelCountYMax;

 pixelCoord.x = col * i32(octSideSize * counts.x) + pixelCoord.x;
 pixelCoord.y = pixelCoord.y % pixelCountYMax;

 return pixelCoord;
}

fn radianceProbeOnce(rayID:f32, tdr:vec3<f32>){
   var texelDirection = sphericalFibonacci(rayID, RAYS_PER_PROBE ) ;
   var rayDirection = normalize( vec3<f32>((randomMatrix * vec4<f32>(texelDirection, 1.0)).xyz));
   var probeUV = getSampleProbeUV(rayDirection.xyz);
   var rayWriteUV = getWriteRayInfoUV();

   var rayProbeBuffer = getCurrentRayHitBuffer(probeUV);
   var rayHitLocation = rayProbeBuffer.WPosition + normalize(rayProbeBuffer.WNormal) * 0.01;

   var rayProbeDistance = length(probeLocation - rayHitLocation) ;
   // rayProbeDistance = min(uniformData.ProbeSpace * 4.0, rayProbeDistance) ;

   // if (dot(rayProbeBuffer.WNormal, rayProbeBuffer.WNormal) < epsilon) {
   //   rayProbeDistance = epsilon ;
   // }

   let rid = i32(probeID) * i32(RAYS_PER_PROBE) + i32(rayID) ;
   depthRaysBuffer[rid] = vec4<f32>(rayDirection.xyz,rayProbeDistance) ;

   // Detect misses and force depth
   var i_weight = max(0.0, dot(tdr,rayDirection) );
   var d_weight = pow(i_weight, uniformData.depthSharpness);
   
   if (i_weight >= epsilon) {
     //  var weightColor = pow(weight, (2.0 - uniformData.probeRoughness) * 2.0);
      resultIrradiance += vec4(rayProbeBuffer.WRadiance.rgb, i_weight );
     
   }
   if(d_weight>= epsilon){
       resultDepth += vec4(rayProbeDistance * d_weight, rayProbeDistance * rayProbeDistance * d_weight, 0.0 , i_weight);
   }
}

fn getCurrentRayHitBuffer(probeUV:vec2<f32>) -> RayProbeBuffer {
  var rayProbeBuffer : RayProbeBuffer ;
  var uv:vec2<i32> = vec2<i32>(probeUV.xy * f32(PROBEMAP_SOURCESIZE - 1.0));
  rayProbeBuffer.WPosition = textureLoad(positionMap, uv, 0).xyz ;
  rayProbeBuffer.WNormal = normalize(textureLoad(normalMap, uv, 0).xyz * 2.0 - 1.0);
  rayProbeBuffer.WRadiance = textureLoad(colorMap, uv, 0).xyzw * energyConservation;
  return rayProbeBuffer ;
}

fn getSampleProbeUV(dir0:vec3<f32>) -> vec2<f32> {
   var dir = applyQuaternion(dir0, quaternion);
   let faceId = dir_to_faceId(dir);
   var targetUV:vec2<f32> = convert_xyz_to_cube_uv(dir.x, dir.y, dir.z);
   targetUV.x = 1.0 - targetUV.x;
   let threshould = 0.5 / PROBE_SOURCESIZE;
   targetUV = clamp(targetUV, vec2<f32>(threshould), vec2<f32>(1.0 - threshould));

   targetUV.x = f32(faceId) + targetUV.x;

   let aspect:f32 = PROBE_SOURCESIZE / PROBEMAP_SOURCESIZE;
   targetUV = targetUV * aspect ;

   var fullCol = u32(PROBEMAP_SOURCESIZE) / u32(PROBE_SOURCESIZE);
   var offsetSampleUv = vec2<f32>( f32(probeID / fullCol) * 6.0 , f32(probeID % fullCol)) * aspect;
   return targetUV + offsetSampleUv;
}

fn getWriteRayInfoUV() -> vec2<i32> {
  var writeUV = vec2<i32>(i32(workgroup_idy),i32(probeID)) ;
  return writeUV ;
}

fn writeRayHitData( uv:vec2<i32> , data:CacheHitData){
  let index = uv.y * i32(OCT_RT_SIZE) + uv.x ;
  irradianceBuffer[index] = data.color ;
  depthBuffer[index] = data.depth ;
}

fn readRayHitData( uv:vec2<i32> ) -> CacheHitData{
  var data:CacheHitData;
  let index = uv.y * i32(OCT_RT_SIZE) + uv.x ;
  data.color = irradianceBuffer[index] ;
  data.depth = depthBuffer[index] ;
  return data;
}

fn getCurrentDir() -> vec3<f32> {
  var ux = f32(workgroup_idx) / OCT_SIDE_SIZE_f32;
  var uy = f32(workgroup_idy) / OCT_SIDE_SIZE_f32;
  var uv = vec2<f32>(ux,uy) * 2.0 - 1.0 ;
  var dir = octDecode(uv) ;
  return normalize(dir) ;
}


`;class Uh{constructor(e){n(this,"irradianceBuffer"),n(this,"depthBuffer"),n(this,"probeIrradianceMap"),n(this,"probeDepthMap"),n(this,"volume"),n(this,"computeShader"),n(this,"depthRaysBuffer"),this.volume=e,this.initPipeline()}initPipeline(){this.computeShader=new be(Lh);let e=_.setting.gi,t=e.octRTMaxSize*e.octRTMaxSize;this.irradianceBuffer=new fe(t*4,GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST),this.computeShader.setStorageBuffer("irradianceBuffer",this.irradianceBuffer),this.depthBuffer=new fe(t*4,GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST),this.computeShader.setStorageBuffer("depthBuffer",this.depthBuffer),this.depthRaysBuffer=new fe(4096*4*2*2*2,GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC),this.computeShader.setStorageBuffer("depthRaysBuffer",this.depthRaysBuffer),this.computeShader.setStorageBuffer("probes",this.volume.probesBuffer),this.computeShader.setStorageBuffer("uniformData",this.volume.irradianceVolumeBuffer),this.computeShader.setStorageBuffer("models",de.modelMatrixBindGroup.matrixBufferDst)}setTextures(e,t,r){this.probeIrradianceMap=t,this.probeDepthMap=r;let a=e[0],s=e[1],o=e[2];this.computeShader.setStorageTexture("probeIrradianceMap",this.probeIrradianceMap),this.computeShader.setStorageTexture("probeDepthMap",this.probeDepthMap),this.computeShader.setSamplerTexture("positionMap",a),this.computeShader.setSamplerTexture("normalMap",s),this.computeShader.setSamplerTexture("colorMap",o)}readBuffer(){return this.depthRaysBuffer.readBuffer()}compute(e,t){let r=this.volume.setting,a=w.beginCommandEncoder(),s=Q.instance.getProbes(e.scene);this.computeShader.workerSizeX=r.octRTSideSize/8,this.computeShader.workerSizeY=r.octRTSideSize/8,this.computeShader.workerSizeZ=s.length,w.computeCommand(a,[this.computeShader])}}let Oh=`
  #include "MathShader"
  #include "IrradianceVolumeData_frag"

  struct IrradianceField {
      probeStartPosition: vec4<f32>,
      probeCounts:vec4<f32>,
      probeStep:f32,
      irradianceTextureWidth:f32,
      irradianceTextureHeight:f32,
      irradianceProbeSideLength:f32,
  };

  @group(0) @binding(0) var outputBuffer : texture_storage_2d<rgba16float, write>;
  @group(0) @binding(1) var<storage,read> uniformData : IrradianceVolumeData ;

  @group(1) @binding(0) var normalMapSampler : sampler;
  @group(1) @binding(1) var normalMap : texture_2d<f32>;

  @group(1) @binding(2) var colorMapSampler : sampler;
  @group(1) @binding(3) var colorMap : texture_2d<f32>;

  @group(1) @binding(4) var litMapSampler : sampler;
  @group(1) @binding(5) var litMap : texture_2d<f32>;

  @group(1) @binding(6) var irradianceMapSampler : sampler;
  @group(1) @binding(7) var irradianceMap : texture_2d<f32>;

  var<private> wsn:vec3<f32>;
  var<private> ulitColor:vec4<f32>;
  var<private> litColor:vec4<f32>;
  var<private> irradianceFieldSurface : IrradianceField ;
  var<private> probeID:u32;

  var<private> quaternion:vec4<f32> = vec4<f32>(0.0, -0.7071067811865475, 0.7071067811865475, 0.0);

  fn getIrradianceFieldSurface() -> IrradianceField{
    let data = uniformData;
    irradianceFieldSurface.probeStartPosition = vec4<f32>(data.startX, data.startY, data.startZ, 0.0);
    irradianceFieldSurface.probeCounts = vec4<f32>(data.gridXCount, data.gridYCount, data.gridZCount, 0.0);
    irradianceFieldSurface.probeStep = data.ProbeSpace;
    irradianceFieldSurface.irradianceTextureWidth = data.OctRTMaxSize;
    irradianceFieldSurface.irradianceTextureHeight = data.OctRTMaxSize;
    irradianceFieldSurface.irradianceProbeSideLength = data.OctRTSideSize;
    return irradianceFieldSurface;
  }

  fn rotateDir(n:vec3<f32>) -> vec3<f32>{
     return normalize(applyQuaternion(-n, quaternion));
  }

  fn sampleLitColor(uv:vec2<i32>) -> vec4<f32>
  {
      var oc1:vec4<f32> = textureSampleLevel(litMap, litMapSampler, vec2<f32>(0.0), 0.0);
      var oc:vec4<f32> = textureLoad(litMap, uv, 0);
      return oc;
  }

  fn sampleNormal(uv:vec2<i32>) -> vec4<f32>
  {
      var oc1:vec4<f32> = textureSampleLevel(normalMap, normalMapSampler, vec2<f32>(0.0), 0.0);
      var oc:vec4<f32> = textureLoad(normalMap, uv, 0);
      return oc;
  }

  fn sampleColor(uv:vec2<i32>) -> vec4<f32>
  {
      var oc1:vec4<f32> = textureSampleLevel(colorMap, colorMapSampler, vec2<f32>(0.0), 0.0);
      var oc:vec4<f32> = textureLoad(colorMap, uv, 0);
      return oc;
  }

  fn sampleProbe(fragCoord:vec2<u32>){
    var uv = vec2<i32>(i32(fragCoord.x), i32(fragCoord.y)) ;

    litColor = sampleLitColor(uv);

    var normalMap = sampleNormal(uv);
    wsn = normalMap.xyz * 2.0 - 1.0;

    ulitColor = sampleColor(uv);
  }

  @compute @workgroup_size( 8 , 8 , 1 )
  fn CsMain(@builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
  {
    getIrradianceFieldSurface();
    var fragCoord = vec2<u32>( globalInvocation_id.x, globalInvocation_id.y);
    probeID = globalInvocation_id.z;
    fragCoord = fragCoord + getCoordOffset(probeID);

    sampleProbe(fragCoord);

    let irradiance = getIrradianceColor();
    let result = blendIrradianceColor(irradiance);
    textureStore(outputBuffer, vec2<i32>(fragCoord), result);
  }

  fn blendIrradianceColor(irradiance:vec4<f32>) -> vec4<f32>{
     var bounceColor = irradiance * ulitColor;
     let bounceIntensity = getBounceIntensity(uniformData.bounceIntensity);
     let conservation1 = 1.0 / sqrt((1.0 + bounceIntensity * 0.55));
     let conservation2 = 1.0 / sqrt((1.0 + bounceIntensity));
     var result = litColor * conservation2 + bounceColor * sqrt(bounceIntensity) * conservation1;
     return vec4<f32>(result.xyz, litColor.w);
  }

  fn getBounceIntensity(intensity:f32) -> f32 {
    var value = clamp(intensity, 0.0, 1.0) * 10.0;
    return value;
  }

  fn getCoordOffset(id:u32) -> vec2<u32>{
      var fullCol = u32(uniformData.ProbeSourceTextureSize / uniformData.ProbeSize);
      var offsetSampleUv = vec2<u32>( (id / fullCol) * 6u , id % fullCol) * u32(uniformData.ProbeSize);
      return offsetSampleUv;
  }

  fn getIrradianceColor() -> vec4<f32>{
     var probeIrradiance: vec4<f32> = vec4<f32>(0.0);
     if(length(wsn) > 0.01){
       probeIrradiance = getIrrdiaceIndex(i32(probeID), wsn);
     }
     return probeIrradiance;
  }

  fn getIrrdiaceIndex(index:i32, wsn:vec3<f32>) -> vec4<f32>{
    var wsN = rotateDir(wsn.xyz);
    var texCoord:vec2<f32> = textureCoordFromDirection(wsN,
      index,
      irradianceFieldSurface.irradianceTextureWidth,
      irradianceFieldSurface.irradianceTextureHeight,
      irradianceFieldSurface.irradianceProbeSideLength);

    var probeIrradiance: vec3<f32> = textureSampleLevel(irradianceMap, irradianceMapSampler, texCoord, 0.0).xyz;
    return vec4<f32>(probeIrradiance, 1.0);
  }

  fn textureCoordFromDirection(dir:vec3<f32>, probeIndex:i32, width:f32, height:f32, sideLength:f32) -> vec2<f32>
  {
      var uv = getWriteOctUVByID(dir, u32(probeIndex), sideLength) ;
      uv.x = uv.x / irradianceFieldSurface.irradianceTextureWidth;
      uv.y = uv.y / irradianceFieldSurface.irradianceTextureHeight;
      return uv ;
  }

  fn getWriteOctUVByID(dir:vec3<f32> , probeID:u32, size: f32) -> vec2<f32>
  {
      var blockCount = u32(irradianceFieldSurface.probeCounts.x * irradianceFieldSurface.probeCounts.z) ;
      var offsetX = (probeID % blockCount) % u32(irradianceFieldSurface.probeCounts.x) ;
      var offsetY = u32(irradianceFieldSurface.probeCounts.z - 1.0) - (probeID % blockCount) / u32(irradianceFieldSurface.probeCounts.x) ;
      var offsetZ = probeID / blockCount ;

      var pixelCoord = (( octEncode(dir) + 1.0 ) * 0.5) * vec2<f32>(size,size) ;

      var blockOffset = vec2<f32>(0.0);
      blockOffset.x = f32(offsetX) * size;
      blockOffset.y = f32(offsetY) * size + f32(offsetZ) * f32(irradianceFieldSurface.probeCounts.z) * size;

      let mapHeight = u32(irradianceFieldSurface.irradianceTextureHeight);
      var probeCounts:vec3<f32> = vec3<f32>(irradianceFieldSurface.probeCounts.xyz);

      var gridOffsetFrom = vec2<i32>(blockOffset) + 1;
      var gridOffsetTo = offsetByCol(gridOffsetFrom, size, mapHeight, probeCounts);

      pixelCoord = pixelCoord + vec2<f32>(gridOffsetTo - 1) + vec2<f32>(vec2<i32>(vec2<f32>(gridOffsetTo) / size) * 2);

      return pixelCoord + 1.0 ;
  }

  fn offsetByCol(pixelCoord0:vec2<i32>, octSideSize:f32, mapHeight:u32, counts:vec3<f32>) -> vec2<i32>
  {
    var pixelCoord = pixelCoord0;
    let blockSize:vec2<i32> = vec2<i32>(i32(octSideSize * counts.x),  i32(octSideSize * counts.z));
    let blockSizeYBorder:i32 = i32((octSideSize + 2.0) * counts.z);
    let blockMaxRowBorder:i32 = i32(mapHeight) / blockSizeYBorder;
    let pixelCountYMax:i32 = blockMaxRowBorder * i32(octSideSize * counts.z);
    let col:i32 = pixelCoord.y / pixelCountYMax;

    pixelCoord.x = col * i32(octSideSize * counts.x) + pixelCoord.x;
    pixelCoord.y = pixelCoord.y % pixelCountYMax;

    return pixelCoord;
  }
`;class Nh{constructor(e){n(this,"blendTexture"),n(this,"volume"),n(this,"computerShader"),this.volume=e,this.initPipeline()}initPipeline(){let e=_.setting.gi;this.blendTexture=new ne(e.probeSourceTextureSize,e.probeSourceTextureSize,G.rgba16float,!1,GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING),this.computerShader=new be(Oh),this.computerShader.setStorageTexture("outputBuffer",this.blendTexture),this.computerShader.setStorageBuffer("uniformData",this.volume.irradianceVolumeBuffer)}setInputs(e){let t=e[0],r=e[1],a=e[2],s=e[3];this.computerShader.setSamplerTexture("normalMap",t),this.computerShader.setSamplerTexture("colorMap",r),this.computerShader.setSamplerTexture("litMap",a),this.computerShader.setSamplerTexture("irradianceMap",s)}compute(e,t){let r=w.beginCommandEncoder(),a=this.volume.setting,s=a.probeXCount*a.probeYCount*a.probeZCount,o=a.probeSize;this.computerShader.workerSizeX=o*6/8,this.computerShader.workerSizeY=o/8,this.computerShader.workerSizeZ=s,w.computeCommand(r,[this.computerShader])}}let Fh=`

#include "GlobalUniform"
#include "MathShader"
#include "FastMathShader"
#include "ColorUtil"

struct ConstUniform{
   screenWidth:f32,
   screenHeight:f32
}

struct LightData {
     index:f32,
     lightType:i32,
     radius:f32,
     linear:f32,
     
     position:vec3<f32>,
     lightMatrixIndex:f32,

     direction:vec3<f32>,
     quadratic:f32,

     lightColor:vec3<f32>,
     intensity:f32,

     innerCutOff :f32,
     outerCutOff:f32,
     range :f32,
     castShadow:i32,

     lightTangent:vec3<f32>,
     ies:f32,
};

struct Uniforms {
     matrix : array<mat4x4<f32>>
 };

const PointLightType = 1;
const DirectLightType = 2;
const SpotLightType = 3;

@group(0) @binding(1) var outputBuffer : texture_storage_2d<rgba16float, write>;
@group(0) @binding(2) var prefilterMapSampler: sampler;
@group(0) @binding(3) var prefilterMap: texture_cube<f32>;

@group(1) @binding(0) var positionMapSampler : sampler;
@group(1) @binding(1) var positionMap : texture_2d<f32>;

@group(1) @binding(2) var normalMapSampler : sampler;
@group(1) @binding(3) var normalMap : texture_2d<f32>;

@group(1) @binding(4) var colorMapSampler : sampler;
@group(1) @binding(5) var colorMap : texture_2d<f32>;

@group(1) @binding(6) var shadowMapSampler : sampler_comparison;
@group(1) @binding(7) var shadowMap : texture_depth_2d_array;

@group(1) @binding(8) var pointShadowMapSampler: sampler;
@group(1) @binding(9) var pointShadowMap: texture_depth_cube_array ;

@group(2) @binding(0)
var<storage,read> lightBuffer: array<LightData>;

@group(2) @binding(1)
var<storage, read> models : Uniforms;

struct ShadowStruct{
 directShadowVisibility:f32,
 pointShadows:array<f32,8>,
}

var<private> shadowStrut: ShadowStruct ;
var<private> ulitColor:vec3<f32>;
var<private> wPosition:vec3<f32>;
var<private> wNormal:vec3<f32>;

const LUMEN = 10.764;

fn samplePosition(uv:vec2<i32>) -> vec4<f32>
{
   var oc1:vec4<f32> = textureSampleLevel(positionMap, positionMapSampler, vec2<f32>(0.0), 0.0);
   var oc:vec4<f32> = textureLoad(positionMap, uv, 0) ;
   return oc;
}

fn sampleNormal(uv:vec2<i32>) -> vec4<f32>
{
   var oc1:vec4<f32> = textureSampleLevel(normalMap, normalMapSampler, vec2<f32>(0.0), 0.0);
   var oc:vec4<f32> = textureLoad(normalMap, uv, 0);
   return oc;
}

fn sampleColor(uv:vec2<i32>) -> vec4<f32>
{
   var oc1:vec4<f32> = textureSampleLevel(colorMap, colorMapSampler, vec2<f32>(0.0), 0.0);
   var oc:vec4<f32> = textureLoad(colorMap, uv, 0);
   ulitColor = vec3(oc.xyz);
   return oc;
}

const csmCount:i32 = ${nt.Cascades} ;
fn directShadowMaping(P:vec3<f32>, N:vec3<f32>, shadowBias: f32)  {
  let enableCSM:bool = globalUniform.enableCSM > 0.5;
  var light = lightBuffer[0];
  var visibility = 1.0;
  var shadowIndex = i32(light.castShadow);
  if (shadowIndex >= 0 ) {
    var shadowMatrix:mat4x4<f32>;
    if(enableCSM && csmCount > 1){
      for(var csm:i32 = 0; csm < csmCount; csm ++){
        var csmShadowBias = globalUniform.csmShadowBias[csm];
        shadowMatrix = globalUniform.csmMatrix[csm];
        let csmShadowResult = directShadowMapingIndex(light, shadowMatrix, P, N, csm, csmShadowBias);
        if(csmShadowResult.y < 0.5){
          visibility = csmShadowResult.x;
          break;
        }
      }
    }else{
      shadowMatrix = globalUniform.shadowMatrix[shadowIndex];
      visibility = directShadowMapingIndex(light, shadowMatrix, P, N, shadowIndex, shadowBias).x;
    }
  }
  shadowStrut.directShadowVisibility = visibility;
}

fn directShadowMapingIndex(light:LightData, matrix:mat4x4<f32>, P:vec3<f32>, N:vec3<f32>, depthTexIndex:i32, shadowBias:f32) -> vec2<f32>
{
  var visibility = 1.0;
  var isOutSideArea:f32 = 1.0;
  var shadowPosTmp = matrix * vec4<f32>(P.xyz, 1.0);
  var shadowPos = shadowPosTmp.xyz / shadowPosTmp.w;
  var varying_shadowUV = shadowPos.xy * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5, 0.5);
  if (varying_shadowUV.x <= 1.0
    && varying_shadowUV.x >= 0.0
    && varying_shadowUV.y <= 1.0
    && varying_shadowUV.y >= 0.0
    && shadowPosTmp.z <= 1.0
    && shadowPosTmp.z >= 0.0)
  {
    isOutSideArea = 0.0;
    var uvOnePixel = 1.0 / vec2<f32>(globalUniform.shadowMapSize);
    var NoL = abs(dot(N, normalize(light.direction)));
    var bias = shadowBias / max(NoL, 0.000001);
    visibility = textureSampleCompareLevel(shadowMap, shadowMapSampler, varying_shadowUV, depthTexIndex, shadowPos.z - bias);
    visibility += 0.001;
  }
  return vec2<f32>(visibility, isOutSideArea);
}

fn pointShadowMapCompare(shadowBias:f32){
   for(var i:i32 = i32(0) ; i < i32(8); i = i + 1 )
   { 
       var v = 1.0 ;
       let light = lightBuffer[i] ;
       if(light.castShadow < 0 ){
         shadowStrut.pointShadows[i] = v ;
         continue ;
       }

       let frgToLight = wPosition - light.position.xyz;
       var dir:vec3<f32> = normalize(frgToLight)  ;

       var len = length(frgToLight) ;
       var depth = textureSampleLevel(pointShadowMap,pointShadowMapSampler,dir.xyz,i,0); 
       depth *= globalUniform.far ;
       if((len - shadowBias) > depth){
          v = 0.0 ; 
       }
       shadowStrut.pointShadows[i] = v ;
   }
} 

fn directLighting( albedo:vec3<f32> , WP :vec3<f32>, N:vec3<f32> , V:vec3<f32> , light:LightData , shadowBias:f32  ) -> vec3<f32> {
 var L = -normalize(light.direction.xyz) ;
 var NoL = max(dot(N,L),0.0);
 let lightCC = pow( light.lightColor.rgb,vec3<f32>(2.2));
 var lightColor = getHDRColor( lightCC , light.linear ) ;
 var att = light.intensity / LUMEN ;
 if(light.castShadow>=0){
     lightColor *= shadowStrut.directShadowVisibility ;
 }
 let finalLight = (albedo / PI) * lightColor * NoL * att * 2.0 ;
 return finalLight ;
}

fn pointLighting( albedo:vec3<f32>,WP:vec3<f32>, N:vec3<f32>, V:vec3<f32>, light:LightData ) -> vec3<f32> {
 let lightPos = models.matrix[u32(light.lightMatrixIndex)][3].xyz;
 var dir = lightPos.xyz - WP ;
 let dist = length(dir);
 var color = vec3<f32>(0.0) ;

 if(dist != 0.0){
   dir *= 1.0 / dist ;
 }

 if( abs(dist) < light.range ){
     var L = dir ;
     var atten = 1.0 ;
     atten = 1.0 - smoothstep(0.0,light.range,dist) ;
     atten *= 1.0 / max(light.radius,0.0001) ;

     var lightColor = light.lightColor.rgb  ;
     lightColor = getHDRColor(lightColor , light.linear ) * light.intensity / LUMEN * 2.0;
     color = (albedo / PI) * lightColor.rgb * atten ;
 }

 return  color *0.0;
}

fn spotLight( albedo:vec3<f32>,WP:vec3<f32>, N:vec3<f32>, V:vec3<f32>, light:LightData ) -> vec3<f32> {
 let lightPos = models.matrix[u32(light.lightMatrixIndex)][3].xyz;
 var dir = lightPos.xyz - WP ;
 let dist = length(dir) ;

 if(dist != 0.0){
   dir *= 1.0 / dist ;
 }

 var color = vec3<f32>(0.0) ;
 if( abs(dist) < light.range * 2.0 ){
     var L = dir ;
     let theta = dot(-L, normalize(light.direction));
     let angle = acos(theta) ;
     var atten = 1.0 ;
     atten = 1.0 - smoothstep(0.0,light.range,dist) ;
     atten *= 1.0 / max(light.radius,0.1) ;
     if(angle < light.outerCutOff){
       if(angle > light.innerCutOff){
         atten *= 1.0 - smoothstep(light.innerCutOff, light.outerCutOff, angle) ;
       }
     }else{
       atten = 0.0 ;
     }
     var lightColor = light.lightColor.rgb  ;
     lightColor = getHDRColor(lightColor , light.linear ) * light.intensity / LUMEN * 2.0;
     color = (albedo / PI) * lightColor.rgb * atten ;
   }
 return  color ;
}

fn coordFun(fragCoord:vec2<u32>)-> vec4<f32>{
 var uv = vec2<i32>(i32(fragCoord.x), i32(fragCoord.y)) ;
 var pos = samplePosition(uv);

 var normalMap = sampleNormal(uv);
 var normal = normalize( normalMap.xyz * 2.0 - 1.0 );

 var color = sampleColor(uv);
 var emissive = vec4<f32>(pos.a,normalMap.a,color.a,0.0) * 1.0 ;
 if(pos.w + 1.0 > 10000.0){
   return vec4<f32>(color);
 }
 var V = normalize(pos.xyz - globalUniform.cameraWorldMatrix[3].xyz);
 var N = normal.xyz ;

 wPosition = pos.xyz;
 wNormal = N;

 directShadowMaping(wPosition, wNormal, globalUniform.shadowBias);
 pointShadowMapCompare(globalUniform.shadowBias);

 var lighting = vec3<f32>(0.0);
 let lightCount = 32 ;
 for(var i:i32 = 0 ; i < lightCount ; i = i + 1 )
 {
     let light = lightBuffer[i];
     switch (light.lightType) {
         case PointLightType: {
             lighting += pointLighting(color.rgb,pos.xyz,N,V,light);
         }
         case DirectLightType: {
             lighting += directLighting(color.rgb,pos.xyz,N,V,light,globalUniform.shadowBias);
         }
         case SpotLightType: {
             lighting += spotLight(color.rgb,pos.xyz,N,V,light);
         }
         default: {
         }
     }
 }

 // lighting = vec3<f32>(1.0) / (vec3<f32>(1.0) + lighting.rgb) * lighting.rgb;

 var skyLight: vec3<f32> = globalUniform.skyExposure * (textureSampleLevel(prefilterMap, prefilterMapSampler, N.xyz, 8.0 ).rgb);
 // skyLight = LinearToGammaSpace(skyLight);
 // skyLight = (color.rgb / 3.1415926 ) * skyLight;
 // skyLight = vec3<f32>(1.0) / (vec3<f32>(1.0) + skyLight.rgb) * skyLight.rgb;

 lighting = lighting.rgb ;//+ skyLight.rgb ;

 return vec4<f32>(lighting.rgb,color.w)+emissive;
}

// fn vertexToCoord(vertexPosition:vec3<f32>) -> vec4<f32>{
//   var worldPos = vec4<f32>(vertexPosition.xyz, 1.0);
//   var fragPosition = globalUniform.viewMat * worldPos ;
//   // var position = globalUniform.projMat * fragPosition ;
//   return fragPosition;
// }

@compute @workgroup_size( 8 , 8 , 1 )
fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
{
   var fragCoord = vec2<u32>( globalInvocation_id.x, globalInvocation_id.y);
   var color = coordFun(fragCoord);
   
   // color = vec4(pow(color.rgb,vec3<f32>(1.0/2.4)),1.0);
   textureStore(outputBuffer, vec2<i32>(fragCoord),color);
}

`;class kh{constructor(){n(this,"computeShader"),n(this,"worldPosMap"),n(this,"worldNormalMap"),n(this,"colorMap"),n(this,"shadowMap"),n(this,"pointShadowMap"),n(this,"lightingTexture");let e=_.setting.gi;this.lightingTexture=new ne(e.probeSourceTextureSize,e.probeSourceTextureSize,G.rgba16float,!1,GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING)}create(e){let t=de.getLightEntries(e.scene);this.computeShader=new be(Fh);let r=de.getCameraGroup(e.camera);this.computeShader.setUniformBuffer("globalUniform",r.uniformGPUBuffer),this.computeShader.setStorageTexture("outputBuffer",this.lightingTexture),this.computeShader.setStorageBuffer("lightBuffer",t.storageGPUBuffer),this.computeShader.setStorageBuffer("models",de.modelMatrixBindGroup.matrixBufferDst),this.computeShader.setSamplerTexture("positionMap",this.worldPosMap),this.computeShader.setSamplerTexture("normalMap",this.worldNormalMap),this.computeShader.setSamplerTexture("colorMap",this.colorMap),this.computeShader.setSamplerTexture("shadowMap",this.shadowMap),this.computeShader.setSamplerTexture("pointShadowMap",this.pointShadowMap),this.computeShader.setSamplerTexture("prefilterMap",_.res.defaultSky)}setInputs(e){this.worldPosMap=e[0],this.worldNormalMap=e[1],this.colorMap=e[2],this.shadowMap=e[3],this.pointShadowMap=e[4]}compute(e,t){this.computeShader||this.create(e);let r=w.beginCommandEncoder(),a=_.setting.gi;this.computeShader.workerSizeX=a.probeSourceTextureSize/8,this.computeShader.workerSizeY=a.probeSourceTextureSize/8,this.computeShader.workerSizeZ=1,w.computeCommand(r,[this.computeShader])}}let Ha=new je("GIRenderStartEvent"),rn=new je("GIRenderCompleteEvent");class pg{constructor(){n(this,"count"),n(this,"complete")}}class zh extends di{constructor(e){super(),n(this,"cubeCamera"),n(this,"volume"),n(this,"probeCountPerFrame",1),n(this,"nextProbeIndex",-1),n(this,"tempProbeList",[]),n(this,"isRenderCloudGI"),n(this,"probeRenderResult"),n(this,"renderStatus","none"),n(this,"positionMap"),n(this,"normalMap"),n(this,"colorMap"),n(this,"probeNext",128),n(this,"sizeW"),n(this,"sizeH"),n(this,"lightingPass"),n(this,"bouncePass"),n(this,"irradianceComputePass"),n(this,"irradianceDepthMap"),n(this,"irradianceColorMap"),this.passType=re.GI,this.volume=e;let t=e.setting;this.cubeCamera=new Ph(.01,5e3),this.sizeW=t.probeSourceTextureSize,this.sizeH=t.probeSourceTextureSize,this.probeNext=t.probeSourceTextureSize/t.probeSize,this.initIrradianceMap(e),this.probeRenderResult=new pg;let r=new Rh(this.sizeW,this.sizeH);this.positionMap=r.attachments[0],this.normalMap=r.attachments[1],this.colorMap=r.attachments[2],this.setRenderStates(r)}setInputTexture(e){this.lightingPass=new kh,this.bouncePass=new Nh(this.volume),this.irradianceComputePass=new Uh(this.volume),this.lightingPass.setInputs([this.positionMap,this.normalMap,this.colorMap,e[0],e[1]]),this.bouncePass.setInputs([this.normalMap,this.colorMap,this.lightingPass.lightingTexture,this.irradianceColorMap]),this.irradianceComputePass.setTextures([this.positionMap,this.normalMap,this.bouncePass.blendTexture],this.irradianceColorMap,this.irradianceDepthMap)}setIrradianceData(e,t,r,a){if(r!=this.irradianceColorMap.width||a!=this.irradianceColorMap.height){console.error("irradiance image size not match !");return}this.writeToTexture(this.irradianceColorMap,e,r,a),this.writeToTexture(this.irradianceDepthMap,t,r,a)}updateProbe(e,t,r){let a=Q.instance.getLights(e.scene),s=this.volume.setting.probeSize;t.drawCallFrame+=1,this.cubeCamera.x=t.x,this.cubeCamera.y=t.y,this.cubeCamera.z=t.z,this.volume.setting.debugCamera?(this.cubeCamera.x=e.camera.transform.x,this.cubeCamera.y=e.camera.transform.y,this.cubeCamera.z=e.camera.transform.z,this.cubeCamera.rotationX=e.camera.transform.rotationX,this.cubeCamera.rotationY=e.camera.transform.rotationY,this.cubeCamera.rotationZ=e.camera.transform.rotationZ):(this.cubeCamera.rotationX=t.rotationX,this.cubeCamera.rotationY=t.rotationY,this.cubeCamera.rotationZ=t.rotationZ);let o=this.cubeCamera,l=Math.floor(t.index/this.probeNext)*(s*6),h=Math.floor(t.index%this.probeNext)*s;r.setViewport(0+l,h,s,s,0,1),this.renderSceneOnce(e,o.right_camera,r,a),r.setViewport(s+l,h,s,s,0,1),this.renderSceneOnce(e,o.left_camera,r,a),r.setViewport(s*2+l,h,s,s,0,1),this.renderSceneOnce(e,o.up_camera,r,a),r.setViewport(s*3+l,h,s,s,0,1),this.renderSceneOnce(e,o.down_camera,r,a),r.setViewport(s*4+l,h,s,s,0,1),this.renderSceneOnce(e,o.front_camera,r,a),r.setViewport(s*5+l,h,s,s,0,1),this.renderSceneOnce(e,o.back_camera,r,a)}renderSceneOnce(e,t,r,a){this.volume.uploadBuffer();let s=Q.instance.getRenderNodes(e.scene,t);w.bindCamera(r,t);let o=Math.max(0,_.setting.render.drawOpMin),l=Math.min(_.setting.render.drawOpMax,s.opaqueList.length),h=Q.instance.getRenderShaderCollect(e);for(const u of h){let c=u[1];for(const d of c){let g=d[1];if(g.preInit){g.nodeUpdate(e,this.passType,this.rendererPassState,null);break}}}for(let u=o;u<l;++u){let c=s.opaqueList[u];c.enable&&c.transform.enable&&(c.preInit||c.nodeUpdate(e,this.passType,this.rendererPassState,null),c.renderPass2(e,this.passType,this.rendererPassState,null,r))}Q.instance.sky&&(Q.instance.sky.preInit||Q.instance.sky.nodeUpdate(e,this.passType,this.rendererPassState,null),Q.instance.sky.renderPass2(e,this.passType,this.rendererPassState,null,r)),o=Math.max(0,_.setting.render.drawTrMin),l=Math.min(_.setting.render.drawTrMax,s.transparentList.length);for(let u=o;u<l;++u){let c=s.transparentList[u];c.enable&&c.transform.enable&&(c.preInit||c.nodeUpdate(e,this.passType,this.rendererPassState,null),c.renderPass2(e,this.passType,this.rendererPassState,null,r))}}render(e,t){if(!_.setting.gi.enable)return;this.volume.updateOrientation(),this.volume.isVolumeFrameChange=!1,this.volume.uploadBuffer(),this.rendProbe(e);let r=this.probeRenderResult.count>0;(Q.instance.state.giLightingChange||r||_.setting.gi.realTimeGI)&&(Q.instance.state.giLightingChange=!1,this.lightingPass.compute(e,this.rendererPassState),this.bouncePass.compute(e,this.rendererPassState),this.irradianceComputePass.compute(e,this.rendererPassState)),this.probeRenderResult.complete&&this.dispatchEvent(rn)}startRenderGI(e=0){this.nextProbeIndex==-1&&e==0&&this.dispatchEvent(Ha),this.nextProbeIndex=e,this.renderStatus="rendering"}startRenderCloudGI(){this.dispatchEvent(Ha),this.nextProbeIndex=0,this.renderStatus="rendering",this.isRenderCloudGI=!0}rendProbe(e){let t=_.setting.gi.autoRenderProbe,r=!1;if(t?(this.nextProbeIndex==-1&&this.startRenderGI(),r=!0):r=this.renderStatus=="rendering",this.probeRenderResult.count=0,this.probeRenderResult.complete=!1,r){let a=Q.instance.getProbes(e.scene);this.renderContext.clean(),this.renderContext.beginRenderPass(),this.tempProbeList.length=0;let s=Math.min(this.probeCountPerFrame,a.length);for(this.probeRenderResult.count=s;s>0;){const l=a[this.nextProbeIndex];this.updateProbe(e,l,this.renderContext.encoder),s--,this.nextProbeIndex++,l.drawCallFrame<3&&this.tempProbeList.push(l)}this.tempProbeList.length>0&&this.volume.updateProbes(this.tempProbeList);let o=this.nextProbeIndex>=a.length;this.nextProbeIndex>=a.length&&this.isRenderCloudGI&&this.updateProbe(e,a[0],this.renderContext.encoder),this.renderContext.endRenderPass(),o&&(this.nextProbeIndex=-1,this.renderStatus="complete",this.probeRenderResult.complete=!0)}}initIrradianceMap(e){let t=e.setting,r=GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST;this.irradianceDepthMap=new ne(t.octRTMaxSize,t.octRTMaxSize,G.rgba16float,!1,r),this.irradianceDepthMap.name="irradianceDepthMap",this.irradianceColorMap=new ne(t.octRTMaxSize,t.octRTMaxSize,G.rgba16float,!1,r),this.irradianceColorMap.name="irradianceColorMap"}writeToTexture(e,t,r,a){console.log(e.name);const s=I.device.createBuffer({size:t.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC});I.device.queue.writeBuffer(s,0,t);const o=w.beginCommandEncoder();o.copyBufferToTexture({buffer:s,bytesPerRow:r*16},{texture:e.getGPUTexture()},{width:r,height:a,depthOrArrayLayers:1}),w.endCommandEncoder(o)}}class an extends Mh{constructor(e){super(e)}start(){super.start();let e=yt.getGBufferFrame("ColorPassGBuffer");{let t=[],r=new $l;if(_.setting.render.zPrePass&&(e.zPreTexture=this.depthPassRenderer.rendererPassState.depthTexture),r.setRenderStates(e),_.setting.gi.enable){let a=de.getLightEntries(this.view.scene);this.ddgiProbeRenderer=new zh(a.irradianceVolume),this.ddgiProbeRenderer.setInputTexture([this.shadowMapPassRenderer.depth2DArrayTexture,this.pointLightShadowRenderer.cubeArrayTexture]),r.setIrradiance(this.ddgiProbeRenderer.irradianceColorMap,this.ddgiProbeRenderer.irradianceDepthMap),this.rendererMap.addRenderer(this.ddgiProbeRenderer),t.push(this.ddgiProbeRenderer.positionMap,this.ddgiProbeRenderer.normalMap,this.ddgiProbeRenderer.colorMap,this.ddgiProbeRenderer.lightingPass.lightingTexture,this.ddgiProbeRenderer.irradianceColorMap,this.ddgiProbeRenderer.irradianceDepthMap)}this.postRenderer&&this.postRenderer.setDebugTexture(t),this.rendererMap.addRenderer(r)}_.setting.render.debug&&this.debug()}debug(){}}class Gh{constructor(){n(this,"_factor"),n(this,"_doubleFactor"),this._factor=1,this._doubleFactor=2}get accelerateInterpolator(){return this._factor}set accelerateInterpolator(e){this._factor=e,this._doubleFactor=2*this._factor}getInterpolation(e){return this._factor==1?e*e:Math.pow(e,this._doubleFactor)}}class Qh{constructor(){n(this,"_factor",1)}get decelerateInterpolator(){return this._factor}set decelerateInterpolator(e){this._factor=e}getInterpolation(e){let t;return this._factor==1?t=1-(1-e)*(1-e):t=1-Math.pow(1-e,2*this._factor),t}}class Vh{constructor(){n(this,"_factor",1)}getInterpolation(e){return Math.cos((e+1)*Math.PI)/2+.5}}class Hh{getInterpolation(e){return e}}class Yh{getInterpolation(e){return 4.9*e+4.9*e}}class gt{constructor(){}static bounce(e){return e*e*9.8}getInterpolation(e){return e*=1.1226,e<.3535?gt.bounce(e):e<.7408?gt.bounce(e-.54719)+.7:e<.9644?gt.bounce(e-.8526)+.9:gt.bounce(e-1.0435)+.95}getBounceInterpolation(e){return e<.5?gt.bounce(e):gt.bounce(e-1)}geJumpUp(e,t){return t<.5?(t=t/.5,e*t-gt.bounce(t)):t<.8?(t=(t-.5)/(.8-.5),(e*t-gt.bounce(t))*.3):t<1?(t=(t-.8)/(1-.8),(e*t-gt.bounce(t))*.15):e*t-gt.bounce(t)}}class Xh{constructor(){n(this,"_tension"),this._tension=2}get anticipateInterpolator(){return this._tension}set anticipateInterpolator(e){this._tension=e}getInterpolation(e){return e*e*((this._tension+1)*e-this._tension)}}class qr{constructor(){n(this,"_tension"),this._tension=1*1.5}anticipateOvershootInterpolator(e){this._tension=e*1.5}anticipateOvershootInterpolator2(e,t){this._tension=e*t}getInterpolation(e){return e<.5?.5*qr.a(e*2,this._tension):.5*(qr.o(e*2-2,this._tension)+2)}static a(e,t){return e*e*((t+1)*e-t)}static o(e,t){return e*e*((t+1)*e+t)}}class Wh{constructor(e){n(this,"_cycles"),this._cycles=e}getInterpolation(e){return Math.sin(2*this._cycles*Math.PI*e)}}class jh{constructor(){n(this,"_tension"),this._tension=2}getInterpolation(e){return e-=1,e*e*((this._tension+1)*e+this._tension)+1}}var sn=(i=>(i[i.AccelerateInterpolator=0]="AccelerateInterpolator",i[i.DecelerateInterpolator=1]="DecelerateInterpolator",i[i.AccelerateDecelerateInterpolator=2]="AccelerateDecelerateInterpolator",i[i.LinearInterpolator=3]="LinearInterpolator",i[i.BounceInterpolator=4]="BounceInterpolator",i[i.AnticipateInterpolator=5]="AnticipateInterpolator",i[i.AnticipateOvershootInterpolator=6]="AnticipateOvershootInterpolator",i[i.CycleInterpolator=7]="CycleInterpolator",i[i.OvershootInterpolator=8]="OvershootInterpolator",i[i.JumperInterpolator=9]="JumperInterpolator",i))(sn||{});const nr=class{constructor(){n(this,"complete",!1),n(this,"onComplete"),n(this,"onProgress"),n(this,"target"),n(this,"property"),n(this,"targetProperty"),n(this,"durtion"),n(this,"interpolatorEnum"),n(this,"delayTime",0),n(this,"_interpolator"),n(this,"_ct",0),n(this,"_p",0)}static to(i,e,t,r=0){var a=new nr;return a.target=i,a.property=e,a.durtion=t,a.interpolatorEnum=r,a.start(),a.delayTime=e.delayTime?e.delayTime:0,e.onComplete&&(a.onComplete=e.onComplete),e.onProgress&&(a.onProgress=e.onProgress),this.interpolators.push(a),a}static tick(i){let e=nr.interpolators;for(let t of e)t.complete?nr.remove(t,!0):t.tick(i)}static remove(i,e){let t=nr.interpolators,r=t.indexOf(i);r!=-1&&t.splice(r,1),e&&i.dispose()}static removeList(i,e){i.forEach(t=>{this.remove(t,e)})}start(){window.AccelerateInterpolator=Gh,window.DecelerateInterpolator=Qh,window.AccelerateDecelerateInterpolator=Vh,window.LinearInterpolator=Hh,window.BounceInterpolator=gt,window.AnticipateInterpolator=Xh,window.AnticipateOvershootInterpolator=qr,window.CycleInterpolator=Wh,window.OvershootInterpolator=jh,window.JumperInterpolator=Yh,this._interpolator=new window[sn[this.interpolatorEnum]],this.targetProperty={};for(let i in this.property)this.targetProperty[i]=this.target[i]}tick(i){if(this.delayTime<=0){this._p=Math.min(this._ct/this.durtion,1);let e=this._interpolator.getInterpolation(this._p),t=this.property,r=this.target,a=this.targetProperty,s,o;for(let l in t)o=t[l],s=a[l],r[l]=s+(o-s)*e;this.onProgress!=null&&this.onProgress(this._p),this._ct>=this.durtion&&(this.complete=!0,this.onComplete!=null&&this.onComplete(this.target)),this._ct+=i}else this.delayTime-=i}dispose(){this.onComplete=null,this.onProgress=null,this.target=null,this.property=null,this.targetProperty=null,this.interpolatorEnum=null,this._interpolator=null,nr.remove(this)}};let nn=nr;n(nn,"interpolators",[]);class rt{static hasString(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}static getEllipsis(e,t=4){let r=e;return r.length>t&&(r=r.slice(0,t)+"..."),r}static getURLName(e){var t;t=e.split("/");let r=t[t.length-1];return r=r.split(".")[0],r}static getFileFormat(e){var t=e.lastIndexOf(".");t++;var r=e.length;e.indexOf("?",t)!==-1&&(r=e.indexOf("?",t));var a=e.substr(t,r-t);return a=a.toLowerCase(),a}static readLineProperty(e,t){e.trim().split(" ").forEach((r,a)=>{let s=r.split("=");if(s.length>1){let o=s[0],l=s[1];Object.prototype.hasOwnProperty.call(t,o)&&(l.indexOf('"')==-1?t[o]=parseFloat(s[1]):t[o]=l.replace('"',"").replace('"',""))}})}static getPath(e){var t=e.lastIndexOf("/");return t++,e.substring(0,t)}static normalizePath(e){var t=e.replaceAll("//","/");return t=t.replaceAll("\\","/"),t}static getStringList(e,t=";"){return e.split(t)}static formatTime(e){let r=e/1e3/60,a=Math.floor(r),s=Math.floor(r-a);return[a.toString(),s.toString()]}static trim(e){return e.replace(/^\s+/g,"").replace(/\s+$/g,"")}static isEmpty(e){return!e||typeof e>"u"||e==null||typeof e=="string"&&this.trim(e)===""||e==="null"}static strCut(e,t){if(e.length*2<=t)return e;for(var r=0,a="",s=0;s<e.length;s++)if(a=a+e.charAt(s),e.charCodeAt(s)>128){if(r=r+2,r>=t)return a.substring(0,a.length-1)+"..."}else if(r=r+1,r>=t)return a.substring(0,a.length-2)+"...";return a}static toQueryPair(e,t,r=!1){return e+"="+(r?encodeURIComponent(t):t)}static stringFormat(e,...t){if(arguments.length===0)throw new Error("please give arg at least one !");if(arguments.length===2&&typeof arguments[1]=="object")for(let r in arguments[1]){let a=new RegExp("({"+r+"})","g");e=e.replace(a,arguments[1][r])}else for(let r=0;r<t.length;r++){if(t[r]==null)return e;{let a=new RegExp("({["+r+"]})","g");e=e.replace(a,t[r])}}return e}static parseJson2String(e,t){let r=null,a="",s=0,o="    ";return t=t||{},t.newlineAfterColonIfBeforeBraceOrBracket=t.newlineAfterColonIfBeforeBraceOrBracket===!0,t.spaceAfterColon=t.spaceAfterColon!==!1,typeof e!="string"||(e=JSON.parse(e)),e=JSON.stringify(e),r=/([\{\}])/g,e=e.replace(r,`\r
$1\r
`),r=/([\[\]])/g,e=e.replace(r,`\r
$1\r
`),r=/(\,)/g,e=e.replace(r,`$1\r
`),r=/(\r\n\r\n)/g,e=e.replace(r,`\r
`),r=/\r\n\,/g,e=e.replace(r,","),t.newlineAfterColonIfBeforeBraceOrBracket||(r=/\:\r\n\{/g,e=e.replace(r,":{"),r=/\:\r\n\[/g,e=e.replace(r,":[")),t.spaceAfterColon&&(r=/\:/g,e=e.replace(r,":")),e.split(`\r
`).forEach(function(l,h){let u=0,c=0,d="";for(l.match(/\{$/)||l.match(/\[$/)?c=1:l.match(/\}/)||l.match(/\]/)?s!==0&&(s-=1):c=0,u=0;u<s;u++)d+=o;a+=d+l+`\r
`,s+=c}),a}static compareVersion(e,t){e=e.split("."),t=t.split(".");let r=Math.max(e.length,t.length);for(;e.length<r;)e.push("0");for(;t.length<r;)t.push("0");for(let a=0;a<r;a++){let s=parseInt(e[a]),o=parseInt(t[a]);if(s>o)return 1;if(s<o)return-1}return 0}static buildRandomCode(){let e="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789",t=e.length,r="";for(let s=0;s<26;s++){let o=Math.floor(Math.random()*t);r+=e.charAt(o)}return`${new Date().getTime()}-${r}`}static UUID(){return"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,function(e){var t=Math.random()*16|0,r=e=="x"?t:t&3|8;return r.toString(16)})}static stringToHash(e){let t=0;if(e.length==0)return t;for(let r=0;r<e.length;r++){const a=e.charCodeAt(r);t=(t<<5)-t+a,t=t&t}return t}static parseUrl(e,t){return t.match(/^(blob|http|https):/)?t:e+t}}n(rt,"_filterChar",[" ","  ",";",`
`,"\r","	",`
`,"\r","	"]);class ei extends st{constructor(e=!0){super(),n(this,"_source"),n(this,"imageData"),this.useMipmap=e}get source(){return this._source}set source(e){this._source=e,this._source instanceof HTMLImageElement?this._source.decode().then(async()=>{if(this._source instanceof HTMLImageElement){const t=await createImageBitmap(this._source,{imageOrientation:this.flipY?"flipY":"from-image"});this.generate(t)}}):(this._source instanceof HTMLCanvasElement||this._source instanceof ImageBitmap)&&this.generate(this._source)}async load(e,t){if(e.indexOf(";base64")!=-1){const r=document.createElement("img");let a=e.indexOf("data:image"),s=e.substring(a,e.length);r.src=s,await r.decode(),r.width=Math.max(r.width,32),r.height=Math.max(r.height,32);const o=await createImageBitmap(r,{resizeWidth:r.width,resizeHeight:r.height,imageOrientation:this.flipY?"flipY":"from-image"});this.format=G.rgba8unorm,this.generate(o)}else{const r=await fetch(e,{headers:Object.assign({Accept:"image/avif,image/webp,*/*"},t?.headers)});let a=await Mi.read(e,r,t),s=new Blob([a],{type:"image/jpeg"});a=null,await this.loadFromBlob(s)}return this.name=rt.getURLName(e),!0}async loadFromBlob(e){this.imageData=e;let t=await createImageBitmap(e,{imageOrientation:this.flipY?"flipY":"from-image"});if(t.width<32||t.height<32){let r=Math.max(t.width,32),a=Math.max(t.height,32);t=await createImageBitmap(t,{resizeWidth:r,resizeHeight:a,imageOrientation:this.flipY?"flipY":"from-image"})}return this.format=G.rgba8unorm,this.generate(t),!0}}class Mi{constructor(){n(this,"baseUrl",""),n(this,"initUrl"),n(this,"_progress",0)}async loadBinData(e,t){return this.baseUrl=rt.getPath(e),this.initUrl=e,new Promise(async(r,a)=>{fetch(e,{headers:t?.headers}).then(async s=>{if(s.ok){let o=await Mi.read(e,s,t),l=o.buffer;o=null,r(l)}else throw Error("request rejected with status "+s.status)}).catch(s=>{t.onError&&t.onError(s),a(s)})})}async loadAsyncBitmapTexture(e,t){this.baseUrl=rt.getPath(e),this.initUrl=e;let r=new ei;return r.url=e,r.name=rt.getURLName(e),await r.load(e,t),_.res.addTexture(e,r),r}async loadJson(e,t){return this.baseUrl=rt.getPath(e),this.initUrl=e,new Promise(async(r,a)=>{fetch(e,{headers:t?.headers}).then(async s=>{if(s.ok){let o=await Mi.read(e,s,t);const h=new TextDecoder("utf-8").decode(o);o=null,r(JSON.parse(h))}else throw Error("request rejected with status"+s.status)}).catch(s=>{t.onError&&t.onError(s),a(s)})})}async loadTxt(e,t){return this.baseUrl=rt.getPath(e),new Promise(async(r,a)=>{fetch(e).then(async s=>{if(s.ok){let o=await Mi.read(e,s,t);const h=new TextDecoder("utf-8").decode(o);o=null,r({data:h})}else throw Error("request rejected with status"+s.status)}).catch(s=>{t.onError&&t.onError(s),a(s)})})}static async read(e,t,r){const a=t.body.getReader(),s=+t.headers.get("Content-Length");let o=0,l=[],h=[];for(;;){const{done:d,value:g}=await a.read();if(d){s>0&&r&&r.onComplete&&r.onComplete.call(this,e);break}l.push(g),o+=g.length,s>0?r&&r.onProgress&&r.onProgress.call(this,o,s,e):h.push(g.length)}if(h.length>0)for(let d=0;d<l.length;d++)console.log(h[d]),r&&r.onProgress&&r.onProgress.call(this,h[d],o,e),h[d]==o&&r&&r.onComplete&&r.onComplete.call(this,e);let u=new Uint8Array(o),c=0;for(let d of l)u.set(d,c),c+=d.length;return u}}class ot extends Mi{async load(e,t,r,a){switch(t.format){case"bin":return new Promise(async(s,o)=>{this.loadBinData(e,r).then(async l=>{let h=new t;if(h.userData=a,h.baseUrl=this.baseUrl,h.initUrl=e,await h.parseBuffer(l),h.verification())s(h);else throw new Error("parser error")}).catch(l=>{o(l)})});case"json":return new Promise((s,o)=>{this.loadJson(e,r).then(async l=>{let h=new t;h.userData=a,h.baseUrl=this.baseUrl,h.initUrl=e,h.loaderFunctions=r,await h.parseJson(l),s(h)}).catch(l=>{o(l)})});case"text":return new Promise((s,o)=>{this.loadTxt(e,r).then(async l=>{let h=new t;h.userData=a,h.baseUrl=this.baseUrl,h.initUrl=e,h.loaderFunctions=r,l.data?(await h.parseString(l.data),s(h)):o("text load is empty!")}).catch(l=>{o(l)})})}}}class Xt{constructor(){n(this,"baseUrl"),n(this,"initUrl"),n(this,"loaderFunctions"),n(this,"userData"),n(this,"data")}parseString(e){}parseJson(e){}parseBuffer(e){}parseTexture(e){throw this.parserError("Method not implemented.",-1)}parse(e){}verification(e){throw this.parserError("Method not implemented.",-1)}parserError(e,t){console.error(`error id:${t} ${e}`)}}n(Xt,"format","bin");class Ya{constructor(){n(this,"asset"),n(this,"accessors"),n(this,"buffers"),n(this,"bufferViews"),n(this,"materials"),n(this,"meshes"),n(this,"nodes"),n(this,"scene",0),n(this,"scenes"),n(this,"textures"),n(this,"cameras"),n(this,"skins"),n(this,"resources"),n(this,"images"),n(this,"samplers"),n(this,"animations"),n(this,"extensions")}}class mg{constructor(){n(this,"nodes")}}class Ag{constructor(){n(this,"name"),n(this,"type"),n(this,"color"),n(this,"intensity"),n(this,"range"),n(this,"spot"),n(this,"isParsed")}}class _g{constructor(){n(this,"name"),n(this,"rotation"),n(this,"scale"),n(this,"translation"),n(this,"children"),n(this,"matrix"),n(this,"mesh",-1),n(this,"isParsed"),n(this,"dnode"),n(this,"camera"),n(this,"skin"),n(this,"nodeId"),n(this,"primitives"),n(this,"extensions"),n(this,"light")}}class vg{constructor(){n(this,"attributes"),n(this,"indices"),n(this,"material"),n(this,"mode"),n(this,"name"),n(this,"targets"),n(this,"extensions"),n(this,"morphTargetsRelative")}}class xg{constructor(){n(this,"name"),n(this,"primitives"),n(this,"isParsed"),n(this,"dprimitives"),n(this,"weights"),n(this,"extras")}}class yg{constructor(){n(this,"bufferView"),n(this,"componentType"),n(this,"count"),n(this,"type"),n(this,"max"),n(this,"min"),n(this,"isParsed"),n(this,"daccessor"),n(this,"normalized"),n(this,"sparse"),n(this,"byteOffset"),n(this,"computeResult")}}const Cg=window.SharedArrayBuffer?function(e){return e&&e.buffer&&(e.buffer instanceof ArrayBuffer||e.buffer instanceof window.SharedArrayBuffer)}:function(e){return e&&e.buffer&&e.buffer instanceof ArrayBuffer},on=5120,Kr=5121,ln=5122,hn=5123,un=5124,cn=5125,fn=5126,bg=32819,wg=32820,Sg=33635,Ig=5131,Eg=33640,Bg=35899,Tg=35902,Dg=36269,Mg=34042,qh={};{const i=qh;i[on]=Int8Array,i[Kr]=Uint8Array,i[ln]=Int16Array,i[hn]=Uint16Array,i[un]=Int32Array,i[cn]=Uint32Array,i[fn]=Float32Array,i[bg]=Uint16Array,i[wg]=Uint16Array,i[Sg]=Uint16Array,i[Ig]=Uint16Array,i[Eg]=Uint32Array,i[Bg]=Uint32Array,i[Tg]=Uint32Array,i[Dg]=Uint32Array,i[Mg]=Uint32Array}function Pg(i){switch(i){case Int8Array:return on;case Uint8Array:return Kr;case Uint8ClampedArray:return Kr;case Int16Array:return ln;case Uint16Array:return hn;case Int32Array:return un;case Uint32Array:return cn;case Float32Array:return fn;default:throw new Error("unsupported typed array type")}}function Rg(i){if(i instanceof Int8Array)return on;if(i instanceof Uint8Array||i instanceof Uint8ClampedArray)return Kr;if(i instanceof Int16Array)return ln;if(i instanceof Uint16Array)return hn;if(i instanceof Int32Array)return un;if(i instanceof Uint32Array)return cn;if(i instanceof Float32Array)return fn;throw new Error("unsupported typed array type")}function dn(i){const e=qh[i];if(!e)throw new Error("unkonw gl type");return e}function Lg(i,e=Float32Array){return Cg(i)?i:new e(i)}class Jr{static async apply(e,t){if(!t.extensions)return;const r=t.extensions.KHR_draco_mesh_compression;if(!r)return;let a=this._workers.get(e.gltf);a||(a=new Worker(await this.initDecoder()),this._workers.set(e.gltf,a)),a.postMessage({type:"init",decoderConfig:{}});let s=e.parseBufferView(r.bufferView);if(!s.result){let o=await new Promise((l,h)=>{a.onmessage=u=>{const c=u.data;c.type=="decode"?l(c.result):c.type=="error"&&h(c.error)},a.postMessage({type:"decoder",buffer:s,attributes:r.attributes},[s])});s.result=o}return s.result}static unload(e){let t=this._workers.get(e);t&&(t.terminate(),this._workers.delete(e))}static async initDecoder(){if(!this._workerCode){let e=await new ot().loadTxt("https://cdn.orillusion.com/draco_decoder_gltf.js");const t=new Blob([e.data,"",`(${Ug})()`],{type:"application/javascript"});this._workerCode=URL.createObjectURL(t)}return this._workerCode}}n(Jr,"_workerCode"),n(Jr,"_workers",new Map);function Ug(){let i,e;onmessage=t=>{const r=t.data;switch(r.type){case"init":i=r.decoderConfig,e=new Promise((o,l)=>{i.onModuleLoaded=h=>{o({draco:h})},DracoDecoderModule(i)});break;case"decoder":const a=r.buffer,s=r.attributes;e.then(o=>{const l=o.draco;let h=new l.Decoder,u=new l.DecoderBuffer;u.Init(new Int8Array(a),a.byteLength);let c,d;try{const g=h.GetEncodedGeometryType(u);g==l.TRIANGULAR_MESH?(d=new l.Mesh,c=h.DecodeBufferToMesh(u,d)):self.postMessage(new Error("INVALID_GEOMETRY_TYPE:"+g)),c.ok()||self.postMessage(new Error("DracoDecode:"+c.error_msg()));let m={};for(const A in s){let v=h.GetAttributeByUniqueId(d,s[A]);const y=v.num_components(),S=d.num_points()*y,T=S*Float32Array.BYTES_PER_ELEMENT,D=l.DT_FLOAT32,M=l._malloc(T);h.GetAttributeDataArrayForAllPoints(d,v,D,T,M);const P=new Float32Array(l.HEAPF32.buffer,M,S).slice();l._free(M),m[A]={data:P,numComponents:y,normalize:!1}}{const v=d.num_faces()*3,y=v*4,C=l._malloc(y);h.GetTrianglesUInt32Array(d,y,C);const S=new Uint32Array(l.HEAPF32.buffer,C,v).slice();l._free(C),m.indices={data:S,numComponents:1,normalize:!1}}self.postMessage({type:"decode",result:m})}catch(g){self.postMessage({type:"error",error:g.message})}finally{l.destroy(d),l.destroy(h),l.destroy(u)}});break}}}class Kh{constructor(e){n(this,"gltf"),this.gltf=e}parse(e){const t=this.gltf.cameras[e];if(!t)return this.errorMiss("camera",e);if(t.isParsed)return t.dcamera;t.isParsed=!0,t.dcamera=!1;const{name:r,type:a,perspective:s,orthographic:o}=t;if(a==="perspective"&&s){const{aspectRatio:l,yfov:h,zfar:u,znear:c}=s;t.dcamera=Object.assign({},{name:r,type:a,yfov:h,znear:c,aspectRatio:l,zfar:u})}else if(a==="orthographic"&&o){const{xmag:l,ymag:h,zfar:u,znear:c}=o;t.dcamera=Object.assign({},{name:r,type:a,xmag:l,ymag:h,zfar:u,znear:c})}return t.dcamera}errorMiss(e,t){throw new Error(e+t)}}const Jh=class extends Xt{constructor(){super(...arguments),n(this,"_gltf")}async parseJson(i){this._gltf=new Ya,this._gltf={...this._gltf,...i},this._gltf.resources={},await Promise.all([this.load_gltf_bin(),this.load_gltf_textures()]);let e=new Ka,t=await e.parse(this.initUrl,this._gltf,this._gltf.scene);return e.destory(),e=null,t?(this.data=t.rootNode,t.rootNode):(this._gltf=null,null)}verification(){if(this.data)return!0;throw new Error("Method not implemented.")}static getMeshNameCounter(){return function(){return`GLTF_NO_NAME_PRIMITIVE_${Jh._counter++}`}}static getModelNameCounter(){let i=0;return function(){return`GLTF_NO_NAME_MESH_${i++}`}}static getTexCoordDefine(i){return`UV_NUM ${i}`}static getVertexColorDefine(i){return`HAS_VERTEXCOLOR ${i}`}static getBaseColorTextureDefine(){return"HAS_BASECOLORMAP"}static getMetalRoughnessDefine(){return"HAS_METALROUGHNESSMAP"}static getNormalMapDefine(){return"HAS_NORMALMAP"}static getEmissiveMapDefine(){return"HAS_EMISSIVEMAP"}static getOcclusionMapDefine(){return"HAS_OCCLUSIONMAP"}static getMorphTargetsDefine(i){return`MORPH_TARGET_NUM ${i}`}static getMorphtargetPositionDefine(){return"HAS_MORPH_POSITION"}static getMorphtargetNormalDefine(){return"HAS_MORPH_NORMAL"}static getMorphtargetTangentDefine(){return"HAS_MORPH_TANGENT"}static getJointsNumDefine(i){return`JOINTS_NUM ${i}`}static getJointVec8Define(){return"JOINT_VEC8"}static getHasNormalDefine(){return"HAS_NORMAL"}static getHasTangentDefine(){return"HAS_TANGENT"}static getHasNormalMapDefine(){return"HAS_NORMAL_MAP"}static getAlphaMaskDefine(){return"ALPHA_MASK"}static getAlphaBlendDefine(){return"ALPHA_BLEND"}async load_gltf_bin(){var i;if(this._gltf.buffers&&this._gltf.buffers.length>0){let e=[];for(let t=0;t<this._gltf.buffers.length;t++){const r=this._gltf.buffers[t];if(r.uri.substring(0,5)!=="data:"){let a=rt.parseUrl(this.baseUrl,r.uri);(i=this.loaderFunctions)!=null&&i.onUrl&&(a=await this.loaderFunctions.onUrl(a));let s=new ot().loadBinData(a,this.loaderFunctions).then(o=>{this._gltf.resources[r.uri]=o});e.push(s)}}await Promise.all(e)}}async load_gltf_textures(){var i;if(this._gltf,this._gltf.images){let e=[];for(let t=0;t<this._gltf.images.length;t++){const r=this._gltf.images[t];if(r.uri){let a=rt.parseUrl(this.baseUrl,r.uri);(i=this.loaderFunctions)!=null&&i.onUrl&&(a=await this.loaderFunctions.onUrl(a));let s=new ot().loadAsyncBitmapTexture(a,this.loaderFunctions).then(o=>{o.name=rt.getURLName(r.uri),this._gltf.resources[o.name]=o});e.push(s)}}await Promise.all(e)}}};let Je=Jh;n(Je,"format","json"),n(Je,"_counter",0),n(Je,"defaultMaterial",{name:"GLTF_DEFAULT_MATERIAL",alphaCutoff:.33,alphaMode:"MASK",pbrMetallicRoughness:{name:"GLTF_DEFAULT_MATERIAL",defines:[],doubleSided:!1,baseColorFactor:[1,1,1,1],metallicFactor:1,roughnessFactor:1,emissiveFactor:[0,0,0]}});class Zh{constructor(e){n(this,"gltf"),n(this,"subParser"),this.gltf=e.gltf,this.subParser=e}async parse(e){const t=this.gltf.meshes[e];if(!t)return this.errorMiss("mesh",e);if(t.isParsed)return t.dprimitives;const r=t.primitives,a=t.extras,s=[];for(let o=0;o<r.length;o++){const l=r[o],{attributes:h,indices:u,material:c,mode:d,name:g,targets:m,morphTargetsRelative:A,extensions:v}=l;let y=t.name;for(let R in h)y+=R;y+=`indices:${u}`,y+=`material:${c}`;const C={attribArrays:{indices:[]},weights:[],defines:[],material:null,drawMode:null,meshName:null,modelName:null,morphTargetsRelative:!1,targetNames:a?a.targetNames:null};let S=!1,T=0,D=!1,M;v&&v.KHR_draco_mesh_compression&&(M=await Jr.apply(this.subParser,l));for(const R in h){const U=M?M[R]:this.parseAccessor(h[R]);if(U){let E;switch(R){case"POSITION":E=X.position;break;case"NORMAL":E=X.normal,S=!0;break;case"TEXCOORD_0":E=X.uv,T++;break;case"JOINTS_0":E=X.joints0;break;case"JOINTS_1":E=X.joints1,D=!0;break;case"WEIGHTS_0":E=X.weights0;break;case"WEIGHTS_1":E=X.weights1;break;default:E=R}C.attribArrays[E]=U}}if(S&&C.defines.push(Je.getHasNormalDefine()),T&&C.defines.push(Je.getTexCoordDefine(T)),D&&C.defines.push(Je.getJointVec8Define()),u!==void 0){const R=M?M.indices:this.parseAccessor(u);R&&(C.attribArrays.indices=R)}const P=await this.parseMaterial(c);if(P&&(C.material=P,C.defines=C.defines.concat(P.defines)),C.drawMode=d===void 0?4:d,C.meshName=()=>y,C.modelName=t.name||Je.getModelNameCounter(),m){C.defines.push(Je.getMorphTargetsDefine(m.length)),C.morphTargetsRelative=!0;let R=!1,U=!1,E=!1;for(let F=0;F<m.length;F++){const V=m[F];Object.keys(V).forEach(Y=>{const j=this.parseAccessor(V[Y]);if(j){let oe;switch(Y){case"POSITION":oe=le.MORPH_POSITION_PREFIX+F,R=!0;break;case"NORMAL":oe=le.MORPH_NORMAL_PREFIX+F,U=!0;break;case"TANGENT":oe=le.MORPH_TANGENT_PREFIX+F,E=!0;break;default:oe=!1}oe?C.attribArrays[oe]=j:console.error(`glTF has unsupported morph target attribute ${Y}`)}})}R&&C.defines.push(Je.getMorphtargetPositionDefine()),U&&C.defines.push(Je.getMorphtargetNormalDefine()),E&&C.defines.push(Je.getMorphtargetTangentDefine()),C.weights=t.weights||new Array(m.length).fill(0)}s.push(C)}return t.dprimitives=s,t.isParsed=!0,t.dprimitives}parseAccessor(e){return this.subParser.parseAccessor(e)}parseMaterial(e){return this.subParser.parseMaterial(e)}errorMiss(e,t){throw new Error(e+t)}}class $h{constructor(e){n(this,"gltf"),n(this,"subParser"),this.gltf=e.gltf,this.subParser=e}async parse(e){let t;if(e==null?t=Je.defaultMaterial:t=this.gltf.materials[e],!t)return this.errorMiss("material",e);if(t.isParsed)return t.dmaterial;let{name:r,pbrMetallicRoughness:a,normalTexture:s,occlusionTexture:o,emissiveTexture:l,emissiveFactor:h,alphaMode:u,alphaCutoff:c,doubleSided:d,extensions:g}=t;const m={name:r,defines:[],doubleSided:!!d,baseColorFactor:[1,1,1,1],emissiveFactor:null,alphaCutoff:0,enableBlend:!1,baseColorTexture:null,metallicRoughnessTexture:null,normalTexture:null,occlusionTexture:null,emissiveTexture:null,transformUV1:null,transformUV2:null,extensions:null};if(a){const{baseColorFactor:A,metallicFactor:v,roughnessFactor:y,baseColorTexture:C,metallicRoughnessTexture:S}=a;if(Object.assign(m,{baseColorFactor:A||[1,1,1,1],metallicFactor:v===void 0?1:v,roughnessFactor:y===void 0?.5:y}),C){let T=C.extensions;if(T){let M=T.KHR_texture_transform;M&&(m.transformUV1=new q(M.offset?M.offset[0]:0,M.offset?M.offset[1]:0,M.scale?M.scale[0]:1,M.scale?M.scale[1]:1))}const D=await this.parseTexture(C.index);D?m.baseColorTexture=D:m.baseColorTexture=_.res.redTexture}if(S){const T=await this.parseTexture(S.index);T?m.metallicRoughnessTexture=T:m.metallicRoughnessTexture=_.res.blackTexture}}else Object.assign(m,{baseColorFactor:[1,1,1,1],metallicFactor:0,roughnessFactor:.5});if(m.baseColorFactor&&m.baseColorFactor[3]<1&&(u=u==="MASK"?"MASK":"BLEND"),u&&u!=="OPAQUE"&&(u==="MASK"&&(m.defines.push(Je.getAlphaMaskDefine()),m.alphaCutoff=c===void 0?.5:c),u==="BLEND"&&(m.defines.push(Je.getAlphaBlendDefine()),m.enableBlend=!0)),s){const A=await this.parseTexture(s.index);A?m.normalTexture=A:m.normalTexture=_.res.normalTexture}if(o){const A=await this.parseTexture(o.index);A&&(m.occlusionTexture=A)}if(h&&(m.emissiveFactor=h),l){const A=await this.parseTexture(l.index);A?m.emissiveTexture=A:m.emissiveTexture=_.res.blackTexture}return g&&(m.extensions=g),t.isParsed=!0,t.dmaterial=m,m}async parseTexture(e){return this.subParser.parseTexture(e)}errorMiss(e,t){throw new Error(e+t)}}class eu{constructor(e){n(this,"gltf"),n(this,"subParser"),this.gltf=e.gltf,this.subParser=e}parse(e){const t=this.gltf.skins[e];if(!t)return this.errorMiss("skin",e);if(t.isParsed)return t.dskin;const{name:r,joints:a,inverseBindMatrices:s,skeleton:o}=t;if(!a)return this.errorMiss("skin.joints",e);t.isParsed=!0,t.dskin=!1;let l={name:r,skeleton:null,inverseBindMatrices:null,joints:a,defines:[Je.getJointsNumDefine(a.length)]};if(o)l.skeleton=o;else{var h=-1;for(let u=0;u<this.gltf.nodes.length;u++)if(this.gltf.nodes[u].name=="root"){h=u;break}if(h==-1){let u=this.gltf.scenes[this.gltf.scene];h=u.nodes[u.nodes.length-1]}l.skeleton=h}if(l.inverseBindMatrices=le.IDENTITY_INVERSE_BIND_MATRICES,s!==void 0){const u=this.parseAccessor(s);if(u){const c=u.data,d=[];for(let g=0;g<c.length;g+=16)d.push(c.slice(g,g+16));l.inverseBindMatrices=d}else l=null}return t.dskin=l,t.dskin}parseAccessor(e){return this.subParser.parseAccessor(e)}errorMiss(e,t){throw new Error(e+t)}}class tu{constructor(e=""){n(this,"name",""),n(this,"index",0),n(this,"parent",null),n(this,"children",[]),n(this,"scale",new p),n(this,"rotation",new K),n(this,"translation",new p),this.name=e}}class iu{constructor(e=[]){n(this,"joints"),this.joints=e}get numJoint(){return this.joints.length}addJoint(e){e.index=this.joints.push(e)-1}getJointName(e){return this.joints[e].name}getJointParentIndex(e){let t=this.joints[e];return t.parent?t.parent.index:-1}getJointByName(e){for(let t of this.joints)if(t.name==e)return t;return null}}class gn{constructor(e,t=!1){n(this,"index"),n(this,"worldMatrix"),this.index=e,this.worldMatrix=new H(!t)}}class Zr{constructor(e,t=!1){n(this,"time"),n(this,"_skeleton"),n(this,"_jointsPose"),n(this,"mJointMatrixIndexTable"),this._skeleton=e,this._jointsPose=new Array(e.numJoint),this.mJointMatrixIndexTable=new Array(e.numJoint);for(let r=0;r<e.numJoint;r++){let a=new gn(r,t);this._jointsPose[r]=a,this.mJointMatrixIndexTable[r]=a.worldMatrix.index}}buildSkeletonPose(e){let t=new p,r=new K,a=new p,s=new Array(this._skeleton.numJoint);this.time=e[11]>0?e[11]:e[24];for(let o=0;o<this._skeleton.numJoint;o++){let l=12*o*4,h=new Float32Array(e.buffer,e.byteOffset+l,12),u=new H;t.set(h[0],h[1],h[2]),r.set(h[4],h[5],h[6],h[7]),a.set(h[8],h[9],h[10]),Ra(r.getEulerAngles(),a,t,u),s[o]=u;let c=new gn(o);const d=this._skeleton.getJointParentIndex(o);if(d<0)c.worldMatrix.copyFrom(u);else{let g=this._jointsPose[d];Al(g.worldMatrix,u,c.worldMatrix)}this._jointsPose[o]=c}}get numJoint(){return this._skeleton.numJoint}get joints(){return this._jointsPose}get jointMatrixIndexTable(){return this.mJointMatrixIndexTable}lerp(e,t,r){for(let a=0;a<this._jointsPose.length;a++){let s=e._jointsPose[a],o=t._jointsPose[a];this._jointsPose[a].worldMatrix.lerp(s.worldMatrix,o.worldMatrix,r)}}copyFrom(e){for(let t=0;t<this._jointsPose.length;t++)this._jointsPose[t].worldMatrix.copyFrom(e._jointsPose[t].worldMatrix)}reset(){for(let e=0;e<this._jointsPose.length;e++)this._jointsPose[e].worldMatrix.identity()}}class ru extends je{constructor(e,t){super(),n(this,"skeletonAnimation"),this.type=e,this.time=t}}class Xa{constructor(e,t,r,a){if(n(this,"name",""),n(this,"_skeleton"),n(this,"_skeletonPoses"),n(this,"_animationClipData"),n(this,"_events"),this.name=e,this._skeleton=t,this._animationClipData=a,r>0&&a){this._skeletonPoses=new Array(r);let s=12*t.numJoint;for(let o=0;o<r;o++){let l=s*o*4,h=new Float32Array(a.buffer,l,s),u=new Zr(t);u.buildSkeletonPose(h),this._skeletonPoses[o]=u}}}get totalTime(){return this._skeletonPoses[this._skeletonPoses.length-1].time}get frameRate(){return this.totalTime/this._skeletonPoses.length}get skeleton(){return this._skeleton}get numFrame(){return this._skeletonPoses.length-1}get animationClipData(){return this._animationClipData}getSkeletonPose(e){return this._skeletonPoses[e]}getLerpSkeletonPose(e,t,r,a){let s=this.getSkeletonPose(e),o=this.getSkeletonPose(t);return a.lerp(s,o,r),a}createSubClip(e,t,r){var a=new Xa(e,this._skeleton,0,null);const s=Math.max(Math.floor(t/this.frameRate),0),o=Math.min(Math.floor(r/this.frameRate),this._skeletonPoses.length-1);a._skeletonPoses=this._skeletonPoses.slice(s,o);const l=12*this._skeleton.numJoint*4;return this._animationClipData=new Float32Array(this._animationClipData,s*l,(o-s)*l),a}addEvent(e,t){this._events||(this._events=new Array),this._events.push(new ru(e,t))}removeEvent(e){this._events&&(this._events=this._events.filter(t=>t.type!=e))}getEvents(){return this._events}}class pn{constructor(e){n(this,"gltf"),n(this,"subParser"),this.gltf=e.gltf,this.subParser=e}parse(e){let t=new iu;return this.buildSkeleton(t,void 0,e),t}parseSkeletonAnimation(e,t){let r=this.subParser.parseAccessor(t.samplers[0].input).data.length,a=12*e.numJoint,s=new Float32Array(a*r);for(var o=0;o<e.numJoint;o++)for(var l=0;l<r;l++){var h=a*l+12*o;s[h+0]=1,s[h+1]=1,s[h+2]=1,s[h+3]=1}for(let d of t.channels){let g=t.samplers[d.sampler];const m=this.subParser.parseAccessor(g.input),A=this.subParser.parseAccessor(g.output);let v=d.target.node,y=d.target.path,C=this.gltf.nodes[v];if(!C)continue;let S=e.getJointByName(C.name);switch(y){case"scale":for(var l=0;l<r;l++){var u=l*A.numComponents,h=a*l+12*S.index;s[h+0]=A.data[u+0],s[h+1]=A.data[u+1],s[h+2]=A.data[u+2],s[h+3]=1}break;case"rotation":for(var l=0;l<r;l++){var u=l*A.numComponents,h=a*l+12*S.index+4;s[h+0]=A.data[u+0],s[h+1]=A.data[u+1],s[h+2]=A.data[u+2],s[h+3]=A.data[u+3]}break;case"translation":for(var l=0;l<r;l++){var u=l*A.numComponents,h=a*l+12*S.index+8;s[h+0]=A.data[u+0],s[h+1]=A.data[u+1],s[h+2]=A.data[u+2],s[h+3]=m.data[l*m.numComponents]}break}}return new Xa(t.name,e,r,s)}buildSkeleton(e,t,r,a=0){let s=this.gltf.nodes[r];s.name||(s.name="Node_"+r);let o=new tu(s.name);if(o.parent=t,s.scale&&o.scale.set(s.scale[0],s.scale[1],s.scale[2]),s.rotation&&o.rotation.set(s.rotation[0],s.rotation[1],s.rotation[2],s.rotation[3]),s.translation&&o.translation.set(s.translation[0],s.translation[1],s.translation[2]),e.addJoint(o),s.children)for(let l of s.children)this.buildSkeleton(e,o,l,a+1)}}class au{constructor(e){n(this,"loop",!0),n(this,"speed",1),n(this,"t",0),n(this,"time",0),n(this,"weight",0),n(this,"currFrame",0),n(this,"lastFrame",-1),n(this,"nextFrame",0),n(this,"clip"),n(this,"animation"),n(this,"_isEnd",!1),n(this,"_currSkeletonPose"),this.clip=e,this._currSkeletonPose=new Zr(this.clip.skeleton)}reset(){this.time=0,this.weight=0,this._isEnd=!1}get name(){return this.clip.name}get currSkeletonPose(){return this._currSkeletonPose}update(e){this.time=(this.time+e*this.speed)%this.clip.totalTime;let t=this.time/this.clip.frameRate;if(this.currFrame=Math.trunc(t),this.t=t-this.currFrame,this.currFrame<0&&(this.currFrame=this.clip.numFrame+this.currFrame),this.time>=0?this.nextFrame=(this.currFrame+1)%this.clip.numFrame:(this.nextFrame=this.currFrame-1,this.nextFrame<0&&(this.nextFrame=this.clip.numFrame+this.nextFrame),this.t=1-this.t),this._isEnd)this.currFrame=this.nextFrame=this.speed<0?0:this.clip.numFrame-1;else if(this.currFrame!=this.lastFrame){let s=this.speed<0?0:this.clip.numFrame;this.currFrame==s&&(this.loop?(this.currFrame=0,this.nextFrame=1,this.time=this.t=0):(this.currFrame=this.nextFrame=this.speed<0?0:this.clip.numFrame-1,this._isEnd=!0));var r=this.clip.getEvents();if(r)for(let o of r){var a=Math.floor(o.time/this.clip.frameRate);if(a=Math.min(a,this.clip.numFrame),a=Math.max(a,0),a==this.currFrame){o.skeletonAnimation=this.animation,this.animation.eventDispatcher.dispatchEvent(o);break}}this.lastFrame=this.currFrame}this.clip.getLerpSkeletonPose(this.currFrame,this.nextFrame,this.t,this._currSkeletonPose)}}class Ai extends Ee{constructor(){super(),n(this,"isPlaying",!0),n(this,"timeScale",1),n(this,"_skeleton"),n(this,"_clips",[]),n(this,"_clipStates",new Map),n(this,"_mixSkeletonPose"),n(this,"_mixTempSkeletonPose"),n(this,"_currentClipState"),n(this,"_bindList",[]),n(this,"_jointMatrixIndexTableBuffer"),n(this,"_crossFadeState")}start(){}get currName(){return this._currentClipState?this._currentClipState.name:""}set skeleton(e){this._skeleton=e,this._mixSkeletonPose=new Zr(this._skeleton,!0),this._mixTempSkeletonPose=new Zr(this._skeleton);const t=new Float32Array(this._mixSkeletonPose.jointMatrixIndexTable);this._jointMatrixIndexTableBuffer=new fe(this._skeleton.numJoint*4,0,t)}get skeleton(){return this._skeleton}get finalSkeletonPose(){return this._mixSkeletonPose}get jointMatrixIndexTableBuffer(){return this._jointMatrixIndexTableBuffer}getJointIndexTable(e){let t=new Array;for(let r=0;r<e.length;r++){const a=e[r];let s=this._skeleton.getJointByName(a);t[r]=s?s.index:-1}return t}addAnimationClip(e){if(!this._clipStates.has(e.name)){this._clips.push(e);let t=new au(e);t.animation=this,this._clipStates.set(e.name,t),this._currentClipState||this.setCurrentClipState(t)}}getAnimationClip(e){var t=this.getAnimationClipState(e);return t?t.clip:null}getAnimationClips(){return this._clips}getAnimationClipState(e){return this._clipStates.has(e)?this._clipStates.get(e):null}getAnimationClipStates(){return this._clipStates}pause(){this.isPlaying=!1}resume(){this.isPlaying=!0}play(e,t=1,r=!1){if(this._currentClipState&&this._currentClipState.name==e)return r&&this._currentClipState.reset(),!1;let a=this.getAnimationClipState(e);return a?(a.speed=t,a.reset(),this._clipStates.forEach((s,o)=>{s.weight=0}),this.setCurrentClipState(a),!0):!1}crossFade(e,t){if(t<.01){this.play(e);return}if(this._currentClipState.name==e)return;let r=this.getAnimationClipState(e);r&&(r.reset(),this._crossFadeState?(this._crossFadeState.inClip&&(this._crossFadeState.inClip.weight=0),this._crossFadeState.outClip&&(this._crossFadeState.outClip.weight=0),this._crossFadeState.reset(r,this._currentClipState,t)):this._crossFadeState=new Og(r,this._currentClipState,t),this._currentClipState=r)}setAnimIsLoop(e,t){this._clipStates.has(e)&&(this._clipStates.get(e).loop=t)}addJointBind(e,t){this._bindList.push({jointName:e,obj:t})}removeJointBind(e){for(let t=0;t<this._bindList.length;t++)if(this._bindList[t].obj==e){this._bindList.splice(t,1);break}}onUpdate(){if(!this.isPlaying)return;let e=he.delta*.001*this.timeScale;this._crossFadeState&&this._crossFadeState.update(e);var t=0,r=[];if(this._clipStates.forEach((s,o)=>{s.weight>0&&(s.update(e),t+=s.weight,r.push(s))}),r.length>0){this._mixSkeletonPose.copyFrom(r[0].currSkeletonPose);for(var a=1;a<r.length;++a){const s=r[a];this._mixTempSkeletonPose.lerp(this._mixSkeletonPose,s.currSkeletonPose,s.weight/t),this._mixSkeletonPose.copyFrom(this._mixTempSkeletonPose)}}}cloneTo(e){let t=e.addComponent(Ai);t.skeleton=this.skeleton;for(var r=0;r<this._clips.length;++r)t.addAnimationClip(this._clips[r])}setCurrentClipState(e){this._currentClipState!=e&&(this._currentClipState=e,this._currentClipState.weight=1)}}class Og{constructor(e,t,r){n(this,"inClip"),n(this,"outClip"),n(this,"currentTime"),n(this,"crossFadeTime"),this.reset(e,t,r)}reset(e,t,r){this.inClip=e,this.outClip=t,this.currentTime=0,this.crossFadeTime=r}update(e){!this.inClip||!this.outClip||(this.currentTime+=e,this.inClip.weight=Math.min(Math.abs(this.currentTime%this.crossFadeTime)/this.crossFadeTime,1),this.outClip.weight=1-this.inClip.weight,Math.abs(this.currentTime)>=this.crossFadeTime&&(this.inClip.weight=1,this.outClip.weight=0,this.inClip=null,this.outClip=null))}}class Wa{static add(e){this.list.indexOf(e)==-1&&this.list.push(e)}static remove(e){let t=this.list.indexOf(e);t!=-1&&this.list.splice(t,1)}}n(Wa,"list",[]);class ja extends Ee{constructor(){super(),n(this,"name"),n(this,"size",1),n(this,"lightData"),n(this,"dirFix",1),n(this,"bindOnChange"),n(this,"needUpdateShadow",!0),n(this,"realTimeShadow",!0),n(this,"_castGI",!1),n(this,"_castShadow",!1),n(this,"_iesProfiles")}init(){this.transform.object3D.bound=new Be(new p,new p),this.lightData=new Rr,this.lightData.lightMatrixIndex=this.transform.worldMatrix.index}onChange(){this.bindOnChange&&this.bindOnChange(),this.transform.object3D.bound.setFromCenterAndSize(this.transform.worldPosition,new p(this.size,this.size,this.size)),this._castGI&&(Q.instance.state.giLightingChange=!0),this._castShadow?(this.needUpdateShadow=!0,Ge.addShadowLight(this)):Ge.removeShadowLight(this)}start(){this.transform.onPositionChange=()=>this.onPositionChange(),this.transform.onScaleChange=()=>this.onScaleChange(),this.transform.onRotationChange=()=>this.onRotChange(),this.onPositionChange(),this.onRotChange(),this.onScaleChange()}onPositionChange(){this.lightData.lightPosition.copyFrom(this.transform.worldPosition)}onRotChange(){this.dirFix==1?this.lightData.direction.copyFrom(this.transform.forward):this.lightData.direction.copyFrom(this.transform.back),this.lightData.lightTangent.copyFrom(this.transform.up),this.onChange()}onScaleChange(){this.onChange()}onEnable(){this.onChange(),Q.instance.addLight(this.transform.scene3D,this)}onDisable(){this.onChange(),Q.instance.removeLight(this.transform.scene3D,this),Ge.removeShadowLight(this)}set iesProfiles(e){this._iesProfiles=e,this.lightData.iesIndex=e.index,Bi.use=!0,this.onChange()}get iesProfile(){return this._iesProfiles}get r(){return this.lightData.lightColor.r}set r(e){this.lightData.lightColor.r=e,this.onChange()}get g(){return this.lightData.lightColor.g}set g(e){this.lightData.lightColor.g=e,this.onChange()}get b(){return this.lightData.lightColor.b}set b(e){this.lightData.lightColor.b=e,this.onChange()}get lightColor(){return this.lightData.lightColor}set lightColor(e){this.lightData.lightColor=e,this.onChange()}get intensity(){return this.lightData.intensity}set intensity(e){this.lightData.intensity=e,this.onChange()}set castShadow(e){e!=this._castShadow&&(this._castShadow=e,this.onChange())}get castShadow(){return this._castShadow}get shadowIndex(){return this.lightData.castShadowIndex}get castGI(){return this._castGI}set castGI(e){e?Wa.add(this):Wa.remove(this),this._castGI=e,e&&this.onChange()}get direction(){return this.lightData.direction}destroy(e){this.bindOnChange=null,Q.instance.removeLight(this.transform.scene3D,this),Ge.removeShadowLight(this),this.transform.eventDispatcher.removeEventListener(Ue.ROTATION_ONCHANGE,this.onRotChange,this),this.transform.eventDispatcher.removeEventListener(Ue.SCALE_ONCHANGE,this.onScaleChange,this),super.destroy(e)}}class su extends ja{constructor(){super(),n(this,"shadowCamera")}init(){super.init(),this.object3D.name==""&&(this.object3D.name="DirectionLight_"+Mt()),this.radius=Number.MAX_SAFE_INTEGER,this.lightData.lightType=ze.DirectionLight,this.lightData.linear=0,this.lightData.quadratic=.3}start(){super.start(),this.castGI=!0}get radius(){return this.lightData.range}set radius(e){this.lightData.range=e,this.onChange()}get indirect(){return this.lightData.quadratic}set indirect(e){this.lightData.quadratic=e,this.onChange()}debug(){}}class nu extends ja{constructor(){super()}init(){super.init(),this.lightData.lightType=ze.PointLight,this.object3D.name==""&&(this.object3D.name="PointLight"+Mt())}get range(){return this.lightData.range}set range(e){this.lightData.range=e,this.onChange()}get at(){return this.lightData.linear}set at(e){this.lightData.linear=e,this.onChange()}get radius(){return this.lightData.radius}set radius(e){this.lightData.radius=e,this.onChange()}get quadratic(){return this.lightData.quadratic}set quadratic(e){this.lightData.quadratic=e,this.onChange()}start(){this.transform.rotationX=90,super.start()}onUpdate(){}onGraphic(e){let t=e.graphic3D.createCustomShape(`PointLight_${this.object3D.instanceID}`,this.transform);t.buildAxis(),t.buildCircle(p.ZERO,this.range,32,p.X_AXIS),t.buildCircle(p.ZERO,this.range,32,p.Y_AXIS),t.buildCircle(p.ZERO,this.range,32,p.Z_AXIS)}debug(){}debugDraw(e){}}class ou extends ja{constructor(){super()}init(){super.init(),this.lightData.lightType=ze.SpotLight,this.object3D.name==""&&(this.object3D.name="SpotLight"+Mt())}get innerAngle(){return this.lightData.innerAngle/this.lightData.outerAngle*100}set innerAngle(e){this.lightData.innerAngle=J(e,0,100)/100*this.lightData.outerAngle,this.onChange()}get outerAngle(){return this.lightData.outerAngle*qi*2}set outerAngle(e){this.lightData.outerAngle=J(e,1,179)*_e*.5,this.onChange()}get radius(){return this.lightData.radius}set radius(e){this.lightData.radius=e,this.onChange()}get range(){return this.lightData.range}set range(e){this.lightData.range=e,this.onChange()}get at(){return this.lightData.linear}set at(e){this.lightData.linear=e,this.onChange()}start(){super.start(),this.lightData.lightType=ze.SpotLight}onUpdate(){}onGraphic(e){let t=e.graphic3D.createCustomShape(`SpotLight_${this.object3D.instanceID}`,this.transform);const r=this.range,a=this.outerAngle/2;t.buildAxis();let s=(90-a)*_e,o=r*Math.cos(s),l=r*Math.sin(s);t.buildLines([p.ZERO,new p(0,o,l)]),t.buildLines([p.ZERO,new p(o,0,l)]),s=(90+a)*_e,o=r*Math.cos(s),l=r*Math.sin(s),t.buildLines([p.ZERO,new p(0,o,l)]),t.buildLines([p.ZERO,new p(o,0,l)]),t.buildArcLine(p.ZERO,r,90-a,90+a,16,p.X_AXIS),t.buildArcLine(p.ZERO,r,90-a,90+a,16,p.Y_AXIS),t.buildCircle(new p(0,0,r*Math.sin(s)),r*Math.cos(s),32,p.Z_AXIS)}debug(){}debugDraw(e){}}class qa extends ue{constructor(){super(),n(this,"skinJointsName"),n(this,"mInverseBindMatrixData"),n(this,"mInverseBindMatrixBuffer"),n(this,"mSkeletonAnimation"),n(this,"mJointIndexTableBuffer"),this.addRendererMask(Le.SkinnedMesh)}start(){if(super.start(),this.skeletonAnimation=this.object3D.getComponent(Ai),!this.skeletonAnimation){let e=this.object3D.parentObject.parentObject.getComponentsInChild(Ai);e.length>0&&(this.skeletonAnimation=e[0]),this.skeletonAnimation||(this.skeletonAnimation=this.object3D.getComponentFromParent(Ai))}}onEnable(){super.onEnable()}get skeletonAnimation(){return this.mSkeletonAnimation}set skeletonAnimation(e){if(this.mSkeletonAnimation=e,!!e&&!this.mJointIndexTableBuffer){let t=this.mSkeletonAnimation.getJointIndexTable(this.skinJointsName);this.mJointIndexTableBuffer=new fe(t.length*4,0,new Float32Array(t)),this.mJointIndexTableBuffer.visibility=GPUShaderStage.VERTEX|GPUShaderStage.COMPUTE}}get skinInverseBindMatrices(){return this.mInverseBindMatrixData}set skinInverseBindMatrices(e){this.mInverseBindMatrixData=e;var t=new Float32Array(e.length*16);for(let r=0;r<e.length;r++){let a=r*16,s=e[r];t.set(s,a)}this.mInverseBindMatrixBuffer=new fe(t.byteLength,0,t),this.mInverseBindMatrixBuffer.visibility=GPUShaderStage.VERTEX|GPUShaderStage.COMPUTE}get inverseBindMatrixBuffer(){return this.mInverseBindMatrixBuffer}get jointIndexTableBuffer(){return this.mJointIndexTableBuffer.buffer}cloneTo(e){let t=e.addComponent(qa);t.geometry=this.geometry,t.material=this.material.clone(),t.castShadow=this.castShadow,t.castGI=this.castGI,t.receiveShadow=this.receiveShadow,t.rendererMask=this.rendererMask,t.skinJointsName=this.skinJointsName,t.skinInverseBindMatrices=this.skinInverseBindMatrices,t.mJointIndexTableBuffer=this.mJointIndexTableBuffer}nodeUpdate(e,t,r,a){for(let s=0;s<this.materials.length;s++){let l=this.materials[s].getPass(t);if(l)for(let h=0;h<l.length;h++){const u=l[h];u.pipeline||(u.setStorageBuffer("jointsMatrixIndexTable",this.mSkeletonAnimation.jointMatrixIndexTableBuffer),u.setStorageBuffer("jointsInverseMatrix",this.mInverseBindMatrixBuffer),u.setStorageBuffer("jointsIndexMapingTable",this.mJointIndexTableBuffer))}}super.nodeUpdate(e,t,r,a)}}class lu{static apply(e,t,r){let a=t.extensions;if(a&&a.KHR_materials_clearcoat){r.defaultPass.setDefine("USE_CLEARCOAT",!0);let s=a.KHR_materials_clearcoat;"clearcoatFactor"in s&&(t.clearcoatFactor=s.clearcoatFactor,r.clearcoatFactor=t.clearcoatFactor),"clearcoatRoughnessFactor"in s&&(t.clearcoatRoughnessFactor=s.clearcoatRoughnessFactor,r.clearcoatRoughnessFactor=t.clearcoatRoughnessFactor)}}}class hu{static apply(e,t,r){let a=t.extensions;a&&a.KHR_materials_emissive_strength?(r.emissiveIntensity=a.KHR_materials_emissive_strength.emissiveStrength*.5,r.emissiveMap==_.res.blackTexture&&(r.emissiveMap=_.res.whiteTexture)):r.emissiveIntensity=1}}class uu{static apply(e,t,r){let a=t.extensions;a&&a.KHR_materials_unlit?r.supportLight=!0:r.supportLight=!1}}class cu{constructor(e){n(this,"gltf"),n(this,"subParser"),n(this,"_testCount",8),n(this,"_hasCastShadow",!1),this.gltf=e.gltf,this.subParser=e}async convertNodeToObject3D(e,t){const r=new f.Object3D;if(r.name=e.name,r[le.GLTF_NODE_INDEX_PROPERTY]=e.nodeId,e.nodeObj=r,e.matrix&&(e.translation=[0,0,0],e.rotation=[0,0,0,1],e.scale=[1,1,1]),e.translation&&(r.transform.x=e.translation[0],r.transform.y=e.translation[1],r.transform.z=e.translation[2]),e.rotation){let a=new K;a.setFromArray(e.rotation),r.transform.localRotQuat=a}if(e.scale&&(r.transform.scaleX=e.scale[0],r.transform.scaleY=e.scale[1],r.transform.scaleZ=e.scale[2]),t.addChild(r),e.light&&this.convertLight(e,r),e.primitives&&this.convertprimitives(e,r),e.skeleton){let a=r.addComponent(Ai);if(a){a.skeleton=this.subParser.parseSkeleton(e.skeleton.skeleton);for(let s=0;s<this.gltf.animations.length;s++){let o=this.gltf.animations[s];o.name||(o.name=s.toString());let l=this.subParser.parseSkeletonAnimation(a.skeleton,o);a.addAnimationClip(l)}}}return r}convertLight(e,t){switch(e.light.type){case"directional":let r=t.addComponent(su);t.name=e.light.name,r.intensity=e.light.intensity*.1,r.radius=Number.MAX_SAFE_INTEGER,r.dirFix=-1,this._hasCastShadow||(this._hasCastShadow=!0,r.castShadow=this._hasCastShadow),r.lightColor=e.light.color?new z(e.light.color[0],e.light.color[1],e.light.color[2]):new z(1,1,1,1),r.debug();break;case"point":if(this._testCount>0){let s=t.addComponent(nu);s.name=e.light.name,s.intensity=e.light.intensity?e.light.intensity*8*2:1,s.radius=8,s.at=2,s.range=e.light.range?e.light.range:8,s.lightColor=e.light.color?new z(e.light.color[0],e.light.color[1],e.light.color[2]):new z(1,1,1,1)}this._testCount--;break;case"spot":let a=t.addComponent(ou);a.name=e.light.name,a.intensity=e.light.intensity*5,a.radius=1,a.dirFix=-1,a.at=2,a.range=e.light.range?e.light.range:8,a.outerAngle=e.light.spot.outerConeAngle*qi,a.lightColor=e.light.color?new z(e.light.color[0],e.light.color[1],e.light.color[2]):new z(1,1,1,1);break}}convertprimitives(e,t){for(let r=0;r<e.primitives.length;r++){const a=e.primitives[r];a.modelName;let s=a.material;s.name==null&&(s.name=Mt());let o,l=`matkey_${s.name}`;if(s&&this.gltf.resources[l])o=this.gltf.resources[l];else{let g=o=new xi;if(this.gltf.resources[l]=g,g.name=s.name,a.material){const{baseColorTexture:m,baseColorFactor:A,metallicFactor:v,roughnessFactor:y,doubleSided:C,metallicRoughnessTexture:S,normalTexture:T,occlusionTexture:D,emissiveTexture:M,emissiveFactor:P,enableBlend:R,alphaCutoff:U}=a.material;let E=g=this.applyMaterialExtensions(a.material,g);if("enableBlend"in a.material&&(a.material.enableBlend?(E.blendMode=ve.NORMAL,E.depthWriteEnabled=!1):E.blendMode=ve.NONE,a.material.defines&&a.material.defines.indexOf("ALPHA_BLEND")!=-1&&(E.blendMode=ve.ALPHA,E.transparent=!0,E.depthWriteEnabled=!1)),"alphaCutoff"in a.material&&U>0&&(E.alphaCutoff=U,E.blendMode=ve.NORMAL,E.transparent=!0,E.depthWriteEnabled=!1),a.material.transformUV1&&(E.uvTransform_1=a.material.transformUV1),a.material.transformUV2&&(E.uvTransform_2=a.material.transformUV2),E.baseColor=new z(A[0],A[1],A[2],A[3]),E.roughness=y,E.metallic=v,E.doubleSide=C,E.ao=1,m&&(E.baseMap=m),T&&(E.normalMap=T),S&&(E.maskMap=S),D&&S!=D&&(E.aoMap=D),M&&(E.emissiveMap=M),P&&(P[0]>0||P[1]>0||P[2]>0)){E.emissiveMap&&E.emissiveMap==_.res.blackTexture&&(E.emissiveMap=_.res.whiteTexture);let F=P[3]?P[3]:1;E.emissiveColor=new z(P[0],P[1],P[2],F),E.emissiveIntensity=1}}}const{attribArrays:h,modelName:u,drawMode:c}=a;let d;if(!h.indices.data){let g=[],m=h.position.data.length/3/3;for(let A=0;A<m;A++){let v=A*3;g.push(v+2),g.push(v+0),g.push(v+1)}h.indices={data:new Uint8Array(g),normalize:!1,numComponents:1}}if(!h.normal){let g=[],m=h.position.data.length/3;for(let A=0;A<m;A++)g.push(0),g.push(0),g.push(0);h.normal={data:new Float32Array(g),normalize:!1,numComponents:3}}if(h.indices.data&&h.indices.data.length>3){let g=a.meshName();this.gltf.resources[g]?d=this.gltf.resources[g]:(d||(d=this.createGeometryBase(g,h,a)),this.gltf.resources[g]=d);const m=new f.Object3D;if(m.name=u+r,this.gltf.animations&&h[X.joints0]!=null){d||(d=this.createGeometryBase(u,h,a)),this.gltf.resources[g]=d;let A=this.gltf.nodes[e.skin.skeleton];if(A.dnode&&A.dnode.nodeObj){let C=A.dnode.nodeObj.addComponent(Ai);if(C){C.skeleton=this.subParser.parseSkeleton(e.skin.skeleton);for(let S=0;S<this.gltf.animations.length;S++){let T=this.gltf.animations[S];T.name||(T.name=S.toString());let D=this.subParser.parseSkeletonAnimation(C.skeleton,T);C.addAnimationClip(D)}}}else A.dnode.skeleton=e.skin;let v=m.addComponent(qa);v.castShadow=!0,v.castGI=!0,v.geometry=d,v.material=o,v.skinJointsName=this.parseSkinJoints(e.skin),v.skinInverseBindMatrices=e.skin.inverseBindMatrices}else{d||(d=this.createGeometryBase(u,h,a)),this.gltf.resources[g]=d,d.hasAttribute(X.joints0)&&d.vertexAttributeMap.delete(X.joints0);let A=m.addComponent(ue);A.castShadow=!0,A.castGI=!0,A.geometry=d,A.material=o}e.skin&&e.skin.defines,t.addChild(m)}}}createGeometryBase(e,t,r){let a=new it;a.name=e,a.morphTargetsRelative=r.morphTargetsRelative;let s=r.targetNames;if(s&&s.length>0){let l=a.morphTargetDictionary={};for(let h=0;h<s.length;h++)l[s[h]]=h}if(a.morphTargetDictionary){let l=t.position.data.length/3,h=new Float32Array(l);for(let u=0;u<l;u++)h[u]=u;t.vIndex={data:h,normalize:!1,numComponents:1}}for(const l in t){let h=t[l];a.setAttribute(l,h.data)}let o=a.getAttribute(X.indices);return a.addSubGeometry({indexStart:0,indexCount:o.data.length,vertexStart:0,index:0}),a}applyMaterialExtensions(e,t){return lu.apply(this.gltf,e,t),uu.apply(this.gltf,e,t),hu.apply(this.gltf,e,t),t}parseSkinJoints(e){let t=[];for(let r of e.joints){let a=this.gltf.nodes[r];t.push(a.name)}return t}}class Ka{constructor(){n(this,"currentSceneName"),n(this,"gltf"),n(this,"initUrl"),n(this,"_generator"),n(this,"_version"),n(this,"_BASE64_MARKER",";base64,"),n(this,"_cameraParser",null),n(this,"_meshParser",null),n(this,"_materialParser",null),n(this,"_skinParser",null),n(this,"_skeletonParser",null),n(this,"_converter",null)}get version(){return this.version?this.version:this.gltf?this.gltf.asset?(this._version=this.gltf.asset.version,this.gltf.asset.minVersion&&(this._version+=`\r minVersion${this.gltf.asset.minVersion}`),this.version):this.errorMiss("asset"):(console.warn("glTF not loaded."),null)}async parse(e,t,r){this.gltf=t,this.initUrl=e;const{version:a,generator:s}=this.gltf.asset;if(this._generator=s,a!=="2.0")return console.error(`GLTFParser only support glTF 2.0 for now! Received glTF version: ${this.version}`),!1;const o={nodes:await this.parseScene(r),animations:this.parseAnimations(),name:this.currentSceneName};return await this.convertToNode(o)}destory(){Jr.unload(this.gltf),this.gltf=null}async parseScene(e){const t=e||this.gltf.scene||0,r=this.gltf.scenes[t];if(typeof r>"u")return this.errorMiss("scene",t);this.currentSceneName=r.name||"GLTF_NO_NAME_SCENE";const a=[],s=r.nodes;for(let o=0;o<s.length;o++){const l=await this.parseNode(s[o]);l&&a.push(l)}return a}async parseNode(e){const t=this.gltf.nodes[e];if(!t)return this.errorMiss("node",e);if(t.isParsed)return t.dnode;const{name:r,matrix:a,translation:s,rotation:o,scale:l}=t,h={name:r,matrix:a,translation:s,rotation:o,scale:l,nodeId:e,camera:null,primitives:null,skin:null,children:null,light:null};if(t.camera!==void 0&&(h.camera=this.parseCamera(t.camera)),t.mesh!==void 0&&(h.primitives=await this.parseMesh(t.mesh)),t.extensions!==void 0&&this.applyNodeExtensions(t,h),t.skin!==void 0){const u=this.parseSkin(t.skin);u&&(h.skin=u)}if(h.children=[],t.children)for(let u=0;u<t.children.length;u++)h.children.push(await this.parseNode(t.children[u]));return t.dnode=h,t.isParsed=!0,t.dnode}errorMiss(e,t){throw new Error(e+t)}parseCamera(e){return this._cameraParser||(this._cameraParser=new Kh(this.gltf)),this._cameraParser.parse(e)}async parseMesh(e){return this._meshParser||(this._meshParser=new Zh(this)),this._meshParser.parse(e)}async parseTexture(e){let t=this.gltf.textures[e];if(t&&!t.dtexture){if(t&&t.source!=null){let r=this.gltf.images[t.source];if(r.uri){let a=r.uri;a=rt.getURLName(a),t.dtexture=this.gltf.resources[a]}else if(r.bufferView){let a=this.parseBufferView(r.bufferView),s=new ei,o=new Blob([a],{type:r.mimeType});await s.loadFromBlob(o),t.dtexture=s}else t.dtexture=this.gltf.resources[r.name]}else if(t.name){let r=rt.getURLName(t.name);t.dtexture=this.gltf.resources[r]}}return t.dtexture||console.log("miss texture , please check texture!",e,t),t.dtexture}async parseMaterial(e){return this._materialParser||(this._materialParser=new $h(this)),this._materialParser.parse(e)}parseAnimations(){return[]}async parseObject3D(e,t){return this._converter||(this._converter=new cu(this)),this._converter.convertNodeToObject3D(e,t)}parseSkeleton(e){return this._skeletonParser||(this._skeletonParser=new pn(this)),this._skeletonParser.parse(e)}parseSkeletonAnimation(e,t){return this._skeletonParser||(this._skeletonParser=new pn(this)),this._skeletonParser.parseSkeletonAnimation(e,t)}async traverse(e,t){for(let r=0;r<t.length;r++){const a=await this.parseObject3D(t[r],e);await this.traverse(a,t[r].children)}}async convertToNode(e){const t=new f.Object3D;t.name=e.name;const r=e.nodes;e.animations;const a=[],s=[];await this.traverse(t,r);let o;return{rootNode:t,textures:a,animations:o,cameras:s}}parseSkin(e){return this._skinParser||(this._skinParser=new eu(this)),this._skinParser.parse(e)}parseAccessor(e){const t=this.gltf.accessors[e];if(!t)return this.errorMiss("accessor",e);if(t.isParsed)return t.daccessor;t.isParsed=!0,t.daccessor=!1;const r=!!t.normalized,a=this.gltf.bufferViews[t.bufferView],s=a&&a.byteStride,o=dn(t.componentType);let l=1;switch(t.type){case"SCALAR":l=1;break;case"VEC2":l=2;break;case"VEC3":l=3;break;case"VEC4":case"MAT2":l=4;break;case"MAT3":l=9;break;case"MAT4":l=16;break;default:l=0;break}if(l===0)return console.error(`glTF has unknown data type in accessor: ${t.type}`),!1;const h=l*o.BYTES_PER_ELEMENT;let u;if(a!==void 0){if(u=this.parseBufferView(t.bufferView),!u)return t.daccessor}else u=new Uint8Array(h*t.count).buffer;let c=this.getTypedArrayFromArrayBuffer(u,s,t.byteOffset||0,o,l,t.count);if(t.sparse){const{count:d,indices:g,values:m}=t.sparse;c=new o(c);const A=g.byteOffset||0,v=this.gltf.bufferViews[g.bufferView],y=dn(g.componentType),C=this.parseBufferView(g.bufferView),S=this.getTypedArrayFromArrayBuffer(C,v.byteStride,A,y,1,d),T=m.byteOffset||0,D=this.gltf.bufferViews[m.bufferView],M=this.parseBufferView(m.bufferView),P=this.getTypedArrayFromArrayBuffer(M,D.byteStride,T,o,l,d);for(let R=0;R<S.length;R++)c.set(P.slice(R*l,R*l+l),S[R]*l)}return t.computeResult={typedArray:c,arrayType:o,numComponents:l},t.daccessor={data:c,numComponents:l,normalize:r},t.daccessor}getTypedArrayFromArrayBuffer(e,t,r,a,s,o){let l;const h=s*a.BYTES_PER_ELEMENT;if(t&&h!==t){const u=s*o;l=new a(u);for(let c=0;c<o;c++){const d=new a(e,r+c*t,s);for(let g=0;g<s;g++)l[c*s+g]=d[g]}}else l=new a(e,r,o*s);return l}parseBufferView(e){const t=this.gltf.bufferViews[e];if(!t)return this.errorMiss("bufferView",e);if(t.isParsed)return t.dbufferView;t.isParsed=!0,t.dbufferView=!1;const r=this.parseBuffer(t.buffer);if(r){const{byteOffset:a,byteLength:s}=t,o=new Uint8Array(r,a||0,s);t.dbufferView=new Uint8Array(o).buffer}return t.dbufferView}parseBuffer(e){const t=this.gltf.buffers[e];if(!t)return this.errorMiss("buffer",e);if(t.isParsed)return t.dbuffer;if(t.isParsed=!0,t.dbuffer=!1,t.uri.substring(0,5)!=="data:"){const r=t.uri,a=this.gltf.resources[r];a?a.byteLength===t.byteLength?t.dbuffer=this.gltf.resources[r]:console.error(`load gltf resource "${r}" at buffers[${e} failed, ArrayBuffer.byteLength not equals buffer's byteLength]`):console.error(`load gltf resource "${r}" at buffers[${e}] failed`)}else{const r=t.uri.indexOf(this._BASE64_MARKER)+this._BASE64_MARKER.length,a=window.atob(t.uri.substring(r)),s=new Uint8Array(a.length);for(let o=0;o<a.length;o++)s[o]=a.charCodeAt(o);t.dbuffer=s.buffer}return t.dbuffer}getLight(e){return this.gltf.extensions.KHR_lights_punctual.lights[e]}applyNodeExtensions(e,t){let r=e.extensions;r.KHR_lights_punctual&&this.gltf.extensions.KHR_lights_punctual&&(t.light=this.getLight(r.KHR_lights_punctual.light))}}class fu{constructor(){n(this,"magic"),n(this,"version"),n(this,"length")}}class du{constructor(){n(this,"chunkLength"),n(this,"chunkType"),n(this,"chunkData")}}class Ja extends Xt{constructor(){super(...arguments),n(this,"_gltf")}async parseBuffer(e){let t=new Uint8Array(e);t.pos=0;const r=this.parseHeader(t);if(r.magic!=1179937895)return console.error("invalid GLB file"),!1;if(r.version!==2)return console.error(`GLBParser only support glTF 2.0 for now! Received glTF version: ${r.version}`),!1;let a=[];for(;t.pos<t.length;){let d=this.parseChunk(t);a.push(d)}if(a[0].chunkType!=1313821514)return console.error("invalid GLBChunk"),!1;let s="",o=65535,l=a[0].chunkData;for(let d=0;d<l.length;d+=o){let g=l.length-d;g=Math.min(g,o);let m=l.subarray(d,d+g);s+=String.fromCharCode(...m)}let h=JSON.parse(s);this._gltf=new Ya,this._gltf={...this._gltf,...h},this._gltf.resources={};for(let d=0;d<this._gltf.buffers.length;d++){let g=this._gltf.buffers[d];g.isParsed=!0,g.dbuffer=a[d+1].chunkData.buffer}if(this._gltf.images)for(let d=0;d<this._gltf.images.length;d++){let g=this._gltf.images[d];g.name=g.name||"bufferView_"+g.bufferView.toString();const m=this._gltf.bufferViews[g.bufferView],A=this._gltf.buffers[m.buffer];let v=new Uint8Array(A.dbuffer,m.byteOffset,m.byteLength),y=new Blob([v],{type:g.mimeType}),C=new ei;await C.loadFromBlob(y),C.name=g.name,this._gltf.resources[g.name]=C}let c=await new Ka().parse(this.initUrl,this._gltf,this._gltf.scene);return c?(this.data=c.rootNode,c.rootNode):null}async parseJsonAndBuffer(e,t){this._gltf=new Ya,this._gltf={...this._gltf,...e},this._gltf.resources={};let r=this._gltf.buffers[0];if(r.isParsed=!0,r.dbuffer=t,this._gltf.images)for(let o=0;o<this._gltf.images.length;o++){let l=this._gltf.images[o];l.name=l.name||"bufferView_"+l.bufferView.toString();const h=this._gltf.bufferViews[l.bufferView],u=this._gltf.buffers[h.buffer];let c=new Uint8Array(u.dbuffer,h.byteOffset,h.byteLength),d=new Blob([c],{type:l.mimeType}),g=new ei;await g.loadFromBlob(d),g.name=l.name,this._gltf.resources[l.name]=g}let s=await new Ka().parse(this.initUrl,this._gltf,this._gltf.scene);return s?(this.data=s.rootNode,s.rootNode):null}verification(){if(this.data)return!0;throw new Error("Method not implemented.")}parseHeader(e){let t=e.pos,r=new fu,a=new Uint32Array(e.buffer,t,3);return e.pos+=a.byteLength,r.magic=a[0],r.version=a[1],r.length=a[2],r}parseChunk(e){let t=e.pos,r=new du,a=new Uint32Array(e.buffer,t,2);t=e.pos+=a.byteLength,r.chunkLength=a[0],r.chunkType=a[1],r.chunkData=new Uint8Array(e.buffer,t,r.chunkLength);const s=new Uint8Array(r.chunkLength);for(let o=0;o<r.chunkLength;o++)s[o]=r.chunkData[o];return r.chunkData=s,e.pos+=r.chunkLength,r}}n(Ja,"format","bin");class $r{constructor(e=0,t="\0"){n(this,"Type",0),n(this,"Line",0),n(this,"Colume",0),n(this,"Literal",""),this.Type=e,this.Literal=t}isTypeEqual(e){return this.Type==e}isLiteralEqual(e){return this.Literal==e}isBuiltinType(){return this.Type>33&&this.Type<101}isDataType(){return this.Type==1||this.isBuiltinType()}isOperation(){return this.Type>102&&this.Type<127}isAssignOperation(){return this.Type>128&&this.Type<133}get nOperationPriorityLevel(){switch(this.Type){case 26:return 1;case 27:return 1;case 125:return 2;case 110:return 3;case 114:return 3;case 105:return 4;case 106:return 4;case 103:return 5;case 104:return 5;case 115:return 6;case 116:return 6;case 119:return 7;case 120:return 7;case 122:return 7;case 123:return 7;case 121:return 8;case 124:return 8;case 111:return 9;case 113:return 10;case 112:return 11;case 107:return 12;case 109:return 13;case 108:return 14;case 24:return 15;case 126:return 16;case 129:return 16;case 130:return 16;case 131:return 16;case 132:return 16}return 99}}var x=(i=>(i[i.EOF=0]="EOF",i[i.IDENT=1]="IDENT",i[i.VOID=2]="VOID",i[i.CONST=3]="CONST",i[i.LAYOUT=4]="LAYOUT",i[i.PRECISION=5]="PRECISION",i[i.ATTRIBUTE=6]="ATTRIBUTE",i[i.UNIFORM=7]="UNIFORM",i[i.VARYING=8]="VARYING",i[i.INVARIANT=9]="INVARIANT",i[i.IN=10]="IN",i[i.OUT=11]="OUT",i[i.INOUT=12]="INOUT",i[i.IF=13]="IF",i[i.ELSE=14]="ELSE",i[i.FOR=15]="FOR",i[i.WHILE=16]="WHILE",i[i.DO=17]="DO",i[i.BREAK=18]="BREAK",i[i.RETURN=19]="RETURN",i[i.CONTINUE=20]="CONTINUE",i[i.STRUCT=21]="STRUCT",i[i.COMMA=22]="COMMA",i[i.COLON=23]="COLON",i[i.QUEMARK=24]="QUEMARK",i[i.SEMICOLON=25]="SEMICOLON",i[i.LEFTSAMLL=26]="LEFTSAMLL",i[i.RIGHTSAMLL=27]="RIGHTSAMLL",i[i.LEFTMEDI=28]="LEFTMEDI",i[i.RIGHTMEDI=29]="RIGHTMEDI",i[i.LEFTBIG=30]="LEFTBIG",i[i.RIGHTBIG=31]="RIGHTBIG",i[i.LITERAL=32]="LITERAL",i[i.BeginBuiltinType=33]="BeginBuiltinType",i[i.INT=34]="INT",i[i.INT_ARRAY=35]="INT_ARRAY",i[i.UINT=36]="UINT",i[i.UINT_ARRAY=37]="UINT_ARRAY",i[i.BOOL=38]="BOOL",i[i.BOOL_ARRAY=39]="BOOL_ARRAY",i[i.FLOAT=40]="FLOAT",i[i.FLOAT_ARRAY=41]="FLOAT_ARRAY",i[i.DOUBLE=42]="DOUBLE",i[i.DOUBLE_ARRAY=43]="DOUBLE_ARRAY",i[i.VEC2=44]="VEC2",i[i.VEC2_ARRAY=45]="VEC2_ARRAY",i[i.VEC3=46]="VEC3",i[i.VEC3_ARRAY=47]="VEC3_ARRAY",i[i.VEC4=48]="VEC4",i[i.VEC4_ARRAY=49]="VEC4_ARRAY",i[i.BVEC2=50]="BVEC2",i[i.BVEC2_ARRAY=51]="BVEC2_ARRAY",i[i.BVEC3=52]="BVEC3",i[i.BVEC3_ARRAY=53]="BVEC3_ARRAY",i[i.BVEC4=54]="BVEC4",i[i.BVEC4_ARRAY=55]="BVEC4_ARRAY",i[i.IVEC2=56]="IVEC2",i[i.IVEC2_ARRAY=57]="IVEC2_ARRAY",i[i.IVEC3=58]="IVEC3",i[i.IVEC3_ARRAY=59]="IVEC3_ARRAY",i[i.IVEC4=60]="IVEC4",i[i.IVEC4_ARRAY=61]="IVEC4_ARRAY",i[i.UVEC2=62]="UVEC2",i[i.UVEC2_ARRAY=63]="UVEC2_ARRAY",i[i.UVEC3=64]="UVEC3",i[i.UVEC3_ARRAY=65]="UVEC3_ARRAY",i[i.UVEC4=66]="UVEC4",i[i.UVEC4_ARRAY=67]="UVEC4_ARRAY",i[i.MAT2x2=68]="MAT2x2",i[i.MAT2x2_ARRAY=69]="MAT2x2_ARRAY",i[i.MAT2x3=70]="MAT2x3",i[i.MAT2x3_ARRAY=71]="MAT2x3_ARRAY",i[i.MAT2x4=72]="MAT2x4",i[i.MAT2x4_ARRAY=73]="MAT2x4_ARRAY",i[i.MAT3x2=74]="MAT3x2",i[i.MAT3x2_ARRAY=75]="MAT3x2_ARRAY",i[i.MAT3x3=76]="MAT3x3",i[i.MAT3x3_ARRAY=77]="MAT3x3_ARRAY",i[i.MAT3x4=78]="MAT3x4",i[i.MAT3x4_ARRAY=79]="MAT3x4_ARRAY",i[i.MAT4x2=80]="MAT4x2",i[i.MAT4x2_ARRAY=81]="MAT4x2_ARRAY",i[i.MAT4x3=82]="MAT4x3",i[i.MAT4x3_ARRAY=83]="MAT4x3_ARRAY",i[i.MAT4x4=84]="MAT4x4",i[i.MAT4x4_ARRAY=85]="MAT4x4_ARRAY",i[i.SAMPLER=86]="SAMPLER",i[i.SAMPLER_1D=87]="SAMPLER_1D",i[i.SAMPLER_2D=88]="SAMPLER_2D",i[i.SAMPLER_3D=89]="SAMPLER_3D",i[i.SAMPLER_CUBE=90]="SAMPLER_CUBE",i[i.SAMPLER_SHADOW=91]="SAMPLER_SHADOW",i[i.SAMPLER_1D_SHADOW=92]="SAMPLER_1D_SHADOW",i[i.SAMPLER_2D_SHADOW=93]="SAMPLER_2D_SHADOW",i[i.TEXTURE_1D=94]="TEXTURE_1D",i[i.TEXTURE_1D_ARRAY=95]="TEXTURE_1D_ARRAY",i[i.TEXTURE_2D=96]="TEXTURE_2D",i[i.TEXTURE_2D_ARRAY=97]="TEXTURE_2D_ARRAY",i[i.TEXTURE_3D=98]="TEXTURE_3D",i[i.TEXTURE_CUBE=99]="TEXTURE_CUBE",i[i.TEXTURE_CUBE_ARRAY=100]="TEXTURE_CUBE_ARRAY",i[i.EndBuiltinType=101]="EndBuiltinType",i[i.BeginOperation=102]="BeginOperation",i[i.ADD=103]="ADD",i[i.SUB=104]="SUB",i[i.MUL=105]="MUL",i[i.DIV=106]="DIV",i[i.AND=107]="AND",i[i.OR=108]="OR",i[i.XOR=109]="XOR",i[i.NOT=110]="NOT",i[i.BITAND=111]="BITAND",i[i.BITOR=112]="BITOR",i[i.BITXOR=113]="BITXOR",i[i.BITNOT=114]="BITNOT",i[i.BITSHIFT_L=115]="BITSHIFT_L",i[i.BITSHIFT_R=116]="BITSHIFT_R",i[i.INC=117]="INC",i[i.DEC=118]="DEC",i[i.GREATER=119]="GREATER",i[i.GREATEREQUAL=120]="GREATEREQUAL",i[i.EQUAL=121]="EQUAL",i[i.LESS=122]="LESS",i[i.LESSEQUAL=123]="LESSEQUAL",i[i.NOTEQUAL=124]="NOTEQUAL",i[i.DOT=125]="DOT",i[i.ASSIGN=126]="ASSIGN",i[i.EndOperation=127]="EndOperation",i[i.BeginAssignOperation=128]="BeginAssignOperation",i[i.ADDASSIGN=129]="ADDASSIGN",i[i.SUBASSIGN=130]="SUBASSIGN",i[i.MULASSIGN=131]="MULASSIGN",i[i.DIVASSIGN=132]="DIVASSIGN",i[i.EndAssignOperation=133]="EndAssignOperation",i))(x||{});class or{constructor(e){n(this,"_char"),n(this,"_line"),n(this,"_column"),n(this,"_source"),n(this,"_currPosition"),n(this,"_nextPosition"),this.reset(e)}reset(e){this._char="",this._line=0,this._column=0,this._source=e,this._currPosition=0,this._nextPosition=0}get source(){return this._source}getChar(){return this._char}get currPosition(){return this._currPosition}peekChar(){return this._nextPosition>=this._source.length?"\0":this._source[this._nextPosition]}readChar(){this._char=this._nextPosition>=this._source.length?"\0":this._source[this._nextPosition],this._char!==`
`?this._column++:(this._line++,this._column=0),this._currPosition=this._nextPosition,this._nextPosition++}readCharAndSkipWhitespace(){this.readChar(),this.skipWhitespace()}readIdentifier(){for(var e=this._currPosition;this.isIdentifier(this._char);)this.readChar();return this._source.substring(e,this._currPosition)}isIdentifier(e){var t=e.charCodeAt(0);return 97<=t&&t<=122||65<=t&&t<=90||48<=t&&t<=57||t==95}skipWhitespace(){for(;this.IsWhitespace(this._char);)this.readChar()}IsWhitespace(e){return e===" "||e==="	"||e==="\r"||e===`
`}skipComment(){for(;this._char!==`
`&&this._char!=="\0";)this.readChar();this.skipWhitespace()}skipMultilineComment(){if(!(this._char!=="/"&&this.peekChar()!=="*")){this.readChar(),this.readChar();for(let e=1;e>0&&this._char!=="\0";)if(this.readChar(),this._char==="/"&&this.peekChar()==="*"){e++,this.readChar();continue}else if(this._char==="*"&&this.peekChar()==="/"){e--,this.readChar();continue}this.readChar(),this.readChar(),this.skipWhitespace()}}isDigit(e){var t=e.charCodeAt(0);return 48<=t&&t<=57}readNumber(){for(var e=this._currPosition;this.isDigit(this._char);)this.readChar();if(this._char===".")for(this.readChar();this.isDigit(this._char);)this.readChar();return this._source.substring(e,this._currPosition)}readValue(){return this.isDigit(this._char)?this.readNumber():this.readIdentifier()}readLine(){var e=this._currPosition,t=this._source.indexOf(`
`,this._currPosition);return t==-1&&(t=this._source.length),this._line++,this._column=0,this._currPosition=t,this._nextPosition=t+1,this._source.substring(e,t+1)}}class gu extends or{constructor(e){super(e.source),n(this,"_tokenPosition",0),n(this,"_tokens",[]),this.parse()}skipToken(e){this._tokenPosition+=e}peekToken(e){return this._tokenPosition+e>=this._tokens.length?new $r(x.EOF,"\0"):this._tokens[this._tokenPosition+e]}GetNextToken(){if(this._tokenPosition>=this._tokens.length)return new $r(x.EOF,"\0");let e=this._tokens[this._tokenPosition];return this._tokenPosition++,e}get currTokenPosition(){return this._tokenPosition}parse(){this.readChar(),this._tokens=new Array;var e;do e=this.nextToken(),this._tokens.push(e);while(e.Type!=x.EOF)}nextToken(){if(this.skipWhitespace(),this._char==="/"){if(this.peekChar()==="/")return this.skipComment(),this.nextToken();if(this.peekChar()==="*")return this.skipMultilineComment(),this.nextToken()}var e=new $r;switch(e.Line=this._line,e.Colume=this._column,this._char){case"\0":e.Type=x.EOF,e.Literal="EOF";break;case".":e.Type=x.DOT,e.Literal=".";break;case",":e.Type=x.COMMA,e.Literal=",";break;case":":e.Type=x.COLON,e.Literal=":";break;case"?":e.Type=x.QUEMARK,e.Literal="?";break;case";":e.Type=x.SEMICOLON,e.Literal=";";break;case"(":e.Type=x.LEFTSAMLL,e.Literal="(";break;case")":e.Type=x.RIGHTSAMLL,e.Literal=")";break;case"[":e.Type=x.LEFTMEDI,e.Literal="[";break;case"]":e.Type=x.RIGHTMEDI,e.Literal="]";break;case"{":e.Type=x.LEFTBIG,e.Literal="{";break;case"}":e.Type=x.RIGHTBIG,e.Literal="}";break;case"+":if(this.peekChar()==="+"){this.readChar(),e.Type=x.INC,e.Literal="++";break}else if(this.peekChar()==="="){this.readChar(),e.Type=x.ADDASSIGN,e.Literal="+=";break}e.Type=x.ADD,e.Literal="+";break;case"-":if(this.peekChar()==="-"){this.readChar(),e.Type=x.DEC,e.Literal="--";break}else if(this.peekChar()==="="){this.readChar(),e.Type=x.SUBASSIGN,e.Literal="-=";break}e.Type=x.SUB,e.Literal="-";break;case"*":if(this.peekChar()==="="){this.readChar(),e.Type=x.MULASSIGN,e.Literal="*=";break}e.Type=x.MUL,e.Literal="*";break;case"/":if(this.peekChar()==="="){this.readChar(),e.Type=x.DIVASSIGN,e.Literal="/=";break}e.Type=x.DIV,e.Literal="/";break;case"&":if(this.peekChar()==="&"){this.readChar(),e.Type=x.AND,e.Literal="&&";break}e.Type=x.BITAND,e.Literal="&";break;case"|":if(this.peekChar()==="|"){this.readChar(),e.Type=x.OR,e.Literal="||";break}e.Type=x.BITOR,e.Literal="&";break;case"^":e.Type=x.BITXOR,e.Literal="^";break;case"!":if(this.peekChar()==="="){this.readChar(),e.Type=x.NOTEQUAL,e.Literal="!=";break}e.Type=x.NOT,e.Literal="!";break;case">":if(this.peekChar()==="="){this.readChar(),e.Type=x.GREATEREQUAL,e.Literal=">=";break}else if(this.peekChar()===">"){this.readChar(),e.Type=x.BITSHIFT_R,e.Literal=">>";break}e.Type=x.GREATER,e.Literal=">";break;case"=":if(this.peekChar()==="="){this.readChar(),e.Type=x.EQUAL,e.Literal="==";break}e.Type=x.ASSIGN,e.Literal="=";break;case"<":if(this.peekChar()==="="){this.readChar(),e.Type=x.LESSEQUAL,e.Literal="<=";break}else if(this.peekChar()==="<"){this.readChar(),e.Type=x.BITSHIFT_L,e.Literal="<<";break}e.Type=x.LESS,e.Literal="<";break;default:return this.isDigit(this._char)?this.readDecimal():(e.Literal=this.readIdentifier(),e.Type=this.lookupIdentifier(e.Literal),this.getChar()=="["&&this.peekChar()=="]"&&e.isBuiltinType()&&(e.Type++,e.Literal+="[]",this.readChar(),this.readChar()),e)}return this.readChar(),e}readDecimal(){var e=new $r;e.Line=this._line,e.Colume=this._column,e.Type=x.LITERAL;var t=this.readNumber();return this._char==="e"?(e.Literal=t+this._char,this.readChar(),e.Literal+=this._char,this.readChar(),e.Literal+=this.readNumber(),e.Type=x.LITERAL,e):this._char==="u"?(this.readChar(),e.Type=x.LITERAL,e.Literal=t+"u",e):this._char==="f"?(this.readChar(),e.Type=x.LITERAL,e.Literal=t+"f",e):(e.Type=x.LITERAL,e.Literal=t,e)}lookupIdentifier(e){switch(e){case"void":return x.VOID;case"int":return x.INT;case"uint":return x.UINT;case"bool":return x.BOOL;case"true":return x.BOOL;case"false":return x.BOOL;case"float":return x.FLOAT;case"vec2":return x.VEC2;case"vec3":return x.VEC3;case"vec4":return x.VEC4;case"bvec2":return x.BVEC2;case"bvec3":return x.BVEC3;case"bvec4":return x.BVEC4;case"ivec2":return x.IVEC2;case"ivec3":return x.IVEC3;case"ivec4":return x.IVEC4;case"uvec2":return x.UVEC2;case"uvec3":return x.UVEC3;case"uvec4":return x.UVEC4;case"mat2":return x.MAT2x2;case"mat2x2":return x.MAT2x2;case"mat2x3":return x.MAT2x3;case"mat2x4":return x.MAT2x4;case"mat3":return x.MAT3x3;case"mat3x2":return x.MAT3x2;case"mat3x3":return x.MAT3x3;case"mat3x4":return x.MAT3x4;case"mat4":return x.MAT4x4;case"mat4x2":return x.MAT4x2;case"mat4x3":return x.MAT4x3;case"mat4x4":return x.MAT4x4;case"sampler":return x.SAMPLER;case"sampler1D":return x.SAMPLER_1D;case"sampler2D":return x.SAMPLER_2D;case"sampler3D":return x.SAMPLER_3D;case"samplerCube":return x.SAMPLER_CUBE;case"samplerShadow":return x.SAMPLER_SHADOW;case"sampler1DShadow":return x.SAMPLER_1D_SHADOW;case"sampler2DShadow":return x.SAMPLER_2D_SHADOW;case"texture1D":return x.TEXTURE_1D;case"texture2D":return x.TEXTURE_2D;case"texture3D":return x.TEXTURE_3D;case"textureCube":return x.TEXTURE_CUBE;case"texture1DArray":return x.TEXTURE_1D_ARRAY;case"texture2DArray":return x.TEXTURE_2D_ARRAY;case"textureCubeArray":return x.TEXTURE_CUBE_ARRAY;case"const":return x.CONST;case"layout":return x.LAYOUT;case"precision":return x.PRECISION;case"attribute":return x.ATTRIBUTE;case"uniform":return x.UNIFORM;case"varying":return x.VARYING;case"invariant":return x.INVARIANT;case"in":return x.IN;case"out":return x.OUT;case"inout":return x.INOUT;case"if":return x.IF;case"else":return x.ELSE;case"for":return x.FOR;case"while":return x.WHILE;case"do":return x.DO;case"break":return x.BREAK;case"return":return x.RETURN;case"continue":return x.CONTINUE;case"struct":return x.STRUCT}return x.IDENT}}class Ng{constructor(){n(this,"name",""),n(this,"value",""),n(this,"args",[])}}class pu extends or{constructor(e){super(e),n(this,"_result"),n(this,"_skipLine"),n(this,"_definitionTables"),this._result="",this._skipLine=!1,this._definitionTables=new Map,this.parse()}parse(){for(this.readChar();this._char!=="\0";){if(this.skipWhitespace(),this._char==="/"){if(this.peekChar()==="/"){this.skipComment();continue}if(this.peekChar()==="*"){this.skipMultilineComment();continue}}if(this._char==="#"){this.readCharAndSkipWhitespace();var e=this.readIdentifier();switch(e){case"version":this.readLine().trim();break;case"define":this.readCharAndSkipWhitespace();var t=this.readIdentifier();if(this.getChar()==="("){let l=new Ng;if(this.readCharAndSkipWhitespace(),this.getChar()!==")")do{var r=this.readIdentifier();if(l.args.push(r),this.skipWhitespace(),this.getChar()===","){this.readCharAndSkipWhitespace();continue}}while(this.getChar()!==")");this.readCharAndSkipWhitespace(),l.name=t,l.value=this.readLine().trim(),this._definitionTables.set(t,l),this.readCharAndSkipWhitespace()}else{let l=this.readLine().trim();l[0]=="="&&(l=l.substring(1)),this._definitionTables.set(t,l)}break;case"if":let o=this.readLine().trim();if(o=="0"||o=="false"){this._skipLine=!0;break}if(this._definitionTables.has(o)&&(o=this._definitionTables.get(o),o=="0"||o=="false")){this._skipLine=!0;break}break;case"ifdef":this.readCharAndSkipWhitespace();var a=this.readIdentifier();this._skipLine=!this._definitionTables.has(a);break;case"else":this._skipLine=!this._skipLine;break;case"endif":this._skipLine=!1;break;default:throw"Unknown preprocessing command:"+e}}else{var s=this.readLine();if(!this._skipLine){for(let o of this._definitionTables.keys()){let l=s.indexOf(o);if(l!=-1){let h=this._definitionTables.get(o);if(typeof h=="string")s=s.replace(o,h);else{let u=h,c=new or(s.substring(l+o.length));if(c.readCharAndSkipWhitespace(),c.getChar()==="("){c.readCharAndSkipWhitespace();for(let A=1;c.getChar()!=="\0"&&A>0;){switch(c.getChar()){case"(":A++;break;case")":A--;break}c.readCharAndSkipWhitespace()}}let d=l,g=d+o.length+c.currPosition,m=s.substring(d,g).trim();if(u.args.length>0){let A=[],v=m.substring(m.indexOf("(")+1,m.lastIndexOf(")")).trim();v.length>0&&(A=this.parseArgs(v));let y=u.value.substring(u.value.indexOf("("));for(let C=0;C<u.args.length;C++)y=y.replace(u.args[C],A[C]);y=u.value.substring(0,u.value.indexOf("("))+y,s=s.replace(m,y)}else s=s.replace(m,u.value)}}}this._result+=s}this.readChar()}}}get source(){return this._result}parseArgs(e){let t=[],r=0,a=new or(e),s=a.currPosition;if(a.readCharAndSkipWhitespace(),a.getChar()!=="\0")for(a.readCharAndSkipWhitespace();a.getChar()!=="\0";){switch(a.getChar()){case"(":r++;break;case")":r--;break;case",":if(r==0){let o=e.substring(s,a.currPosition);t.push(o),s=a.currPosition+1}break}a.readCharAndSkipWhitespace()}if(s<a.currPosition){let o=e.substring(s,a.currPosition);t.push(o)}return t}}class mu{constructor(e){n(this,"result"),n(this,"ASTRoot"),n(this,"_syntax"),this.result="",this._syntax=e,this.ASTRoot=e.ASTRoot}generateWGSL(){let e=new mn;var t=new xu;let r=[],a=[],s=[];for(let c of this.ASTRoot.nodes)if(c instanceof ra)if(c.scope=="in")if(c.nodes[0]instanceof Te){e.layoutsIn.push(c);let d=new _n;d.name=c.nodes[0].name,d.type=c.nodes[0].type,d.locationID=Number.parseInt(c.qualifier.get("location")),t.inputAttribute.push(d)}else if(c.qualifier.has("local_size_x"))e.workGroupSize=c;else throw"not impl";else if(c.scope=="out")if(e.layoutsOut.push(c),c.nodes[0]instanceof Te){let d=new _n;d.name=c.nodes[0].name,d.type=c.nodes[0].type,d.locationID=Number.parseInt(c.qualifier.get("location")),t.outputAttribute.push(d)}else throw"not impl";else if(c.scope=="uniform")if(a.push(c),c.nodes[0]instanceof Te){let d=new An;d.name=c.nodes[0].name,d.type=c.nodes[0].type,d.setID=Number.parseInt(c.qualifier.get("set")),d.bindingID=Number.parseInt(c.qualifier.get("binding")),t.uniformInfo.push(d)}else if(c.nodes[0]instanceof ti){let d=new An;d.name="unif"+t.uniformInfo.length.toString(),d.type=c.nodes[0].name,d.setID=Number.parseInt(c.qualifier.get("set")),d.bindingID=Number.parseInt(c.qualifier.get("binding")),t.uniformInfo.push(d)}else throw"not impl";else c.scope=="buffer"&&r.push(c);else s.push(c);e.stage="fragment";let o=0,l=new or(""),h=this._syntax.lexer.source,u=new Map;for(;(o=h.indexOf("gl_",o))!=-1;){l.reset(h.substring(o,o+32)),l.readChar();let c=l.readIdentifier();if(o+=c.length,!u.has(c))switch(u.set(c,c),c){case"gl_InstanceID":e.stage="vertex",e.builtinIn.push("@builtin(instance_index) gl_InstanceID: u32");break;case"gl_Position":e.stage="vertex",e.builtinOut.push("@builtin(position) gl_Position: vec4<f32>"),e.addIdentifier("gl_Position","stout.gl_Position");break;case"gl_VertexIndex":e.stage="vertex",e.builtinIn.push("@builtin(vertex_index) gl_VertexIndex: u32");break;case"gl_FrontFacing":e.stage="fragment",e.builtinIn.push("@builtin(front_facing) gl_FrontFacing: bool");break;case"gl_FragDepth":e.stage="fragment",e.builtinOut.push("@builtin(frag_depth) gl_FragDepth: f32"),e.addIdentifier("gl_FragDepth","stout.gl_FragDepth");break;case"gl_WorkGroupID":e.stage="compute",e.builtinIn.push("@builtin(workgroup_id) gl_WorkGroupID: vec3<u32>");break;case"gl_NumWorkGroups":e.stage="compute",e.builtinIn.push("@builtin(num_workgroups) gl_NumWorkGroups: vec3<u32>");break;case"gl_LocalInvocationID":e.stage="compute",e.builtinIn.push("@builtin(local_invocation_id) gl_LocalInvocationID: vec3<u32>");break;case"gl_LocalInvocationIndex":e.stage="compute",e.builtinIn.push("@builtin(local_invocation_index) gl_LocalInvocationIndex: u32");break;case"gl_GlobalInvocationID":e.stage="compute",e.builtinIn.push("@builtin(global_invocation_id) gl_GlobalInvocationID: vec3<u32>");break;default:throw"Unprocessed built-in variables: "+c}}for(let c of a)c.nodes[0]instanceof ti&&(t.sourceCode+=c.nodes[0].formatToWGSL(e,0),t.sourceCode+=`\r
`);for(let c of a)t.sourceCode+=c.formatToWGSL(e,0);t.sourceCode+=`\r
`;for(let c of r)c.nodes[0]instanceof ti&&(t.sourceCode+=c.nodes[0].formatToWGSL(e,0),t.sourceCode+=`\r
`);for(let c of r)t.sourceCode+=c.formatToWGSL(e,0);t.sourceCode+=`\r
`;for(let c of s)t.sourceCode+=c.formatToWGSL(e,0),c instanceof Te&&(t.sourceCode+=`;\r
`);return t}}class mn{constructor(e){n(this,"_stage","fragment"),n(this,"_builtinIn",[]),n(this,"_builtinOut",[]),n(this,"_layoutsIn",[]),n(this,"_layoutsOut",[]),n(this,"_layoutUniformCount",0),n(this,"_workGroupSize"),n(this,"_parentContext"),n(this,"_identifierEnv",new Map),this._parentContext=e}get stage(){return this.parentContext!=null?this.parentContext.stage:this._stage}set stage(e){this.parentContext!=null&&(this.parentContext.stage=e),this._stage=e}get builtinIn(){return this.parentContext!=null?this.parentContext.builtinIn:this._builtinIn}get builtinOut(){return this.parentContext!=null?this.parentContext.builtinOut:this._builtinOut}get layoutsIn(){return this.parentContext!=null?this.parentContext.layoutsIn:this._layoutsIn}get layoutsOut(){return this.parentContext!=null?this.parentContext.layoutsOut:this._layoutsOut}get layoutUniformCount(){return this.parentContext!=null?this.parentContext.layoutUniformCount:this._layoutUniformCount}set layoutUniformCount(e){if(this.parentContext!=null){this.parentContext.layoutUniformCount=e;return}this._layoutUniformCount=e}get workGroupSize(){return this.parentContext!=null?this.parentContext.workGroupSize:this._workGroupSize}set workGroupSize(e){this.parentContext!=null&&(this.parentContext.workGroupSize=e),this._workGroupSize=e}get parentContext(){return this._parentContext}findIdentifier(e){return this._identifierEnv.has(e)?this._identifierEnv.get(e):this._parentContext!=null?this._parentContext.findIdentifier(e):e}addIdentifier(e,t){this._identifierEnv.set(e,t)}hasIdentifier(e){return this._identifierEnv.has(e)}}class ge{constructor(){n(this,"nodes",[])}addNode(e){this.nodes.push(e)}formatToWGSL(e,t){return""}}class ti extends ge{constructor(e){super(),n(this,"name",""),n(this,"fields",[]),this.name=e}static parse(e){if(e.peekToken(0).Type==x.IDENT&&e.peekToken(1).Type==x.LEFTBIG){let t=new ti(e.peekToken(0).Literal);for(e.skipToken(2);e.peekToken(0).Type!=x.RIGHTBIG;){let r=Te.parse(e);t.fields.push(r)}return e.peekToken(0).Type==x.RIGHTBIG&&e.skipToken(1),e.peekToken(0).Type==x.SEMICOLON&&e.skipToken(1),t}throw"Error parsing structure: Unexpected character"}formatToWGSL(e,t){let r="",a=t<=0?"":"    ".repeat(t);r+=a+"struct "+this.name+` {\r
`;for(let s of this.fields)s.arraySize.nodes.length<=0?r+=a+"  "+s.name+": "+bt(s.type)+`,\r
`:s.arraySize.nodes[0]instanceof ri?r+=a+"  "+s.name+": array<"+bt(s.type)+", "+s.arraySize.nodes[0].value+`>,\r
`:r+=a+"  "+s.name+": array<"+bt(s.type)+", "+s.arraySize.nodes[0].formatToWGSL(e,0)+`>,\r
`;return r+=a+`};\r
`,r}}class Za extends ge{constructor(e,t,r,a){super(),n(this,"name"),n(this,"args"),n(this,"body"),n(this,"returnType"),this.name=e,this.args=t,this.body=r,this.returnType=a}static parse(e){if((e.peekToken(0).isBuiltinType()||e.peekToken(0).Type==x.VOID)&&e.peekToken(1).Type==x.IDENT&&e.peekToken(2).Type==x.LEFTSAMLL){let t=e.peekToken(0).Literal,r=e.peekToken(1).Literal;e.skipToken(2);let a=new Array;if(e.peekToken(0).Type!=x.LEFTSAMLL)throw"Error parsing function parameter list: Unexpected character";for(e.skipToken(1);e.peekToken(0).Type!=x.EOF;){if(e.peekToken(0).Type==x.RIGHTSAMLL){e.skipToken(1);break}(e.peekToken(0).Type==x.INOUT||e.peekToken(0).Type==x.IN||e.peekToken(0).Type==x.OUT)&&e.skipToken(1);let o=Te.parse(e);a.push(o),e.peekToken(0).Type==x.COMMA&&e.skipToken(1)}let s=Lt.parse(e);return new Za(r,a,s,t)}throw"Error parsing function: Unexpected character"}formatToWGSL(e,t){let r="",a=t<=0?"":"    ".repeat(t),s,o=e.layoutsOut.length>0||e.builtinOut.length>0;switch(e.stage){case"compute":s="ComputeOutput";break;case"vertex":s="VertexOutput";break;case"fragment":s="FragmentOutput";break;default:s="StructOutput";break}if(this.name=="main"&&o){r+="struct "+s+` {\r
`;for(let c of e.layoutsOut)if(c.nodes[0]instanceof Te){let d=c.nodes[0];c.qualifier.size==1&&c.qualifier.has("location")&&(r+="  @location("+c.qualifier.get("location")+") "),r+=d.name+": "+bt(d.type)+`,\r
`,e.addIdentifier(d.name,"stout."+d.name)}let u=e.builtinOut;for(let c of u)r+="  "+c+`,\r
`;r+=`};\r
\r
`}let l="";if(this.name=="main"&&(e.workGroupSize!=null?l+="@"+e.stage+" "+e.workGroupSize.formatToWGSL(e,0)+` \r
`:l+="@"+e.stage+`\r
`),e=new mn(e),l+=a+"fn "+this.name+"(",this.name!="main"){for(let u=0;u<this.args.length;u++){let c=this.args[u];u>0&&(l+=", "),l+=c.name+": "+bt(c.type),e.addIdentifier(c.name,c.name)}l+=") -> "+bt(this.returnType)}else{let u=e.layoutsIn;for(let d=0;d<u.length;d++){let g=u[d];if(d>0?l+=`,\r
    `:l+=`\r
    `,g.nodes[0]instanceof Te){let m=g.nodes[0];g.qualifier.size==1&&g.qualifier.has("location")&&(l+="@location("+g.qualifier.get("location")+") "),l+=m.name+": "+bt(m.type),e.addIdentifier(m.name,m.name)}}u.length>0&&(l+=`,\r
    `);let c=e.builtinIn;for(let d of c)l+=d+`,\r
    `;o?l+=") -> "+s:l+=") "}let h="";this.name=="main"&&o&&(h+="    var stout: "+s+` ;\r
`);for(let u of this.body.nodes)h+=u.formatToWGSL(e,t+1),!(u instanceof Ui)&&!(u instanceof Li)&&!(u instanceof Ri)&&(h+=`;\r
`);return this.name=="main"&&o&&(h+=`    return stout;\r
`),r+=l+` {\r
`,r+=h,r+=a+`}\r
`,r+=`\r
`,r}}class $a extends ge{constructor(){super(),n(this,"args",[])}static parse(e){if(e.peekToken(0).Type==x.LEFTSAMLL){e.skipToken(1);let t=new $a;for(;e.peekToken(0).Type!=x.EOF;){if(e.peekToken(0).Type==x.RIGHTSAMLL){e.skipToken(1);break}let r=ie.parse(e);t.args.push(r),e.peekToken(0).Type==x.COMMA&&e.skipToken(1)}return t}throw"Error parsing function argument table: Unexpected character"}}class Pi extends ge{constructor(e,t){super(),n(this,"name"),n(this,"args"),this.name=e,this.args=t}static parse(e){if(e.peekToken(0).isDataType()&&e.peekToken(1).Type==x.LEFTSAMLL){let t=e.peekToken(0).Literal;e.skipToken(1);let r=$a.parse(e);return new Pi(t,r)}throw"Error parsing function argument table: Unexpected character"}formatToWGSL(e,t){let r="",a=t<=0?"":"    ".repeat(t);if(this.name=="texture"&&this.args.args[0].nodes[0]instanceof Pi){let s=this.args.args[0].nodes[0];if(s.name=="sampler2D"){r+=a+"textureSample(";for(let o=0;o<s.args.args.length;o++){let l=s.args.args[o];o>0&&(r+=", "),r+=l.formatToWGSL(e,0)}for(let o=1;o<this.args.args.length;o++){let l=this.args.args[o];o>0&&(r+=", "),r+=l.formatToWGSL(e,0)}return r+=")",r}}r+=a+bt(this.name)+"(";for(let s=0;s<this.args.args.length;s++){let o=this.args.args[s];s>0&&(r+=", "),r+=o.formatToWGSL(e,0)}return r+=")",r}}class Te extends ge{constructor(e,t,r=new ie){super(),n(this,"type"),n(this,"name"),n(this,"arraySize"),n(this,"hasIn"),n(this,"hasOut"),n(this,"hasConst"),this.type=e,this.name=t,this.hasIn=!1,this.hasOut=!1,this.hasConst=!1,this.arraySize=r}static parse(e){let t=new Te("",""),r=e.peekToken(0);if(r.Type==x.CONST)e.skipToken(1),t.hasConst=!0;else if(r.Type==x.IN)e.skipToken(1),t.hasIn=!0;else if(r.Type==x.OUT)e.skipToken(1),t.hasOut=!0;else if(r.Type==x.INOUT)e.skipToken(1),t.hasIn=!0,t.hasOut=!0;else if(!r.isDataType())throw"Error parsing declaration expression: Unexpected character("+r.Literal+")";if(r=e.peekToken(0),r.isDataType()&&e.peekToken(1).Type==x.LEFTMEDI){if(t.type=r.Literal,e.skipToken(2),t.arraySize=ie.parse(e),e.peekToken(0).Type==x.RIGHTMEDI&&e.skipToken(1),e.peekToken(0).Type!=x.IDENT)throw"Unexpected";t.name=e.peekToken(0).Literal,e.skipToken(1)}else if(r.isDataType()&&e.peekToken(1).Type==x.IDENT&&e.peekToken(2).Type==x.LEFTMEDI)t.type=e.peekToken(0).Literal,t.name=e.peekToken(1).Literal,e.skipToken(3),e.peekToken(0).Type==x.RIGHTMEDI?e.skipToken(1):(t.arraySize=ie.parse(e),e.peekToken(0).Type==x.RIGHTMEDI&&e.skipToken(1));else if(r.isDataType()&&e.peekToken(1).Type==x.IDENT)t.type=e.peekToken(0).Literal,t.name=e.peekToken(1).Literal,e.skipToken(2);else throw"Error parsing declaration expression: Unexpected character("+r.Literal+")";if(r=e.peekToken(0),r.Type==x.SEMICOLON)return e.skipToken(1),t;if(r.Type==x.RIGHTSAMLL)return t;if(r.Type==x.ASSIGN){let a=e.peekToken(0);e.skipToken(1);let s=new ii(t.name),o=ie.parse(e);return e.peekToken(0).Type==x.SEMICOLON&&e.skipToken(1),t.addNode(new _i(a,s,o)),t}else if(r.Type==x.COMMA){for(;e.peekToken(0).Type==x.COMMA&&e.peekToken(1).Type==x.IDENT;){let a=new Te(t.type,e.peekToken(1).Literal);t.addNode(a),e.skipToken(2),e.peekToken(0).Type==x.ASSIGN&&(e.skipToken(-1),a.addNode(ie.parse(e)))}return t}throw"Error parsing declaration expression: Unexpected character("+e.peekToken(0).Literal+")"}formatToWGSL(e,t){let r="",a=t<=0?"":"    ".repeat(t);if(this.hasConst?r+=a+"let ":r+=a+"var ",e.addIdentifier(this.name,this.name),this.arraySize.nodes.length<=0?r+=this.name+": "+bt(this.type):this.arraySize.nodes[0]instanceof ri?r+=this.name+": array<"+bt(this.type)+", "+this.arraySize.nodes[0].value+">":r+=this.name+": array<"+bt(this.type)+", "+this.arraySize.nodes[0].formatToWGSL(e,0)+">",this.nodes.length>0&&this.nodes[0]instanceof _i)r+=" = "+this.nodes[0].rightValue.formatToWGSL(e,0);else if(this.nodes.length>0&&this.nodes[0]instanceof ie&&this.nodes[0].nodes[0]instanceof _i)r+=" = "+this.nodes[0].nodes[0].rightValue.formatToWGSL(e,0);else if(this.nodes.length>0&&this.nodes[0]instanceof Te){r+=`;\r
`;for(let s of this.nodes)r+=s.formatToWGSL(e,t)+`;\r
`}else r+=`;\r
`;return r}}class Ri extends ge{constructor(e,t,r,a){super(),n(this,"expression1"),n(this,"condition"),n(this,"expression2"),n(this,"loopBody"),this.expression1=e,this.condition=t,this.expression2=r,this.loopBody=a}static parse(e){if(e.peekToken(0).Type==x.FOR&&e.peekToken(1).Type==x.LEFTSAMLL){e.skipToken(2);let t;e.peekToken(0).Type==x.SEMICOLON?(e.skipToken(1),t=new ie):e.peekToken(0).isDataType()&&e.peekToken(1).Type==x.IDENT&&e.peekToken(2).Type==x.ASSIGN?(t=new Te(e.peekToken(0).Literal,e.peekToken(1).Literal),e.skipToken(1),t.addNode(ie.parse(e)),e.peekToken(0).Type==x.SEMICOLON&&e.skipToken(1)):(t=ie.parse(e),e.peekToken(0).Type==x.SEMICOLON&&e.skipToken(1));let r;e.peekToken(0).Type==x.SEMICOLON?(e.skipToken(1),r=new ie):(r=ie.parse(e),e.peekToken(0).Type==x.SEMICOLON&&e.skipToken(1));let a;e.peekToken(0).Type==x.SEMICOLON?(e.skipToken(1),a=new ie):(a=ie.parse(e),e.peekToken(0).Type==x.SEMICOLON&&e.skipToken(1)),e.peekToken(0).Type==x.RIGHTSAMLL&&e.skipToken(1);let s;return e.peekToken(0).Type==x.LEFTBIG?s=Lt.parse(e):s=new Lt,new Ri(t,r,a,s)}throw"Error parsing for loop: Unexpected character"}formatToWGSL(e,t){let r="",a=t<=0?"":"    ".repeat(t);r+=a+"for (",r+=this.expression1.formatToWGSL(e,0)+"; ",r+=this.condition.formatToWGSL(e,0)+"; ",r+=this.expression2.formatToWGSL(e,0)+")",r+=` { \r
`;for(let s of this.loopBody.nodes)r+=s.formatToWGSL(e,t+1),!(s instanceof Ui)&&!(s instanceof Li)&&!(s instanceof Ri)&&(r+=`;\r
`);return r+=a+`} \r
`,r}}class Li extends ge{constructor(e,t){super(),n(this,"conditionExpr"),n(this,"loopBody"),this.conditionExpr=e,this.loopBody=t}static parse(e){if(e.peekToken(0).Type==x.WHILE){e.skipToken(1),e.peekToken(0).Type==x.LEFTSAMLL&&e.skipToken(1);let t=ie.parse(e);e.peekToken(0).Type==x.RIGHTSAMLL&&e.skipToken(1);let r=Lt.parse(e);return new Li(t,r)}throw"Error parsing while loop: Unexpected character"}formatToWGSL(e,t){let r="",a=t<=0?"":"    ".repeat(t);r+=a+`loop {\r
`,r+=a+"    if ("+this.conditionExpr.formatToWGSL(e,0)+`) { break; }\r
\r
`;for(let s of this.loopBody.nodes)r+=s.formatToWGSL(e,t+1),!(s instanceof Ui)&&!(s instanceof Li)&&!(s instanceof Ri)&&(r+=`;\r
`);return r+=a+`}\r
`,r}}class Fg extends ge{constructor(){super()}}class Ui extends ge{constructor(e,t,r){super(),n(this,"conditionExpr"),n(this,"trueBranch"),n(this,"falseBranch"),this.conditionExpr=e,this.trueBranch=t,this.falseBranch=r}static parse(e){if(e.peekToken(0).Type==x.IF){e.skipToken(1),e.peekToken(0).Type==x.LEFTSAMLL&&e.skipToken(1);let t=ie.parse(e),r,a=new Lt;if(e.peekToken(0).Type==x.RIGHTSAMLL&&e.skipToken(1),e.peekToken(0).Type==x.LEFTBIG?r=Lt.parse(e):(r=new Lt,e.peekToken(0).Type==x.RETURN?r.addNode(ta.parse(e)):r.addNode(ie.parse(e))),e.peekToken(0).Type==x.ELSE)if(e.skipToken(1),e.peekToken(0).Type==x.LEFTBIG)a=Lt.parse(e);else throw"not impl";return new Ui(t,r,a)}throw"Error parsing IF branch statement: Unexpected character"}formatToWGSL(e,t){let r="",a=t<=0?"":"    ".repeat(t);r+=a+"if ("+this.conditionExpr.formatToWGSL(e,0)+`) {\r
`;for(let s of this.trueBranch.nodes)r+=s.formatToWGSL(e,t+1)+`;\r
`;if(this.falseBranch.nodes.length>0){r+=a+`} else {\r
`;for(let s of this.falseBranch.nodes)r+=s.formatToWGSL(e,t+1)+`;\r
`}return r+=a+`}\r
`,r}}class ie extends ge{constructor(){super()}static parse(e){let t=new Array,r=new Array,a=0;for(;e.peekToken(0).Type!=x.EOF;){let s=e.peekToken(0);if(s.Type==x.SEMICOLON||s.Type==x.RIGHTMEDI||s.Type==x.COMMA||s.Type==x.COLON||s.Type==x.RIGHTBIG)break;if(s.isOperation()){if(s.isOperation()){if(s.Type==x.INC||s.Type==x.DEC){let o=s;e.skipToken(1);let l=ie.parse(e);r.push(new lr(o,void 0,l));continue}else if(t.length>0){if(t[t.length-1].nOperationPriorityLevel<=s.nOperationPriorityLevel)ie.unionOperation(t,r);else if(t.length>0&&t[t.length-1].Literal=="-"){let l=t.pop(),h=r.pop();r.push(new lr(l,void 0,h))}}t.push(s),e.skipToken(1)}}else if(s.Type==x.LITERAL){r.push(new ri(s.Literal)),e.skipToken(1);continue}else if(s.Type==x.LEFTSAMLL){a++,t.push(s),e.skipToken(1);continue}else if(s.Type==x.RIGHTSAMLL){if(a<=0)break;for(a--;ie.unionOperation(t,r););if(t[t.length-1].Type==x.LEFTSAMLL){t.pop();let o=new Au;o.addNode(r.pop()),r.push(o)}e.skipToken(1);continue}else if(s.Type==x.IDENT){if(e.peekToken(1).Type==x.INC||e.peekToken(1).Type==x.DEC){let o=e.peekToken(1),l=new ii(s.Literal);r.push(new lr(o,l,void 0)),e.skipToken(2);continue}else if(e.peekToken(1).Type==x.LEFTSAMLL){r.push(Pi.parse(e));continue}else if(e.peekToken(1).Type==x.DOT){r.push(ia.parse(e));continue}else if(e.peekToken(1).Type==x.LEFTMEDI){r.push(Oi.parse(e));continue}r.push(new ii(s.Literal)),e.skipToken(1);continue}else{if(s.isBuiltinType()&&e.peekToken(1).Type==x.LEFTSAMLL){r.push(Pi.parse(e));continue}if(s.isAssignOperation()){let o=s;e.skipToken(1);let l=r.pop(),h=ie.parse(e);r.push(new _i(o,l,h));continue}if(s.Type==x.LEFTBIG&&(e.peekToken(1).Type==x.LITERAL||e.peekToken(1).Type==x.SUB&&e.peekToken(2).Type==x.LITERAL)){r.push(ea.parse(e));continue}if(s.Type==x.QUEMARK){t.length>0&&t[t.length-1].nOperationPriorityLevel<=s.nOperationPriorityLevel&&ie.unionOperation(t,r),e.skipToken(1);let o=r.pop(),l=ie.parse(e);e.peekToken(0).Type==x.COLON&&e.skipToken(1);let h=ie.parse(e);if(r.push(new _u(o,l,h)),e.peekToken(-1).Type==x.SEMICOLON)break;continue}if(s.Type==x.LEFTMEDI){e.skipToken(1);let o=ie.parse(e);e.peekToken(0).Type==x.RIGHTMEDI&&e.skipToken(1);let l=r.pop();r.push(new Oi(l,o));continue}throw"An unexpected character"}}for(;t.length>0&&ie.unionOperation(t,r););if(t.length<=0&&r.length==1){let s=new ie;return s.addNode(r.pop()),s}throw"Error parsing expression: Unexpected character("+e.peekToken(0).Literal+")"}formatToWGSL(e,t){return this.nodes[0].formatToWGSL(e,t)}static unionOperation(e,t){if(e.length<0||t.length<2){if(e.length>0&&e[e.length-1].Literal=="-"){let r=e.pop(),a=t.pop();return t.push(new lr(r,void 0,a)),!0}return!1}if(e[e.length-1].isOperation()){let r=t.pop(),a=e.pop(),s=t.pop();return a.Type==x.DOT?t.push(new ia(s,r)):t.push(new _i(a,s,r)),!0}return!1}}class Au extends ge{constructor(){super()}formatToWGSL(e,t){return(t<=0?"":"    ".repeat(t))+"("+this.nodes[0].formatToWGSL(e,0)+")"}}class ii extends ge{constructor(e){super(),n(this,"name"),this.name=e}formatToWGSL(e,t){return(t<=0?"":"    ".repeat(t))+e.findIdentifier(this.name)}}class ri extends ge{constructor(e){super(),n(this,"value"),this.value=e}static parse(e){let t=e.peekToken(0);if(t.Type==x.SUB&&e.peekToken(1).Type==x.LITERAL){let r=new ri("-"+e.peekToken(1).Literal);return e.skipToken(2),r}else if(t.Type==x.LITERAL){let r=new ri(t.Literal);return e.skipToken(1),r}throw"Error parsing literal constants: Unexpected characters("+t.Literal+")"}formatToWGSL(e,t){return(t<=0?"":"    ".repeat(t))+this.value}}class ea extends ri{constructor(e){super(""),n(this,"arrayValue"),this.arrayValue=e}static parse(e){if(e.peekToken(0).Type==x.LEFTBIG&&e.peekToken(1).Type==x.LITERAL||e.peekToken(0).Type==x.LEFTBIG&&e.peekToken(1).Type==x.SUB&&e.peekToken(2).Type==x.LITERAL){e.skipToken(1);let t=[];for(;e.peekToken(0).Type!=x.RIGHTBIG;){if(e.peekToken(0).Type==x.LEFTSAMLL){t.push(ea.parse(e));continue}if(t.push(ri.parse(e)),e.peekToken(0).Type==x.COMMA){e.skipToken(1);continue}else if(e.peekToken(0).Type==x.RIGHTBIG){e.skipToken(1);break}else throw"Error parsing array constants: Unexpected characters"}return new ea(t)}throw"Error parsing array constants: Unexpected characters"}formatToWGSL(e,t){let r="",a=t<=0?"":"    ".repeat(t);this.arrayValue[0].value.includes(".")?r+=a+"array<f32, "+this.arrayValue.length.toString()+">(":r+=a+"array<i32, "+this.arrayValue.length.toString()+">(";for(let s=0;s<this.arrayValue.length;s++)s>0&&(r+=", "),r+=this.arrayValue[s].formatToWGSL(e,0);return r+=")",r}}class kg extends ge{constructor(){super()}}class zg extends ge{constructor(){super()}}class es extends ge{constructor(){super()}static parse(e){if(e.peekToken(0).Type==x.CONTINUE&&e.peekToken(1).Type==x.SEMICOLON)return e.skipToken(2),new es;throw"Error parsing continue: Unexpected character"}formatToWGSL(e,t){let r="",a=t<=0?"":"    ".repeat(t);return r+=a+"continue",r}}class ta extends ge{constructor(e){super(),n(this,"value"),this.value=e}static parse(e){if(e.peekToken(0).Type==x.RETURN){e.skipToken(1);let t=ie.parse(e);return e.peekToken(0).Type==x.SEMICOLON&&e.skipToken(1),new ta(t)}throw"Error parsing return expression: Unexpected character"}formatToWGSL(e,t){let r="",a=t<=0?"":"    ".repeat(t);return r+=a+"return "+this.value.formatToWGSL(e,0),r}}class lr extends ge{constructor(e,t,r){super(),n(this,"op"),n(this,"leftValue"),n(this,"rightValue"),this.op=e,this.leftValue=t,this.rightValue=r}formatToWGSL(e,t){let r="",a=t<=0?"":"    ".repeat(t);if(this.op.Literal=="++"||this.op.Literal=="--")if(this.leftValue!=null){let s=this.leftValue.formatToWGSL(e,0);r+=a+s+" = "+s+" "+this.op.Literal[0]+" 1"}else{let s=this.rightValue.formatToWGSL(e,0);r+=a+s+" = "+s+" "+this.op.Literal[0]+" 1"}else this.leftValue!=null?r+=a+this.leftValue.formatToWGSL(e,0)+this.op.Literal:r+=a+this.op.Literal+this.rightValue.formatToWGSL(e,0);return r}}class _i extends ge{constructor(e,t,r){super(),n(this,"op"),n(this,"leftValue"),n(this,"rightValue"),this.op=e,this.leftValue=t,this.rightValue=r}formatToWGSL(e,t){let r="",a=t<=0?"":"    ".repeat(t);return r+=a+this.leftValue.formatToWGSL(e,0)+" "+this.op.Literal+" "+this.rightValue.formatToWGSL(e,0),r}}class _u extends ge{constructor(e,t,r){super(),n(this,"condition"),n(this,"expression1"),n(this,"expression2"),this.condition=e,this.expression1=t,this.expression2=r}static parse(e){throw"Error parsing ternary operation expression: Unexpected character"}formatToWGSL(e,t){return""}}class ia extends ge{constructor(e,t){super(),n(this,"leftValue"),n(this,"rightValue"),this.leftValue=e,this.rightValue=t}static parse(e){if(e.peekToken(0).Type==x.IDENT&&e.peekToken(1).Type==x.DOT&&e.peekToken(2).Type==x.IDENT){let t=new ii(e.peekToken(0).Literal),r=new ii(e.peekToken(2).Literal);return e.skipToken(3),new ia(t,r)}throw"Error parsing selection expression: Unexpected character"}formatToWGSL(e,t){return(t<=0?"":"    ".repeat(t))+this.leftValue.formatToWGSL(e,0)+"."+this.rightValue.formatToWGSL(e,0)}}class Oi extends ge{constructor(e,t){super(),n(this,"leftValue"),n(this,"indexValue"),this.leftValue=e,this.indexValue=t}static parse(e){if(e.peekToken(0).Type==x.IDENT&&e.peekToken(1).Type==x.LEFTMEDI){let t=new ii(e.peekToken(0).Literal);e.skipToken(2);let r=ie.parse(e);e.peekToken(0).Type==x.RIGHTMEDI&&e.skipToken(1);let a=new Oi(t,r);for(;e.peekToken(0).Type==x.LEFTMEDI;)e.skipToken(1),r=ie.parse(e),e.peekToken(0).Type==x.RIGHTMEDI&&e.skipToken(1),a=new Oi(a,r);return a}throw"Error parsing index expression: Unexpected character"}formatToWGSL(e,t){return(t<=0?"":"    ".repeat(t))+this.leftValue.formatToWGSL(e,0)+"["+this.indexValue.formatToWGSL(e,0)+"]"}}class Lt extends ge{constructor(){super()}static parse(e){if(e.peekToken(0).Type==x.LEFTBIG){e.skipToken(1);let t=new Lt;for(let r=1;r>0&&e.peekToken(0).Type!=x.EOF;){let a=e.peekToken(0);if(a.Type==x.LEFTBIG){r++,e.skipToken(1);continue}if(a.Type==x.RIGHTBIG){r--,e.skipToken(1);continue}if(a.Type==x.SEMICOLON){e.skipToken(1);continue}if(a.isDataType()&&e.peekToken(1).Type==x.IDENT){t.addNode(Te.parse(e));continue}if(a.Type==x.CONST&&e.peekToken(1).isDataType()&&e.peekToken(2).Type==x.IDENT){t.addNode(Te.parse(e));continue}else if(a.Type==x.IDENT&&e.peekToken(1).Type==x.ASSIGN){t.addNode(ie.parse(e)),e.peekToken(0).Type==x.SEMICOLON&&e.skipToken(1);continue}else if(a.Type==x.IDENT&&e.peekToken(1).Type==x.LEFTMEDI){let s=Oi.parse(e);if(e.peekToken(0).Type==x.ASSIGN){let o=e.peekToken(0);e.skipToken(1);let l=ie.parse(e);e.peekToken(0).Type==x.RIGHTMEDI&&e.skipToken(1),t.addNode(new _i(o,s,l));continue}t.addNode(s);continue}else if(a.Type==x.IDENT&&e.peekToken(1).Type==x.DOT){let s=ie.parse(e);t.addNode(s);continue}else if(a.Type==x.IDENT&&e.peekToken(1).isAssignOperation()){let s=e.peekToken(1),o=new ii(a.Literal);e.skipToken(2);let l=ie.parse(e);e.peekToken(0).Type==x.SEMICOLON&&e.skipToken(1),t.addNode(new _i(s,o,l));continue}else if(a.Type==x.IDENT&&(e.peekToken(1).Type==x.INC||e.peekToken(1).Type==x.DEC)&&e.peekToken(2).Type==x.SEMICOLON){let s=e.peekToken(1);t.addNode(new lr(s,new ii(a.Literal),void 0)),e.skipToken(3);continue}else if(a.Type==x.RETURN){t.addNode(ta.parse(e));continue}else if(a.Type==x.CONTINUE){t.addNode(es.parse(e));continue}else if(a.Type==x.WHILE){t.addNode(Li.parse(e));continue}else if(a.Type==x.FOR){t.addNode(Ri.parse(e));continue}else if(a.Type==x.IF){t.addNode(Ui.parse(e));continue}else if(a.Type==x.IDENT&&e.peekToken(1).Type==x.LEFTSAMLL){t.addNode(Pi.parse(e)),e.peekToken(0).Type==x.SEMICOLON&&e.skipToken(0);continue}throw"Error parsing block: Unexpected symbol("+a.Literal+")"}return t}throw"Error parsing block: Unexpected symbol"}}class ts extends ge{constructor(e,t){super(),n(this,"type"),n(this,"qualifier"),this.type=t,this.qualifier=e}static parse(e){if(e.peekToken(0).Type==x.PRECISION&&e.peekToken(1).Type==x.IDENT&&e.peekToken(2).isBuiltinType()){let t=new ts(e.peekToken(1).Literal,e.peekToken(2).Literal);return e.skipToken(3),e.peekToken(0).Type==x.SEMICOLON&&e.skipToken(1),t}throw"Error parsing precision qualifier: Unexpected character"}formatToWGSL(e,t){return""}}class ra extends ge{constructor(){super(),n(this,"scope",""),n(this,"qualifier",new Map)}addQualifier(e,t=""){this.qualifier.set(e,t)}static parse(e){if(e.peekToken(0).Type==x.LAYOUT&&e.peekToken(1).Type==x.LEFTSAMLL){let t=new ra;e.skipToken(2);do if(e.peekToken(0).Type==x.IDENT){if(e.peekToken(1).Type==x.ASSIGN&&e.peekToken(2).Type==x.LITERAL){let a=e.peekToken(0).Literal,s=e.peekToken(2).Literal;if(t.addQualifier(a,s),e.skipToken(3),e.peekToken(0).Type==x.COMMA){e.skipToken(1);continue}let o=e.peekToken(0);o.Line=0}else if(e.peekToken(1).Type==x.RIGHTSAMLL){let a=e.peekToken(0).Literal;t.addQualifier(a,""),e.skipToken(1);break}else if(e.peekToken(1).Type==x.COMMA){let a=e.peekToken(0).Literal;t.addQualifier(a,""),e.skipToken(2);continue}}while(e.peekToken(0).Type!=x.RIGHTSAMLL);if(e.peekToken(0).Type==x.RIGHTSAMLL&&e.skipToken(1),t.scope=e.peekToken(0).Literal,e.skipToken(1),e.peekToken(0).Type==x.SEMICOLON)return e.skipToken(1),t;if(e.peekToken(0).isBuiltinType()&&e.peekToken(1).Type==x.IDENT&&e.peekToken(2).Type==x.SEMICOLON){let r=new Te(e.peekToken(0).Literal,e.peekToken(1).Literal);return t.addNode(r),e.skipToken(3),t}else if(e.peekToken(0).Type==x.IDENT&&e.peekToken(1).Type==x.LEFTBIG){let r=ti.parse(e);return t.addNode(r),e.peekToken(0).Type==x.IDENT&&e.peekToken(1).Type==x.SEMICOLON&&(r.addNode(new Te(r.name,e.peekToken(0).Literal)),e.skipToken(2)),t}else throw"Error parsing layout qualifier type: Unexpected symbol("+e.peekToken(0).Literal+")"}throw"Error parsing layout qualifier: Unexpected symbol"}formatToWGSL(e,t){let r="";if(this.qualifier.size==1&&this.qualifier.has("location"))r+="@location("+this.qualifier.get("location")+") ";else if(this.qualifier.size==2&&this.qualifier.has("set")&&this.qualifier.has("binding"))r+="@group("+this.qualifier.get("set")+") @binding("+this.qualifier.get("binding")+") ";else if(this.qualifier.size>=1&&this.qualifier.has("binding"))r+="@group(0) @binding("+this.qualifier.get("binding")+") ";else if(this.qualifier.size==1&&this.qualifier.has("push_constant"))r+="@push_constant ";else if(this.qualifier.size>=1&&this.qualifier.has("local_size_x"))r+="@workgroup_size(",r+=this.qualifier.get("local_size_x")+", ",r+=this.qualifier.has("local_size_y")?this.qualifier.get("local_size_y")+", ":"1, ",r+=this.qualifier.has("local_size_z")?this.qualifier.get("local_size_z")+"":"1",r+=")";else if(this.nodes.length<=0)return"";let a=this.nodes[0];if(a instanceof Te){switch(a.type){case"sampler":case"texture2D":r+="var ";break;default:this.scope=="buffer"?e.stage=="compute"?r+="var<storage, read_write> ":r+="var<storage, read> ":r+="var<"+this.scope+"> ";break}e.addIdentifier(a.name,a.name),r+=a.name+": "+bt(a.type)+`;\r
`}else if(a instanceof ti){if(this.scope=="buffer"?e.stage=="compute"?r+="var<storage, read_write> ":r+="var<storage, read> ":r+="var<"+this.scope+"> ",a.nodes.length<=0){let s="unif"+e.layoutUniformCount.toString();for(;e.hasIdentifier(s);)e.layoutUniformCount++,s="unif"+e.layoutUniformCount.toString();for(let o of a.fields)e.addIdentifier(o.name,s+"."+o.name);r+=s+": "+a.name+`;\r
`,e.layoutUniformCount++}else{let s=a.nodes[0];r+=s.name+": "+s.type+`;\r
`}return r}return r}}function bt(i){switch(i){case"int":return"i32";case"int[]":return"array<i32>";case"uint":return"u32";case"uint[]":return"array<u32>";case"float":return"f32";case"float[]":return"array<f32>";case"vec2":return"vec2<f32>";case"vec3":return"vec3<f32>";case"vec4":return"vec4<f32>";case"vec2[]":return"array<vec2<f32>>";case"vec3[]":return"array<vec3<f32>>";case"vec4[]":return"array<vec4<f32>>";case"ivec2":return"vec2<i32>";case"ivec3":return"vec3<i32>";case"ivec4":return"vec4<i32>";case"ivec2[]":return"array<vec2<i32>>";case"ivec3[]":return"array<vec3<i32>>";case"ivec4[]":return"array<vec4<i32>>";case"mat2":return"mat2x2<f32>";case"mat2x2":return"mat2x2<f32>";case"mat2x3":return"mat2x3<f32>";case"mat2x4":return"mat2x4<f32>";case"mat2[]":return"array<mat2x2<f32>>";case"mat2x2[]":return"array<mat2x2<f32>>";case"mat2x3[]":return"array<mat2x3<f32>>";case"mat2x4[]":return"array<mat2x4<f32>>";case"mat3":return"mat3x3<f32>";case"mat3x2":return"mat3x2<f32>";case"mat3x3":return"mat3x3<f32>";case"mat3x4":return"mat3x4<f32>";case"mat3[]":return"array<mat3x3<f32>>";case"mat3x2[]":return"array<mat3x2<f32>>";case"mat3x3[]":return"array<mat3x3<f32>>";case"mat3x4[]":return"array<mat3x4<f32>>";case"mat4":return"mat4x4<f32>";case"mat4x2":return"mat4x2<f32>";case"mat4x3":return"mat4x3<f32>";case"mat4x4":return"mat4x4<f32>";case"mat4[]":return"array<mat4x4<f32>>";case"mat4x2[]":return"array<mat4x2<f32>>";case"mat4x3[]":return"array<mat4x3<f32>>";case"mat4x4[]":return"array<mat4x4<f32>>";case"texture2D":return"texture_2d<f32>"}return i}class vu{constructor(e){n(this,"_lexer"),n(this,"_rootNode"),this._lexer=e,this._rootNode=new ge,this.parse()}get lexer(){return this._lexer}parse(){for(;this.peekToken(0).Type!==x.EOF;){if(this.peekToken(0).Type==x.SEMICOLON){this.skipToken(1);continue}let e=this.parseStatement();e!==null&&this._rootNode.addNode(e)}}parseStatement(){let e=this.peekToken();if(e.Type==x.LAYOUT&&this.peekToken(1).Type==x.LEFTSAMLL)return ra.parse(this._lexer);if(e.Type==x.STRUCT)return this.skipToken(1),ti.parse(this._lexer);if((e.isBuiltinType()||e.Type==x.VOID)&&this.peekToken(1).Type==x.IDENT&&this.peekToken(2).Type==x.LEFTSAMLL)return Za.parse(this._lexer);if(e.Type==x.CONST&&this.peekToken(1).isDataType())return Te.parse(this._lexer);if(e.isDataType()&&this.peekToken(1).Type==x.IDENT)return Te.parse(this._lexer);if(e.Type==x.OUT&&this.peekToken(1).isDataType()&&this.peekToken(2).Type==x.IDENT)return Te.parse(this._lexer);if(e.Type==x.PRECISION)return ts.parse(this._lexer);throw"Error parsing statement: Unexpected character"}skipToken(e){this._lexer.skipToken(e)}peekToken(e=0){return this._lexer.peekToken(e)}getNextToken(){return this._lexer.GetNextToken()}get ASTRoot(){return this._rootNode}}class is{static convertGLSL(e){var t=new pu(e),r=new gu(t),a=new vu(r),s=new mu(a);return s.generateWGSL()}}n(is,"VertexShader","VertexShader"),n(is,"FragmentShader","FragmentShader");class An{constructor(){n(this,"setID",0),n(this,"bindingID",0),n(this,"name",""),n(this,"type","")}}class _n{constructor(){n(this,"name",""),n(this,"type",""),n(this,"locationID",0),n(this,"builtinName","")}isBuiltinAttribute(){return this.builtinName!=""}}class xu{constructor(){n(this,"uniformInfo",[]),n(this,"inputAttribute",[]),n(this,"outputAttribute",[]),n(this,"sourceCode","")}}var Ut=(i=>(i[i.vertex=0]="vertex",i[i.fragment=1]="fragment",i[i.computer=2]="computer",i))(Ut||{});class yu{constructor(){n(this,"blendMode",ve.NONE),n(this,"depthCompare",_t.less),n(this,"depthWriteEnabled",!0),n(this,"frontFace","ccw"),n(this,"cullMode",ui.back),n(this,"topology",Da.triangle_list),n(this,"depthBias",10),n(this,"useLight",!1),n(this,"useProbe",!1),n(this,"acceptGI",!1),n(this,"acceptShadow",!1),n(this,"castShadow",!1),n(this,"castReflection",!1),n(this,"receiveEnv",!1),n(this,"renderLayer",1e3),n(this,"renderOrder",2e3),n(this,"unclippedDepth",!1),n(this,"transparent",!1),n(this,"multisample",0),n(this,"label"),n(this,"useZ",!0),n(this,"splitTexture",!1),n(this,"alphaCutoff"),n(this,"useFragDepth",!1)}setFromMapValues(e){e.has("blendMode")&&(this.blendMode=this.convertBlendMode(e.get("blendMode"))),e.has("depthCompare")&&(this.depthCompare=e.get("depthCompare")),e.has("depthWriteEnabled")&&(this.depthWriteEnabled=e.get("depthWriteEnabled")),e.has("frontFace")&&(this.frontFace=e.get("frontFace")),e.has("cullMode")&&(this.cullMode=e.get("cullMode")),e.has("topology")&&(this.topology=e.get("topology")),e.has("depthBias")&&(this.depthBias=e.get("depthBias")),e.has("useLight")&&(this.useLight=e.get("useLight")),e.has("useProbe")&&(this.useProbe=e.get("useProbe")),e.has("acceptGI")&&(this.acceptGI=e.get("acceptGI")),e.has("acceptShadow")&&(this.acceptShadow=e.get("acceptShadow")),e.has("castShadow")&&(this.castShadow=e.get("castShadow")),e.has("receiveEnv")&&(this.receiveEnv=e.get("receiveEnv")),e.has("renderLayer")&&(this.renderLayer=e.get("renderLayer")),e.has("renderOrder")&&(this.renderOrder=e.get("renderOrder")),e.has("unclippedDepth")&&(this.unclippedDepth=e.get("unclippedDepth")),e.has("multisample")&&(this.multisample=e.get("multisample")),e.has("label")&&(this.label=e.get("label")),e.has("useZ")&&(this.useZ=e.get("useZ"))}convertBlendMode(e){switch(e){case"ABOVE":return ve.ABOVE;case"ALPHA":return ve.ALPHA;case"NORMAL":return ve.NORMAL;case"ADD":return ve.ADD;case"BELOW":return ve.BELOW;case"ERASE":return ve.ERASE;case"MUL":return ve.MUL;case"SCREEN":return ve.SCREEN;case"DIVD":return ve.DIVD;case"SOFT_ADD":return ve.SOFT_ADD}return ve.NONE}}class Cu extends qt{constructor(){super(),n(this,"uniformNodes",[]),n(this,"_onChange",!0),this.bufferType=Tt.MaterialDataUniformGPUBuffer}initDataUniform(e){this.uniformNodes=e;let t=0;for(const r in e){const a=e[r];a||console.error(r,"is empty"),t+=a.size*4}t=Math.floor(t/256+1)*256,this.createBuffer(GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,t/4);for(const r in e){const a=e[r];a||console.error(r,"is empty");let s=this.memory.allocation_node(a.size*4);a.memoryInfo=s,a.bindOnChange=()=>this.onChange()}}onChange(){this._onChange=!0}apply(){if(this.uniformNodes.length!=0&&this._onChange){for(const e in this.uniformNodes)this.uniformNodes[e].update();super.apply(),this._onChange=!1}}}class Ot{static init(){this.renderShaderModulePool=new Map,this.renderShader=new Map}}n(Ot,"renderShaderModulePool"),n(Ot,"renderShader");class rs{static getSharePipeline(e){let t=this.pipelineMap.get(e);return t||null}static setSharePipeline(e,t){this.pipelineMap.set(e,t)}}n(rs,"pipelineMap",new Map);class He extends Ms{constructor(e,t){super(),n(this,"useRz",!1),n(this,"vsName"),n(this,"fsName"),n(this,"shaderState"),n(this,"textures"),n(this,"pipeline"),n(this,"bindGroupLayouts"),n(this,"materialDataUniformBuffer"),n(this,"envMap"),n(this,"prefilterMap"),n(this,"_sourceVS"),n(this,"_sourceFS"),n(this,"_destVS"),n(this,"_destFS"),n(this,"_vsShaderModule"),n(this,"_fsShaderModule"),n(this,"_textureGroup",-1),n(this,"_textureChange",!1),n(this,"_groupsShaderReflectionVarInfos"),n(this,"_cacheEntries"),this.vsName=e.toLowerCase(),this.fsName=t.toLowerCase(),this.vsName in N||console.error("Shader Not Register, Please Register Shader!",this.vsName),this.fsName in N||console.error("Shader Not Register, Please Register Shader!",this.fsName),N[this.vsName]&&(this._sourceVS=N[this.vsName]),N[this.fsName]&&(this._sourceFS=N[this.fsName]),this.textures={},this.bindGroups=[],this.shaderState=new yu,this.materialDataUniformBuffer=new Cu,this.materialDataUniformBuffer.visibility=GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,this._bufferDic.set("global",this.materialDataUniformBuffer),this._bufferDic.set("materialUniform",this.materialDataUniformBuffer)}get renderOrder(){return this.shaderState.renderOrder}set renderOrder(e){this.shaderState.renderOrder!=e&&(this._valueChange=!0),this.shaderState.renderOrder=e}get doubleSide(){return this.shaderState.cullMode==ui.none}set doubleSide(e){let t=e?ui.none:this.cullMode;this.shaderState.cullMode!=t&&(this._valueChange=!0),this.shaderState.cullMode=t}get cullMode(){return this.shaderState.cullMode}set cullMode(e){this.shaderState.cullMode!=e&&(this._valueChange=!0),this.shaderState.cullMode=e}get frontFace(){return this.shaderState.frontFace}set frontFace(e){this.shaderState.frontFace!=e&&(this._valueChange=!0),this.shaderState.frontFace=e}get depthBias(){return this.shaderState.depthBias}set depthBias(e){this.shaderState.depthBias!=e&&(this._valueChange=!0),this.shaderState.depthBias=e}get topology(){return this.shaderState.topology}set topology(e){this.shaderState.topology!=e&&(this._valueChange=!0),this.shaderState.topology=e}get blendMode(){return this.shaderState.blendMode}set blendMode(e){this.shaderState.blendMode!=e&&(this._valueChange=!0,e!=ve.NORMAL&&e!=ve.NONE&&(this.renderOrder=3e3)),this.shaderState.blendMode=e}get depthCompare(){return this.shaderState.depthCompare}set depthCompare(e){this.shaderState.depthCompare!=e&&(this._valueChange=!0),this.shaderState.depthCompare=e}setShaderEntry(e="",t=""){this.vsEntryPoint=e,this.fsEntryPoint=t}setUniform(e,t){super.setUniform(e,t),this.materialDataUniformBuffer.onChange()}setTexture(e,t){t&&this.textures[e]!=t&&(this.textures[e]&&this.textures[e].unBindStateChange(this),this._textureChange=!0,this.textures[e]=t,e=="envMap"?this.envMap=t:e=="prefilterMap"&&(this.prefilterMap=t),t.bindStateChange(()=>{this._textureChange=!0},this))}get baseColor(){return this.getUniform("baseColor")}set baseColor(e){this.setUniform("baseColor",e)}getTexture(e){return this.textures[e]}genRenderPipeline(e,t){let r=this.createGroupLayouts();this.createPipeline(e,t,r)}reBuild(e,t){this.compileShader(Ut.vertex,this._destVS,t),this.compileShader(Ut.fragment,this._destFS,t),this.genRenderPipeline(e,t)}apply(e,t,r){this.materialDataUniformBuffer.apply(),this._textureChange&&this._textureGroup!=-1&&(this._textureChange=!1,this.genGroups(this._textureGroup,this.shaderReflection.groups,!0)),this._valueChange&&(this._shaderChange&&(this.preCompile(e),this._shaderChange=!1),this.shaderVariant=ct.genRenderShaderVariant(this),this.reBuild(e,t),this._valueChange=!1,r&&r())}preCompile(e){this.preDefine(e),this.preCompileShader(Ut.vertex,this._sourceVS.concat()),this.preCompileShader(Ut.fragment,this._sourceFS.concat()),this.genReflection()}applyPostDefine(e,t){return t.outAttachments.length>1?(this.defineValue.USE_WORLDPOS=!0,this.defineValue.USEGBUFFER=!0):(this.defineValue.USE_WORLDPOS=!1,this.defineValue.USEGBUFFER=!1),ut.parse(e,this.defineValue)}setBindGroup(e,t){this.bindGroups[e]=t}checkBuffer(e,t){}preCompileShader(e,t,r){let a=t;if(a.indexOf("version ")!=-1){var s=is.convertGLSL(a);a=s.sourceCode}for(const o in this.constValues)if(Object.prototype.hasOwnProperty.call(this.constValues,o)){const l=this.constValues[o];a=a.replaceAll(`&${o}`,l.toString())}switch(e){case Ut.vertex:this._destVS=a;break;case Ut.fragment:this._destFS=a;break}}compileShader(e,t,r){let a=t;a=this.applyPostDefine(a,r);let s=t;for(let l in this.defineValue)s+=`${l}=${this.defineValue[l]},`;let o=Ot.renderShaderModulePool.get(s);switch(o||(a=this.applyPostDefine(a,r),o=I.device.createShaderModule({label:e==Ut.vertex?this.vsName:this.fsName,code:a}),o.getCompilationInfo().then(l=>{l.messages.length>0&&(console.log(a),console.log(l))}),Ot.renderShaderModulePool.set(s,o)),e){case Ut.vertex:this._vsShaderModule=o,this._destVS=a;break;case Ut.fragment:this._fsShaderModule=o,this._destFS=a;break}}getGroupLayout(e,t){let r=[];for(let a=0;a<t.length;a++){const s=t[a];if(s)if(s.varType=="uniform"){this._bufferDic.has(s.varName)||console.error(`not set ${s.varName} buffer`);let o=this._bufferDic.get(s.varName).visibility,l={binding:s.binding,visibility:o,buffer:{type:"uniform"}};r.push(l)}else if(s.varType=="storage-read"){this._bufferDic.has(s.varName)||console.error(`not set ${s.varName} buffer`);let o=this._bufferDic.get(s.varName).visibility,l={binding:s.binding,visibility:o,buffer:{type:"read-only-storage"}};r.push(l)}else if(s.varType=="var")switch(s.dataType){case"sampler":{let o=s.varName.replace("Sampler",""),l=this.textures[o]?this.textures[o]:_.res.redTexture,h={binding:s.binding,visibility:l.visibility,sampler:l.samplerBindingLayout};r.push(h),this._textureGroup=e}break;case"sampler_comparison":{let o=s.varName.replace("Sampler",""),l=this.textures[o]?this.textures[o]:_.res.redTexture,h={binding:s.binding,visibility:l.visibility,sampler:l.sampler_comparisonBindingLayout};r.push(h),this._textureGroup=e}break;case"texture_2d<f32>":case"texture_2d_array<f32>":case"texture_cube<f32>":case"texture_depth_2d":case"texture_depth_2d_array":case"texture_depth_cube":case"texture_depth_cube_array":{let o=this.textures[s.varName]?this.textures[s.varName]:_.res.redTexture,l={binding:s.binding,visibility:o.visibility,texture:o.textureBindingLayout};r.push(l),this._textureGroup=e,ae.getInstance().attached(o,this)}break;case"texture_external":{let o=this.textures[s.varName]?this.textures[s.varName]:_.res.redTexture,l={binding:s.binding,visibility:o.visibility,externalTexture:{}};r.push(l),this._textureGroup=e,ae.getInstance().attached(o,this)}break;default:{let o=this.textures[s.varName]?this.textures[s.varName]:_.res.redTexture,l={binding:s.binding,visibility:o.visibility,texture:o.textureBindingLayout};r.push(l),this._textureGroup=e,ae.getInstance().attached(o,this)}break}else{debugger;console.error("bind group can't empty")}}return r}genGroups(e,t,r=!1){if(!this.bindGroups[e]||r){const a=t[e];let s=[];for(let l=0;l<a.length;l++){const h=a[l];if(h){if(h.varType=="uniform"){let u=this._bufferDic.get(h.varName);if(u){if(u.bufferType==Tt.MaterialDataUniformGPUBuffer){let d=[];for(let g=0;g<h.dataFields.length;g++){const m=h.dataFields[g];this.uniforms[m.name]||console.error(`shader-${this.vsName}:${this.fsName} ${m.name}is empty`),d.push(this.uniforms[m.name])}this.materialDataUniformBuffer.initDataUniform(d)}let c={binding:h.binding,resource:{buffer:u.buffer,offset:0,size:u.memory.shareDataBuffer.byteLength}};s.push(c),this.checkBuffer(h.varName,u)}else console.error(`shader${this.vsName}-${this.fsName}`,`buffer ${h.varName} is missing!`)}else if(h.varType=="storage-read"){let u=this._bufferDic.get(h.varName);if(u){let c={binding:h.binding,resource:{buffer:u.buffer,offset:0,size:u.memory.shareDataBuffer.byteLength}};s.push(c),this.checkBuffer(h.varName,u)}else console.error(`buffer ${h.varName} is missing!`)}else if(h.varType=="var")if(h.dataType=="sampler"){let u=h.varName.replace("Sampler",""),c=this.textures[u];if(c||(c=_.res.blackTexture,this.setTexture(u,c)),c){let d={binding:h.binding,resource:c.gpuSampler};s.push(d)}else console.error(`shader${this.vsName}-${this.fsName}`,`texture ${h.varName} is missing! `)}else if(h.dataType=="sampler_comparison"){let u=h.varName.replace("Sampler",""),c=this.textures[u];if(c){let d={binding:h.binding,resource:c.gpuSampler_comparison};s.push(d)}else console.error(`shader${this.vsName}-${this.fsName}`,`texture ${h.varName} is missing! `)}else{let u=this.textures[h.varName];if(u||(u=_.res.whiteTexture,this.setTexture(h.varName,u)),u){let c={binding:h.binding,resource:u.getGPUView()};s.push(c)}else console.error(`shader${this.vsName}-${this.fsName}`,`texture ${h.varName} is missing! `)}}}let o=I.device.createBindGroup({layout:this.bindGroupLayouts[e],entries:s});this.bindGroups[e]=o}}createPipeline(e,t,r){let a=e,s=this.shaderState,o=t.outAttachments;if(t.outColor!=-1){let u=o[t.outColor];s.blendMode!=ve.NONE?u.blend=Qs.getBlend(s.blendMode):delete u.blend}let l={label:this.vsName+"|"+this.fsName,layout:r,primitive:{topology:s.topology,cullMode:s.cullMode,frontFace:s.frontFace},vertex:void 0};this.vsEntryPoint!=""&&(l.vertex={module:this._vsShaderModule,entryPoint:this.vsEntryPoint,buffers:a.vertexBuffer.vertexBufferLayouts}),this.fsEntryPoint!=""&&(l.fragment={module:this._fsShaderModule,entryPoint:this.fsEntryPoint,targets:o}),s.multisample>0&&(l.multisample={count:s.multisample}),(t.zPreTexture||t.depthTexture)&&(s.blendMode!=ve.NONE,_.setting.render.zPrePass&&t.zPreTexture&&s.useZ?l.depthStencil={depthWriteEnabled:!1,depthCompare:_t.less,format:t.zPreTexture.format}:l.depthStencil={depthWriteEnabled:s.depthWriteEnabled,depthCompare:s.depthCompare,format:t.depthTexture.format});let h=rs.getSharePipeline(this.shaderVariant);h?this.pipeline=h:(this.pipeline=w.createPipeline(l),rs.setSharePipeline(this.shaderVariant,this.pipeline))}createGroupLayouts(){this._groupsShaderReflectionVarInfos=[];let e=this.shaderReflection;this.bindGroupLayouts=[Nr.getGlobalDataBindGroupLayout()];for(let r=1;r<e.groups.length;r++){let a=e.groups[r];if(a){let s=this.getGroupLayout(r,a);this._groupsShaderReflectionVarInfos[r]=a;let o=I.device.createBindGroupLayout({entries:s,label:`vs${this.vsName} fs${this.fsName} ${a.length}`});this.bindGroupLayouts[r]=o}else console.error("can't set empty group!",r)}let t=I.device.createPipelineLayout({bindGroupLayouts:this.bindGroupLayouts});return this._groupsShaderReflectionVarInfos[0],this._groupsShaderReflectionVarInfos[1]&&this.genGroups(1,this._groupsShaderReflectionVarInfos),this._groupsShaderReflectionVarInfos[2]&&this.genGroups(2,this._groupsShaderReflectionVarInfos),this._groupsShaderReflectionVarInfos[3]&&this.genGroups(3,this._groupsShaderReflectionVarInfos),t}preDefine(e){let t=e.hasAttribute(X.joints0),r=e.hasAttribute(X.a_morphPositions_0),a=e.hasAttribute(X.TANGENT),s=e.hasAttribute(X.color),o=this.shaderState.acceptGI,l=this.shaderState.useLight;this.defineValue.USE_SKELETON=t,this.defineValue.USE_MORPHTARGETS=r,"USE_TANGENT"in this.defineValue||(this.defineValue.USE_TANGENT=a),this.defineValue.USE_GI=o,this.defineValue.USE_CASTSHADOW=this.shaderState.castShadow,this.defineValue.USE_SHADOWMAPING=this.shaderState.acceptShadow,this.defineValue.USE_LIGHT=l,this.defineValue.USE_VERTXCOLOR=s,_.setting.pick.mode=="pixel"&&(this.defineValue.USE_WORLDPOS=!0),_.setting.gi.enable?this.defineValue.USEGI=!0:this.defineValue.USEGI=!1,_.setting.render.debug&&(this.defineValue.USE_DEBUG=!0,this.defineValue.DEBUG_CLUSTER=!0),this.shaderState.useLight?this.defineValue.USE_LIGHT=!0:this.defineValue.USE_LIGHT=!1,_.setting.render.useLogDepth?(this.defineValue.USE_LOGDEPTH=!0,this.shaderState.useFragDepth=!0):this.defineValue.USE_LOGDEPTH=!1,this.shaderState.useFragDepth?this.defineValue.USE_OUTDEPTH=!0:this.defineValue.USE_OUTDEPTH=!1,this.defineValue.USE_PCF_SHADOW=_.setting.shadow.type=="PCF",this.defineValue.USE_HARD_SHADOW=_.setting.shadow.type=="HARD",this.defineValue.USE_SOFT_SHADOW=_.setting.shadow.type=="SOFT",this.defineValue.USE_CSM=nt.Cascades>1,this.defineValue.USE_IES_PROFILE=Bi.use}genReflection(){this.shaderVariant=ct.genRenderShaderVariant(this);let e=ct.poolGetReflection(this.shaderVariant);if(e)this.shaderReflection=e;else{let t=ut.parse(this._destVS,this.defineValue);t=ut.parse(t,this.defineValue),ct.getShaderReflection2(t,this);let r=ut.parse(this._destFS,this.defineValue);r=ut.parse(r,this.defineValue),ct.getShaderReflection2(r,this),ct.final(this)}this.shaderState.splitTexture=this.shaderReflection.useSplit}destroy(e){for(const t in this.textures)if(Object.prototype.hasOwnProperty.call(this.textures,t)){const r=this.textures[t];if(ae.getInstance().detached(r,this),e&&!ae.getInstance().hasReference(r))r.destroy(e);else{r.destroy(!1);let a=ae.getInstance().getReference(r),s=[];a.forEach((o,l)=>{"name"in o?s.push(o.name):s.push("NaN")})}}this.bindGroups.length=0,this.shaderState=null,this.textures=null,this.pipeline=null,this.bindGroupLayouts=null,this._sourceVS=null,this._sourceFS=null,this._destVS=null,this._destFS=null,this._vsShaderModule=null,this._fsShaderModule=null,this.materialDataUniformBuffer.destroy(e),this.materialDataUniformBuffer=null}static destroyShader(e){Ot.renderShader.has(e)&&(Ot.renderShader.get(e).destroy(),Ot.renderShader.delete(e))}static getShader(e){return Ot.renderShader.get(e)}static createShader(e,t){let r=new He(e,t);return Ot.renderShader.set(r.instanceID,r),r.instanceID}}class vi{constructor(){n(this,"name"),n(this,"instanceID"),n(this,"enable",!0),n(this,"_defaultPass"),n(this,"_renderPasses"),n(this,"_depthCompare",_t.less),this._renderPasses=new Map}get depthCompare(){return this._depthCompare}set depthCompare(e){this._depthCompare=e,this._defaultPass.depthCompare=e}get defaultPass(){return this._defaultPass}set defaultPass(e){this._defaultPass=e,this.addPass(re.COLOR,e)}get doubleSide(){return this._defaultPass.doubleSide}set doubleSide(e){this._defaultPass.doubleSide=e}get castShadow(){return this.defaultPass.shaderState.castShadow}set castShadow(e){let t=this.defaultPass;t.shaderState.castShadow=e}get blendMode(){return this.defaultPass.blendMode}set blendMode(e){let t=this.defaultPass;t.blendMode=e}get transparent(){return this.defaultPass.shaderState.transparent}set transparent(e){let t=this.defaultPass;t.shaderState.transparent=e,e&&(t.renderOrder=3e3)}get cullMode(){return this.defaultPass.cullMode}set cullMode(e){let t=this.defaultPass;t.cullMode=e}hasPass(e){return this._renderPasses.has(e)}getPass(e){return this._renderPasses.get(e)}getAllPass(){return this._renderPasses.get(re.COLOR)}addPass(e,t,r=-1){this._renderPasses.has(e)||this._renderPasses.set(e,[]);let a=this._renderPasses.get(e);return e==re.COLOR&&a.length==0&&(this._defaultPass=t),a.indexOf(t)!=-1||(r==-1?a.push(t):a.splice(r,-1,t)),a}removePass(e,t){if(this._renderPasses.has(e)){let r=this._renderPasses.get(e);t<r.length&&r.splice(t,1)}}clone(){return null}destroy(e){for(const t of this._renderPasses){let r=t[1];for(const a of r)for(const s in a.textures)s.indexOf("defaultOri")==-1&&a.textures[s].destroy(e)}}}class aa extends vi{constructor(){super()}setDefault(){let e=this.defaultPass;e.setUniformFloat("shadowBias",35e-5),e.setUniformVector4("transformUV1",new q(0,0,1,1)),e.setUniformVector4("transformUV2",new q(0,0,1,1)),e.setUniformColor("baseColor",new z),e.setUniformColor("emissiveColor",new z(1,1,1)),e.setUniformVector4("materialF0",new q(.04,.04,.04,1)),e.setUniformFloat("envIntensity",1),e.setUniformFloat("normalScale",1),e.setUniformFloat("roughness",1),e.setUniformFloat("metallic",0),e.setUniformFloat("ao",1),e.setUniformFloat("roughness_min",0),e.setUniformFloat("roughness_max",1),e.setUniformFloat("metallic_min",0),e.setUniformFloat("metallic_max",1),e.setUniformFloat("emissiveIntensity",0),e.setUniformFloat("alphaCutoff",0),e.setUniformFloat("ior",1.5),e.setUniformFloat("clearcoatFactor",0),e.setUniformFloat("clearcoatRoughnessFactor",0),e.setUniformColor("clearcoatColor",new z(1,1,1)),e.setUniformFloat("clearcoatWeight",0)}get baseMap(){return this.defaultPass.getTexture("baseMap")}set baseMap(e){this.defaultPass.setTexture("baseMap",e)}get baseColor(){return this.defaultPass.getUniform("baseColor")}set baseColor(e){this.defaultPass.setUniformColor("baseColor",e)}get normalMap(){return this.defaultPass.getTexture("normalMap")}set normalMap(e){this.defaultPass.setTexture("normalMap",e)}get doubleSide(){return this.defaultPass.doubleSide}set doubleSide(e){this.defaultPass.doubleSide=e}get alphaCutoff(){return this.defaultPass.shaderState.alphaCutoff}set alphaCutoff(e){this.defaultPass.setDefine("USE_ALPHACUT",!0),this.defaultPass.shaderState.alphaCutoff=e,this.defaultPass.setUniform("alphaCutoff",e)}get emissiveColor(){return this.defaultPass.getUniform("emissiveColor")}set emissiveColor(e){this.defaultPass.setUniform("emissiveColor",e)}get emissiveIntensity(){return this.defaultPass.getUniform("emissiveIntensity")}set emissiveIntensity(e){this.defaultPass.setUniform("emissiveIntensity",e)}get uvTransform_1(){return this.defaultPass.uniforms.transformUV1.vector4}set uvTransform_1(e){this.defaultPass.setUniformVector4("transformUV1",e)}get uvTransform_2(){return this.defaultPass.uniforms.transformUV2.vector4}set uvTransform_2(e){this.defaultPass.setUniformVector4("transformUV2",e)}get depthWriteEnabled(){return this.defaultPass.shaderState.depthWriteEnabled}set depthWriteEnabled(e){this.defaultPass.shaderState.depthWriteEnabled=e}get materialF0(){return this.defaultPass.uniforms.materialF0.vector4}set materialF0(e){this.defaultPass.setUniformVector4("materialF0",e)}get roughness(){return this.defaultPass.uniforms.roughness.value}set roughness(e){this.defaultPass.setUniformFloat("roughness",e)}get metallic(){return this.defaultPass.uniforms.metallic.value}set metallic(e){this.defaultPass.setUniformFloat("metallic",e)}get ao(){return this.defaultPass.uniforms.ao.value}set ao(e){this.defaultPass.setUniformFloat("ao",e)}get metallic_min(){return this.defaultPass.uniforms.metallic_min.value}set metallic_min(e){this.defaultPass.setUniformFloat("metallic_min",e)}get metallic_max(){return this.defaultPass.uniforms.metallic_max.value}set metallic_max(e){this.defaultPass.setUniformFloat("metallic_max",e)}get roughness_min(){return this.defaultPass.uniforms.roughness_min.value}set roughness_min(e){this.defaultPass.setUniformFloat("roughness_min",e)}get roughness_max(){return this.defaultPass.uniforms.roughness_max.value}set roughness_max(e){this.defaultPass.setUniformFloat("roughness_max",e)}get normalScale(){return this.defaultPass.uniforms.normalScale.value}set normalScale(e){this.defaultPass.setUniformFloat("normalScale",e)}get maskMap(){return this.defaultPass.textures.maskMap}set maskMap(e){this.defaultPass.setDefine("USE_MR",!0),this.defaultPass.setTexture("maskMap",e)}set aoMap(e){e&&(this.defaultPass.setTexture("aoMap",e),e!=_.res.whiteTexture&&this.defaultPass.setDefine("USE_AOTEX",!0))}get aoMap(){return this.defaultPass.textures.aoMap}set clearCoatRoughnessMap(e){e&&(console.log("USE_CLEARCOAT_ROUGHNESS"),this.defaultPass.setTexture("clearCoatRoughnessMap",e),this.defaultPass.setDefine("USE_CLEARCOAT_ROUGHNESS",!0))}get clearCoatRoughnessMap(){return this.defaultPass.textures.clearCoatRoughnessMap}get brdfLUT(){return this.defaultPass.textures.brdfLUT}set brdfLUT(e){this.defaultPass.setTexture("brdfLUT",e),this.defaultPass.setTexture("brdflutMap",e)}get emissiveMap(){return this.defaultPass.textures.emissiveMap}set emissiveMap(e){this.defaultPass.setTexture("emissiveMap",e)}set envIntensity(e){this.defaultPass.setUniformFloat("envIntensity",e)}get envIntensity(){return this.defaultPass.uniforms.envIntensity.value}set ior(e){this.defaultPass.setUniformFloat("ior",e)}get ior(){return this.defaultPass.uniforms.ior.value}useCleanCoat(){this.defaultPass.setDefine("USE_CLEARCOAT",!0)}set clearcoatFactor(e){this.defaultPass.setUniformFloat("clearcoatFactor",e),this.useCleanCoat()}get clearcoatFactor(){return this.defaultPass.uniforms.clearcoatFactor.value}set clearcoatRoughnessFactor(e){this.defaultPass.setUniformFloat("clearcoatRoughnessFactor",e),this.useCleanCoat()}get clearcoatRoughnessFactor(){return this.defaultPass.uniforms.clearcoatRoughnessFactor.value}set clearcoatWeight(e){this.defaultPass.setUniformFloat("clearcoatWeight",e),this.useCleanCoat()}get clearcoatWeight(){return this.defaultPass.uniforms.clearcoatWeight.value}set clearcoatColor(e){this.defaultPass.setUniformColor("clearcoatColor",e),this.useCleanCoat()}get clearcoatColor(){return this.defaultPass.uniforms.clearcoatColor.color}}class xi extends aa{constructor(){super();let e=new He("PBRLItShader","PBRLItShader");this.defaultPass=e,e.setShaderEntry("VertMain","FragMain");let t=e.shaderState;t.acceptShadow=!0,t.castShadow=!0,t.receiveEnv=!0,t.acceptGI=!0,t.useLight=!0;let r=_.res.getTexture("BRDFLUT");this.brdfLUT=r,e.setDefine("USE_BRDF",!0),this.setDefault(),this.baseMap=_.res.whiteTexture,this.normalMap=_.res.normalTexture,this.emissiveMap=_.res.blackTexture,this.alphaCutoff=.5}clone(){let e=new xi,t=e.defaultPass;return t.setUniform("shadowBias",this.defaultPass.getUniform("shadowBias")),t.setUniform("transformUV1",this.defaultPass.getUniform("transformUV1")),t.setUniform("transformUV2",this.defaultPass.getUniform("transformUV2")),t.setUniform("baseColor",this.defaultPass.getUniform("baseColor")),t.setUniform("emissiveColor",this.defaultPass.getUniform("emissiveColor")),t.setUniform("materialF0",this.defaultPass.getUniform("materialF0")),t.setUniform("envIntensity",this.defaultPass.getUniform("envIntensity")),t.setUniform("normalScale",this.defaultPass.getUniform("normalScale")),t.setUniform("roughness",this.defaultPass.getUniform("roughness")),t.setUniform("metallic",this.defaultPass.getUniform("metallic")),t.setUniform("ao",this.defaultPass.getUniform("ao")),t.setUniform("roughness_min",this.defaultPass.getUniform("roughness_min")),t.setUniform("roughness_max",this.defaultPass.getUniform("roughness_max")),t.setUniform("metallic_min",this.defaultPass.getUniform("metallic_min")),t.setUniform("metallic_max",this.defaultPass.getUniform("metallic_max")),t.setUniform("emissiveIntensity",this.defaultPass.getUniform("emissiveIntensity")),t.setUniform("alphaCutoff",this.defaultPass.getUniform("alphaCutoff")),t.setUniform("ior",this.defaultPass.getUniform("ior")),t.setUniform("clearcoatFactor",this.defaultPass.getUniform("clearcoatFactor")),t.setUniform("clearcoatRoughnessFactor",this.defaultPass.getUniform("clearcoatRoughnessFactor")),t.setUniform("clearcoatColor",this.defaultPass.getUniform("clearcoatColor")),t.setUniform("clearcoatWeight",this.defaultPass.getUniform("clearcoatWeight")),t.setTexture("baseMap",this.defaultPass.getTexture("baseMap")),t.setTexture("normalMap",this.defaultPass.getTexture("normalMap")),t.setTexture("emissiveMap",this.defaultPass.getTexture("emissiveMap")),t.setTexture("aoMap",this.defaultPass.getTexture("aoMap")),t.setTexture("maskMap",this.defaultPass.getTexture("maskMap")),e}}class vn extends Xt{constructor(){super(...arguments),n(this,"textData",""),n(this,"source_vertices"),n(this,"source_normals"),n(this,"source_tangents"),n(this,"source_textureCoords"),n(this,"matLibs"),n(this,"geometrys"),n(this,"activeGeo"),n(this,"facesMaterialsIndex"),n(this,"mtl"),n(this,"mtlUrl")}async parseString(e){return this.source_vertices=[],this.source_normals=[],this.source_tangents=[],this.source_textureCoords=[],this.matLibs={},this.geometrys={},this.textData=e,await Promise.all([this.parserOBJ(),this.loadMTL()]),this.parser_mesh(),"null"}applyVector2(e,t,r){t[e]&&t[e].length>0?(r.push(t[e][0]),r.push(t[e][1])):(r.push(0),r.push(0))}applyVector3(e,t,r){r.push(t[e][0]),r.push(t[e][1]),r.push(t[e][2])}applyVector4(e,t,r){r.push(t[e][0]),r.push(t[e][1]),r.push(t[e][2]),r.push(t[e][3])}async loadMTL(){let t=await new ot().loadTxt(this.baseUrl+this.mtlUrl),r=t.data,a,s=r.split(`\r
`);for(let h=0;h<s.length;h++){let u=s[h];var o=u.indexOf("#");o!=-1&&(u=u.substring(0,o)),u=u.trim();var l=u.split(/\s+/);l[0]==="newmtl"?(a={name:l[1]},this.matLibs[l[1]]=a):l[0].indexOf("map_")!=-1?(a[l[0]]=l[1],a.textures||(a.textures=[l[l.length-1]]),a.textures.push(l[l.length-1])):l.length==2?a[l[0]]=Number(l[1]):l.length==3?a[l[0]]=[Number(l[1]),Number(l[2])]:l.length==4&&(a[l[0]]=[Number(l[1]),Number(l[2]),Number(l[3])])}for(const h in this.matLibs){const u=this.matLibs[h];if(u.textures&&u.textures.length>0)for(let c=0;c<u.textures.length;c++){const d=rt.normalizePath(this.baseUrl+u.textures[c]);await _.res.loadTexture(d)}}return t=null,!0}async load_textures(){}parserLine(e){var t=e.indexOf("#");if(t!=-1){if(e.indexOf("# object")!=-1){var r=e.split(/\s+/);let g=r[1],m=r[2];this.activeGeo={type:g,name:m[1],source_mat:"",source_faces:[]},this.geometrys[m]=this.activeGeo}e=e.substring(0,t)}e=e.trim();var r=e.split(/\s+/);if(r[0]==="v"){var a=[Number(r[1]),Number(r[2]),Number(r[3]),r[4]?1:Number(r[4])];this.source_vertices.push(a)}else if(r[0]==="vt"){var s=[Number(r[1]),Number(r[2]),r[3]?1:Number(r[3])];this.source_textureCoords.push(s)}else if(r[0]==="vn"){var o=[Number(r[1]),Number(r[2]),Number(r[3])];this.source_normals.push(o)}else if(r[0]==="f"){for(var l={indices:[],texture:[],normal:[]},h=1;h<r.length;++h){var u=r[h].indexOf("//"),c=r[h].split(/\W+/);u>0?(l.indices.push(c[0]),l.normal.push(c[1])):c.length===1?l.indices.push(c[0]):c.length===2?(l.indices.push(c[0]),l.texture.push(c[1])):c.length===3&&(l.indices.push(c[0]),l.texture.push(c[1]),l.normal.push(c[2]))}this.activeGeo.source_faces.push(l)}else r[0]==="usemtl"?this.activeGeo.source_mat=r[1]:r[0]==="mtllib"&&(this.mtlUrl=r[1])}async parserOBJ(){let e=this.textData.split(`\r
`);for(let t=0;t<e.length;t++){const r=e[t];this.parserLine(r)}return this.textData="",!0}async parser_mesh(){for(const e in this.geometrys){const t=this.geometrys[e];t.vertex_arr=[],t.normal_arr=[],t.uv_arr=[],t.indeice_arr=[];let r=0;for(let s=0;s<t.source_faces.length;s++){const o=t.source_faces[s];let l=parseInt(o.indices[0])-1,h=parseInt(o.indices[1])-1,u=parseInt(o.indices[2])-1,c=parseInt(o.normal[0])-1,d=parseInt(o.normal[1])-1,g=parseInt(o.normal[2])-1,m=parseInt(o.texture[0])-1,A=parseInt(o.texture[1])-1,v=parseInt(o.texture[2])-1;if(this.applyVector3(l,this.source_vertices,t.vertex_arr),this.applyVector3(c,this.source_normals,t.normal_arr),this.applyVector2(m,this.source_textureCoords,t.uv_arr),t.indeice_arr[r]=r++,this.applyVector3(h,this.source_vertices,t.vertex_arr),this.applyVector3(d,this.source_normals,t.normal_arr),this.applyVector2(A,this.source_textureCoords,t.uv_arr),t.indeice_arr[r]=r++,this.applyVector3(u,this.source_vertices,t.vertex_arr),this.applyVector3(g,this.source_normals,t.normal_arr),this.applyVector2(v,this.source_textureCoords,t.uv_arr),t.indeice_arr[r]=r++,o.indices.length>3){let y=parseInt(o.indices[3])-1,C=parseInt(o.normal[3])-1,S=parseInt(o.texture[3])-1;this.applyVector3(l,this.source_vertices,t.vertex_arr),this.applyVector3(c,this.source_normals,t.normal_arr),this.applyVector2(m,this.source_textureCoords,t.uv_arr),t.indeice_arr[r]=r++,this.applyVector3(u,this.source_vertices,t.vertex_arr),this.applyVector3(g,this.source_normals,t.normal_arr),this.applyVector2(v,this.source_textureCoords,t.uv_arr),t.indeice_arr[r]=r++,this.applyVector3(y,this.source_vertices,t.vertex_arr),this.applyVector3(C,this.source_normals,t.normal_arr),this.applyVector2(S,this.source_textureCoords,t.uv_arr),t.indeice_arr[r]=r++}}let a=new f.Object3D;for(const s in this.geometrys){const o=this.geometrys[s];let l=new it;l.setIndices(new Uint32Array(o.indeice_arr)),l.setAttribute(X.position,new Float32Array(o.vertex_arr)),l.setAttribute(X.normal,new Float32Array(o.normal_arr)),l.setAttribute(X.uv,new Float32Array(o.uv_arr)),l.setAttribute(X.TEXCOORD_1,new Float32Array(o.uv_arr)),l.addSubGeometry({indexStart:0,indexCount:o.indeice_arr.length,vertexStart:0,index:0});let h=new xi,u=this.matLibs[o.source_mat];h.baseMap=_.res.getTexture(rt.normalizePath(this.baseUrl+u.map_Kd));let c=new f.Object3D,d=c.addComponent(ue);d.geometry=l,d.material=h,a.addChild(c)}this.data=a}}verification(){if(this.data)return!0;throw new Error("Method not implemented.")}}n(vn,"format","text");let bu=`
    struct ImageSize {
        srcWidth: i32,
            srcHeight : i32,
                dstWidth : i32,
                    dstHeight : i32,
    };

    @group(0) @binding(0) var<uniform>size : ImageSize;
    @group(0) @binding(1) var inputTexture: texture_2d<f32>;
    @group(0) @binding(2) var outputTexture: texture_storage_2d<rgba8unorm, write>;

    @compute @workgroup_size(8, 8, 1)
    fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
        var uv: vec2<f32> = vec2<f32>(f32(GlobalInvocationID.x) / f32(size.dstWidth), f32(GlobalInvocationID.y) / f32(size.dstHeight));
        uv = uv * vec2<f32>(f32(size.srcWidth), f32(size.srcHeight));
        var dstId: vec2<i32> = vec2<i32>(i32(GlobalInvocationID.x), i32(GlobalInvocationID.y));
        var srcId: vec2<i32> = vec2<i32>(i32(GlobalInvocationID.x * 2u), i32(GlobalInvocationID.y * 2u));
        textureStore(outputTexture, dstId, textureLoad(inputTexture, srcId, 0));
    }
`,wu=`
    struct ImageSize {
        srcWidth: i32,
            srcHeight : i32,
                dstWidth : i32,
                    dstHeight : i32,
    };

    @group(0) @binding(0) var<uniform>size : ImageSize;
    @group(0) @binding(1) var inputTexture: texture_2d<f32>;
    @group(0) @binding(2) var outputTexture: texture_storage_2d<rgba8unorm, write>;

    fn repeat_i32(id: i32, max: i32) -> i32 {
        var ret = id;
        if (id < 0) {
            ret = max + id;
        }
        if (id >= max) {
            ret = id - max;
        }
        return ret;
    }

    fn clamp_i32(id: i32, max: i32) -> i32 {
        var ret = id;
        if (id < 0) {
            ret = 0;
        }
        if (id >= max) {
            ret = max - 1;
        }
        return ret;
    }

    fn blur(idx: u32) -> vec4 < f32 > {
        var id: vec2<i32>;
        id.y = i32(idx) / size.srcWidth;
        id.x = i32(idx) - i32(id.y) * size.srcWidth;
        var _BlurSpread: i32 = 1;
        var result = vec4<f32>(0.0, 0.0, 0.0, 0.0);
        let g: array < f32, 3u > = array<f32, 3u > (0.4026, 0.2442, 0.0545);
        var uv: vec2<i32>;
        for(var h: i32 = 0; h< 5; h = h + 1) {
        let offsetU: i32 = (h - 2) * _BlurSpread;
        uv.x = id.x + offsetU;
        uv.x = clamp_i32(uv.x, size.srcWidth);
        for (var v: i32 = 0; v < 5; v = v + 1) {
            let offsetV: i32 = (v - 2) * _BlurSpread;
            uv.y = id.y + offsetV;
            uv.y = clamp(uv.y, 0, size.srcHeight);
            let weightU: i32 = abs(h - 2);
            let weightV: i32 = abs(v - 2);
            let resultWeight: f32 = g[weightU] * g[weightV];
            var colorf32: vec4<f32> = textureLoad(inputTexture, uv, 0);
            let sampleColor: vec4<f32> = vec4<f32>(colorf32 * resultWeight);
            result = result + sampleColor;
        }
    }

    return result;
    }

    @compute @workgroup_size(8, 8, 1)
    fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
        var uv: vec2<f32> = vec2<f32>(f32(GlobalInvocationID.x) / f32(size.dstWidth), f32(GlobalInvocationID.y) / f32(size.dstHeight));
        uv = uv * vec2<f32>(f32(size.srcWidth), f32(size.srcHeight));
        let srcIdx = i32(uv.y) * size.srcWidth + i32(uv.x);
        var dstId: vec2<i32> = vec2<i32>(i32(GlobalInvocationID.x), i32(GlobalInvocationID.y));
        textureStore(outputTexture, dstId, blur(u32(srcIdx)));
    }
`;class Su{static blurImageFromTexture(e,t,r,a){const s=I.device;let o=a?wu:bu;const l=s.createComputePipeline({layout:"auto",compute:{module:s.createShaderModule({code:o}),entryPoint:"main"}}),h=4*4,u=s.createBuffer({size:h,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});s.queue.writeBuffer(u,0,new Uint32Array([e.width,e.height,t,r]));const c=s.createTexture({size:[t,r,1],mipLevelCount:1,format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.RENDER_ATTACHMENT,label:"blurImageFromTexture"});let d=[{binding:0,resource:{buffer:u,size:4*4}},{binding:1,resource:e.gpuTexture.createView({format:"rgba8unorm",dimension:"2d",baseMipLevel:0,mipLevelCount:1})},{binding:2,resource:c.createView({format:"rgba8unorm",dimension:"2d",baseMipLevel:0,mipLevelCount:1})}];const g=s.createBindGroup({layout:l.getBindGroupLayout(0),entries:d}),m=w.beginCommandEncoder(),A=m.beginComputePass();return A.setPipeline(l),A.setBindGroup(0,g),A.dispatchWorkgroups(Math.floor(t/8),Math.floor(r/8)),A.end(),w.endCommandEncoder(m),u.destroy(),c}}class as extends st{constructor(){super(4,4),n(this,"width",4),n(this,"height",4),n(this,"depthOrArrayLayers",6),n(this,"visibility",GPUShaderStage.FRAGMENT),n(this,"textureBindingLayout",{viewDimension:"cube",multisampled:!1}),n(this,"samplerBindingLayout",{type:"filtering"}),this.addressModeU=Et.clamp_to_edge,this.addressModeV=Et.clamp_to_edge,this.addressModeW=Et.clamp_to_edge,this.magFilter=this.minFilter="linear",this.mipmapFilter="linear",this.visibility=GPUShaderStage.FRAGMENT}createTextureDescriptor(e,t,r,a,s=GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT,o=1){this.width=e,this.height=t,this.format=a,this.usage=s,this.textureDescriptor={size:{width:e,height:t,depthOrArrayLayers:6},mipLevelCount:r,format:a,usage:s,dimension:"2d"},o>1?this.viewDescriptor={dimension:"cube-array"}:this.viewDescriptor={dimension:this.textureBindingLayout.viewDimension}}}const Iu=class{static createFace(i,e,t,r){const a=I.device;this.pipeline==null&&(this.pipeline=a.createComputePipeline({layout:"auto",compute:{module:a.createShaderModule({code:Iu.createCube}),entryPoint:"main"}}));const s=this.pipeline,o=4*4;this.configBuffer||(this.configBuffer=a.createBuffer({size:o,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST})),a.queue.writeBuffer(this.configBuffer,0,new Uint32Array([i,0,0,0])),this.blurSettingBuffer||(this.blurSettingBuffer=a.createBuffer({size:o,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST})),a.queue.writeBuffer(this.blurSettingBuffer,0,new Float32Array([0,0,0,0]));let l=[{binding:0,resource:{buffer:this.configBuffer,size:4*4}},{binding:1,resource:t.getGPUView()},{binding:2,resource:r.getGPUView()}];const h=a.createBindGroup({layout:s.getBindGroupLayout(0),entries:l}),u=w.beginCommandEncoder(),c=u.beginComputePass();c.setPipeline(s),c.setBindGroup(0,h),c.dispatchWorkgroups(e/8,e/8),c.end(),w.endCommandEncoder(u)}};let hr=Iu;n(hr,"createCube",`

struct SettingUniform {
  faceIndex : i32,
  srcHeight : i32,
  dstWidth : i32,
  dstHeight : i32
};

@group(0) @binding(0) var<uniform> settingUniform : SettingUniform;
@group(0) @binding(1) var inputTex : texture_2d<f32>;
@group(0) @binding(2) var outTex : texture_storage_2d<rgba8unorm, write>;

@compute @workgroup_size(8, 8, 1)
fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
  let coord = vec2<i32>(GlobalInvocationID.xy);
  
  let outTexSize = textureDimensions(outTex).xy;
  let outTexel = 1.0 / vec2<f32>(outTexSize - 1);
  
  let uv_0 = vec2<f32>(coord) * outTexel;
  var oc = samplePixel(settingUniform.faceIndex, uv_0);
  textureStore(outTex, coord, oc);
}

fn samplePixel(face:i32, uv01:vec2<f32>) -> vec4<f32> {
    let rectangle_v2_f32 = round(vec2<f32>(0.25, 0.33333) * vec2<f32>(textureDimensions(inputTex).xy));
    let rectangle = vec2<i32>(rectangle_v2_f32);
    
    var offsetIndex = vec2<i32>(0);
    if(face == 0){
        offsetIndex.x = 2;
        offsetIndex.y = 1;
    }else if(face == 1){
        offsetIndex.x = 0;
        offsetIndex.y = 1;
    }else if(face == 2){
        offsetIndex.x = 1;
        offsetIndex.y = 0;
    }else if(face == 3){
        offsetIndex.x = 1;
        offsetIndex.y = 2;
    }else if(face == 4){
        offsetIndex.x = 1;
        offsetIndex.y = 1;
    }else if(face == 5){
        offsetIndex.x = 3;
        offsetIndex.y = 1;
    }
    
    let coordOffset = rectangle * offsetIndex;
    let coordIndex = vec2<i32>(vec2<f32>(rectangle - 1) * uv01);
    var oc = textureLoad(inputTex, coordOffset + coordIndex, 0);
    return oc;
}
`),n(hr,"configBuffer",null),n(hr,"blurSettingBuffer",null),n(hr,"pipeline");class xn extends as{constructor(){super(),n(this,"_images"),n(this,"_url"),this.useMipmap=!0}generateImages(e){let t=I.device;this.width=this.height=32,"width"in e[0]&&(this.width=this.height=e[0].width);let r=Math.min(this.width,this.height);for(this.mipmapCount=1;r>16;)r/=2,this.mipmapCount++;this.textureBindingLayout.viewDimension="cube",this.samplerBindingLayout.type="filtering",this.createTextureDescriptor(this.width,this.height,this.mipmapCount,this.format),this.textureDescriptor.size={width:this.width,height:this.height,depthOrArrayLayers:6},this.textureDescriptor.dimension="2d",this.gpuTexture=t.createTexture(this.textureDescriptor);let a=[],s=a,o=this.width,l=this.height;if(e[0]instanceof st){for(let h=0;h<6;h++){let u=e[h];a[h]=u.getGPUTexture()}this.uploadMipmapGPUTexture(0,this.width,this.width,a)}else{this.uploadBaseImages(this.width,e);for(let h=0;h<6;h++){let u=new ei(!1);u.format=this.format,u.source=e[h],a[h]=u.getGPUTexture()}}for(let h=1;h<this.mipmapCount;h++){s=a,a=[];let u={width:o,height:l,gpuTexture:null};o=o/2,l=l/2;for(let c=0;c<6;c++)u.gpuTexture=s[c],a[c]=Su.blurImageFromTexture(u,o,l,!1);this.uploadMipmapGPUTexture(h,o,l,a)}this.gpuSampler=t.createSampler(this)}uploadBaseImages(e,t){let r=I.device;const a=w.beginCommandEncoder();for(let s=0;s<6;s++)r.queue.copyExternalImageToTexture({source:t[s]},{texture:this.gpuTexture,mipLevel:0,origin:{x:0,y:0,z:s}},{width:e,height:e,depthOrArrayLayers:1});w.endCommandEncoder(a)}uploadMipmapGPUTexture(e,t,r,a){const s=w.beginCommandEncoder();for(let o=0;o<6;o++)s.copyTextureToTexture({texture:a[o],mipLevel:0,origin:{x:0,y:0,z:0}},{texture:this.gpuTexture,mipLevel:e,origin:{x:0,y:0,z:o}},{width:t,height:r,depthOrArrayLayers:1});w.endCommandEncoder(s)}get images(){return this._images}set images(e){if(this._images=e,this._images[0]instanceof HTMLImageElement){let t=function(o,l){l.decode().then(async()=>{r[o]=await createImageBitmap(l),a--,a==0&&s.generateImages(r)})},r=[],a=6,s=this;for(let o=0;o<6;o++)t(o,this._images[o])}else(this._images instanceof HTMLCanvasElement||this._images instanceof ImageBitmap)&&this.generateImages(this._images)}async load(e){this._url=e;let t=6,r=[];this.format=G.rgba8unorm;let a=this;async function s(o,l){const h=document.createElement("img");if(h.src=l,h.setAttribute("crossOrigin",""),await h.decode(),r[o]=await createImageBitmap(h),t--,t==0)return a.generateImages(r),!0}for(let o=0;o<6;o++)await s(o,e[o]);return!0}async loadStd(e){this._url=e,this.format=G.rgba8unorm;const t=document.createElement("img");t.src=e,t.setAttribute("crossOrigin",""),await t.decode();let r=new ei(!1);r.name=rt.getURLName(e),r.format="rgba8unorm",r.source=await createImageBitmap(t);let a=Math.round(Math.log2(r.width/4));a=Math.pow(2,a),this.width=this.height=a;let s=[];for(let o=0;o<6;o++){let l=new ne(a,a,this.format,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_SRC|GPUTextureUsage.TEXTURE_BINDING);l.name="face "+o,s.push(l),hr.createFace(o,this.width,r,l)}return this.generateImages(s),!0}}var Eu=(i=>(i[i.Left=0]="Left",i[i.Right=1]="Right",i[i.Bottom=2]="Bottom",i[i.Top=3]="Top",i[i.Back=4]="Back",i[i.Front=5]="Front",i))(Eu||{});class yn{static getRotationToFace(e){let t=K.identity().clone(),r=new p,a=new H().identity(),s=new p;switch(e){case 3:r.set(0,-1,0),s.set(0,0,-1);break;case 2:r.set(0,1,0),s.set(0,0,1);break;case 1:r.set(1,0,0),s.set(0,1,0);break;case 0:r.set(-1,0,0),s.set(0,1,0);break;case 4:r.set(0,0,-1),s.set(0,1,0);break;case 5:return K.identity()}return a.lookAt(new p,r,s),t.setFromRotationMatrix(a),t}}let Bu=`
  struct ImageSize {
    srcWidth : i32,
    srcHeight : i32,
    dstWidth : i32,
    dstHeight : i32
  };

  @group(0) @binding(0) var<uniform> size : ImageSize;
  @group(0) @binding(1) var<storage,read_write> faceRotation: array<vec4<f32>>;
  @group(0) @binding(2) var inputTexSampler : sampler;
  @group(0) @binding(3) var inputTex : texture_2d<f32>;

  @group(1) @binding(0) var outputBuffer0 : texture_storage_2d_array<rgba16float, write>;

  fn SampleSphericalMap(v: vec3<f32>) -> vec2<f32> {
      var uv:vec2<f32> = vec2<f32>(atan2(v.z, v.x), asin(v.y));
      //uv = (uv * (vec2<f32>(0.1590999960899353, 0.3183000087738037) + vec2<f32>(0.0010000000474974513)));
      uv = uv * vec2<f32>(0.1590999960899353, 0.3183000087738037);
      uv = uv + vec2<f32>(0.5);
      uv = clamp(uv, vec2<f32>(0.0), vec2<f32>(1.0));
      return uv;
  }


  fn applyQuaternion(position:vec3<f32>, q:vec4<f32>) -> vec3<f32>{
      let x:f32 = position.x;
      let y:f32 = position.y;
      let z:f32 = position.z;

      let qx:f32 = q.x;
      let qy:f32 = q.y;
      let qz:f32 = q.z;
      let qw:f32 = q.w;

      let ix:f32 = qw * x + qy * z - qz * y;
      let iy:f32 = qw * y + qz * x - qx * z;
      let iz:f32 = qw * z + qx * y - qy * x;
      let iw:f32 = -qx * x - qy * y - qz * z;

      var ret: vec3<f32>;
      ret.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
      ret.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
      ret.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;

      return ret;
  }

  fn convertIdToDir3(uv_i32:vec2<i32>, quaternion:vec4<f32>) -> vec3<f32>{
      var uv_f32:vec2<f32> = vec2<f32>(uv_i32.xy);
      var halfSize:f32 = f32(size.dstWidth / 2) - 0.5;
      var worldDirection:vec3<f32> = vec3<f32>(uv_f32.x - halfSize, uv_f32.y - halfSize, -halfSize);
      worldDirection = normalize(worldDirection);
      worldDirection = applyQuaternion(worldDirection, quaternion);
      return worldDirection;
  }

  @compute @workgroup_size(8, 8, 1)
  fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
    let coord = vec2<i32>(GlobalInvocationID.xy);
    let quaternion = faceRotation[GlobalInvocationID.z];
    var worldDirection:vec3<f32> = convertIdToDir3(coord, quaternion);
    let uv_f32:vec2<f32> = SampleSphericalMap(worldDirection);
    let oc = textureSampleLevel(inputTex, inputTexSampler, uv_f32 , 0.0);
    textureStore(outputBuffer0, coord, i32(GlobalInvocationID.z), oc);
  }
`,Tu=`
  struct ImageSize {
    srcWidth : i32,
    srcHeight : i32,
    dstWidth : i32,
    dstHeight : i32
  };

  @group(0) @binding(0) var<uniform> size : ImageSize;
  @group(0) @binding(1) var<storage, read> tex_in: array<vec4<f32>>;
  @group(0) @binding(2) var outputBuffer : texture_storage_2d<rgba16float, write>;

  @compute @workgroup_size(8, 8, 1)
  fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
    let fragCoord = vec2<i32>(i32(GlobalInvocationID.x), i32(GlobalInvocationID.y));
    var oc:vec4<f32> = tex_in[fragCoord.y * size.srcWidth + fragCoord.x] / 256.0;
    var e = pow(2.0, oc.w * 255.0 - 128.0);
    oc = oc * e;
    oc = scaleByThreshold(oc, 40.0);
    textureStore(outputBuffer, fragCoord , vec4<f32>(oc.xyz, 1.0) );
  }

  fn scaleByThreshold(color:vec4<f32>, threshold:f32) -> vec4<f32>{
    var oc = color;
    let brightness = length(vec3<f32>(oc.xyz));
    var scale = brightness / threshold;
    if(scale > 1.0){
        scale = 1.0 / pow(scale, 0.7);
        oc = oc * scale;
    }
    oc.a = 1.0;
    return oc;
  }
`;const wt=class{static convertRGBE2RGBA(i,e){const t=I.device,r=t.createComputePipeline({layout:"auto",compute:{module:t.createShaderModule({code:Tu}),entryPoint:"main"}}),a=t.createBuffer({size:4*4,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});t.queue.writeBuffer(a,0,new Uint32Array([i.width,i.height,i.width,i.height]));const s=t.createBuffer({size:e.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC});t.queue.writeBuffer(s,0,e);let o=[{binding:0,resource:{buffer:a,size:4*4}},{binding:1,resource:{buffer:s,size:e.byteLength}},{binding:2,resource:i.getGPUView()}];const l=t.createBindGroup({layout:r.getBindGroupLayout(0),entries:o}),h=w.beginCommandEncoder(),u=h.beginComputePass();u.setPipeline(r),u.setBindGroup(0,l),u.dispatchWorkgroups(Math.floor(i.width/8),Math.floor(i.height/8)),u.end(),w.endCommandEncoder(h),a.destroy()}static makeTextureCube(i,e,t){const r=I.device;wt.makeFaceTexturePipeline||(wt.makeFaceTexturePipeline=r.createComputePipeline({layout:"auto",compute:{module:r.createShaderModule({code:Bu}),entryPoint:"main"}}));const a=wt.makeFaceTexturePipeline,s=4*4;wt.configBuffer||(wt.configBuffer=r.createBuffer({size:s,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST})),r.queue.writeBuffer(wt.configBuffer,0,new Uint32Array([i.width,i.height,e,e]));const o=4*6;if(!wt.quaternionBuffer){wt.quaternionBuffer=r.createBuffer({size:o*4*6,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST});let m=new Float32Array(4*6);for(let A=0;A<6;A++){let v=yn.getRotationToFace(A);m[A*4+0]=v.x,m[A*4+1]=v.y,m[A*4+2]=v.z,m[A*4+3]=v.w}r.queue.writeBuffer(wt.quaternionBuffer,0,m)}let l=[{binding:0,resource:{buffer:wt.configBuffer,size:4*4}},{binding:1,resource:{buffer:wt.quaternionBuffer,size:o*4}},{binding:2,resource:i.gpuSampler},{binding:3,resource:i.getGPUView()}],h=[{binding:0,resource:t}];const u=r.createBindGroup({layout:a.getBindGroupLayout(0),entries:l}),c=r.createBindGroup({layout:a.getBindGroupLayout(1),entries:h}),d=w.beginCommandEncoder(),g=d.beginComputePass();g.setPipeline(a),g.setBindGroup(0,u),g.setBindGroup(1,c),g.dispatchWorkgroups(e/8,e/8,6),g.end(),w.endCommandEncoder(d)}};let Ni=wt;n(Ni,"makeFaceTexturePipeline"),n(Ni,"configBuffer"),n(Ni,"quaternionBuffer");class Cn extends st{constructor(){super(32,32,null),this.isHDRTexture=!0}create(e=32,t=32,r=null,a=!0){this.width=e,this.height=t;let s=I.device;const o=2,l=e*4*o;let h=r;this.format=G.rgba16float,this.useMipmap=a,this.updateTextureDescription(),this.updateGPUTexture();const u=s.createBuffer({size:h.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC});s.queue.writeBuffer(u,0,h);const c=w.beginCommandEncoder();return c.copyBufferToTexture({buffer:u,bytesPerRow:l},{texture:this.getGPUTexture()},{width:e,height:t,depthOrArrayLayers:1}),w.endCommandEncoder(c),this.useMipmap||(this.samplerBindingLayout.type="filtering",this.textureBindingLayout.sampleType="float"),this.gpuSampler=s.createSampler(this),this}async load(e,t){return(await new ot().load(e,ss,t)).getHDRTexture()}}const Du=new Float32Array(1),Gg=new Int32Array(Du.buffer);let ur=function(i){Du[0]=i;const e=Gg[0];let t=e>>16&32768,r=e>>12&2047;const a=e>>23&255;return a<103?t:a>142?(t|=31744,t|=(a==255?1:0)&&e&8388607,t):a<114?(r|=2048,t|=(r>>114-a)+(r>>113-a&1),t):(t|=a-112<<10|r>>1,t+=r&1,t)};var Mu=(i=>(i[i.RGBE_RETURN_FAILURE=-1]="RGBE_RETURN_FAILURE",i[i.rgbe_read_error=1]="rgbe_read_error",i[i.rgbe_write_error=2]="rgbe_write_error",i[i.rgbe_format_error=3]="rgbe_format_error",i[i.rgbe_memory_error=4]="rgbe_memory_error",i))(Mu||{});class bn{constructor(){n(this,"valid"),n(this,"string"),n(this,"comments"),n(this,"programtype"),n(this,"format"),n(this,"gamma"),n(this,"exposure"),n(this,"width"),n(this,"height")}}class ss extends Xt{constructor(){super(...arguments),n(this,"_rgbeArray"),n(this,"_width"),n(this,"_height"),n(this,"_RGBE_RETURN_FAILURE",-1),n(this,"_parserType",G.rgba8uint)}parseBuffer(e){let t,r=new Uint8Array(e);r.pos=0;const a=this.paserHeader(r);if(a instanceof bn){const s=this._width=a.width,o=this._height=a.height;let l=this.parserPixel(r.subarray(r.pos),s,o);if(l instanceof Uint8Array){switch(this._rgbeArray=l,this._parserType){}return this.data=t,t}}return null}verification(){if(this.data&&this.data instanceof st)return!0;if(this._rgbeArray)return!0;throw new Error("Method not implemented.")}getTexture(){return this.data}getCubeTexture(){let e=this._width/4;return new ns().createFromHDRData(e,{width:this._width,height:this._height,array:this._rgbeArray})}getHDRTexture(){return new Cn().create(this._width,this._height,this._rgbeArray)}parseError(e,t){switch(e){case 1:console.error("Read Error: "+(t||""));break;case 2:console.error("Write Error: "+(t||""));break;case 3:console.error("Bad File Format: "+(t||""));break;default:case 4:console.error("Error: "+(t||""))}return-1}parserBlock(e,t,r){t=t||1024;let s=e.pos,o=-1,l=0,h="",u=String.fromCharCode.apply(null,new Uint16Array(e.subarray(s,s+128)));const c=`
`;for(;0>(o=u.indexOf(c))&&l<t&&s<e.byteLength;)h+=u,l+=u.length,s+=128,u+=String.fromCharCode.apply(null,new Uint16Array(e.subarray(s,s+128)));return-1<o?(r!==!1&&(e.pos+=l+o+1),h+u.slice(0,o)):!1}paserHeader(e){const t=/^#\?(\S+)/,r=/^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,a=/^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,s=/^\s*FORMAT=(\S+)\s*$/,o=/^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,l=new bn;let h,u;if(e.pos>=e.byteLength||!(h=this.parserBlock(e)))return this.parseError(1,"no header found");if(!(u=h.match(t)))return this.parseError(3,"bad initial token");const c=1,d=2,g=4;for(l.valid|=c,l.programtype=u[1],l.string+=h+`
`;h=this.parserBlock(e),h!==!1;){if(l.string+=h+`
`,h.charAt(0)==="#"){l.comments+=h+`
`;continue}if((u=h.match(r))&&(l.gamma=Math.floor(parseFloat(u[1])*10)/10),(u=h.match(a))&&(l.exposure=Math.floor(parseFloat(u[1])*10)/10),(u=h.match(s))&&(l.valid|=d,l.format=u[1]),(u=h.match(o))&&(l.valid|=g,l.height=parseInt(u[1],10),l.width=parseInt(u[2],10)),l.valid&d&&l.valid&g)break}return l.valid&d?l.valid&g?l:(this.parseError(3,"missing image size specifier"),null):(this.parseError(3,"missing format specifier"),null)}parserPixel(e,t,r){const a=t;if(a<8||a>32767||e[0]!==2||e[1]!==2||e[2]&128)return new Uint8Array(e);if(a!==(e[2]<<8|e[3]))return this.parseError(3,"wrong scanline width");const s=new Uint8Array(4*t*r);if(!s.length)return this.parseError(4,"unable to allocate buffer space");let o=0,l=0;const h=4*a,u=new Uint8Array(4),c=new Uint8Array(h);let d=r;for(;d>0&&l<e.byteLength;){if(l+4>e.byteLength)return this.parseError(1,"");if(u[0]=e[l++],u[1]=e[l++],u[2]=e[l++],u[3]=e[l++],u[0]!=2||u[1]!=2||(u[2]<<8|u[3])!=a)return this.parseError(3,"bad rgbe scanline format");let g=0,m;for(;g<h&&l<e.byteLength;){m=e[l++];const v=m>128;if(v&&(m-=128),m===0||g+m>h)return this.parseError(3,"bad scanline data");if(v){const y=e[l++];for(let C=0;C<m;C++)c[g++]=y}else c.set(e.subarray(l,l+m),g),g+=m,l+=m}const A=a;for(let v=0;v<A;v++){let y=0;s[o]=c[v+y],y+=a,s[o+1]=c[v+y],y+=a,s[o+2]=c[v+y],y+=a,s[o+3]=c[v+y],o+=4}d--}return s}rbgeToFloat(e,t,r,a){const s=e[t+3],o=Math.pow(2,s-128)/255;r[a+0]=e[t+0]*o,r[a+1]=e[t+1]*o,r[a+2]=e[t+2]*o,r[a+3]=1}rbgeToHalfFloat(e,t,r,a){const s=e[t+3],o=Math.pow(2,s-128)/255;r[a+0]=ur(e[t+0]*o),r[a+1]=ur(e[t+1]*o),r[a+2]=ur(e[t+2]*o),r[a+3]=ur(1)}}n(ss,"format","bin");let Pu=`
    struct ImageSize {
        srcWidth : i32,
        srcHeight : i32,
        dstWidth : i32,
        dstHeight : i32
    };
    
    @group(0) @binding(0) var<uniform> size : ImageSize;
    @group(0) @binding(1) var<storage,read_write> faceRotation: array<vec4<f32>>;
    @group(0) @binding(2) var inputTexSampler : sampler;
    @group(0) @binding(3) var inputTex : texture_2d<f32>;
    
    @group(1) @binding(0) var<uniform> blurSetting : vec4<f32>;
    @group(1) @binding(1) var outputBuffer0 : texture_storage_2d_array<rgba16float, write>;
    
    var<private> PI: f32 = 3.14159265359;
    
    fn applyQuaternion(position:vec3<f32>, q:vec4<f32>) -> vec3<f32>{
        let x:f32 = position.x;
        let y:f32 = position.y;
        let z:f32 = position.z;
    
        let qx:f32 = q.x;
        let qy:f32 = q.y;
        let qz:f32 = q.z;
        let qw:f32 = q.w;
    
        let ix:f32 = qw * x + qy * z - qz * y;
        let iy:f32 = qw * y + qz * x - qx * z;
        let iz:f32 = qw * z + qx * y - qy * x;
        let iw:f32 = -qx * x - qy * y - qz * z;
    
        var ret: vec3<f32>;
        ret.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
        ret.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
        ret.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    
        return ret;
    }
    
    fn convertIdToDir3(uv_i32:vec2<i32>, quaternion:vec4<f32>) -> vec3<f32>{
        var uv_f32:vec2<f32> = vec2<f32>(uv_i32.xy);
        var halfSize:f32 = f32(size.dstWidth / 2);
        var worldDirection:vec3<f32> = vec3<f32>(uv_f32.x - halfSize, uv_f32.y - halfSize, -halfSize);
        worldDirection = normalize(worldDirection);
        worldDirection = applyQuaternion(worldDirection, quaternion);
        return worldDirection;
    }
    
    fn VanDerCorpus(n0:u32, base0:u32) -> f32
    {
        var n = n0;
        var base = base0;
        var invBase:f32 = 1.0 / f32(base);
        var denom:f32   = 1.0;
        var result:f32  = 0.0;
    
        for(var i:u32 = 0u; i < 32u; i = i + 1u)
        {
            if(n > 0u)
            {
                denom   = f32(n) % 2.0;
                result = result + denom * invBase;
                invBase = invBase / 2.0;
                n       = u32(f32(n) / 2.0);
            }
        }
    
        return result;
    }
    
    fn HammersleyNoBitOps(i:u32, N:u32) -> vec2<f32>
    {
        return vec2(f32(i)/f32(N), VanDerCorpus(i, 2u));
    }
    
    fn hammersley( i : u32 ,  N : u32 ) -> vec2<f32>
    {
        // Radical inverse based on http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html
        var bits = (i << 16u) | (i >> 16u);
        bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
        bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
        bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
        bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
        var rdi = f32(bits) * 2.3283064365386963e-10;
        return vec2<f32>(f32(i) /f32(N), rdi);
    }
    
    fn ImportanceSampleGGX( Xi:vec2<f32>, N:vec3<f32>, roughness:f32) ->vec3<f32>
    {
        var a = roughness*roughness;
    
        var phi = 2.0 * PI * Xi.x;
        var cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));
        var sinTheta = sqrt(1.0 - cosTheta*cosTheta);
    
        // from spherical coordinates to cartesian coordinates
        var H:vec3<f32>;
        H.x = cos(phi) * sinTheta;
        H.y = sin(phi) * sinTheta;
        H.z = cosTheta;
    
        // from tangent-space vector to world-space sample vector
        var up:vec3<f32>;
        if(abs(N.z) < 0.999)
        {
            up = vec3<f32>(0.0, 0.0, 1.0);
        }
        else
        {
            up = vec3<f32>(1.0, 0.0, 0.0);
        }
        var tangent:vec3<f32>  = normalize(cross(up, N));
        var bitangent:vec3<f32> = cross(N, tangent);
        var sampleVec:vec3<f32> = tangent * H.x + bitangent * H.y + N * H.z;
        return normalize(sampleVec);
    }
    
    fn multiSample(localPos:vec3<f32>, roughness:f32) -> vec4<f32>
    {
        var N: vec3<f32> = normalize(localPos);
        var R: vec3<f32> = N;
        var V: vec3<f32> = R;
    
        let SAMPLE_COUNT:u32 = 1024u;
        var totalWeight:f32 = 0.0;
        var prefilteredColor:vec3<f32> = vec3<f32>(0.0, 0.0, 0.0);
        for(var i:u32 = 0u; i < SAMPLE_COUNT; i = i + 1u)
        {
            var Xi:vec2<f32> = hammersley(i, SAMPLE_COUNT);
            var H :vec3<f32> = ImportanceSampleGGX(Xi, N, roughness);
            var L :vec3<f32> = normalize(2.0 * dot(V, H) * H - V);
    
            var NdotL:f32 = max(dot(N, L), 0.0);
            if(NdotL > 0.0)
            {
                var att = 1.0 ;//( f32(SAMPLE_COUNT - i) / f32(SAMPLE_COUNT)) ;
    
                prefilteredColor = prefilteredColor + sampleColor(L).rgb * NdotL;
                prefilteredColor = prefilteredColor * att ;
                totalWeight      = totalWeight + NdotL;
            }
        }
        prefilteredColor = prefilteredColor / totalWeight;
    
        return vec4<f32>(prefilteredColor, 1.0);
    }
    
    fn SampleSphericalMap(v: vec3<f32>) -> vec2<f32> {
        var uv:vec2<f32> = vec2<f32>(atan2(v.z, v.x), asin(v.y));
        //uv = (uv * (vec2<f32>(0.1590999960899353, 0.3183000087738037) + vec2<f32>(0.0010000000474974513)));
        uv = uv * vec2<f32>(0.1590999960899353, 0.3183000087738037);
        uv = uv + vec2<f32>(0.5);
        uv = clamp(uv, vec2<f32>(0.0), vec2<f32>(1.0));
        return uv;
    }
    
    fn sampleColor(d:vec3<f32>) -> vec4<f32>
    {
        let uv_f32:vec2<f32> = SampleSphericalMap(d);
        let oc = textureSampleLevel(inputTex, inputTexSampler, uv_f32 , 0.0);
        //let dir = vec3<f32>(-d.x, -d.y, d.z);
        //var oc:vec4<f32> = textureSampleLevel(cubeMap, cubeMapSampler, dir, 0.0);
        return oc;
    }
    
    @compute @workgroup_size(8, 8, 1)
    fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
        let coord = vec2<i32>(GlobalInvocationID.xy);
        let quaternion = faceRotation[GlobalInvocationID.z];
        var worldDirection:vec3<f32> = convertIdToDir3(coord, quaternion);
        var oc:vec4<f32> = multiSample(worldDirection, blurSetting.x);
        textureStore(outputBuffer0, coord, i32(GlobalInvocationID.z), oc);
    }

`;class cr{static importantSample(e,t,r,a){const s=I.device;this.pipeline==null&&(this.pipeline=s.createComputePipeline({layout:"auto",compute:{module:s.createShaderModule({code:Pu}),entryPoint:"main"}}));const o=this.pipeline,l=4*4;this.configBuffer||(this.configBuffer=s.createBuffer({size:l,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST})),s.queue.writeBuffer(this.configBuffer,0,new Uint32Array([e.width,e.height,t,t]));const h=4*6;if(!this.quaternionBuffer){this.quaternionBuffer=s.createBuffer({size:h*4*6,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST});let y=new Float32Array(4*6);for(let C=0;C<6;C++){let S=yn.getRotationToFace(C);y[C*4+0]=S.x,y[C*4+1]=S.y,y[C*4+2]=S.z,y[C*4+3]=S.w}s.queue.writeBuffer(this.quaternionBuffer,0,y)}this.blurSettingBuffer||(this.blurSettingBuffer=s.createBuffer({size:l,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST})),s.queue.writeBuffer(this.blurSettingBuffer,0,new Float32Array([r,0,0,0]));const u=e.erpTexture;let c=[{binding:0,resource:{buffer:this.configBuffer,size:4*4}},{binding:1,resource:{buffer:this.quaternionBuffer,size:h*4}},{binding:2,resource:u.gpuSampler},{binding:3,resource:u.getGPUView()}],d=[{binding:0,resource:{buffer:this.blurSettingBuffer,size:4*4}},{binding:1,resource:a}];const g=s.createBindGroup({layout:o.getBindGroupLayout(0),entries:c}),m=s.createBindGroup({layout:o.getBindGroupLayout(1),entries:d}),A=w.beginCommandEncoder(),v=A.beginComputePass();v.setPipeline(o),v.setBindGroup(0,g),v.setBindGroup(1,m),v.dispatchWorkgroups(t/8,t/8,6),v.end(),w.endCommandEncoder(A)}}n(cr,"configBuffer",null),n(cr,"quaternionBuffer",null),n(cr,"blurSettingBuffer",null),n(cr,"pipeline");class wn{constructor(e){n(this,"faceTextureRef"),n(this,"_texture"),this._texture=e,this.faceTextureRef={}}uploadTexture(e,t){let r=this.getGpuSource(e);return Ni.makeTextureCube(t,this._texture.width,r.v),this}uploadErpTexture(e){let t=this.getGpuSource(0);return Ni.makeTextureCube(e,this._texture.width,t.v),this.generateMipmap(e),this}getGpuSource(e){let t=this.faceTextureRef[e];return t||(t={t:this._texture.getGPUTexture(),v:this._texture.getGPUTexture().createView({format:this._texture.format,dimension:"2d-array",baseMipLevel:e,mipLevelCount:1,arrayLayerCount:6})},this.faceTextureRef[e]=t),t}generateMipmap(e){let t=1;for(;t<this._texture.mipmapCount;)this.generateMipmapAtLevel(t,e),t++}generateMipmapAtLevel(e,t,r=3){let a=this._texture.width/Math.pow(2,e),s={width:a,height:a,erpTexture:t},o=(e+1)/this._texture.mipmapCount;o=Math.pow(o,r);let l=this.getGpuSource(e);cr.importantSample(s,a,o,l.v)}}class ns extends as{constructor(){super(),n(this,"_url"),n(this,"_faceData"),this.useMipmap=!0,this.format=G.rgba16float,this.isHDRTexture=!0,this._faceData=new wn(this)}createFromHDRData(e,t){let r=new ne(t.width,t.height,G.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING),a=new Float32Array(t.array);return Ni.convertRGBE2RGBA(r,a),this.createFromTexture(e,r),this}createFromTexture(e,t){this.width=this.height=e,this.textureBindingLayout.viewDimension="cube";let r=this.width;for(this.mipmapCount=1;r>16;)r/=2,this.mipmapCount++;return this.createTextureDescriptor(e,e,this.mipmapCount,this.format),this.textureDescriptor.size={width:e,height:e,depthOrArrayLayers:6},this.textureDescriptor.dimension="2d",this.gpuSampler=I.device.createSampler(this),this._faceData.uploadErpTexture(t),this}async load(e,t){return this._url=e,(await new ot().load(e,ss,t)).getCubeTexture()}}function Ru(i){return new TextDecoder().decode(i)}class os{constructor(e,t,r,a){n(this,"buffer"),n(this,"binOffset"),n(this,"binLength"),n(this,"header"),this.buffer=e,this.binOffset=t+r,this.binLength=a;let s=null;if(r!==0){const o=new Uint8Array(e,t,r);s=JSON.parse(Ru(o))}else s={};this.header=s}getKeys(){return Object.keys(this.header)}getData(e,t,r=null,a=null){const s=this.header;if(!(e in s))return null;const o=s[e];if(o instanceof Object){if(Array.isArray(o))return o;{const{buffer:l,binOffset:h,binLength:u}=this,c=o.byteOffset||0,d=o.type||a,g=o.componentType||r;if("type"in o&&a&&o.type!==a)throw new Error("FeatureTable: Specified type does not match expected type.");let m;switch(d){case"SCALAR":m=1;break;case"VEC2":m=2;break;case"VEC3":m=3;break;case"VEC4":m=4;break;default:throw new Error(`FeatureTable : Feature type not provided for "${e}".`)}let A;const v=h+c,y=t*m;switch(g){case"BYTE":A=new Int8Array(l,v,y);break;case"UNSIGNED_BYTE":A=new Uint8Array(l,v,y);break;case"SHORT":A=new Int16Array(l,v,y);break;case"UNSIGNED_SHORT":A=new Uint16Array(l,v,y);break;case"INT":A=new Int32Array(l,v,y);break;case"UNSIGNED_INT":A=new Uint32Array(l,v,y);break;case"FLOAT":A=new Float32Array(l,v,y);break;case"DOUBLE":A=new Float64Array(l,v,y);break;default:throw new Error(`FeatureTable : Feature component type not provided for "${e}".`)}if(v+y*A.BYTES_PER_ELEMENT>h+u)throw new Error("FeatureTable: Feature data read outside binary body length.");return A}}else return o}}class Sn extends os{constructor(e,t,r,a,s){super(e,r,a,s),n(this,"batchSize"),this.batchSize=t}getData(e,t=null,r=null){return super.getData(e,this.batchSize,t,r)}}function In(i){let e;if(i instanceof DataView?e=i:e=new DataView(i),String.fromCharCode(e.getUint8(0))==="{")return null;let t="";for(let r=0;r<4;r++)t+=String.fromCharCode(e.getUint8(r));return t}class Lu{async parse(e){const t=new DataView(e),r=In(t);console.assert(r==="b3dm");const a=t.getUint32(4,!0);console.assert(a===1);const s=t.getUint32(8,!0);console.assert(s===e.byteLength);const o=t.getUint32(12,!0),l=t.getUint32(16,!0),h=t.getUint32(20,!0),u=t.getUint32(24,!0),c=28,d=new os(e,c,o,l),g=c+o+l,m=new Sn(e,d.getData("BATCH_LENGTH"),g,h,u),A=g+h+u,v=new Uint8Array(e,A,s-A);return{version:a,featureTable:d,batchTable:m,glbBytes:v}}}const ls=class extends Lu{constructor(){super(),n(this,"adjustmentTransform"),n(this,"gltfBuffer"),this.adjustmentTransform=new H().identity(),ls.tempMatrix||(ls.tempMatrix=new H().identity())}async parse(i){const e=await super.parse(i);this.gltfBuffer=e.glbBytes.slice().buffer;let r=await new Tn().parseBinary(this.gltfBuffer),{batchTable:a,featureTable:s}=e;const o=s.getData("RTC_CENTER");o&&(r.x+=o[0],r.y+=o[1],r.z+=o[2]);let l=r.getComponent(Ue);l.updateWorldMatrix();let h=ls.tempMatrix;h.compose(l.localPosition,l.localRotQuat,l.localScale),h.multiply(this.adjustmentTransform);let u=h.decompose(vt.QUATERNION);return l.localRotQuat.copyFrom(u[1]),l.localRotQuat=l.localRotQuat,l.localPosition.copyFrom(u[0]),l.localPosition=l.localPosition,l.localScale.copyFrom(u[2]),l.localScale=l.localScale,l.updateWorldMatrix(),r.batchTable=a,r.featureTable=s,r}static decodeText(i){if(typeof TextDecoder<"u")return new TextDecoder().decode(i);let e="";for(let t=0,r=i.length;t<r;t++)e+=String.fromCharCode(i[t]);try{return decodeURIComponent(escape(e))}catch{return e}}};let Fi=ls;n(Fi,"tempMatrix");class En extends Xt{async parseBuffer(e){let t=new Fi;t.adjustmentTransform=this.userData,this.data=await t.parse(e)}verification(){if(this.data)return!0;throw new Error("Method not implemented.")}}n(En,"format","bin");const Uu="glTF",sa=12,Ou={JSON:1313821514,BIN:5130562},Bn={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:"KHR_materials_pbrSpecularGlossiness",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression"};class Nu{constructor(e){n(this,"name"),n(this,"content"),n(this,"body"),n(this,"header"),this.name=Bn.KHR_BINARY_GLTF,this.content=null,this.body=null;const t=new DataView(e,0,sa);if(this.header={magic:Fi.decodeText(new Uint8Array(e.slice(0,4))),version:t.getUint32(4,!0),length:t.getUint32(8,!0)},this.header.magic!==Uu)throw new Error("GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("GLTFLoader: Legacy binary file detected.");const r=this.header.length-sa,a=new DataView(e,sa);let s=0;for(;s<r;){const o=a.getUint32(s,!0);s+=4;const l=a.getUint32(s,!0);if(s+=4,l===Ou.JSON){const h=new Uint8Array(e,sa+s,o);this.content=Fi.decodeText(h)}else if(l===Ou.BIN){const h=sa+s;this.body=e.slice(h,h+o)}s+=o}if(this.content===null)throw new Error("GLTFLoader: JSON content not found.")}}class Tn{constructor(){n(this,"_binary")}async parseBinary(e){this._binary=e;const t=Fi.decodeText(new Uint8Array(this._binary,0,4)),r={};let a,s;if(t===Uu){try{s=r[Bn.KHR_BINARY_GLTF]=new Nu(this._binary)}catch{return}a=r[Bn.KHR_BINARY_GLTF].content}else a=Fi.decodeText(new Uint8Array(this._binary));const o=JSON.parse(a);return await this.parseGLB(o,s.body)}async parseGLB(e,t){return await new Ja().parseJsonAndBuffer(e,t)}}class Fu{async parse(e){const t=new DataView(e),r=In(t);console.assert(r==="i3dm");const a=t.getUint32(4,!0);console.assert(a===1);const s=t.getUint32(8,!0);console.assert(s===e.byteLength);const o=t.getUint32(12,!0),l=t.getUint32(16,!0),h=t.getUint32(20,!0),u=t.getUint32(24,!0);t.getUint32(28,!0);const c=32,d=new os(e,c,o,l),g=c+o+l,m=new Sn(e,d.getData("INSTANCES_LENGTH"),g,h,u),A=g+h+u,v=new Uint8Array(e,A,s-A);return{version:a,featureTable:d,batchTable:m,glbBytes:v}}}class ku extends f.Object3D{constructor(e,t,r){super(),n(this,"_geometry"),n(this,"_material"),n(this,"_instanceList"),this._geometry=e,this._material=t,this._instanceList=[];for(let a=0;a<r;a++){let s,o=new f.Object3D;s=o.addComponent(ue),s.geometry=this._geometry,s.material=this._material,this.addChild(o),this._instanceList.push(o)}}setMatrixAt(e,t){let r=this._instanceList[e],a=t.decompose(vt.QUATERNION),s=r.transform;return s.localRotQuat.copyFrom(a[1]),s.localRotQuat=s.localRotQuat,s.localPosition.copyFrom(a[0]),s.localPosition=s.localPosition,s.localScale.copyFrom(a[2]),s.localScale=s.localScale,this}}const at=class extends Fu{constructor(){super(),n(this,"adjustmentTransform"),n(this,"_gltfBuffer"),at.tempFwd||(at.tempFwd=new p),at.tempUp||(at.tempUp=new p),at.tempRight||(at.tempRight=new p),at.tempPos||(at.tempPos=new p),at.tempQuat||(at.tempQuat=new K),at.tempSca||(at.tempSca=new p),at.tempMat||(at.tempMat=new H),this.adjustmentTransform=new H().identity()}async parse(i){const e=await super.parse(i);this._gltfBuffer=e.glbBytes.slice().buffer;let r=await new Tn().parseBinary(this._gltfBuffer),{batchTable:a,featureTable:s}=e;const o=this.adjustmentTransform,l=s.getData("INSTANCES_LENGTH"),h=s.getData("POSITION",l,"FLOAT","VEC3"),u=s.getData("NORMAL_UP",l,"FLOAT","VEC3"),c=s.getData("NORMAL_RIGHT",l,"FLOAT","VEC3"),d=s.getData("SCALE_NON_UNIFORM",l,"FLOAT","VEC3"),g=s.getData("SCALE",l,"FLOAT","SCALAR"),m=new Map,A=[];r.traverse(C=>{let S;if(S=C?C.getComponent(ue):null,S){const{geometry:T,material:D}=S,M=new ku(T,D,l);M.localPosition=M.localPosition.copy(C.localPosition),M.localRotation=M.localRotation.copy(C.localRotation),M.localScale=M.localScale.copy(C.localScale),A.push(M),m.set(C,M)}});const v=new p;for(let C=0;C<l;C++)v.x+=h[C*3+0]/l,v.y+=h[C*3+1]/l,v.z+=h[C*3+2]/l;m.forEach((C,S)=>{const T=S.parent?S.parentObject:null;T&&(T.removeChild(S),T.addChild(C),C.transform.updateWorldMatrix(),C.transform.worldMatrix.transformVector4(v,C.localPosition))});const y=at;for(let C=0;C<l;C++){y.tempMat.identity(),y.tempPos.set(h[C*3+0]-v.x,h[C*3+1]-v.y,h[C*3+2]-v.z),u?(y.tempUp.set(u[C*3+0],u[C*3+1],u[C*3+2]),y.tempRight.set(c[C*3+0],c[C*3+1],c[C*3+2]),y.tempRight.crossProduct(y.tempUp,y.tempFwd).normalize(),y.tempMat.makeBasis(y.tempRight,y.tempUp,y.tempFwd),y.tempQuat.setFromRotationMatrix(y.tempMat)):y.tempQuat.set(0,0,0,1),g?y.tempSca.setScalar(g[C]):d?y.tempSca.set(d[C*3+0],d[C*3+1],d[C*3+2]):y.tempSca.set(1,1,1),y.tempMat.compose(y.tempPos,y.tempQuat,y.tempSca),y.tempMat.multiplyMatrices(y.tempMat,o);for(let S=0,T=A.length;S<T;S++)A[S].setMatrixAt(C,y.tempMat)}return r.batchTable=a,r.featureTable=s,r}};let ai=at;n(ai,"tempFwd"),n(ai,"tempUp"),n(ai,"tempRight"),n(ai,"tempPos"),n(ai,"tempQuat"),n(ai,"tempSca"),n(ai,"tempMat");class Dn extends Xt{async parseBuffer(e){let t=new ai;t.adjustmentTransform=this.userData,this.data=await t.parse(e)}verification(){if(this.data)return!0;throw new Error("Method not implemented.")}}n(Dn,"format","bin");class hs extends as{constructor(){super(),n(this,"_faceData"),n(this,"_url"),this.useMipmap=!0,this.format=G.rgba16float,this._faceData=new wn(this)}get ldrImageUrl(){return this._url}async load(e,t){this._url=e;let r=new ei(!1);return await r.load(e,t),this.createFromLDRTexture(r),this}createFromLDRTexture(e){let t=Math.log2(e.width/4);return t=Math.pow(2,Math.round(t)),this.createFromTexture(t,e),this}createFromTexture(e,t){this.width=this.height=e,this.textureBindingLayout.viewDimension="cube";let r=this.width;for(this.mipmapCount=1;r>16;)r/=2,this.mipmapCount++;return this.createTextureDescriptor(e,e,this.mipmapCount,this.format),this.textureDescriptor.size={width:e,height:e,depthOrArrayLayers:6},this.textureDescriptor.dimension="2d",this.gpuSampler=I.device.createSampler(this),this._faceData.uploadErpTexture(t),this}}let zu=`
var<private>PI: f32 = 3.141592653589793;

// fn saturate( x : f32 ) -> f32 {
//     return clamp(x, 0.0, 1.0);
// }

fn hammersley(i : u32, N : u32) -> vec2<f32>
{
    // Radical inverse based on http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html
    var bits = (i << 16u) | (i >> 16u);
    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
    var rdi = f32(bits) * 2.3283064365386963e-10;
    return vec2<f32>(f32(i) / f32(N), rdi);
}

fn G_Smith(NoV: f32, NoL : f32, roughness : f32) -> f32
{
    var k = (roughness * roughness) / 2.0;
    var GGXL = NoL / (NoL * (1.0 - k) + k);
    var GGXV = NoV / (NoV * (1.0 - k) + k);
    return GGXL * GGXV;
}

fn V_SmithGGXCorrelated(NoV: f32, NoL : f32, roughness : f32) -> f32
{
    var a2 = pow(roughness, 4.0);
    var GGXV = NoL * sqrt(NoV * NoV * (1.0 - a2) + a2);
    var GGXL = NoV * sqrt(NoL * NoL * (1.0 - a2) + a2);
    return 0.5 / (GGXV + GGXL);
}


// Based on Karis 2014
fn importanceSampleGGX(Xi: vec2<f32>, roughness: f32, N: vec3<f32>) -> vec3<f32>
{
    var a = roughness * roughness;
    // Sample in spherical coordinates
    var Phi = 2.0 * PI * Xi.x;
    var CosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a * a - 1.0) * Xi.y));
    var SinTheta = sqrt(1.0 - CosTheta * CosTheta);
    // Construct tangent space vector
    var H: vec3<f32>;
    H.x = SinTheta * cos(Phi);
    H.y = SinTheta * sin(Phi);
    H.z = CosTheta;

    // Tangent to world space
    var UpVector = vec3<f32>(1.0, 0.0, 0.0);
    if (abs(N.z) < 0.999) {
        UpVector = vec3<f32>(0.0, 0.0, 1.0);
    }
    var TangentX = normalize(cross(UpVector, N));
    var TangentY = cross(N, TangentX);
    return TangentX * H.x + TangentY * H.y + N * H.z;
}


// Karis 2014
fn integrateBRDF(roughness: f32, NoV: f32) -> vec2<f32>
{
    var V: vec3<f32>;
    V.x = sqrt(1.0 - NoV * NoV); // sin
    V.y = 0.0;
    V.z = NoV; // cos

    // N points straight upwards for this integration
    var N = vec3<f32>(0.0, 0.0, 1.0);

    var A = 0.0;
    var B = 0.0;
    var numSamples = 1024u;

    for (var i = 0u; i < numSamples; i += 1u) {
        var Xi = hammersley(i, numSamples);
        // Sample microfacet direction
        var H = importanceSampleGGX(Xi, roughness, N);

        // Get the light direction
        var L = 2.0 * dot(V, H) * H - V;

        var NoL = saturate(dot(N, L));
        var NoH = saturate(dot(N, H));
        var VoH = saturate(dot(V, H));

        if (NoL > 0.0) {
            var V_pdf = V_SmithGGXCorrelated(NoV, NoL, roughness) * VoH * NoL / NoH;
            var Fc = pow(1.0 - VoH, 5.0);
            A += (1.0 - Fc) * V_pdf;
            B += Fc * V_pdf;
        }
    }

    return 4.0 * vec2<f32>(A, B) / f32(numSamples);
}

@group(0) @binding(0) var brdflutTexture: texture_storage_2d<rgba8unorm, write>;
@compute @workgroup_size(8, 8, 1)
// fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(local_invocation_id) local_invocation_id : vec3<u32> ){
fn CsMain(@builtin(global_invocation_id) global_invocation_id : vec3<u32>){
    var fragCoord = vec2<u32>(global_invocation_id.x, global_invocation_id.y);

    var fragColor = vec4<f32>(0.0);
    // Output to screen
    var res = integrateBRDF(f32(fragCoord.y + 1u) / 256.0, f32(fragCoord.x + 1u) / 256.0);
    fragColor = vec4<f32>(res.x, res.y, 0.0, 1.0);

    textureStore(brdflutTexture, vec2<i32>(fragCoord.xy), fragColor);
}
`;class Gu{constructor(){n(this,"compute"),this.compute=new be(zu)}generateBRDFLUTTexture(){let e=new ne(256,256,G.rgba8unorm,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING);this.compute.setStorageTexture("brdflutTexture",e),this.compute.workerSizeX=256/8,this.compute.workerSizeY=256/8;let t=w.beginCommandEncoder();return w.computeCommand(t,[this.compute]),w.endCommandEncoder(t),e}}class Qu extends st{constructor(){super(...arguments),n(this,"_dataBuffer")}create(e,t,r,a=!1){let s=I.device;const o=Math.ceil(e*4/256)*256;this.format=G.rgba8unorm,this.mipmapCount=Math.floor(a?Math.log2(e):1),this.createTextureDescriptor(e,t,this.mipmapCount,this.format);const l=this._dataBuffer=s.createBuffer({size:r.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC});s.queue.writeBuffer(l,0,r);const h=w.beginCommandEncoder();return h.copyBufferToTexture({buffer:l,bytesPerRow:o},{texture:this.getGPUTexture()},{width:e,height:t,depthOrArrayLayers:1}),w.endCommandEncoder(h),a&&Ht.webGPUGenerateMipmap(this),this}updateTexture(e,t,r){let a=I.device;const s=Math.ceil(e*4/256)*256;this.mipmapCount=Math.floor(Math.log2(e)),this._dataBuffer&&this._dataBuffer.destroy(),this._dataBuffer=null;const o=this._dataBuffer=a.createBuffer({size:r.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC});a.queue.writeBuffer(o,0,r);const l=w.beginCommandEncoder();l.copyBufferToTexture({buffer:o,bytesPerRow:s},{texture:this.getGPUTexture()},{width:e,height:t,depthOrArrayLayers:1}),w.endCommandEncoder(l),this.gpuSampler=a.createSampler(this),this.mipmapCount>1&&Ht.webGPUGenerateMipmap(this)}}class fr{constructor(e){n(this,"id"),n(this,"guiTexture"),n(this,"uvRec",new q(0,0,1,1)),n(this,"uvBorder",new q(0,0,0,0)),n(this,"offsetSize",new q(0,0,4,4)),n(this,"borderSize",new q(0,0,0,0)),n(this,"trimSize",new $),n(this,"isSliced",!1),n(this,"height",4),n(this,"width",4),n(this,"xadvance",0),n(this,"xoffset",0),n(this,"yoffset",0),this.guiTexture=e||_.res.defaultGUITexture}}const Mn=class{constructor(i){n(this,"_staticId",-1),n(this,"dynamicId",-1),n(this,"texture"),n(this,"width",1),n(this,"height",1),i||(i=_.res.whiteTexture),this.texture=i,Mn._maxUid++,this._staticId=Mn._maxUid,this.init()}get staticId(){return this._staticId}init(){this.dynamicId=-1,this.width=this.texture.width,this.height=this.texture.height}};let dr=Mn;n(dr,"_maxUid",-1);class Qg{constructor(){n(this,"fntCache",{}),n(this,"fntData",{})}addFontData(e,t,r){this.fntData[`${e}${t}`]=r}getFontData(e,t){return this.fntData[`${e}${t}`]}addFnt(e,t,r,a){let s=`${e}${t}`;this.fntCache[s]||(this.fntCache[s]={}),this.fntCache[s][r]=a}getFnt(e,t,r){let a=`${e}${t}`,s=this.fntCache[a];return s?s[r]:this.fntCache[" "]}}let gr=new Qg;class Vu{constructor(){n(this,"face",""),n(this,"size",0),n(this,"bold",!1),n(this,"italic",!1),n(this,"stretchH",0),n(this,"spacing",""),n(this,"outline",0),n(this,"lineHeight",0),n(this,"base",0),n(this,"scaleW",0),n(this,"scaleH",0),n(this,"pages",0),n(this,"packed",0),n(this,"alphaChnl",0),n(this,"redChnl",0),n(this,"greenChnl",0),n(this,"blueChnl",0),n(this,"count",0),n(this,"fontPage",[]),n(this,"fontChar",{})}}class Hu{constructor(){n(this,"id",0),n(this,"file","")}}class Yu{constructor(){n(this,"id",-1),n(this,"x",0),n(this,"y",0),n(this,"width",0),n(this,"height",0),n(this,"xoffset",0),n(this,"yoffset",0),n(this,"xadvance",0),n(this,"page",0),n(this,"chnl",0)}}const ki=class extends Xt{static parseSprite(i,e){for(const t in e.fontChar)if(Object.prototype.hasOwnProperty.call(e.fontChar,t)){const r=e.fontChar[t];let a=new fr;a.id=r.id.toString(),a.offsetSize.set(0,0,r.width,r.height),a.trimSize.set(r.width,r.height),a.width=r.width,a.height=r.height,a.xadvance=r.xadvance,a.xoffset=r.xoffset,a.yoffset=r.yoffset,a.guiTexture=i[r.page],a.uvRec.set(r.x/e.scaleW,(e.scaleH-(r.y+r.height))/e.scaleH,r.width/e.scaleW,r.height/e.scaleH),gr.addFnt(e.face,e.size,a.id,a)}}verification(){if(this.data)return!0;throw new Error("Method not implemented.")}async parseString(i){let e=this.getNewLine(i),t=i,r=new Vu;t.trim().split(e).forEach((a,s)=>{if(s<2)ki.readLineProperty(a,r);else if(s<r.pages+2){let o=new Hu;ki.readLineProperty(a,o),r.fontPage.push(o)}else if(s<r.pages+3)ki.readLineProperty(a,r);else if(r.count>0){let o=new Yu;ki.readLineProperty(a,o),r.fontChar[o.id]=o,r.count--}}),t="",this.data=r,await this.loadFontTextures()}getNewLine(i){return i.indexOf(`\r
`)!=-1?`\r
`:i.indexOf("\r")!=-1?"\r":`
`}async loadFontTextures(){let i=[],e=this.data;for(const t of e.fontPage){let r=this.baseUrl+t.file;await _.res.loadTexture(r,null,!0);let a=_.res.getTexture(r),s=new dr(a);i.push(s)}ki.parseSprite(i,e),e.fontChar[" "]||ki.insertSpaceChar(e,i[0])}static insertSpaceChar(i,e){let t=new fr,r=i.size*.5,a=i.lineHeight*.5;t.id=" ",t.offsetSize.set(0,0,i.size,i.size),t.trimSize.set(r,a),t.width=r,t.height=a,t.xadvance=0,t.xoffset=0,t.yoffset=0,t.guiTexture=e,t.uvRec.set(0,0,1e-6,1e-6),gr.addFnt(i.face,i.size,t.id,t)}static readLineProperty(i,e){i.trim().split(" ").forEach((t,r)=>{let a=t.split("=");if(a.length>1){let s=a[0],o=a[1];Object.prototype.hasOwnProperty.call(e,s)&&(o.indexOf('"')==-1?e[s]=parseFloat(a[1]):e[s]=o.replace('"',"").replace('"',""))}})}};let Pn=ki;n(Pn,"format","text");function Vg(i,e){let t=new fr;return t.id=i,t.offsetSize.set(0,0,e.width,e.height),t.trimSize.set(e.width,e.height),t.width=e.width,t.height=e.height,t.xadvance=0,t.xoffset=0,t.yoffset=0,t.guiTexture=new dr(e),t.uvRec.set(0,0,1,1),e.isVideoTexture||(e.flipY=!0),t}function Xu(i,e,t){let r=new fr;r.guiTexture=i,r.id=e,r.uvRec.copyFrom(t.textureRect),r.trimSize.x=t.textureRect.z,r.trimSize.y=t.textureRect.w,r.offsetSize.x=t.textureRectOffset.x,r.offsetSize.y=t.textureRectOffset.y,r.offsetSize.z=t.size.x,r.offsetSize.w=t.size.y,r.width=t.size.x,r.height=t.size.y;let a=1/i.width,s=1/i.height;r.uvRec.set(r.uvRec.x*a,r.uvRec.y*s,r.uvRec.z*a,r.uvRec.w*s);let o=.1;return t.border.x<=o&&t.border.y<=o&&t.border.z<=o&&t.border.x<=o?r.isSliced=!1:(r.borderSize.copyFrom(t.border),r.uvBorder.copyFrom(t.border),r.uvBorder.x-=t.textureRectOffset.x,r.uvBorder.y-=t.textureRectOffset.y,r.uvBorder.z=t.border.z-(t.size.x-t.textureRect.z-t.textureRectOffset.x),r.uvBorder.w=t.border.w-(t.size.y-t.textureRect.w-t.textureRectOffset.y),r.uvBorder.x/=t.textureRect.z,r.uvBorder.z/=t.textureRect.z,r.uvBorder.y/=t.textureRect.w,r.uvBorder.w/=t.textureRect.w,r.isSliced=!0),r}class Wu{constructor(e){n(this,"_spriteMap",new Map),n(this,"_spriteList",[]),n(this,"textureSize",new $),n(this,"name"),this.textureSize.set(e.x,e.y)}setTexture(e,t,r){let a=Xu(e,t,r);return this._spriteMap.set(a.id,a),this._spriteList.push(a),a}getSprite(e){return this._spriteMap.get(e)}get spriteList(){return this._spriteList}}class Rn extends Xt{constructor(){super(...arguments),n(this,"_json"),n(this,"_texture")}async parseString(e){this._json=JSON.parse(e);let t=this.userData.replace(".json",".png");this._texture=await _.res.loadTexture(t,null,!0),this.data={json:this._json,texture:this._texture},this.parseAtlas()}verification(){if(this.data)return!0;throw new Error("verify failed.")}parseAtlas(){let e=new Wu(this._json.size),t=new dr(this._texture),r=this._json.atlas;for(const a in r)e.setTexture(t,a,r[a]);_.res.addAtlas(this.baseUrl,e),this.data=e}}n(Rn,"format","text");class ju{constructor(){n(this,"_texturePool"),n(this,"_materialPool"),n(this,"_prefabPool"),n(this,"_gltfPool"),n(this,"_atlasList"),n(this,"normalTexture"),n(this,"maskTexture"),n(this,"whiteTexture"),n(this,"blackTexture"),n(this,"redTexture"),n(this,"blueTexture"),n(this,"greenTexture"),n(this,"yellowTexture"),n(this,"grayTexture"),n(this,"defaultSky"),n(this,"defaultGUITexture"),n(this,"defaultGUISprite"),this._texturePool=new Map,this._materialPool=new Map,this._prefabPool=new Map,this._gltfPool=new Map,this._atlasList=new Map,this.initDefault()}getGltf(e){return this._gltfPool.get(e)}addTexture(e,t){this._texturePool.set(e,t)}getTexture(e){return this._texturePool.get(e)}addMat(e,t){return this._materialPool.set(e,t)}getMat(e){return this._materialPool.get(e)}addPrefab(e,t){this._prefabPool.set(e,t)}getPrefab(e){return this._prefabPool.get(e).instantiate()}addAtlas(e,t){t.name=e,this._atlasList.set(e,t)}getAtlas(e){return this._atlasList.get(e)}getGUISprite(e){for(let t of this._atlasList.values()){let r=t.getSprite(e);if(r)return r}return null}async loadGltf(e,t){if(this._prefabPool.has(e))return this._prefabPool.get(e);let r,a=e.substring(e.lastIndexOf(".")).toLowerCase(),s=new ot;a==".gltf"?r=await s.load(e,Je,t):r=await s.load(e,Ja,t);let o=r.data;return this._prefabPool.set(e,o),this._gltfPool.set(e,r.gltf),o}async loadObj(e,t){if(this._prefabPool.has(e))return this._prefabPool.get(e);let r,a=e.substring(e.lastIndexOf(".")).toLowerCase(),s=new ot;a==".obj"&&(r=await s.load(e,vn,t));let o=r.data;return this._prefabPool.set(e,o),o}async loadB3DM(e,t,r){if(this._prefabPool.has(e))return this._prefabPool.get(e);let o=(await new ot().load(e,En,t,r)).data;return this._prefabPool.set(e,o),o}async loadI3DM(e,t,r){if(this._prefabPool.has(e))return this._prefabPool.get(e);let o=(await new ot().load(e,Dn,t,r)).data;return this._prefabPool.set(e,o),o}async loadTexture(e,t,r){if(this._texturePool.has(e))return this._texturePool.get(e);let a=new ei;return a.flipY=r,await a.load(e,t),this._texturePool.set(e,a),a}async loadHDRTexture(e,t){if(this._texturePool.has(e))return this._texturePool.get(e);let r=new Cn;return r=await r.load(e,t),this._texturePool.set(e,r),r}async loadHDRTextureCube(e,t){if(this._texturePool.has(e))return this._texturePool.get(e);let r=new ns;return r=await r.load(e,t),this._texturePool.set(e,r),r}async loadLDRTextureCube(e,t){if(this._texturePool.has(e))return this._texturePool.get(e);let r=new hs;return r=await r.load(e,t),this._texturePool.set(e,r),r}async loadTextureCubeMaps(e){let t=e[0];if(this._texturePool.has(t))return this._texturePool.get(t);let r=new xn;return await r.load(e),this._texturePool.set(e[0],r),r}async loadTextureCubeStd(e,t){if(this._texturePool.has(e))return this._texturePool.get(e);let r=new xn;return await r.loadStd(e),r}async loadJSON(e,t){return await new ot().loadJson(e,t).then(async r=>r).catch(r=>{console.log(r)})}async loadFont(e,t,r){let s=await new ot().load(e,Pn,t,r),o=s.data;return gr.addFontData(o.face,o.size,o),s.data}async loadAtlas(e,t){return(await new ot().load(e,Rn,t,e)).data}createTexture(e,t,r,a,s,o,l){let h=32,u=32,c=new Uint8Array(h*u*4);this.fillColor(c,e,t,r,a,s,o);let d=new Qu;return d.name=l,d.create(16,16,c,!0),l&&this.addTexture(l,d),d}fillColor(e,t,r,a,s,o,l){for(let h=0;h<t;h++)for(let u=0;u<r;u++){let c=u*t+h;e[c*4+0]=a,e[c*4+1]=s,e[c*4+2]=o,e[c*4+3]=l}}initDefault(){this.normalTexture=this.createTexture(32,32,255*.5,255*.5,255,255,"default-normalTexture"),this.maskTexture=this.createTexture(32,32,255,255*.5,0,255,"default-maskTexture"),this.whiteTexture=this.createTexture(32,32,255,255,255,255,"default-whiteTexture"),this.blackTexture=this.createTexture(32,32,0,0,0,255,"default-blackTexture"),this.redTexture=this.createTexture(32,32,255,0,0,255,"default-redTexture"),this.blueTexture=this.createTexture(32,32,0,0,255,255,"default-blueTexture"),this.greenTexture=this.createTexture(32,32,0,255,0,255,"default-greenTexture"),this.yellowTexture=this.createTexture(32,32,0,255,255,255,"default-yellowTexture"),this.grayTexture=this.createTexture(32,32,128,128,128,255,"default-grayTexture");let t=new Gu().generateBRDFLUTTexture(),r=t.name="BRDFLUT";this.addTexture(r,t),this.defaultSky=new ns,this.defaultSky.createFromTexture(128,this.blackTexture),ae.getInstance().attached(this.defaultSky,this),ae.getInstance().attached(t,this),ae.getInstance().attached(this.normalTexture,this),ae.getInstance().attached(this.maskTexture,this),ae.getInstance().attached(this.whiteTexture,this),ae.getInstance().attached(this.blackTexture,this),ae.getInstance().attached(this.redTexture,this),ae.getInstance().attached(this.blueTexture,this),ae.getInstance().attached(this.greenTexture,this),ae.getInstance().attached(this.yellowTexture,this),ae.getInstance().attached(this.grayTexture,this),this.defaultGUITexture=new dr(this.whiteTexture),this.defaultGUISprite=new fr(this.defaultGUITexture),this.defaultGUISprite.trimSize.set(4,4)}}class ye{}n(ye,"pixelRatio",1),n(ye,"solution",new $(1600,1280)),n(ye,"quadMaxCountForWorld",256),n(ye,"quadMaxCountForView",2048),n(ye,"SortOrderStartWorld",7e3),n(ye,"SortOrderStartView",8e3),n(ye,"SortOrderCanvasSpan",1e4);var Nt=(i=>(i[i.View=0]="View",i[i.World=2]="World",i))(Nt||{}),pr=(i=>(i[i.Simple=0]="Simple",i[i.Sliced=1]="Sliced",i[i.Tiled=2]="Tiled",i[i.Filled=3]="Filled",i))(pr||{}),yi=(i=>(i[i.None=0]="None",i[i.BillboardY=9]="BillboardY",i[i.BillboardXYZ=10]="BillboardXYZ",i))(yi||{});class _{static get frameRate(){return this._frameRate}static set frameRate(e){this._frameRate=e,this._frameRateValue=1/e,e>=360&&(this._frameRateValue=0)}static get size(){return I.presentationSize}static get aspect(){return I.aspect}static get width(){return I.windowWidth}static get height(){return I.windowHeight}static async init(e={}){console.log("Engine Version",Vf),this.divB=document.createElement("div"),this.divB.style.position="absolute",this.divB.style.zIndex="999",this.divB.style.color="#FFFFFF",this.divB.style.top="150px",document.body.appendChild(this.divB),this.setting={...this.setting,...e.engineSetting},await te.init(H.allocCount),await I.init(e.canvasConfig),N.init(),Ot.init(),de.init(),Ne.init(),Ge.init(),this.res=new ju,this._beforeRender=e.beforeRender,this._renderLoop=e.renderLoop,this._lateRender=e.lateRender,this.inputSystem=new Io,this.inputSystem.initCanvas(I.canvas)}static startRenderView(e){this.renderJobs||(this.renderJobs=new Map),this.views=[e];let t=new an(e);return this.renderJobs.set(e,t),t.addPost(new Ys),t.start(),this.resume(),t}static startRenderViews(e){this.renderJobs||(this.renderJobs=new Map),this.views=e;for(let t=0;t<e.length;t++){const r=e[t];let a=new an(r);this.renderJobs.set(r,a),a.addPost(new Ys),a.start()}this.resume()}static getRenderJob(e){return this.renderJobs.get(e)}static pause(){this._requestAnimationFrameID!=0&&(cancelAnimationFrame(this._requestAnimationFrameID),this._requestAnimationFrameID=0)}static resume(){this._requestAnimationFrameID=requestAnimationFrame(e=>this.render(e))}static render(e){this._deltaTime=e-this._time,this._time=e,this._frameRateValue>0?(this._frameTimeCount+=this._deltaTime*.001,this._frameTimeCount>=this._frameRateValue*.95&&(this._frameTimeCount=0,this.updateFrame(e))):this.updateFrame(e),this.resume()}static updateGUIPixelRatio(e,t){let r=ye.solution.x/ye.solution.y,a=e/t;r<a?ye.pixelRatio=t/ye.solution.y:ye.pixelRatio=e/ye.solution.x}static updateFrame(e){he.delta=e-he.time,he.time=e,he.frame+=1,nn.tick(he.delta);let t=this.views,r=0;for(r=0;r<t.length;r++){const o=t[r];o.scene.waitUpdate(),o.camera.resetPerspective(I.aspect)}this.updateGUIPixelRatio(I.canvas.clientWidth,I.canvas.clientHeight),this._beforeRender&&this._beforeRender();for(const o of se.componentsBeforeUpdateList){let l=o[0],h=o[1];for(const u of h){let c=u[0],d=u[1];c.enable&&d(l)}}let a=I.device.createCommandEncoder();for(const o of se.componentsComputeList){let l=o[0],h=o[1];for(const u of h){let c=u[0],d=u[1];c.enable&&d(l,a)}}I.device.queue.submit([a.finish()]);for(const o of se.componentsUpdateList){let l=o[0],h=o[1];for(const u of h){let c=u[0],d=u[1];c.enable&&d(l)}}this._renderLoop&&this._renderLoop(),te.updateAllContinueTransform(0,H.useCount,16),de.modelMatrixBindGroup.writeBuffer(H.useCount*16),this.renderJobs.forEach((o,l)=>{o.renderFrame()});for(const o of se.componentsLateUpdateList){let l=o[0],h=o[1];for(const u of h){let c=u[0],d=u[1];c.enable&&d(l)}}this._lateRender&&this._lateRender()}}n(_,"res"),n(_,"inputSystem"),n(_,"views"),n(_,"_frameRateValue",0),n(_,"_frameRate",360),n(_,"_frameTimeCount",0),n(_,"_deltaTime",0),n(_,"_time",0),n(_,"_beforeRender"),n(_,"_renderLoop"),n(_,"_lateRender"),n(_,"_requestAnimationFrameID",0),n(_,"Engine3D"),n(_,"divB"),n(_,"setting",{occlusionQuery:{enable:!0,debug:!1},pick:{enable:!0,mode:"bound",detail:"mesh"},render:{debug:!1,renderPassState:4,renderState_left:5,renderState_right:5,renderState_split:.5,quadScale:1,hdrExposure:1.5,debugQuad:-1,maxPointLight:1e3,maxDirectLight:4,maxSportLight:1e3,drawOpMin:0,drawOpMax:Number.MAX_SAFE_INTEGER,drawTrMin:0,drawTrMax:Number.MAX_SAFE_INTEGER,zPrePass:!1,useLogDepth:!1,gi:!1,postProcessing:{globalFog:{debug:!1,enable:!1,fogType:0,fogHeightScale:.1,start:400,end:10,density:.02,ins:.5,skyFactor:.5,skyRoughness:.4,overrideSkyFactor:.8,fogColor:new z(112/255,61/255,139/255,1),falloff:.7,rayLength:200,scatteringExponent:2.7,dirHeightLine:10},ssao:{enable:!1,radius:.15,bias:-.1,aoPower:2,debug:!0},outline:{enable:!1,strength:1,groupCount:4,outlinePixel:2,fadeOutlinePixel:4,textureScale:.7,useAddMode:!1,debug:!0},taa:{enable:!1,jitterSeedCount:8,blendFactor:.1,sharpFactor:.6,sharpPreBlurFactor:.5,temporalJitterScale:.13,debug:!0},gtao:{enable:!1,darkFactor:1,maxDistance:5,maxPixel:50,rayMarchSegment:6,multiBounce:!1,usePosFloat32:!0,blendColor:!0,debug:!0},ssr:{enable:!1,pixelRatio:1,fadeEdgeRatio:.2,rayMarchRatio:.5,fadeDistanceMin:600,fadeDistanceMax:2e3,roughnessThreshold:.5,powDotRN:.2,mixThreshold:.1,debug:!0},bloom:{enable:!1,blurX:4,blurY:4,strength:.25,exposure:1,radius:1.3,luminosityThreshold:.98,debug:!1},fxaa:{enable:!1},depthOfView:{enable:!1,iterationCount:3,pixelOffset:1,near:150,far:300}}},shadow:{enable:!0,type:"HARD",pointShadowBias:.002,shadowSize:1024,pointShadowSize:1024,shadowSoft:.005,needUpdate:!0,autoUpdate:!0,updateFrameRate:2,csmMargin:.1,csmScatteringExp:.7,csmAreaScale:.4,debug:!1},gi:{enable:!1,offsetX:0,offsetY:0,offsetZ:0,probeSpace:64,probeXCount:4,probeYCount:2,probeZCount:4,probeSize:32,probeSourceTextureSize:2048,octRTMaxSize:2048,octRTSideSize:16,maxDistance:64*1.73,normalBias:.25,depthSharpness:1,hysteresis:.98,lerpHysteresis:.01,irradianceChebyshevBias:.01,rayNumber:144,irradianceDistanceBias:32,indirectIntensity:1,ddgiGamma:2.2,bounceIntensity:.025,probeRoughness:1,realTimeGI:!1,debug:!1,autoRenderProbe:!1},sky:{type:"HDRSKY",sky:null,skyExposure:1,defaultFar:65536,defaultNear:1},light:{maxLight:4096},material:{materialChannelDebug:!1,materialDebug:!1}}),n(_,"renderJobs");let Hg=`
#include "GlobalUniform"

struct UniformData {
  radius: f32 ,
  bias: f32,
  aoPower: f32 ,
  blurSize: f32 ,
};

// @group(0) @binding(0) var<uniform> standUniform: GlobalUniform;
@group(0) @binding(0) var<uniform> uniformData: UniformData;
@group(0) @binding(1) var colorMap : texture_2d<f32>;
// @group(0) @binding(2) var ssaoMapSampler : sampler;
@group(0) @binding(2) var ssaoMap : texture_2d<f32>;
@group(0) @binding(3) var outTex : texture_storage_2d<rgba16float, write>;

@compute @workgroup_size( 8 , 8 )
fn CsMain( @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
{
  var fragCoord = vec2<i32>( globalInvocation_id.xy );

  var texSize = vec2<f32>(textureDimensions(ssaoMap).xy);
  var texCoord = vec2<f32>(fragCoord) / texSize ;

  let blurSize = i32(uniformData.blurSize);

  var result = vec4<f32>(0.0) ;
  var ii = 0.0 ;
  for (var i = -2; i < 2 ; i+=1) {
     for (var j = -2; j < 2 ; j+=1) {
        var offset = vec2<i32>( i , j ) ;
        result += textureLoad(ssaoMap, fragCoord + offset, 0 );
        // result += textureSampleLevel(ssaoMap,ssaoMapSampler, vec2<f32>( fragCoord + offset) / texSize , 0.0 );
        ii += 1.0 ;
     }
  }
  var fResult = result.r / ii ;
  var color = textureLoad(colorMap, fragCoord , 0 );
  textureStore(outTex, fragCoord , vec4(color.rgb * fResult,1.0) );
}
`,qu=`
#include "GlobalUniform"

  struct BlurSetting{
    near: f32,
    far: f32,
    pixelOffset: f32,
  }

  @group(0) @binding(0) var<uniform> standUniform: GlobalUniform;
  @group(0) @binding(1) var<uniform> blurSetting: BlurSetting;

  @group(0) @binding(2) var positionBufferTex : texture_2d<f32>;
  @group(0) @binding(3) var normalBufferTex : texture_2d<f32>;
  @group(0) @binding(4) var inTexSampler : sampler;
  @group(0) @binding(5) var inTex : texture_2d<f32>;
  @group(0) @binding(6) var outTex : texture_storage_2d<rgba16float, write>;

  var<private> cameraPosition: vec3<f32>;
  var<private> texSize: vec2<u32>;
  var<private> fragCoord: vec2<i32>;
  var<private> texelSize: vec2<f32>;

  @compute @workgroup_size( 8 , 8 , 1 )
  fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
  {
    fragCoord = vec2<i32>( globalInvocation_id.xy );
    texSize = textureDimensions(inTex).xy;
    texelSize = 1.0 / vec2<f32>(texSize - 1);
    if(fragCoord.x >= i32(texSize.x) || fragCoord.y >= i32(texSize.y)){
        return;
    }
    cameraPosition = vec3<f32>(standUniform.cameraWorldMatrix[3].xyz);
    let wPosition:vec3<f32> = textureLoad(positionBufferTex, fragCoord , 0).xyz;
    var distance = length(wPosition - cameraPosition);
    var oc:vec4<f32> = textureLoad(inTex, fragCoord, 0);
    if(distance > blurSetting.near){
        let normal = textureLoad(normalBufferTex, fragCoord, 0);
        var pixelScale = 0.5;
        if(normal.w > 0.5){
            distance = min(distance, blurSetting.far);
            pixelScale = (distance - blurSetting.near) / (blurSetting.far - blurSetting.near);
        }
        oc = mixBlurColor(oc, fragCoord, blurSetting.pixelOffset, pixelScale);
    }
    textureStore(outTex, fragCoord, oc);
  }

  fn mixBlurColor(orginColor:vec4<f32>, coord:vec2<i32>, pixelOffset:f32, scale:f32) -> vec4<f32> {

    let uv = vec2<f32>(coord);
    var uv0 = (uv + scale * vec2<f32>( pixelOffset,  pixelOffset)) * texelSize;
    var uv1 = (uv + scale * vec2<f32>(-pixelOffset,  pixelOffset)) * texelSize;
    var uv2 = (uv + scale * vec2<f32>(-pixelOffset, -pixelOffset)) * texelSize;
    var uv3 = (uv + scale * vec2<f32>( pixelOffset, -pixelOffset)) * texelSize;

    uv0.x = processUVEdge(uv0.x);
    uv0.y = processUVEdge(uv0.y);
    uv1.x = processUVEdge(uv1.x);
    uv1.y = processUVEdge(uv1.y);
    uv2.x = processUVEdge(uv2.x);
    uv2.y = processUVEdge(uv2.y);
    uv3.x = processUVEdge(uv3.x);
    uv3.y = processUVEdge(uv3.y);

    var ob = vec4<f32>(0.0);
    ob += textureSampleLevel(inTex, inTexSampler, uv0, 0.0);
    ob += textureSampleLevel(inTex, inTexSampler, uv1, 0.0);
    ob += textureSampleLevel(inTex, inTexSampler, uv2, 0.0);
    ob += textureSampleLevel(inTex, inTexSampler, uv3, 0.0);
    return mix(orginColor, ob * 0.25, scale);
  }

  fn processUVEdge(v: f32) -> f32{
      var value = v;
      if(value < 0.0){
        value = - value;
      }else if(value > 1.0){
        value = 2.0 - value;
      }
      return value;
  }
`,Ku=`
    #include "GlobalUniform"
    
    struct GTAO{
      maxDistance: f32,
      maxPixel: f32,
      darkFactor: f32,
      rayMarchSegment: f32,
      cameraNear: f32,
      cameraFar: f32,
      multiBounce: f32,
      blendColor: f32,
    }

    @group(0) @binding(1) var<uniform> gtaoData: GTAO;
    @group(0) @binding(2) var<storage, read_write> directions : array<vec2<f32>>;
    @group(0) @binding(3) var<storage, read_write> aoBuffer : array<f32>;

    @group(0) @binding(4) var posTex : texture_2d<f32>;
    @group(0) @binding(5) var normalTex : texture_2d<f32>;
    @group(0) @binding(6) var inTex : texture_2d<f32>;
    @group(0) @binding(7) var outTex : texture_storage_2d<rgba16float, write>;
    
    var<private> texSize: vec2<u32>;
    var<private> fragCoord: vec2<i32>;
    var<private> wPosition: vec3<f32>;
    var<private> wNormal: vec4<f32>;
    var<private> maxPixelScaled: f32;
    
    @compute @workgroup_size( 8 , 8 , 1 )
    fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
    {
      fragCoord = vec2<i32>( globalInvocation_id.xy );
      texSize = textureDimensions(inTex).xy;
      if(fragCoord.x >= i32(texSize.x) || fragCoord.y >= i32(texSize.y)){
          return;
      }
      wNormal = textureLoad(normalTex, fragCoord, 0);
      var oc = textureLoad(inTex, fragCoord, 0);
      let index = fragCoord.x + fragCoord.y * i32(texSize.x);
      let lastFactor = aoBuffer[index];
      var newFactor = 0.0;
      if(wNormal.w < 0.5){//sky
          
      }else{
          wPosition = textureLoad(posTex, fragCoord, 0).xyz;
          let ndc = globalUniform.projMat * globalUniform.viewMat * vec4<f32>(wPosition, 1.0);
          let ndcZ = ndc.z / ndc.w;
          maxPixelScaled = calcPixelByNDC(ndcZ);
          newFactor = rayMarch();
      }
      
      var factor:f32 = mix(lastFactor, newFactor, 0.6);
      aoBuffer[index] = factor;
      factor = blurFactor(factor);
      factor = saturate(1.0 - factor * gtaoData.darkFactor);
      var gtao = vec3<f32>(factor);
      if(gtaoData.multiBounce > 0.5){
          gtao = MultiBounce(factor, oc.xyz);
      }
      
      var outColor = gtao;
      if(gtaoData.blendColor > 0.5){
          outColor = oc.xyz * gtao;
      }
      textureStore(outTex, fragCoord , vec4<f32>(outColor, oc.w));
    }
    
    fn MultiBounce(AO:f32, Albedo:vec3<f32>) -> vec3<f32>
    {
        var A = 2 * Albedo - 0.33;
        var B = -4.8 * Albedo + 0.64;
        var C = 2.75 * Albedo + 0.69;
        return max(vec3<f32>(AO), ((AO * A + B) * AO + C) * AO);
    }
    
    fn calcPixelByNDC(ndcZ:f32) -> f32{
      let nearAspect = gtaoData.cameraNear / (gtaoData.cameraFar - gtaoData.cameraNear);
      let aspect = (1.0 + nearAspect) / (ndcZ + nearAspect);
      var viewPortMax = min(f32(texSize.x), f32(texSize.y));
      var maxPixel = min(viewPortMax, gtaoData.maxPixel * aspect);
      maxPixel = max(0.1, maxPixel);
      return maxPixel;
    }
    
    fn blurFactor(centerFactor:f32) -> f32{
      var coord0 = clamp(fragCoord + vec2<i32>(1, 0) , vec2<i32>(0), vec2<i32>(texSize - 1));
      var coord1 = clamp(fragCoord + vec2<i32>(-1, 0), vec2<i32>(0), vec2<i32>(texSize - 1));
      var coord2 = clamp(fragCoord + vec2<i32>(0, 1) , vec2<i32>(0), vec2<i32>(texSize - 1));
      var coord3 = clamp(fragCoord + vec2<i32>(0, -1), vec2<i32>(0), vec2<i32>(texSize - 1));
      var index0 = coord0.x + coord0.y * i32(texSize.x);
      var index1 = coord1.x + coord1.y * i32(texSize.x);
      var index2 = coord2.x + coord2.y * i32(texSize.x);
      var index3 = coord3.x + coord3.y * i32(texSize.x);
      let factor0:f32 = aoBuffer[index0];
      let factor1:f32 = aoBuffer[index1];
      let factor2:f32 = aoBuffer[index2];
      let factor3:f32 = aoBuffer[index3];
      var factor = 0.25 * (factor0 + factor1 + factor2 + factor3);
      factor = mix(factor, centerFactor, 0.8);
      return factor;
    }
    
    fn rayMarch() -> f32{
      let originNormal = normalize(vec3<f32>(wNormal.xyz) * 2.0 - 1.0);
      let stepPixel = maxPixelScaled / gtaoData.rayMarchSegment;
      var weight:f32 = 0.0;
      var totalWeight:f32 = 0.1;
      for(var i:i32 = 0; i < 8; i += 1){
          let dirVec2 = directions[i];
          for(var j:f32 = 1.1; j < maxPixelScaled; j += stepPixel){
              var sampleCoord = vec2<i32>(dirVec2 * j) + fragCoord;
              if(sampleCoord.x >= 0 && sampleCoord.y >= 0 
                && sampleCoord.x < i32(texSize.x) 
                && sampleCoord.y < i32(texSize.y) )
              {
                totalWeight += 1.0;
                let samplePosition = textureLoad(posTex, sampleCoord, 0).xyz;
                let distanceVec2 = samplePosition - wPosition;
                let distance = length(distanceVec2);
                if(distance < gtaoData.maxDistance && distance > 1.0){
                  let sampleDir = normalize(distanceVec2);
                  var factor = saturate(dot(sampleDir, originNormal) - 0.1);
                  factor *= 1.0 - distance / gtaoData.maxDistance;
                  weight += factor;
                }
              }
          }
      }
      weight /= totalWeight;
      return weight;
    }
  `,Ju=`

    #include "GlobalUniform"
    struct LightData {
      index:f32,
      lightType:i32,
      radius:f32,
      linear:f32,
      
      position:vec3<f32>,
      lightMatrixIndex:f32,

      direction:vec3<f32>,
      quadratic:f32,

      lightColor:vec3<f32>,
      intensity:f32,

      innerCutOff :f32,
      outerCutOff:f32,
      range :f32,
      castShadow:i32,

      lightTangent:vec3<f32>,
      ies:f32,
    };

    struct Uniforms {
      matrix : array<mat4x4<f32>>
    };

    struct CacheGodRay {
      pos:vec3<f32>,
      value:f32,
    };

    struct GodRayUniform{
      intensity: f32,
      rayMarchCount: f32,
      viewPortWidth: f32,
      viewPortHeight: f32,

      blendColor: f32,
      scatteringExponent: f32,
    }

    @group(0) @binding(1) var<uniform> godRayUniform: GodRayUniform;
    @group(0) @binding(2) var posTex : texture_2d<f32>;
    @group(0) @binding(3) var normalTex : texture_2d<f32>;
    @group(0) @binding(4) var inTex : texture_2d<f32>;
    @group(0) @binding(5) var outTex : texture_storage_2d<rgba16float, write>;
    @group(0) @binding(6) var shadowMapSampler : sampler_comparison;
    @group(0) @binding(7) var shadowMap : texture_depth_2d_array;

    @group(1) @binding(0)
    var<storage,read> lightBuffer: array<LightData>;
    @group(1) @binding(1)
    var<storage, read> models : Uniforms;

    @group(2) @binding(0) var<storage, read_write> historyGodRayData: array<CacheGodRay>;
    
    struct ShadowStruct{
      directShadowVisibility:f32,
      pointShadows:array<f32,8>,
     }

    var<private> viewDirection: vec3<f32> ;
    var<private> texSize: vec2<u32>;
    var<private> fragCoord: vec2<i32>;
    var<private> wPosition: vec3<f32>;
    var<private> wNormal: vec4<f32>;
    var<private> directLight: LightData;
    var<private> shadowStrut: ShadowStruct ;

    const csmCount:i32 = ${nt.Cascades} ;
    fn directShadowMaping(P:vec3<f32>, N:vec3<f32>, shadowBias: f32)  {
      let enableCSM:bool = globalUniform.enableCSM > 0.5;
      var light = lightBuffer[0];
      var visibility = 1.0;
      var shadowIndex = i32(light.castShadow);
      if (shadowIndex >= 0 ) {
        var shadowMatrix:mat4x4<f32>;
        if(enableCSM && csmCount > 1){
          for(var csm:i32 = 0; csm < csmCount; csm ++){
            var csmShadowBias = globalUniform.csmShadowBias[csm];
            shadowMatrix = globalUniform.csmMatrix[csm];
            let csmShadowResult = directShadowMapingIndex(light, shadowMatrix, P, N, csm, csmShadowBias);
            if(csmShadowResult.y < 0.5){
              visibility = csmShadowResult.x;
              break;
            }
          }
        }else{
          shadowMatrix = globalUniform.shadowMatrix[shadowIndex];
          visibility = directShadowMapingIndex(light, shadowMatrix, P, N, shadowIndex, shadowBias).x;
        }
      }
      shadowStrut.directShadowVisibility = visibility;
    }
    
    fn directShadowMapingIndex(light:LightData, matrix:mat4x4<f32>, P:vec3<f32>, N:vec3<f32>, depthTexIndex:i32, shadowBias:f32) -> vec2<f32>
    {
      var visibility = 1.0;
      var isOutSideArea:f32 = 1.0;
      var shadowPosTmp = matrix * vec4<f32>(P.xyz, 1.0);
      var shadowPos = shadowPosTmp.xyz / shadowPosTmp.w;
      var varying_shadowUV = shadowPos.xy * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5, 0.5);
      if (varying_shadowUV.x <= 1.0
        && varying_shadowUV.x >= 0.0
        && varying_shadowUV.y <= 1.0
        && varying_shadowUV.y >= 0.0
        && shadowPosTmp.z <= 1.0
        && shadowPosTmp.z >= 0.0)
      {
        isOutSideArea = 0.0;
        var uvOnePixel = 1.0 / vec2<f32>(globalUniform.shadowMapSize);
        var NoL = abs(dot(N, normalize(light.direction)));
        var bias = shadowBias / max(NoL, 0.000001);
        visibility = textureSampleCompareLevel(shadowMap, shadowMapSampler, varying_shadowUV, depthTexIndex, shadowPos.z - bias);
        visibility += 0.001;
      }
      return vec2<f32>(visibility, isOutSideArea);
    }

    @compute @workgroup_size( 8 , 8 , 1 )
    fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
    {
      fragCoord = vec2<i32>( globalInvocation_id.xy );

      texSize = textureDimensions(inTex).xy;
      if(fragCoord.x >= i32(texSize.x) || fragCoord.y >= i32(texSize.y)){
          return;
      }
      wNormal = textureLoad(normalTex, fragCoord, 0);
      var oc = textureLoad(inTex, fragCoord, 0);
      var outColor = oc.xyz;
      directLight = lightBuffer[0] ;
      if(directLight.castShadow >= 0){
        let index = fragCoord.x + fragCoord.y * i32(texSize.x);
        var historyData = historyGodRayData[index];
        let lightColor = directLight.lightColor;
        
        var godRayFactor = 0.0;
        if(wNormal.w > 0.5){
          //not sky
          let lightPos = models.matrix[u32(directLight.lightMatrixIndex)][3].xyz;
          wPosition = textureLoad(posTex, fragCoord, 0).xyz;
          viewDirection = normalize(globalUniform.CameraPos - wPosition) ;
          godRayFactor = rayMarch();
          godRayFactor = updateGodRay(historyData, godRayFactor);
        }
        historyData.pos = wPosition;
        historyData.value = godRayFactor;
        historyGodRayData[index] = historyData;

        outColor = oc.xyz + vec3<f32>(godRayFactor * godRayUniform.intensity * lightColor);
      }
      textureStore(outTex, fragCoord , vec4<f32>(outColor, oc.w));
    }

    fn updateGodRay(historyData:CacheGodRay, newFactor:f32) -> f32 {
      var changeFactor = 0.2;
      if(length(historyData.pos - wPosition) > 0.01){
        changeFactor = 0.4;
      }
      var factor = mix(historyData.value, newFactor, changeFactor);
      
      let pixelOffset = 1 + i32(globalUniform.frame) % 3;
      let coordRange = vec2<i32>(texSize);
      let coordIndex0 = getCoordIndex(fragCoord.x + pixelOffset, fragCoord.y - pixelOffset, coordRange);
      let coordIndex1 = getCoordIndex(fragCoord.x - pixelOffset, fragCoord.y - pixelOffset, coordRange);
      let coordIndex2 = getCoordIndex(fragCoord.x, fragCoord.y + pixelOffset * 2, coordRange);

      let oldOC0 = historyGodRayData[coordIndex0].value;
      let oldOC1 = historyGodRayData[coordIndex1].value;
      let oldOC2 = historyGodRayData[coordIndex2].value;

      let opRound = (oldOC0 + oldOC1 + oldOC2) * 0.3333333;
      factor = mix(opRound, factor, 0.5);

      return factor;
    }

    fn getCoordIndex(x0:i32, y0:i32, size:vec2<i32>) -> i32{
      let x = clamp(x0, 0, size.x - 1);
      let y = clamp(y0, 0, size.y - 1);
      return y * size.x + x;
    }
    
    
    fn rayMarch() -> f32{
      var godRayFactor = 0.0;
      let L = normalize(directLight.direction);
      let rayMarchCount = godRayUniform.rayMarchCount;
      if(godRayUniform.blendColor > 0.5){
        let eyePosition = globalUniform.CameraPos;
        var samplePosition = eyePosition;
        var lastSamplePosition = eyePosition;
        
        var frameOffset = f32(i32(globalUniform.frame) % 4);
        frameOffset *= 0.25;
        var N = normalize(wNormal.xyz);
        for(var i:f32 = 1.0; i < rayMarchCount; i += 1.0){
          var t = (i + frameOffset) / rayMarchCount;
          lastSamplePosition = samplePosition;
          samplePosition = mix(eyePosition, wPosition, t * t);

          // var shadowVisibility = directionShadowMapping(samplePosition, globalUniform.shadowBias);
          directShadowMaping(samplePosition.xyz, N, globalUniform.shadowBias);
          var shadowVisibility = shadowStrut.directShadowVisibility;
          if(shadowVisibility > 0.5){
            var stepFactor = calcGodRayValue(samplePosition, L, viewDirection);
            stepFactor *= length(lastSamplePosition - samplePosition);
            godRayFactor += stepFactor;
          }
        }
        godRayFactor /= length(wPosition - eyePosition);
      }
      return godRayFactor;
    }

    fn calcGodRayValue(pos:vec3<f32>, L:vec3<f32>, V:vec3<f32>) -> f32{
      var halfLoV = normalize(L + V);
      var LoV = saturate(dot(V,halfLoV));
      LoV = pow(LoV, godRayUniform.scatteringExponent);
      var distance = length(pos - globalUniform.CameraPos) / (globalUniform.far);
      distance = 1.0 - saturate(distance);
      distance *= distance;
      return LoV * distance;
    }
  `,Zu=`
    @group(0) @binding(0) var textureR : texture_2d<f32>;
    @group(0) @binding(1) var textureG : texture_2d<f32>;
    @group(0) @binding(2) var textureB : texture_2d<f32>;
    @group(0) @binding(3) var textureA : texture_2d<f32>;
    @group(0) @binding(4) var outTex : texture_storage_2d<rgba8unorm, write>;

    @compute @workgroup_size(8, 8, 1)
    fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
        let size = textureDimensions(outTex);
        let fragCoord : vec2<i32> = vec2<i32>(GlobalInvocationID.xy); 
        var uv:vec2<f32>;
        uv.x = f32(fragCoord.x)/f32(size.x);
        uv.y = f32(fragCoord.y)/f32(size.y);
        var oc:vec4<f32> = textureSampleLevel(atlasTexture, atlasTextureSampler, targetUV, 0.0);

        let sizeR = textureDimensions(textureR);
        let sizeG = textureDimensions(textureG);
        let sizeB = textureDimensions(textureB);
        let sizeA = textureDimensions(textureA);
        
        var tr = textureLoad(textureR, vec2<i32>(uv * sizeR) , 0 ) ;
        var tg = textureLoad(textureG, vec2<i32>(uv * sizeG) , 0 ) ;
        var tb = textureLoad(textureB, vec2<i32>(uv * sizeB) , 0 ) ;
        var ta = textureLoad(textureA, vec2<i32>(uv * sizeA) , 0 ) ;

        let color = vec4<f32>(tr,tg,tb,ta);
        textureStore(outTex, fragCoord , vec4(color));
    }

`,$u=`
   struct OutlineSettingData{
      strength: f32,
      useAddMode: f32,
      outlinePixel: f32,
      fadeOutlinePixel: f32,
      lowTexWidth: f32,
      lowTexHeight: f32,
      slot0: f32,
      slot1: f32,
   }

   @group(0) @binding(0) var<uniform> outlineSetting: OutlineSettingData;
   @group(0) @binding(1) var inTex : texture_2d<f32>;
   @group(0) @binding(2) var lowTexSampler : sampler;
   @group(0) @binding(3) var lowTex : texture_2d<f32>;
   @group(0) @binding(4) var outlineTex : texture_storage_2d<rgba16float, write>;
   
   var<private> texSize: vec2<u32>;
   var<private> fragCoord: vec2<i32>;

   @compute @workgroup_size( 8 , 8 , 1 )
   fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
   {
      fragCoord = vec2<i32>( globalInvocation_id.xy );
      texSize = textureDimensions(outlineTex).xy;
      if(fragCoord.x >= i32(texSize.x) || fragCoord.y >= i32(texSize.y)){
         return;
      }

      var uv01 = vec2<f32>(fragCoord) / (vec2<f32>(texSize) - 1.0);
      var offset = vec2<f32>(texSize) / vec2<f32>(outlineSetting.lowTexWidth, outlineSetting.lowTexHeight);
      offset = 0.5 * offset / (vec2<f32>(texSize) - 1.0);
      uv01 += offset;
      var outLineColor = textureSampleLevel(lowTex, lowTexSampler, uv01, 0.0);

      outLineColor.x *= outlineSetting.strength;
      outLineColor.y *= outlineSetting.strength;
      outLineColor.z *= outlineSetting.strength;

      var inColor = textureLoad(inTex, fragCoord, 0);
      var blendColor:vec3<f32> = vec3<f32>(0.0);
      if(outlineSetting.useAddMode > 0.5){
         blendColor = inColor.xyz + outLineColor.xyz * outLineColor.w;
      }else{
         blendColor = mix(inColor.xyz, outLineColor.xyz, outLineColor.w);
      }
      textureStore(outlineTex, fragCoord, vec4<f32>(blendColor, inColor.w));
   }

`,ec=`
  struct OutlineSettingData{
    strength: f32,
    useAddMode: f32,
    outlinePixel: f32,
    fadeOutlinePixel: f32,
    lowTexWidth: f32,
    lowTexHeight: f32,
    slot0: f32,
    slot1: f32,
  }

  struct OutlineSlotData{
    color: vec3<f32>,
    count: f32,
  }

  struct OutlineWeightData{
    slotIndex:f32,
    outerSlotIndex:f32,
    entityIndex:f32,
    weight:f32
  }

  struct OutlineEntities{
    list: array<f32, 16u>,
  }

  @group(0) @binding(0) var<uniform> outlineSetting: OutlineSettingData;
  @group(0) @binding(1) var<storage, read_write> slotsBuffer : array<OutlineSlotData>;
  @group(0) @binding(2) var<storage, read_write> weightBuffer : array<OutlineWeightData>;
  @group(0) @binding(3) var<storage, read_write> entitiesBuffer : array<OutlineEntities>;
  @group(0) @binding(4) var indexTexture : texture_2d<f32>;

  var<private> texSize: vec2<u32>;
  var<private> lowSize: vec2<i32>;
  var<private> fragCoord: vec2<i32>;
  var<private> fragCoordLow: vec2<i32>;
  var<private> coordIndex: i32;

  var<private> fragOutline: OutlineWeightData;

  @compute @workgroup_size( 8 , 8 , 1 )
  fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
  {
    fragCoordLow = vec2<i32>( globalInvocation_id.xy );
    texSize = textureDimensions(indexTexture).xy;
    lowSize = vec2<i32>(i32(outlineSetting.lowTexWidth), i32(outlineSetting.lowTexHeight));
    let scaleValue = f32(texSize.x) / f32(lowSize.x);
    fragCoord.x = i32(f32(fragCoordLow.x) * scaleValue);
    fragCoord.y = i32(f32(fragCoordLow.y) * scaleValue);

    if(fragCoord.x >= i32(texSize.x) || fragCoord.y >= i32(texSize.y)){
        return;
    }
    if(fragCoordLow.x >= lowSize.x || fragCoordLow.y >= lowSize.y){
        return;
    }
    
    coordIndex = fragCoordLow.x + fragCoordLow.y * lowSize.x;
    fragOutline = weightBuffer[coordIndex];
    var wPos = textureLoad(indexTexture, fragCoord, 0 ) ;
    
    fragOutline.entityIndex = round(wPos.w);
    fragOutline.slotIndex = -1.0;
    fragOutline.outerSlotIndex = -1.0;
    fragOutline.weight = 0.0;
    
    if(fragOutline.entityIndex >= 0.0){
      fragOutline.slotIndex = f32(matchOutlineSlot());
    }
    weightBuffer[coordIndex] = fragOutline;
  }

  fn matchOutlineSlot() -> i32
  {
    for(var i:i32 = 0; i < 8; i ++){
        var slotData:OutlineSlotData = slotsBuffer[i];
        var entities:array<f32, 16u> = entitiesBuffer[i].list;
        let count:i32 = i32(slotData.count);
        for(var j:i32 = 0; j < count; j ++){
            var outlineIndex = entities[j];
            if(abs(fragOutline.entityIndex - outlineIndex) < 0.1){ 
                return i;
            }
        }
    }
    return -1;
  }
`,tc=`
    struct OutlineSettingData{
        strength: f32,
        useAddMode: f32,
        outlinePixel: f32,
        fadeOutlinePixel: f32,
        lowTexWidth: f32,
        lowTexHeight: f32,
        slot0: f32,
        slot1: f32,
    }
    
    struct OutlineSlotData{
        color: vec3<f32>,
        count: f32,
    }
    
    struct OutlineWeightData{
        slotIndex:f32,
        outerSlotIndex:f32,
        entityIndex:f32,
        weight:f32
    }

    @group(0) @binding(0) var<uniform> outlineSetting: OutlineSettingData;
    @group(0) @binding(1) var<storage, read_write> slotsBuffer : array<OutlineSlotData>;
    @group(0) @binding(2) var<storage, read_write> weightBuffer : array<OutlineWeightData>;
    @group(0) @binding(3) var<storage, read_write> oldOutlineColor : array<vec4<f32>>;
    @group(0) @binding(4) var lowTex : texture_storage_2d<rgba16float, write>;
    
    var<private> texSize: vec2<u32>;
    var<private> fragCoord: vec2<i32>;
    var<private> coordIndex: i32;
    var<private> fragOutline: OutlineWeightData;
    
    @compute @workgroup_size( 8 , 8 , 1 )
    fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
    {
        fragCoord = vec2<i32>( globalInvocation_id.xy );
        texSize = textureDimensions(lowTex).xy;
        if(fragCoord.x >= i32(texSize.x) || fragCoord.y >= i32(texSize.y)){
            return;
        }
        
        coordIndex = fragCoord.x + fragCoord.y * i32(texSize.x);
        fragOutline = weightBuffer[coordIndex];
        
        var newOC = vec4<f32>(0.0);
        
        calcOutline();
        let outerSlotIndex:i32 = i32(round(fragOutline.outerSlotIndex));
        if(outerSlotIndex >= 0){
            let outLineColor = slotsBuffer[outerSlotIndex].color;
            newOC = vec4<f32>(outLineColor, fragOutline.weight);
        }
        
        let coordIndex0 = fragCoord.x + 1 + (fragCoord.y + 1) * i32(texSize.x);
        let coordIndex1 = fragCoord.x - 1 + (fragCoord.y + 1) * i32(texSize.x);
        let coordIndex2 = fragCoord.x + (fragCoord.y - 1) * i32(texSize.x);

        let oldOC = oldOutlineColor[coordIndex];
        let oldOC0 = oldOutlineColor[coordIndex0];
        let oldOC1 = oldOutlineColor[coordIndex1];
        let oldOC2 = oldOutlineColor[coordIndex2];
        
        newOC = mix((oldOC + oldOC0 + oldOC1 + oldOC2) * 0.25, newOC, 0.5);
        oldOutlineColor[coordIndex] = newOC;
        textureStore(lowTex, fragCoord, newOC);
    }
    
    fn calcOutline()
    {
        let outlinePixel = outlineSetting.outlinePixel;
        let pixelRadius = outlinePixel + outlineSetting.fadeOutlinePixel;
        let minX = max(0.0, f32(fragCoord.x) - pixelRadius);
        let maxX = min(f32(texSize.x), f32(fragCoord.x) + pixelRadius);
        let minY = max(0.0, f32(fragCoord.y) - pixelRadius);
        let maxY = min(f32(texSize.y), f32(fragCoord.y) + pixelRadius);
        var coordTemp_f32 = vec2<f32>(0.0);
        var coordCurrent_f32 = vec2<f32>(fragCoord);
        var tempCoordIndex = 0;
        var tempWeightData: OutlineWeightData;
        for(var x:f32 = minX; x < maxX; x += 1.0){
            for(var y:f32 = minY; y < maxY; y += 1.0){
                coordTemp_f32.x = x;
                coordTemp_f32.y = y;
                let distanceToOuter = length(coordTemp_f32 - coordCurrent_f32);
                if(distanceToOuter < pixelRadius){
                    var coord_i32 = vec2<i32>(coordTemp_f32);
                    tempCoordIndex = coord_i32.x + coord_i32.y * i32(texSize.x);
                    tempWeightData = weightBuffer[tempCoordIndex];
                    let outlineGap = abs(tempWeightData.slotIndex - fragOutline.slotIndex);
                    if(outlineGap > 0.1){
                        if(tempWeightData.slotIndex > fragOutline.slotIndex){
                            if(abs(tempWeightData.slotIndex - fragOutline.outerSlotIndex) < 0.1){
                                fragOutline.weight = max(fragOutline.weight, calcWeight(pixelRadius, distanceToOuter, outlinePixel));
                                fragOutline.outerSlotIndex = tempWeightData.slotIndex;
                                weightBuffer[tempCoordIndex] = tempWeightData;
                            }else if(tempWeightData.slotIndex > fragOutline.outerSlotIndex){
                                fragOutline.weight = calcWeight(pixelRadius, distanceToOuter, outlinePixel);
                                fragOutline.outerSlotIndex = tempWeightData.slotIndex;
                                weightBuffer[tempCoordIndex] = tempWeightData;
                            }
                        }
                    }
                }
            }
        }
    }
    
    fn calcWeight(totalRadius:f32, distance:f32, innerRadius:f32) -> f32{
        if(distance < innerRadius){
            return 1.0;
        }
        var ret = 1.0 - (distance - innerRadius)  / (totalRadius - innerRadius);

        return ret;
    }
`,ic=`

    #include "GlobalUniform"

    struct PickResult{
        pick_meshID:f32,
        pick_meshID2:f32,
        pick_UV:vec2<f32>,
        pick_Position:vec4<f32>,
        pick_Normal:vec4<f32>,
        pick_Tangent:vec4<f32>,
    }

    //@group(0) @binding(0) var<uniform> globalUniform: GlobalUniform;
    @group(0) @binding(1) var<storage,read_write> outBuffer: PickResult;
    @group(0) @binding(2) var visibleMap : texture_2d<f32>;

    @compute @workgroup_size( 1 )
    fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
    {
    var result:PickResult ;
    // result.pick_meshID
    let texSize = textureDimensions(visibleMap).xy;
    let screenPoint = vec2<f32>(globalUniform.mouseX/globalUniform.windowWidth,globalUniform.mouseY/globalUniform.windowHeight);

    let mouseUV = screenPoint * vec2<f32>(texSize.xy); 
    let info = textureLoad(visibleMap, vec2<i32>(mouseUV) , 0);

    outBuffer.pick_meshID = f32(info.w) ;
    outBuffer.pick_meshID2 = f32(info.w) ;
    outBuffer.pick_Tangent = vec4<f32>(2.0,2.0,2.0,2.0) ;
    outBuffer.pick_UV = vec2<f32>(globalUniform.mouseX,globalUniform.mouseY) ;
    outBuffer.pick_Position = vec4<f32>(info.xyzw) ;
    outBuffer.pick_Normal = vec4<f32>(info.xyzw) ;
    }
`,Yg=`
#include "GlobalUniform"
  struct UniformData {
    radius: f32 ,
    bias: f32,
    aoPower: f32 ,
    blurSize: f32 ,
  };

  @group(0) @binding(0) var<uniform> standUniform: GlobalUniform;
  @group(0) @binding(1) var<uniform> uniformData: UniformData;
  @group(0) @binding(2) var<storage,read> sampleData: array<vec4<f32>>;

  // @group(0) @binding(3) var colorMap : texture_2d<f32>;
  @group(0) @binding(3) var positionMap : texture_2d<f32>;
  @group(0) @binding(4) var normalMap : texture_2d<f32>;

  @group(0) @binding(5) var noiseMapSampler: sampler;
  @group(0) @binding(6) var noiseMap : texture_2d<f32>;

  @group(0) @binding(7) var outTex : texture_storage_2d<rgba16float, write>;

  var<private> kernelSize: i32 = 32 ;

  @compute @workgroup_size( 8 , 8 )
  fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
  {
    var fragCoord = vec2<i32>( globalInvocation_id.xy );

    var texSize = textureDimensions(positionMap).xy;
    var texCoord = vec2<f32>(fragCoord) / vec2<f32>(texSize);

    var fragColor = vec4<f32>(1.0);

    var viewMat = standUniform.viewMat  ;
    // var color = textureLoad(colorMap, fragCoord , 0 ) ;
    var wPos = textureLoad(positionMap, fragCoord , 0 ) ;

    var fragPosition = viewMat * vec4<f32>(wPos.xyz,1.0);
    fragPosition = vec4(fragPosition.xyz / fragPosition.w,1.0) ;

    var texNormal = textureLoad(normalMap, fragCoord , 0 ) ;
    var sampleNormal = texNormal.xyz ;
    sampleNormal = sampleNormal * 2.0 - 1.0;
    var fragNormal = viewMat * vec4<f32>((sampleNormal.xyz),0.0);

    var pes = vec2<f32>(texSize.xy) / 4.0 ;
    var noiseTex:vec4<f32> = textureSampleLevel(noiseMap, noiseMapSampler, texCoord * pes , 0.0);
    var randomVec  = (viewMat * vec4<f32>(normalize(noiseTex.xyz),0.0)).xyz;

    var tangent = normalize(randomVec - fragNormal.xyz * dot(randomVec , fragNormal.xyz));
    var bTangent = cross(fragNormal.xyz, tangent) + 0.0001 ;
    var tbn = mat3x3<f32>(tangent, bTangent, fragNormal.xyz);

    var offset:vec4<f32>;
    var samplePos :vec3<f32>;
    var offsetPosition:f32;
    var sample_depth_v:vec4<f32>;
    var occlusion:f32 = 0.0;
    var rangeCheck:f32 = 0.0 ;
    var radius:f32 = uniformData.radius * 32.0 * fragPosition.z ;

    for(var i:i32 = 0; i < 32 ; i = i + 1 ){
      samplePos  = (tbn * sampleData[i].xyz ) ;
      samplePos  = fragPosition.xyz + samplePos * radius ;

      offset = vec4(samplePos, 1.0);
      offset = standUniform.projMat * offset;

      var off = offset.xyz / offset.w;
      off = (off.xyz * 0.5 ) + 0.5 ;
      off.y = 1.0 - off.y ;
      var offsetUV = vec2<i32>(off.xy * vec2<f32>(texSize.xy));

      sample_depth_v = textureLoad(positionMap, offsetUV.xy , 0 ) ;
      sample_depth_v = vec4<f32>((viewMat * vec4<f32>(sample_depth_v.xyz,1.0)).xyz,1.0);
      offsetPosition = sample_depth_v.z / sample_depth_v.w ;

      rangeCheck = smoothstep(0.0, 1.0, radius / abs(offsetPosition - fragPosition.z ));
      // rangeCheck = smoothstep(0.0, 1.0, radius / uniformData.bias);

      var a = 1.0 ;
      if(offsetPosition >= (samplePos.z + uniformData.bias)){
        a = 0.0 ;
      }
      a = a * rangeCheck ;
      occlusion = occlusion + a ;
    }

    occlusion = 1.0 - ( occlusion / f32(kernelSize) * texNormal.w );
    occlusion = pow(occlusion, uniformData.aoPower) ;

    // color = color * occlusion ;

    textureStore(outTex, fragCoord , vec4(occlusion));
  }
`,rc=`
@group(0) @binding(0) var<storage, read_write> rayTraceBuffer : array<RayTraceRetData>;
  @group(0) @binding(1) var colorMap : texture_2d<f32>;
  @group(0) @binding(2) var ssrMapSampler : sampler;
  @group(0) @binding(3) var ssrMap : texture_2d<f32>;
  @group(0) @binding(4) var outTex : texture_storage_2d<rgba16float, write>;

  var<private> colorTexSize: vec2<u32>;
  var<private> ssrTexSize: vec2<u32>;
  var<private> fragCoord: vec2<i32>;
  var<private> ssrCoord: vec2<i32>;

  struct RayTraceRetData{
    skyColor:vec3<f32>,
    roughness:f32,

    hitCoord:vec2<f32>,
    alpha:f32,
    fresnel:f32,
  }
  
  @compute @workgroup_size( 8 , 8 , 1 )
  fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
  {
    fragCoord = vec2<i32>( globalInvocation_id.xy );
    colorTexSize = textureDimensions(colorMap).xy;
    ssrTexSize = textureDimensions(ssrMap).xy;
    if(fragCoord.x >= i32(colorTexSize.x) || fragCoord.y >= i32(colorTexSize.y)){
        return;
    }
    let scale:f32 = f32(ssrTexSize.x) / f32(colorTexSize.x);
    ssrCoord = vec2<i32>(vec2<f32>(fragCoord.xy) * scale);
    let index = ssrCoord.x + ssrCoord.y * i32(ssrTexSize.x);
    let hitData = rayTraceBuffer[index];
    var color = textureLoad(colorMap, fragCoord , 0);
    var uv01 = vec2<f32>(f32(fragCoord.x), f32(fragCoord.y));
    uv01 = uv01 / vec2<f32>(colorTexSize - 1);
    
    var ssrColor = textureSampleLevel(ssrMap, ssrMapSampler, uv01, 0.0);
    var tc = mix(color, ssrColor, hitData.fresnel) ;
    var outColor = tc ;
    outColor.a = color.a ; 
    textureStore(outTex, fragCoord , outColor );
  }

`,ac=`
  struct SSRUniformData {
    ssrBufferSizeX: f32,
    ssrBufferSizeY: f32,
    colorMapSizeX: f32,
    colorMapSizeY: f32,

    fadeEdgeRatio: f32,
    rayMarchRatio: f32,
    fadeDistanceMin: f32,
    fadeDistanceMax: f32,
    
    mixThreshold: f32,
    roughnessThreshold: f32,
    reflectionRatio: f32,
    powDotRN: f32,

    randomSeedX: f32,
    randomSeedY: f32,
    slot1: f32,
    slot2: f32,
  };

  struct RayTraceRetData{
    skyColor:vec3<f32>,
    roughness:f32,

    hitCoord:vec2<f32>,
    alpha:f32,
    fresnel:f32,
  }

  @group(0) @binding(0) var<uniform> ssrUniform: SSRUniformData;
  @group(0) @binding(1) var<storage, read_write> rayTraceBuffer : array<RayTraceRetData>;
  @group(0) @binding(2) var<storage, read_write> ssrColorData : array<vec4<f32>>;
  @group(0) @binding(3) var<storage, read_write> historyPosition : array<vec4<f32>>;

  @group(0) @binding(4) var colorMap: texture_2d<f32>;
  @group(0) @binding(5) var outTex : texture_storage_2d<rgba16float, write>;

  var<private> ssrBufferCoord: vec2<i32>;
  var<private> colorTexSize: vec2<i32>;
  var<private> bufferData: RayTraceRetData;
  var<private> ssrBufferSize: vec2<i32>;
  var<private> coordIndex: i32;

  @compute @workgroup_size( 8 , 8 , 1 )
  fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
  {
    ssrBufferCoord = vec2<i32>( globalInvocation_id.xy );
    ssrBufferSize = vec2<i32>(i32(ssrUniform.ssrBufferSizeX), i32(ssrUniform.ssrBufferSizeY));
    colorTexSize = vec2<i32>(i32(ssrUniform.colorMapSizeX), i32(ssrUniform.colorMapSizeY));

    if(ssrBufferCoord.x >= ssrBufferSize.x || ssrBufferCoord.y >= ssrBufferSize.y){
        return;
    }

    coordIndex = ssrBufferCoord.x + ssrBufferCoord.y * ssrBufferSize.x;
    bufferData = rayTraceBuffer[coordIndex];
    var oc = vec4<f32>(0.0, 0.0, 0.0, -1.0);
    
    var mixFactor = historyPosition[coordIndex].w;
    
    if(bufferData.alpha >= 0.0 && bufferData.roughness < ssrUniform.roughnessThreshold){
      let roughness = clamp(bufferData.roughness, 0.0, 1.0);
      let prefilterColor = bufferData.skyColor;
      var ssrColor = textureLoad(colorMap, vec2<i32>(bufferData.hitCoord), 0);
      ssrColor.w = bufferData.alpha;
      oc = ssrColor;
    }
    let skyColor = vec4<f32>(bufferData.skyColor, 1.0);
    oc = mix(oc, skyColor, 1.0 - bufferData.alpha);
    
    let lastColor = ssrColorData[coordIndex];
    var newColor = mix(oc, lastColor, mixFactor);
    newColor.w = oc.w;
    
    ssrColorData[coordIndex] = newColor;
    
    textureStore(outTex, ssrBufferCoord , newColor);
  }
`,sc=`
  #include "GlobalUniform"

  struct SSRUniformData {
    ssrBufferSizeX: f32,
    ssrBufferSizeY: f32,
    colorMapSizeX: f32,
    colorMapSizeY: f32,

    fadeEdgeRatio: f32,
    rayMarchRatio: f32,
    fadeDistanceMin: f32,
    fadeDistanceMax: f32,
    
    mixThreshold: f32,
    roughnessThreshold: f32,
    reflectionRatio: f32,
    powDotRN: f32,

    randomSeedX: f32,
    randomSeedY: f32,
    slot1: f32,
    slot2: f32,
  };

  struct HitData{
    hitPos:vec3<f32>,
    hitNormal:vec3<f32>,
    fadeAlpha:vec4<f32>,
    hitCoord:vec2<i32>,
    hitResult:i32,
    hitSky:i32,
  };

  struct RayTraceRetData{
    skyColor:vec3<f32>,
    roughness:f32,

    hitCoord:vec2<f32>,
    alpha:f32,
    fresnel:f32,
  }

  @group(0) @binding(0) var<uniform> standUniform: GlobalUniform;
  @group(0) @binding(1) var<uniform> ssrUniform: SSRUniformData;
  @group(0) @binding(2) var<storage, read_write> rayTraceBuffer : array<RayTraceRetData>;
  @group(0) @binding(4) var<storage, read_write> historyPosition : array<vec4<f32>>;

  @group(0) @binding(5) var zBufferTexture : texture_2d<f32>;
  @group(0) @binding(6) var normalBufferTex : texture_2d<f32>;
  @group(0) @binding(7) var materialBufferTex : texture_2d<f32>;
  @group(0) @binding(8) var prefilterMapSampler: sampler;
  @group(0) @binding(9) var prefilterMap: texture_cube<f32>;

  var<private> rayOrigin: vec3<f32>;
  var<private> rayDirection: vec3<f32>;
  var<private> cameraPosition: vec3<f32>;
  var<private> reflectionDir: vec3<f32>;
  var<private> colorTexSize: vec2<i32>;
  var<private> fragCoordColor: vec2<i32>;
  var<private> ssrBufferCoord: vec2<i32>;
  var<private> ssrBufferSize: vec2<i32>;
  var<private> hitData: HitData;
  var<private> rayTraceRet: RayTraceRetData;
  var<private> worldPosition: vec3<f32>;
  var<private> worldNormal: vec3<f32>;
  var<private> roughness: f32;
  var<private> fresnel: f32;

  var<private> historyPos: vec3<f32>;
  var<private> coordIndex: i32;

  var <private> PI: f32 = 3.14159;

  @compute @workgroup_size( 8 , 8 , 1 )
  fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
  {
    ssrBufferCoord = vec2<i32>( globalInvocation_id.xy);
    ssrBufferSize = vec2<i32>(i32(ssrUniform.ssrBufferSizeX), i32(ssrUniform.ssrBufferSizeY));
    if(ssrBufferCoord.x >= ssrBufferSize.x || ssrBufferCoord.y >= ssrBufferSize.y){
        return;
    }
    coordIndex = ssrBufferCoord.x + ssrBufferCoord.y * ssrBufferSize.x;

    colorTexSize = vec2<i32>(i32(ssrUniform.colorMapSizeX), i32(ssrUniform.colorMapSizeY));
    fragCoordColor = convertColorCoordFromSSRCoord(ssrBufferCoord);

    hitData.fadeAlpha = vec4<f32>(0.0);
    hitData.hitCoord = vec2<i32>(0);
    hitData.hitResult = 0;
    hitData.hitNormal = vec3<f32>(0.0, 1.0, 0.0);
    hitData.hitSky = 1;

    worldPosition = textureLoad(zBufferTexture, fragCoordColor , 0).xyz;
    historyPos = historyPosition[coordIndex].xyz;
    
    var mixFactor = 0.2;
    if(length(historyPos - worldPosition) < ssrUniform.mixThreshold){
        mixFactor = 0.9;
    }
    historyPosition[coordIndex] = vec4<f32>(worldPosition, mixFactor);
    
    let normal_v4 = textureLoad(normalBufferTex, fragCoordColor , 0);
    worldNormal = normalize(vec3<f32>(normal_v4.xyz) * 2.0 - 1.0);
    let materialData = textureLoad(materialBufferTex, fragCoordColor , 0 );
    let roughness = materialData.g * (1.0 - materialData.b);
    fresnel = (1.0 - roughness) * ssrUniform.reflectionRatio;

    cameraPosition = vec3<f32>(standUniform.cameraWorldMatrix[3].xyz);
    rayOrigin = vec3<f32>(worldPosition.xyz);

    rayDirection = normalize(vec3<f32>(worldPosition.xyz - cameraPosition));
    
    var randomSeed = fract(ssrUniform.randomSeedX + worldPosition.x);
    rand_seed.x = randomSeed;
    rand_seed.y = fract(ssrUniform.randomSeedY + worldPosition.y + worldPosition.z);
    randomSeed = rand();
    
    let normalRandom = makeRandomDirection(worldNormal, u32(randomSeed * 256.0), 256, roughness);
    
    reflectionDir = normalize(reflect(rayDirection, normalRandom));

    if(normal_v4.w > 0.5 && roughness < ssrUniform.roughnessThreshold){
      let uvOrigin = vec2<f32>(f32(fragCoordColor.x), f32(fragCoordColor.y));
      let rayMarchPosition = rayOrigin + reflectionDir * 100.0;
      var uvRayMarch = standUniform.projMat * (standUniform.viewMat * vec4<f32>(rayMarchPosition, 1.0));
      var uvOffset = (vec2<f32>(uvRayMarch.xy / uvRayMarch.w) + 1.0) * 0.5;
      uvOffset.y = 1.0 - uvOffset.y;
      uvOffset = uvOffset * vec2<f32>(colorTexSize - 1) - uvOrigin;
      uvOffset = normalize(uvOffset);

      rayTrace(uvOffset);
      if(hitData.hitResult == 1){
          hidingArtifact();
          rayTraceRet.alpha = hitData.fadeAlpha.x * hitData.fadeAlpha.y * hitData.fadeAlpha.z * hitData.fadeAlpha.w;
          if(hitData.hitSky == 1){
            rayTraceRet.alpha = 0.0;
          }
      }else{
        rayTraceRet.alpha = 0.0;
      }
      rayTraceRet.skyColor = getSkyColor();
    }else{
      rayTraceRet.alpha = -1.0;
      rayTraceRet.skyColor = vec3<f32>(0.0);
    }

    rayTraceRet.roughness = roughness;
    rayTraceRet.fresnel = fresnel;
    rayTraceRet.hitCoord = vec2<f32>(hitData.hitCoord);

    let index:i32 = ssrBufferCoord.x + ssrBufferCoord.y * ssrBufferSize.x;
    rayTraceBuffer[index] = rayTraceRet;
  }

  fn makeRandomDirection(srcDirection:vec3<f32>, i:u32, SAMPLE_COUNT:u32, roughness:f32) -> vec3<f32>
  {
    var N: vec3<f32> = normalize(srcDirection);
    var Xi:vec2<f32> = hammersley(i, SAMPLE_COUNT);
    return ImportanceSampleGGX(Xi, N, roughness);
  }

  fn hammersley( i : u32 ,  N : u32 ) -> vec2<f32>
  {
    // Radical inverse based on http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html
    var bits = (i << 16u) | (i >> 16u);
    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
    var rdi = f32(bits) * 2.3283064365386963e-10;
    return vec2<f32>(f32(i) /f32(N), rdi);
  }

  fn ImportanceSampleGGX( Xi:vec2<f32>, N:vec3<f32>, roughness:f32) ->vec3<f32>
  {
    var a = roughness*roughness;

    var phi = 2.0 * PI * Xi.x;
    var cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));
    var sinTheta = sqrt(1.0 - cosTheta*cosTheta);

    // from spherical coordinates to cartesian coordinates
    var H:vec3<f32>;
    H.x = cos(phi) * sinTheta;
    H.y = sin(phi) * sinTheta;
    H.z = cosTheta;

    // from tangent-space vector to world-space sample vector
  var up:vec3<f32>;
    if(abs(N.z) < 0.999)
    {
        up = vec3<f32>(0.0, 0.0, 1.0);
    }
    else
    {
        up = vec3<f32>(1.0, 0.0, 0.0);
    }
  var tangent:vec3<f32>  = normalize(cross(up, N));
  var bitangent:vec3<f32> = cross(N, tangent);
  var sampleVec:vec3<f32> = tangent * H.x + bitangent * H.y + N * H.z;
  return normalize(sampleVec);
  }

  var<private> rand_seed :vec2<f32> = vec2<f32>(0.0);
  fn rand() -> f32 {
    rand_seed.x = fract(cos(dot(rand_seed, vec2<f32>(23.14077926, 232.61690225))) * 136.8168);
    rand_seed.y = fract(cos(dot(rand_seed, vec2<f32>(54.47856553, 345.84153136))) * 534.7645);
    return rand_seed.y;
  }

  fn getSkyColor() -> vec3<f32>{
    let calcRoughness = clamp(roughness, 0.0, 1.0);
    let MAX_REFLECTION_LOD  = f32(textureNumLevels(prefilterMap)) ;
    var prefilterColor = textureSampleLevel(prefilterMap, prefilterMapSampler, reflectionDir, calcRoughness * MAX_REFLECTION_LOD);
    return LinearToGammaSpace(vec3<f32>(prefilterColor.xyz)) * standUniform.skyExposure;
  }

  fn LinearToGammaSpace(linRGB: vec3<f32>) -> vec3<f32> {
      var linRGB1 = max(linRGB, vec3<f32>(0.0));
      linRGB1 = pow(linRGB1, vec3<f32>(0.4166666567325592));
      return max(((1.0549999475479126 * linRGB1) - vec3<f32>(0.054999999701976776)), vec3<f32>(0.0));
  }

  fn convertColorCoordFromSSRCoord(coord:vec2<i32>) -> vec2<i32>{
    let color_ssr_ratio = ssrUniform.colorMapSizeX / ssrUniform.ssrBufferSizeX;
    let targetCoord = vec2<f32>(coord) * color_ssr_ratio;
    return vec2<i32>(targetCoord);
  }

  fn hidingArtifact(){
    let texSizeF32 = vec2<f32>(f32(colorTexSize.x), f32(colorTexSize.y));
    let halfTexSizeF32 = texSizeF32 * 0.5;

    //near screen edge
    var distance2Center = abs(vec2<f32>(f32(hitData.hitCoord.x), f32(hitData.hitCoord.y)) - halfTexSizeF32);
    let halfEdgeSize:f32 = min(texSizeF32.x, texSizeF32.y) * clamp(0.01, ssrUniform.fadeEdgeRatio, 1.0) * 0.5;
    var distance2Edge = min(vec2<f32>(halfEdgeSize), halfTexSizeF32 - distance2Center);
    var ratioXY = distance2Edge / halfEdgeSize;
    hitData.fadeAlpha.x = sqrt(ratioXY.x * ratioXY.y);

    //back face hit
    var backFaceBias = max(0.0, dot(hitData.hitNormal, -reflectionDir));
    hitData.fadeAlpha.y = pow(backFaceBias, max(0.0001, ssrUniform.powDotRN));

    //screen distance ratio
    let maxLength = max(f32(colorTexSize.x), f32(colorTexSize.y)) * ssrUniform.rayMarchRatio;
    let screenPointer = hitData.hitCoord - fragCoordColor;
    var screenDistance = length(vec2<f32>(f32(screenPointer.x), f32(screenPointer.y)));
    screenDistance = clamp(screenDistance / maxLength, 0.0, 1.0);
    hitData.fadeAlpha.z = 1.0 - screenDistance;

    //position distance ratio
    var fadeDistance = length(vec3<f32>(hitData.hitPos - cameraPosition));
    var dFar = ssrUniform.fadeDistanceMax;
    var dNear = ssrUniform.fadeDistanceMin;
    dFar = max(1.0, dFar);
    dNear = clamp(dNear, 0.001, dFar - 0.001);
    fadeDistance = clamp(fadeDistance, dNear, dFar);
    fadeDistance = (fadeDistance - dNear) / (dFar - dNear);
    hitData.fadeAlpha.w = 1.0 - fadeDistance;
  }

  fn rayTrace(rayMarchDir:vec2<f32>){
    let stepLength = 4.0;
    let maxLength = max(f32(colorTexSize.x), f32(colorTexSize.y)) * ssrUniform.rayMarchRatio;
    for(var i:f32 = 1.0; i < maxLength; i = i + stepLength){
        let offsetFloat32 = i * rayMarchDir;
        var uv = fragCoordColor + vec2<i32>(i32(offsetFloat32.x), i32(offsetFloat32.y));
        let hitRet = rayInterestScene(uv);
        if(hitRet > 0){
          hitData.hitResult = hitRet;
          break;
        }
    }
    if(hitData.hitResult == 1){
        let fromUV = hitData.hitCoord;
        for(var i:f32 = -stepLength; i <= 0.0; i = i + 1.0){
          let offsetFloat32 = i * rayMarchDir;
          var uv = fromUV + vec2<i32>(i32(offsetFloat32.x), i32(offsetFloat32.y));
          let hitRet = rayInterestScene(uv);
          if(hitRet == 1){
            let WN = textureLoad(normalBufferTex, hitData.hitCoord , 0 );
            if(WN.w > 0.5){
                hitData.hitSky = 0;
            }
            let normal = vec3<f32>(WN.xyz) * 2.0 - 1.0;
            hitData.hitNormal = normalize(vec3<f32>(normal.xyz));
            break;
          }
        }
    }
  }

  fn rayInterestScene(uv:vec2<i32>) -> i32 {
    if(uv.x < 0 || uv.y < 0 || uv.x >= colorTexSize.x || uv.y >= colorTexSize.y){
      return 2;
    }else{
      let hitPos = textureLoad(zBufferTexture, uv , 0 );
      let testDir = normalize(vec3<f32>(hitPos.xyz - rayOrigin));
      let cosValue = dot(reflectionDir, testDir);

      if(cosValue > 0.9996){
        let cross1 = cross(reflectionDir, -rayDirection);
        let cross2 = cross(reflectionDir, testDir);
        if(dot(cross1, cross2) > 0.0){
          hitData.hitPos = vec3<f32>(hitPos.xyz);
          hitData.hitCoord = uv;
          return 1;
        }
      }
    }
    return 0;
  }
`,nc=`
    @group(0) @binding(0) var<storage, read_write> preColor : array<vec4<f32>>;
    @group(0) @binding(1) var preColorTex : texture_storage_2d<rgba16float, write>;

    var<private> texSize: vec2<u32>;
    var<private> fragCoord: vec2<i32>;
    var<private> coordIndex: i32;
    
    @compute @workgroup_size( 8 , 8 , 1 )
    fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
    {
      fragCoord = vec2<i32>( globalInvocation_id.xy );
      texSize = textureDimensions(preColorTex).xy;
      if(fragCoord.x >= i32(texSize.x) || fragCoord.y >= i32(texSize.y)){
          return;
      }
      coordIndex = fragCoord.x + fragCoord.y * i32(texSize.x);
      textureStore(preColorTex, fragCoord , preColor[coordIndex]);
    }
 `,oc=`
    struct TAAData{
      preProjMatrix: mat4x4<f32>,
      preViewMatrix: mat4x4<f32>,
      jitterFrameIndex: f32,
      blendFactor: f32,
      sharpFactor: f32,
      sharpPreBlurFactor: f32,
      jitterX: f32,
      jitterY: f32,
      slot0: f32,
      slot1: f32,
    }
    @group(0) @binding(0) var<uniform> taaData: TAAData;
    @group(0) @binding(1) var inTex : texture_2d<f32>;
    @group(0) @binding(2) var outTex : texture_storage_2d<rgba16float, write>;

    var<private> texSize: vec2<u32>;
    var<private> fragCoord: vec2<i32>;

    @compute @workgroup_size( 8 , 8 , 1 )
    fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
    {
      fragCoord = vec2<i32>( globalInvocation_id.xy );
      texSize = textureDimensions(outTex).xy;
      if(fragCoord.x >= i32(texSize.x) || fragCoord.y >= i32(texSize.y)){
          return;
      }
      
      let c0 = textureLoad(inTex, vec2<i32>(fragCoord.x, fragCoord.y - 1), 0);
      let c1 = textureLoad(inTex, vec2<i32>(fragCoord.x, fragCoord.y + 1), 0);
      let c2 = textureLoad(inTex, vec2<i32>(fragCoord.x - 1, fragCoord.y), 0);
      let c3 = textureLoad(inTex, vec2<i32>(fragCoord.x + 1, fragCoord.y), 0);
      
      var roundColor = (c0 + c1 + c2 + c3) * 0.25;
      let originColor = textureLoad(inTex, fragCoord, 0);
      let blurColor = mix(roundColor, originColor, taaData.sharpPreBlurFactor);
      var oc = (originColor - blurColor * taaData.sharpFactor) / (1.0 - taaData.sharpFactor);
      oc = clamp(oc, vec4<f32>(0.0), oc);
      textureStore(outTex, fragCoord , oc);
    }
`,lc=`
#include "GlobalUniform"

struct TAAData{
  preProjMatrix: mat4x4<f32>,
  preViewMatrix: mat4x4<f32>,
  jitterFrameIndex: f32,
  blendFactor: f32,
  sharpFactor: f32,
  sharpPreBlurFactor: f32,
  jitterX: f32,
  jitterY: f32,
  slot0: f32,
  slot1: f32,
}

@group(0) @binding(0) var<uniform> standUniform: GlobalUniform;
@group(0) @binding(1) var<uniform> taaData: TAAData;
@group(0) @binding(2) var<storage, read_write> preColorBuffer : array<vec4<f32>>;

@group(0) @binding(3) var preColorTexSampler : sampler;
@group(0) @binding(4) var preColorTex : texture_2d<f32>;
@group(0) @binding(5) var posTex : texture_2d<f32>;
@group(0) @binding(6) var inTexSampler : sampler;
@group(0) @binding(7) var inTex : texture_2d<f32>;
@group(0) @binding(8) var outTex : texture_storage_2d<rgba16float, write>;

var<private> texSize: vec2<u32>;
var<private> fragCoord: vec2<i32>;
var<private> coordIndex: i32;
var<private> color_min: vec4<f32>;
var<private> color_max: vec4<f32>;
var<private> color_avg: vec4<f32>;
var<private> re_proj_uv01: vec2<f32>;
var<private> FLT_EPS:f32 = 5.960464478e-8;  // 2^-24, machine epsilon: 1 + EPS = 1 (half of the ULP for 1.0f)

@compute @workgroup_size( 8 , 8 , 1 )
fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
{
  fragCoord = vec2<i32>( globalInvocation_id.xy );
  texSize = textureDimensions(inTex).xy;
  if(fragCoord.x >= i32(texSize.x) || fragCoord.y >= i32(texSize.y)){
      return;
  }
  let frame = standUniform.frame;
  coordIndex = fragCoord.x + fragCoord.y * i32(texSize.x);
  
  let oc = blendColor();
  preColorBuffer[coordIndex] = oc;
  textureStore(outTex, fragCoord , oc);
}

fn blendColor() -> vec4<f32>
{
  var preCoord = fragCoord;
  var mixWeight = 1.0;
  re_proj_uv01 = vec2<f32>(0.0);
  var reProjectionCoord:vec2<f32> = vec2<f32>(fragCoord);
  //var jitterUVOffset = 0.5 * vec2<f32>(taaData.jitterX, -taaData.jitterY);
  if(taaData.jitterFrameIndex > 0.5){
      var wPos = textureLoad(posTex, fragCoord, 0);
      let ndc = taaData.preProjMatrix * (taaData.preViewMatrix * vec4<f32>(wPos.xyz, 1.0));
      re_proj_uv01 = vec2<f32>(ndc.x, -ndc.y) / ndc.w;
      re_proj_uv01 = (re_proj_uv01 + 1.0) * 0.5;
      
      if(re_proj_uv01.x >= 0.0 && re_proj_uv01.x <= 1.0 && re_proj_uv01.y >= 0.0 && re_proj_uv01.y <= 1.0){
          mixWeight = taaData.blendFactor;
          //reProjectionCoord = re_proj_uv01 + jitterUVOffset;
          reProjectionCoord.x = re_proj_uv01.x * f32(texSize.x - 1);
          reProjectionCoord.y = re_proj_uv01.y * f32(texSize.y - 1);
          preCoord = vec2<i32>(reProjectionCoord);
      }else{ 
          //outside of screen
          mixWeight = 1.0;
      }
  }
  
  var curUV01 = vec2<f32>(fragCoord) / vec2<f32>(texSize - 1);
  //curUV01 += jitterUVOffset;
  
  let curColor = textureSampleLevel(inTex, inTexSampler, curUV01, 0.0);
  
  let preIndex = preCoord.x + preCoord.y * i32(texSize.x);
  var preColor = textureSampleLevel(preColorTex, preColorTexSampler, re_proj_uv01, 0.0);
  
  //minmax9(fragCoord);
  minmax4(fragCoord);
  
  preColor = clip_aabb(color_min.xyz, color_max.xyz, color_avg, preColor);
  var outColor = mix(preColor, curColor, mixWeight);

  return outColor;
}

fn clampCoord(coord0:vec2<i32>) -> vec2<i32>{
  return clamp(coord0, vec2<i32>(0), vec2<i32>(texSize - 1));
}

fn minmax4(coord:vec2<i32>) {
      let uv0 = clampCoord(vec2<i32>(coord.x - 1, coord.y));
      let uv1 = clampCoord(vec2<i32>(coord.x, coord.y - 1));
      let uv2 = clampCoord(vec2<i32>(coord.x, coord.y + 1));
      let uv3 = clampCoord(vec2<i32>(coord.x + 1, coord.y));
      
      let c0 = textureLoad(inTex, uv0, 0);
      let c1 = textureLoad(inTex, uv1, 0);
      let c2 = textureLoad(inTex, uv2, 0);
      let c3 = textureLoad(inTex, uv3, 0);
      
      color_min = min(c0, min(c1, min(c2, c3)));
      color_max = max(c0, max(c1, max(c2, c3)));
      color_avg = (c0 + c1 + c2 + c3) * 0.25;
  }
  
 fn minmax9(coord:vec2<i32>) {
      let uv0 = clampCoord(vec2<i32>(coord.x - 1, coord.y - 1));
      let uv1 = clampCoord(vec2<i32>(coord.x - 1, coord.y));
      let uv2 = clampCoord(vec2<i32>(coord.x - 1, coord.y + 1));
      let uv3 = clampCoord(vec2<i32>(coord.x, coord.y - 1));
      let uv4 = clampCoord(vec2<i32>(coord.x, coord.y));
      let uv5 = clampCoord(vec2<i32>(coord.x, coord.y + 1));
      let uv6 = clampCoord(vec2<i32>(coord.x + 1, coord.y - 1));
      let uv7 = clampCoord(vec2<i32>(coord.x + 1, coord.y));
      let uv8 = clampCoord(vec2<i32>(coord.x + 1, coord.y + 1));
      
      let ctl = textureLoad(inTex, uv0, 0);
      let ctc = textureLoad(inTex, uv1, 0);
      let ctr = textureLoad(inTex, uv2, 0);
      let cml = textureLoad(inTex, uv3, 0);
      let cmc = textureLoad(inTex, uv4, 0);
      let cmr = textureLoad(inTex, uv5, 0);
      let cbl = textureLoad(inTex, uv6, 0);
      let cbc = textureLoad(inTex, uv7, 0);
      let cbr = textureLoad(inTex, uv8, 0);
      
      color_min = min(ctl, min(ctc, min(ctr, min(cml, min(cmc, min(cmr, min(cbl, min(cbc, cbr))))))));
      color_max = max(ctl, max(ctc, max(ctr, max(cml, max(cmc, max(cmr, max(cbl, max(cbc, cbr))))))));
      color_avg = (ctl + ctc + ctr + cml + cmc + cmr + cbl + cbc + cbr) / 9.0;
  }
  
  fn clip_aabb(aabb_max:vec3<f32>, aabb_min:vec3<f32>, color_avg:vec4<f32>, input_texel:vec4<f32>) -> vec4<f32>
  {
      var p_clip:vec3<f32> = 0.5 * (aabb_max + aabb_min);
      var e_clip:vec3<f32> = 0.5 * (aabb_max - aabb_min) + FLT_EPS;
      var v_clip:vec4<f32> = input_texel - vec4<f32>(p_clip, color_avg.w);
      var v_unit:vec3<f32> = v_clip.xyz / e_clip;
      var a_unit:vec3<f32> = abs(v_unit);
      var ma_unit:f32 = max(a_unit.x, max(a_unit.y, a_unit.z));

      if (ma_unit > 1.0){
          return vec4<f32>(p_clip, color_avg.w) + v_clip / ma_unit;
      }else{
          return input_texel;
      }
  }`,hc=`
#include "WorldMatrixUniform"
#include "GlobalUniform"

struct VertexOutput {
    @location(0) fragUV: vec2<f32>,
    @builtin(position) member: vec4<f32>
};

#if USE_MORPHTARGETS
    ${Re.getMorphTargetShaderBinding(2,1)}
#endif

#if USE_SKELETON
    ${Er.groupBindingAndFunctions(2,1)} 
#endif

var<private> worldMatrix: mat4x4<f32>;

struct VertexAttributes{
  @builtin(instance_index) index : u32,
  @location(0) position: vec3<f32>,
  @location(1) normal: vec3<f32>,
  @location(2) uv: vec2<f32>,
  @location(3) TEXCOORD_1: vec2<f32>,

  #if USE_TANGENT
      @location(4) TANGENT: vec4<f32>,
      #if USE_SKELETON
          @location(5) joints0: vec4<f32>,
          @location(6) weights0: vec4<f32>,
          #if USE_JOINT_VEC8
          @location(7) joints1: vec4<f32>,
          @location(8) weights1: vec4<f32>,
      #endif
      #elseif USE_MORPHTARGETS
          ${Re.getMorphTargetAttr(5)}
      #endif
  #elseif USE_SKELETON
      @location(4) joints0: vec4<f32>,
      @location(5) weights0: vec4<f32>,
      #if USE_JOINT_VEC8
      @location(6) joints1: vec4<f32>,
      @location(7) weights1: vec4<f32>,
      #endif
  #elseif USE_MORPHTARGETS
     ${Re.getMorphTargetAttr(4)}
  #endif
}



@vertex
fn main(vertex:VertexAttributes) -> VertexOutput {
    worldMatrix = models.matrix[vertex.index];
    let shadowMatrix: mat4x4<f32> = globalUniform.projMat * globalUniform.viewMat ;
    var vertexPosition = vertex.position.xyz;
    var vertexNormal = vertex.normal.xyz;

    #if USE_MORPHTARGETS
     ${Re.getMorphTargetCalcVertex()}    
    #endif

    #if USE_SKELETON
        #if USE_JOINT_VEC8
          worldMatrix *= getSkeletonWorldMatrix_8(vertex.joints0, vertex.weights0, vertex.joints1, vertex.weights1);
        #else
          worldMatrix *= getSkeletonWorldMatrix_4(vertex.joints0, vertex.weights0);
        #endif
    #endif

    var worldPos = worldMatrix * vec4<f32>(vertexPosition, 1.0) ;
    var vPos = shadowMatrix * worldPos;

    return VertexOutput(vertex.uv, vPos );  
}
`,uc=`
#include "WorldMatrixUniform"
#include "GlobalUniform"

struct VertexOutput {
    @location(0) fragUV: vec2<f32>,
    @location(1) worldPos: vec3<f32>,
    @builtin(position) member: vec4<f32>
};

#if USE_MORPHTARGETS
    ${Re.getMorphTargetShaderBinding(2,1)}
##endif
 
#if USE_SKELETON
    ${Er.groupBindingAndFunctions(2,1)} 
#endif

var<private> worldMatrix: mat4x4<f32>;

struct VertexAttributes{
  @builtin(instance_index) index : u32,
  @location(0) position: vec3<f32>,
  @location(1) normal: vec3<f32>,
  @location(2) uv: vec2<f32>,
  @location(3) TEXCOORD_1: vec2<f32>,

  #if USE_TANGENT
      @location(4) TANGENT: vec4<f32>,
      #if USE_SKELETON
          @location(5) joints0: vec4<f32>,
          @location(6) weights0: vec4<f32>,
          #if USE_JOINT_VEC8
          @location(7) joints1: vec4<f32>,
          @location(8) weights1: vec4<f32>,
      #endif
      #elseif USE_MORPHTARGETS
         ${Re.getMorphTargetAttr(5)}
      #endif
  #elseif USE_SKELETON
      @location(4) joints0: vec4<f32>,
      @location(5) weights0: vec4<f32>,
      #if USE_JOINT_VEC8
      @location(6) joints1: vec4<f32>,
      @location(7) weights1: vec4<f32>,
      #endif
  #elseif USE_MORPHTARGETS
      ${Re.getMorphTargetAttr(4)}
  #endif
}

@vertex
fn main(vertex:VertexAttributes) -> VertexOutput {
    worldMatrix = models.matrix[vertex.index];
    let shadowMatrix: mat4x4<f32> = globalUniform.projMat * globalUniform.viewMat ;
    var vertexPosition = vertex.position.xyz;

    #if USE_MORPHTARGETS
        ${Re.getMorphTargetCalcVertex()}
    #endif

    #if USE_SKELETON
        #if USE_JOINT_VEC8
          worldMatrix *= getSkeletonWorldMatrix_8(vertex.joints0, vertex.weights0, vertex.joints1, vertex.weights1);
        #else
          worldMatrix *= getSkeletonWorldMatrix_4(vertex.joints0, vertex.weights0);
        #endif
    #endif

    var worldPos = worldMatrix * vec4<f32>(vertexPosition, 1.0) ;
    var vPos = shadowMatrix * worldPos;
    return VertexOutput(vertex.uv, worldPos.xyz , vPos ); 
}
`,cc=`
    #if USE_ALPHACUT
      @group(1) @binding(0)
      var baseMapSampler: sampler;
      @group(1) @binding(1)
      var baseMap: texture_2d<f32>;
    #endif

    struct FragmentOutput {
      @location(0) o_Target: vec4<f32>,
      @builtin(frag_depth) out_depth: f32
    };

    struct MaterialUniform {
      lightWorldPos: vec3<f32>,
      cameraFar: f32,
    };

    @group(2) @binding(0)
    var<uniform> materialUniform: MaterialUniform;

    @fragment
    fn main(@location(0) fragUV: vec2<f32> , @location(1) worldPos:vec3<f32> ) -> FragmentOutput {
        var distance = length(worldPos.xyz - materialUniform.lightWorldPos ) ;
        distance = distance / materialUniform.cameraFar ;
        var fragOut:FragmentOutput; 

      #if USE_ALPHACUT
        let Albedo = textureSample(baseMap,baseMapSampler,fragUV);
        if(Albedo.w > 0.5){
          fragOut = FragmentOutput(vec4<f32>(0.0),distance);
        }
      #else
        fragOut = FragmentOutput(vec4<f32>(0.0),distance);
      #endif
      
        return fragOut ;
    }
`,fc=`
    #if USE_ALPHACUT
      @group(1) @binding(0)
      var baseMapSampler: sampler;
      @group(1) @binding(1)
      var baseMap: texture_2d<f32>;
    #endif

    struct FragmentOutput {
      @location(0) o_Target: vec4<f32>,
      @builtin(frag_depth) out_depth: f32
    };

    struct MaterialUniform {
      lightWorldPos: vec3<f32>,
      cameraFar: f32,
    };

    @group(2) @binding(0)
    var<uniform> materialUniform: MaterialUniform;

    @fragment
    fn main(@location(0) fragUV: vec2<f32> , @location(1) clipPos:vec3<f32> ) -> FragmentOutput {
        // var distance = length(worldPos.xyz - materialUniform.lightWorldPos ) ;
        // distance = distance / materialUniform.cameraFar ;
        var fragOut:FragmentOutput; 

      // #if USE_ALPHACUT
      //   let Albedo = textureSample(baseMap,baseMapSampler,fragUV);
      //   if(Albedo.w > 0.5){
      //     fragOut = FragmentOutput(vec4<f32>(0.0),distance);
      //   }
      // #else
      //   fragOut = FragmentOutput(vec4<f32>(0.0),distance);
      // #endif
      
        return fragOut ;
    }
`,Xg=`
#include "GlobalUniform"

struct RenderBound{
    index:f32,
}

struct Uniforms {
    matrix : array<mat4x4<f32>>
};

//@group(0) @binding(0) var<uniform> globalUniform: GlobalUniform;
@group(0) @binding(1) var<storage, read> models : Uniforms;
@group(0) @binding(2) var<storage, read> planes: array<vec4<f32>,7>;
@group(0) @binding(3) var<storage, read> cullingList: array<RenderBound>;
@group(0) @binding(4) var<storage,read_write> outBuffer: array<f32>;


var<private> boundPoints : array<vec4<f32>,8> ;   

fn IsInClipSpace( coord : vec4<f32> ) -> bool {
    return -coord.w <= coord.x && coord.x <= coord.w
        && -coord.w <= coord.y && coord.y <= coord.w
        && -coord.w <= coord.z && coord.z <= coord.w;
}

fn IsOutsideThePlane( plane: vec4<f32>, pointPosition : vec3<f32> ) -> bool{
    if(dot(plane.xyz, pointPosition) + plane.w > 0.0){
        return true;
    }
    return false;
}

fn containsBox( size:vec3<f32> , center:vec3<f32> ) -> f32 {
    var c = 0.0 ;
    var d = 0.0 ;

    var r = max(size.x, size.y);
    var sr = max(r , size.z);
    var scx = center.x;
    var scy = center.y;
    var scz = center.z;

    for(var p:i32 = 0; p < 6 ; p = p + 1 ){
        var plane = planes[p];
        d = plane.x * scx + plane.y * scy + plane.z * scz + plane.w;
        if (d <= -sr) {
        return 0.0;
        }
        if (d > sr) {
        c+=1.0;
        }
    }

    if( c >= 6.0 ){
        return 2.0 ;
    }else{
        return 1.0 ;
    }
}

@compute @workgroup_size( 128 )
fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
{
    let id = globalInvocation_id.x ;
    if(id + 1u > u32(planes[6].x) ){
        outBuffer[id] = f32(0.0); 
        return ;
    }

    let renderBound = cullingList[id];
    let boundID = i32(renderBound.index) ;
    var plane = planes[0];

    let worldMatrix = models.matrix[boundID];
    let projMat = globalUniform.projMat ;

    let const_boundMin : vec3<f32> = vec3<f32>(-0.5,-0.5,-0.5) ;   
    let const_boundMax : vec3<f32> = vec3<f32>(0.5,0.5,0.5) ;   

    let boundMin = worldMatrix * vec4<f32>(const_boundMin, 1.0);
    let boundMax = worldMatrix * vec4<f32>(const_boundMax, 1.0);

    let size = abs( boundMax.xyz - boundMin.xyz ) * 0.65 ;
    let center = worldMatrix[3].xyz ;

    var isIn :f32 = 0.0 ;

    isIn = containsBox(size,center);

    outBuffer[id] = f32(isIn); 
}
`,Ln=`
#include "Common_vert"
#include "FragmentVarying"
#include "GlobalUniform"

struct FragmentOutput {
    @location(0) o_Position: vec4<f32>,
    @location(1) o_Normal: vec4<f32>,
    @location(2) o_Color: vec4<f32>
};

struct MaterialUniform {
    baseColor: vec4<f32>,
    emissiveColor: vec4<f32>,
    emissiveIntensity: f32,
    normalScale: f32,
    alphaCutoff: f32
};

@group(2) @binding(0)
var<uniform> materialUniform: MaterialUniform;

@group(1) @binding(auto)
var baseMapSampler: sampler;
@group(1) @binding(auto)
var baseMap: texture_2d<f32>;

@group(1) @binding(auto)
var normalMapSampler: sampler;
@group(1) @binding(auto)
var normalMap: texture_2d<f32>;

@group(1) @binding(auto)
var emissiveMapSampler: sampler;
@group(1) @binding(auto)
var emissiveMap: texture_2d<f32>;

fn vert(inputData:VertexAttributes) -> VertexOutput {
    ORI_Vert(inputData) ;
    return ORI_VertexOut ;
}

var<private> ORI_FragmentOutput: FragmentOutput;
var<private> ORI_VertexVarying: FragmentVarying;

@fragment
fn FragMain(vertex_varying:FragmentVarying) -> FragmentOutput {
    ORI_VertexVarying = vertex_varying;
    var texColor = textureSample(baseMap, baseMapSampler, ORI_VertexVarying.fragUV0.xy );

    var emissive = textureSample(emissiveMap, emissiveMapSampler, ORI_VertexVarying.fragUV0.xy ).rgb ;
    let intensity = materialUniform.emissiveIntensity * materialUniform.emissiveColor.a ;
    emissive = emissive.rgb * materialUniform.emissiveColor.rgb ;
    emissive = convertToHDRRGB(emissive,intensity);

    if (materialUniform.alphaCutoff-texColor.w > 0.0) {
        discard ;
    }

    var o_Position = vec4<f32>(ORI_VertexVarying.vWorldPos.xyz,emissive.r) ;
    var o_Normal = vec4<f32>((ORI_VertexVarying.vWorldNormal.xyz * 0.5 + 0.5 ),emissive.g) ;
    var o_Color = vec4<f32>((texColor * materialUniform.baseColor).rgb , emissive.b )  ;
    return FragmentOutput(o_Position,o_Normal,vec4<f32>(o_Color));
}

fn convertToHDRRGB( color : vec3<f32> , ins:f32 ) -> vec3<f32> {
    var hdrColor = vec3<f32>(0.0,0.0,0.0);
    hdrColor.r = color.r * pow(2.4, ins);
    hdrColor.g = color.g * pow(2.4, ins);
    hdrColor.b = color.b * pow(2.4, ins);
    return hdrColor;
}
`,dc=`
#include "GlobalUniform"

struct uniformData {
    exposure: f32,
    roughness: f32
};

struct FragmentOutput {
    @location(0) o_Position: vec4<f32>,
    @location(1) o_Normal: vec4<f32>,
    @location(2) o_Color: vec4<f32>
};

@group(1) @binding(4)
var baseMapSampler: sampler;
@group(1) @binding(5)
var baseMap: texture_cube<f32>;

@group(2) @binding(0)
var<uniform> global: uniformData;

fn LinearToGammaSpace(linRGB: vec3<f32>) -> vec3<f32> {
    var linRGB1: vec3<f32>;
    linRGB1 = linRGB;
    linRGB1 = max(linRGB1, vec3<f32>(0.0, 0.0, 0.0));
    linRGB1.x = pow(linRGB1.x, 0.4166666567325592);
    linRGB1.y = pow(linRGB1.y, 0.4166666567325592);
    linRGB1.z = pow(linRGB1.z, 0.4166666567325592);
    return max(((1.0549999475479126 * linRGB1) - vec3<f32>(0.054999999701976776)), vec3<f32>(0.0));
}

@fragment
fn main(@location(0) fragUV: vec2<f32>, @location(1) vWorldPos: vec4<f32>, @location(2) vWorldNormal: vec3<f32>) -> FragmentOutput {
    let maxLevel: u32 = textureNumLevels(baseMap);
    let textureColor:vec3<f32> = textureSampleLevel(baseMap, baseMapSampler, normalize(vWorldPos.xyz), global.roughness * f32(maxLevel) ).xyz;
    let o_Color = 0.618 * vec4<f32>(LinearToGammaSpace(textureColor) * globalUniform.skyExposure , 1.0);
    let o_Normal = vec4(vWorldNormal,1.0) ;
    let o_Position = vec4<f32>(vWorldPos.xyz,100000.0) ;
    return FragmentOutput(o_Position,o_Normal,o_Color);
}
`,gc=`
    @group(0) @binding(0) var<storage,read_write> visibleBuffer: array<f32>;
    @group(0) @binding(1) var zBufferTexture : texture_2d<f32>;

    @compute @workgroup_size(8, 8, 1)
    fn CsMain( @builtin(global_invocation_id) globalInvocation_id : vec3<u32> ) {
        var fragCoord = vec2<i32>( globalInvocation_id.xy );
        let md = textureLoad(zBufferTexture,fragCoord,0);

        let meshID = i32(floor( md.w + 0.1 ));
        if (meshID >= 0) {
            visibleBuffer[meshID] = 1.0 ;
        }
    }
`,pc=`
    #include "GlobalUniform"
    #include "MathShader"
    struct FragmentOutput {
        @location(0) o_Target: vec4<f32>,
        @builtin(frag_depth) out_depth: f32
    };
   

    @fragment
    fn main(@location(0) vID: f32, @location(1) vPos:vec3<f32> ,  @location(2) vClipPos: vec4<f32> ,  @builtin(position) fragCoord : vec4<f32>) -> FragmentOutput {
        var op = vec4<f32>( vPos, vID);
        let d = log2Depth(fragCoord.z+0.00001,globalUniform.near,globalUniform.far);
        return FragmentOutput(op,d);
    }
`,mc=`
    #include "GlobalUniform"
    #include "MathShader"
    struct VertexOutput {
        @location(0) vID: f32 ,
        @location(1) vPos: vec3<f32> ,
        @location(2) vClipPos: vec4<f32> ,
        @builtin(position) member: vec4<f32>
    };

    struct Uniforms {
        matrix : array<mat4x4<f32>>
    };

    @group(0) @binding(1)
    var<storage, read> models : Uniforms;

    var<private> worldMatrix: mat4x4<f32>;

    #if USE_MORPHTARGETS
        ${Re.getMorphTargetShaderBinding(1,0)}
    #endif

    #if USE_SKELETON
        ${Er.groupBindingAndFunctions(1,0)}
    #endif

    @vertex
    fn main(
        @builtin(instance_index) index : u32,
        @location(0) position: vec3<f32>,
        @location(1) normal: vec3<f32>,
        @location(2) uv: vec2<f32>,
        @location(3) TEXCOORD_1: vec2<f32>,

    #if USE_TANGENT
        @location(4) TANGENT: vec4<f32>,
        #if USE_SKELETON
            @location(5) joints0: vec4<f32>,
            @location(6) weights0: vec4<f32>,
            #if USE_JOINT_VEC8
                @location(7) joints1: vec4<f32>,
                @location(8) weights1: vec4<f32>,
            #endif
        #elseif USE_MORPHTARGETS
            ${Re.getMorphTargetAttr(5)}
        #endif
    #elseif USE_SKELETON
        @location(4) joints0: vec4<f32>,
        @location(5) weights0: vec4<f32>,
        #if USE_JOINT_VEC8
            @location(6) joints1: vec4<f32>,
            @location(7) weights1: vec4<f32>,
        #endif
    #elseif USE_MORPHTARGETS
        ${Re.getMorphTargetAttr(4)}
    #endif
    ) -> VertexOutput {
    worldMatrix = models.matrix[index];

    var vertexPosition = position;
    var vertexNormal = normal;
    #if USE_MORPHTARGETS
        ${Re.getMorphTargetCalcVertex()}
    #endif

    #if USE_SKELETON
        #if USE_JOINT_VEC8
            worldMatrix *= getSkeletonWorldMatrix_8(joints0, weights0, joints1, weights1);
        #else
            worldMatrix *= getSkeletonWorldMatrix_4(joints0, weights0);
        #endif
    #endif

        
        let wPos = worldMatrix * vec4<f32>(vertexPosition.xyz, 1.0);
        var fixProjMat = globalUniform.projMat ;
        var rzMatrix : mat4x4<f32> ;
        rzMatrix[0] = vec4<f32>(1.0,0.0,0.0,0.0) ; 
        rzMatrix[1] = vec4<f32>(0.0,1.0,0.0,0.0) ; 
        rzMatrix[2] = vec4<f32>(0.0,0.0,1.0,0.0) ; 
        rzMatrix[3] = vec4<f32>(0.0,0.0,0.0,1.0) ; 
        var clipPos:vec4<f32> = fixProjMat * globalUniform.viewMat * (wPos) ;

        // let d = log2Depth(clipPos.z * (globalUniform.far - globalUniform.near),globalUniform.near,globalUniform.far) ;
        return VertexOutput(f32(index) , wPos.xyz,clipPos, clipPos);
    }

    fn depthToLinear01(depth:f32) -> f32 {
        let a = 1.0 / (globalUniform.near - globalUniform.far);
        return (globalUniform.near*globalUniform.far*a) / (depth + globalUniform.far * a) ;
    }
`,Ac=`
    struct LightData {
        index:f32,
        lightType:i32,
        radius:f32,
        linear:f32,
        
        position:vec3<f32>,
        lightMatrixIndex:f32,

        direction:vec3<f32>,
        quadratic:f32,

        lightColor:vec3<f32>,
        intensity:f32,

        innerCutOff :f32,
        outerCutOff:f32,
        range :f32,
        castShadow:i32,

        lightTangent:vec3<f32>,
        ies:f32,
    };

    const PointLightType = 1;
    const DirectLightType = 2;
    const SpotLightType = 3;

    struct ClusterBox {
        minPoint:vec4<f32>,
        maxPoint:vec4<f32>
    };

    struct LightIndex {
            count:f32,
            start:f32,
            empty0:f32,
            empty1:f32,
    };

    struct ClustersUniform {
        clusterTileX:f32,
        clusterTileY:f32,
        clusterTileZ:f32,
        numLights:f32,
        maxNumLightsPerCluster:f32,
        near:f32,
        far:f32,
        screenWidth:f32,
        screenHeight:f32,
        clusterPix:f32, 
    };

    @group(2) @binding(1)
    var<storage,read> lightBuffer: array<LightData>;
    @group(2) @binding(2)
    var<uniform> clustersUniform : ClustersUniform;
    @group(2) @binding(3)
    var<storage,read> lightAssignBuffer : array<f32>;
    @group(2) @binding(4)
    var<storage,read> assignTable : array<LightIndex>;
    #if DEBUG_CLUSTER
        @group(2) @binding(5)
        var<storage,read> clusterBuffer : array<ClusterBox>;
    #endif

    fn getLight( index:i32 ) -> LightData {
        let lightId = i32(lightAssignBuffer[index]);
        var lightData = lightBuffer[lightId];
        return lightData ;
    }

    fn linearTo01Depth(depth : f32) -> f32 {
        return (globalUniform.far ) * globalUniform.near / fma(depth, globalUniform.near-globalUniform.far, globalUniform.far);
    }

    fn getClusterId3() -> vec3<u32> {
        let z = linearTo01Depth(ORI_VertexVarying.fragCoord.z) ; 

        let sliceScale = f32(clustersUniform.clusterTileZ) / log2(globalUniform.far / globalUniform.near);
        let sliceBias = -(f32(clustersUniform.clusterTileZ) * log2(globalUniform.near) / log2(globalUniform.far / globalUniform.near));
        let zTile = u32(max(log2(z) * sliceScale + sliceBias, 0.0));

        var screenUV = ORI_VertexVarying.fragCoord.xy / vec2<f32>( globalUniform.windowWidth , globalUniform.windowHeight );
        let i = u32(floor(screenUV.x * clustersUniform.clusterTileX)) ;
        let j = u32(floor(screenUV.y * clustersUniform.clusterTileY) );

        return vec3<u32>(i,j,zTile);
    }

    fn getCluster() -> LightIndex {
        let tile = getClusterId3();
        let id = tile.x +
            tile.y * u32(clustersUniform.clusterTileX) +
            tile.z * u32(clustersUniform.clusterTileX) * u32(clustersUniform.clusterTileY);
        return assignTable[id];
    }

    fn getClusterIndex() -> u32 {
        let tile = getClusterId3();
        let id = tile.x +
            tile.y * u32(clustersUniform.clusterTileX) +
            tile.z * u32(clustersUniform.clusterTileX) * u32(clustersUniform.clusterTileY);
        return id;
    }
`,_c=`
    #include "WorldMatrixUniform"
    #include "GlobalUniform"

    struct VertexOutput {
        @location(0) fragUV: vec2<f32>,
            @builtin(position) member: vec4<f32>
    };

    @vertex
    fn main(@builtin(instance_index) index : u32, @location(0) position: vec3<f32>, @location(1) TEXCOORD_1: vec2<f32>) -> VertexOutput {
        let id = u32(index);
        let worldMatrix = models.matrix[id];

        let screenPos = vec2(((TEXCOORD_1 * 2.0) - vec2<f32>(1.0))) * 0.5 ; 
        return VertexOutput(TEXCOORD_1, vec4<f32>(screenPos, 0.0, 1.0));
    }
`,vc=`
#version 450

layout(location = 0) in vec2 fragUV;

layout(location = 0) out vec4 o_Target;

layout(set = 0, binding = 0) uniform ConstUniform {
    mat4 projMat;
    mat4 viewMat;
    mat4 shadowMatrix;
    mat4 cameraWorldMatrix;
    mat4 pvMatrixInv;
    float frame;
    float time;
    float delta;
    float shadowBias;
    float skyExposure;
    float renderPassState;
    float quadScale;

};

layout(set = 2, binding = 0) uniform sampler baseMapSampler;
layout(set = 2, binding = 1) uniform texture2D baseMap;
layout(set = 3, binding = 0) uniform MaterialDataUniform {
    vec4 color;
};

void main() {
        vec2 uv = fragUV.xy;
    uv.y = 1.0 - uv.y;
        vec4 colorTexture = texture(sampler2D(baseMap, baseMapSampler), uv * quadScale) * color;
    o_Target = vec4(colorTexture.rgb, colorTexture.a);

    if (o_Target.r <= 0.5 && o_Target.g <= 0.5 && o_Target.b <= 0.5) {
        discard;
    }
    // float gamma     = 2.2;
    // float exposure  = 1.0;
    // float pureWhite = 1.0;

    // float luminance = dot(colorTexture.rgb, vec3(0.2126, 0.7152, 0.0722));
    // float mappedLuminance = (luminance * (1.0 + luminance/(pureWhite*pureWhite))) / (1.0 + luminance);

    // // Scale color by ratio of average luminances.
    // vec3 mappedColor = (mappedLuminance / luminance) * colorTexture.rgb;

    // // Gamma correction.
    // o_Target = vec4(pow(o_Target.rgb, vec3(1.0/gamma)), 1.0);
};
`,Wg=`
#version 450
layout(location = 0) in vec3 position;
layout(location = 1) in vec3 normal;
layout(location = 2) in vec2 uv;

layout(location = 0) out vec2 fragUV;
layout(location = 1) out vec4 vWorldPos;
layout(location = 2) out vec3 vWorldNormal;

layout(set = 0, binding = 0) 
uniform ConstUniform {
    mat4 projMat;
    mat4 viewMat;
    mat4 shadowMatrix;
};

layout(set = 1, binding = 0) 
buffer Uniforms {
    mat4[] modeMat;
};

 mat4 inverse( in mat4 m ){
    return mat4(
        m[0][0], m[1][0], m[2][0], 0.0,
        m[0][1], m[1][1], m[2][1], 0.0,
        m[0][2], m[1][2], m[2][2], 0.0,
        -dot(m[0].xyz,m[3].xyz),
        -dot(m[1].xyz,m[3].xyz),
        -dot(m[2].xyz,m[3].xyz),
        1.0 );
}

void main(){
    fragUV = uv;
    mat4 modelMat = modeMat[gl_InstanceID]; 
    mat4 vm = viewMat * modelMat;
	mat3 normalMatrix = mat3(vm[0].xyz,vm[1].xyz,vm[2].xyz);
	vec3 eNormal = normalize( normalMatrix * normal );
    
    vWorldPos = modelMat * vec4(position.xyz,1.0) ;

    mat4 fixedViewMat = viewMat ;
    fixedViewMat[3] = vec4(0.0,0.0,-8.0,1.0);
    vec4 mvPosition = modelMat * vec4( position.xyz, 1.0 );
    gl_Position = projMat * fixedViewMat * mvPosition;
}

`,jg=`
#version 450

layout(location = 0) in vec2 fragUV;
layout(location = 1) in vec4 vWorldPos;
layout(location = 2) in vec3 vWorldNormal;

layout(location = 0) out vec4 o_Target;

layout(set = 2, binding = 0) 
uniform sampler baseMapSampler;
layout(set = 2, binding = 1) 
uniform texture2D baseMap;

layout(set = 3, binding = 0) uniform uniformData {
    vec3 eyesPos;
    float exposure;
    float roughness;
};

vec3 LinearToGammaSpace(in vec3 linRGB)
{
    vec3 _linRGB = vec3(linRGB) ;
    _linRGB = max(linRGB, vec3(0.0, 0.0, 0.0));
    _linRGB.r = pow(linRGB.r,0.416666667);
    _linRGB.g = pow(linRGB.g,0.416666667);
    _linRGB.b = pow(linRGB.b,0.416666667);
    return max(1.055 * _linRGB - 0.055, vec3(0.0));
}

void main(){
    int maxMipLevel = textureQueryLevels(baseMap, fragUV).x ;
    vec4 textureColor = textureCubeLod( sampler2D(baseMap, baseMapSampler), normalize(vWorldPos.xyz), roughness * float(maxMipLevel) ) ;
    o_Target = vec4(LinearToGammaSpace(textureColor.rgb),1.0) * exposure ;
}

`,qg=`
#version 450

layout(location = 0) in vec2 fragUV;

layout(location = 0) out vec4 o_Target;

layout(set = 0, binding = 0) uniform ConstUniform {
    mat4 projMat;
    mat4 viewMat;
    mat4 shadowMatrix;
    mat4 cameraWorldMatrix ;
    mat4 pvMatrixInv ;
    float frame;
    float time;
    float detail;
    float shadowBias;
    float skyExposure;
    float renderPassState;
    float quadScale;
    float intensity;
};

layout(set = 2, binding = 0) uniform sampler baseMapSampler;
layout(set = 2, binding = 1) uniform texture2D baseMap;

layout(set = 2, binding = 2) uniform sampler lutMapSample;
layout(set = 2, binding = 3) uniform texture2D lutMap;

layout(set = 3, binding = 0) uniform UniformData{
    float intensity ;
};

void main() {
    vec2 uv = fragUV.xy;
    uv.y = 1.0 - uv.y;
    vec4 col = texture(sampler2D(baseMap, baseMapSampler), uv * quadScale);
    // vec3 col = vec3(pow(base.xyz,vec3(1.0/2.2)));

    float Bcolor = col.b * 63.0;
	vec2 quad1;
    quad1.y = floor(floor(Bcolor) / 8.0);
    quad1.x = floor(Bcolor) - (quad1.y * 8.0);

    vec2 quad2;
    quad2.y = floor(ceil(Bcolor) / 8.0);
    quad2.x = ceil(Bcolor) - (quad2.y * 8.0);

    const float tmp = (0.125-(0.5/512.0)) ;
    const float tmp2 = 0.5/512.0 ;

    vec2 uv1;
    vec2 uv2;
	uv1.x = ((quad1.x)*0.125)+ tmp2 + (tmp* col.r);
	uv1.y = (((quad1.y)*0.125) + tmp2 + (tmp* col.g));

	uv2.x = ((quad2.x)*0.125)+ tmp2 + (tmp* col.r);
	uv2.y = (((quad2.y)*0.125)+ tmp2 + (tmp* col.g));

    vec4 color1 = texture(sampler2D(lutMap, lutMapSample), uv1);
    vec4 color2 = texture(sampler2D(lutMap, lutMapSample), uv2);

    vec4 newColor = mix(color1, color2, fract(Bcolor));
    // vec3 outC = pow(newColor.xyz,vec3(2.2));

    o_Target = vec4(newColor.rgb, col.a );
    // o_Target = vec4(1.0);
}
`;class Un{}n(Un,"Ori_AllShader",`
        #include "Common_vert"
        #include "Common_frag"
        #include "BxDF_frag"

        fn vert(inputData:VertexAttributes) -> VertexOutput {
            ORI_Vert(inputData) ;
            return ORI_VertexOut ;
        }

        fn frag(){
            ORI_ShadingInput.BaseColor = materialUniform.baseColor ;
            ORI_ShadingInput.Roughness = materialUniform.roughness  ;
            ORI_ShadingInput.Metallic = materialUniform.metallic ;
            ORI_ShadingInput.Specular = 0.5 ;
            ORI_ShadingInput.AmbientOcclusion = materialUniform.ao ;
            ORI_ShadingInput.EmissiveColor = vec4<f32>(0.0);

            ORI_ShadingInput.Normal = ORI_VertexVarying.vWorldNormal.rgb ;

            #if USE_SHADOWMAPING
                useShadow();
            #endif

            BxDFShading();
        }
    `);let xc=`
    #include "Common_vert"
    #include "Common_frag"
    #include "UnLit_frag"
    #include "Irradiance_frag"
    #include "MathShader"
    
    struct MaterialUniform {
      probeUniform:vec4<f32>,
    };

    @group(2) @binding(0)
    var<uniform> materialUniform: MaterialUniform;

    var<private> probeID: i32 ;
    var<private> debugType: i32 ;
    
    fn vert(inputData:VertexAttributes) -> VertexOutput {
        ORI_Vert(inputData) ;
        return ORI_VertexOut ;
    }

    fn frag(){
        probeID = i32(materialUniform.probeUniform.x);
        debugType = i32(materialUniform.probeUniform.y);
        if(debugType == 0){
            ORI_ShadingInput.BaseColor = debugProbe(probeID);
        }else if(debugType == 1){
            ORI_ShadingInput.BaseColor = getIrradiance();
        }else if(debugType == 2){
            ORI_ShadingInput.BaseColor = debugProbeDepth(probeID);
        }
        UnLit();
    }
    `,yc=`
    #include "Common_vert"
    #include "Common_frag"
    #include "UnLit_frag"
    #include "UnLitMaterialUniform_frag"

    // @group(1) @binding(auto)
    // var noes_MapSampler: sampler;
    // @group(1) @binding(auto)
    // var noes_Map: texture_2d<f32>;

    @group(1) @binding(auto)
    var splitTexture_MapSampler: sampler;
    @group(1) @binding(auto)
    var splitTexture_Map: texture_2d<f32>;

    fn vert(inputData:VertexAttributes) -> VertexOutput {
        ORI_Vert(inputData) ;
        return ORI_VertexOut ;
    }

    fn frag(){
        var screenUV = ORI_VertexVarying.fragPosition.xy / ORI_VertexVarying.fragPosition.w;
        screenUV = (screenUV.xy + 1.0) * 0.5;
        screenUV.y = 1.0 - screenUV.y;

        screenUV.x = clamp(sin(screenUV.x * 1.0),0.0,1.0) ;
        screenUV.y = clamp(sin(screenUV.y * 1.0),0.0,1.0) ;
        // screenUV.y = cos(ORI_VertexVarying.fragPosition.y/7.15);

        let frameMap = textureSample(splitTexture_Map,splitTexture_MapSampler,screenUV);
        // let noesMap = textureSample(noes_Map,noes_MapSampler,screenUV);

        ORI_ShadingInput.BaseColor = vec4<f32>( frameMap.rgb , 1.0) ;
        UnLit();
    }
`,Cc=`
    #include "Common_vert"
    #include "Common_frag"
    #include "ClusterLight"
    #include "UnLit_frag"
    #include "UnLitMaterialUniform_frag"

    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_2d<f32>;

    fn vert(inputData:VertexAttributes) -> VertexOutput {
        ORI_Vert(inputData) ;
        return ORI_VertexOut ;
    }

    fn frag(){
        var transformUV1 = materialUniform.transformUV1;
        var transformUV2 = materialUniform.transformUV2;

        var uv = transformUV1.zw * ORI_VertexVarying.fragUV0 + transformUV1.xy; 
        let baseColor = textureSample(baseMap,baseMapSampler,uv) ;
        if(baseColor.w < 0.5){
            discard ;
        }

        var lightColor = vec4<f32>(0.0);
        let lightIndex = getCluster();
        let start = max(lightIndex.start, 0.0);
        let count = max(lightIndex.count, 0.0);
        let end = max(start + count , 0.0);
        for(var i:i32 = i32(start) ; i < i32(end); i += 1 )
        {
          let light = getLight(i32(i));
  
          switch (light.lightType) {
            case PointLightType: {
            }
            case DirectLightType: {
                var normal = ORI_VertexVarying.vWorldNormal ;
                let intensity = (light.intensity/10.0);
                let att = max(dot(normal,-light.direction),0.0) * intensity ;
                lightColor += baseColor * att * 0.5 + baseColor * 0.5 ; 
                // lightColor = baseColor * 0.5; 
            }
            case SpotLightType: {
            }
            default: {
            }
          }
        }
        
        ORI_ShadingInput.BaseColor = lightColor * materialUniform.baseColor ;
        ORI_ShadingInput.BaseColor.w = 1.0 ;
        UnLit();

        // let n = globalUniform.near ;
        // let f = globalUniform.far ;
        // let z = ORI_VertexVarying.fragCoord.z ;
        // ORI_FragmentOutput.out_depth = z * (n/(f-n)) ;
    }
`,Kg=`
    #include "Common_vert"
    #include "Common_frag"
    #include "UnLit_frag"

    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_2d<f32>;


    struct MaterialUniform {
        baseColor:vec4<f32>,
        lineWeight:f32
    };

    @group(2) @binding(0)
    var<uniform> materialUniform: MaterialUniform;

    fn vert(vertex:VertexAttributes) -> VertexOutput {
        var vertexPosition = vertex.position;
        var vertexNormal = vertex.normal;

                #if USE_MORPHTARGETS
                    vertexPosition = vertexPosition * morphTargetData.morphBaseInfluence + vertex.a_morphPositions_0 * morphTargetData.morphInfluence0;
                    #if USE_MORPHNORMALS
                        vertexNormal = vertexNormal * morphTargetData.morphBaseInfluence + vertex.a_morphNormals_0 * morphTargetData.morphInfluence0;
                    #endif
                #endif

                #if USE_SKELETON
                    #if USE_JOINT_VEC8
                        let skeletonNormal = getSkeletonWorldMatrix_8(vertex.joints0, vertex.weights0, vertex.joints1, vertex.weights1);
                        ORI_MATRIX_M *= skeletonNormal ;
                        // vertexNormal = vec4<f32>(vec4<f32>(vertexNormal,0.0) * skeletonNormal).xyz; 
                    #else
                        let skeletonNormal = getSkeletonWorldMatrix_4(vertex.joints0, vertex.weights0);
                        ORI_MATRIX_M *= skeletonNormal ;
                        // vertexNormal = vec4<f32>(vec4<f32>(vertexNormal,0.0) * skeletonNormal).xyz; 
                    #endif
                #endif


                #if USE_TANGENT
                    ORI_VertexOut.varying_Tangent = vertex.TANGENT ;
                #endif

                ORI_NORMALMATRIX = transpose(inverse( mat3x3<f32>(ORI_MATRIX_M[0].xyz,ORI_MATRIX_M[1].xyz,ORI_MATRIX_M[2].xyz) ));

                let worldNormal = normalize(ORI_NORMALMATRIX * vertexNormal.xyz) ;

                vertexPosition = vertexPosition + worldNormal * materialUniform.lineWeight ;

                var worldPos = (ORI_MATRIX_M * vec4<f32>(vertexPosition.xyz, 1.0));
                var viewPosition = ORI_MATRIX_V * worldPos;
                var clipPosition = ORI_MATRIX_P * viewPosition ;

                ORI_VertexOut.varying_UV0 = vertex.uv.xy ;
                ORI_VertexOut.varying_UV1 = vertex.TEXCOORD_1.xy;
                ORI_VertexOut.varying_ViewPos = viewPosition / viewPosition.w;
                ORI_VertexOut.varying_Clip = clipPosition ;
                ORI_VertexOut.varying_WPos = worldPos ;
                ORI_VertexOut.varying_WPos.w = f32(vertex.index);
                ORI_VertexOut.varying_WNormal = worldNormal ;
                ORI_VertexOut.member = clipPosition ;


        return ORI_VertexOut ;
    }

    fn frag(){
        let color = textureSample(baseMap,baseMapSampler,ORI_VertexVarying.fragUV0) ;
        ORI_ShadingInput.BaseColor = color * materialUniform.baseColor ;
        ORI_ShadingInput.Roughness = 0.5  ;
        ORI_ShadingInput.Metallic = 0.5 ;
        ORI_ShadingInput.Specular = 0.5 ;
        ORI_ShadingInput.AmbientOcclusion = 1.0 ;
        ORI_ShadingInput.EmissiveColor = vec4<f32>(0.0);
        ORI_ShadingInput.Normal = ORI_VertexVarying.vWorldNormal.rgb ;
        UnLit();
    }
`,Jg=`
        #include "Common_vert"
        #include "Common_frag"
        #include "BxDF_frag"

        @group(1) @binding(auto)
        var rtColorTex: texture_2d<f32>;

        @group(1) @binding(auto)
        var baseMapSampler: sampler;
        @group(1) @binding(auto)
        var baseMap: texture_2d<f32>;

        @group(1) @binding(auto)
        var normalMapSampler: sampler;
        @group(1) @binding(auto)
        var normalMap: texture_2d<f32>;

        @group(1) @binding(auto)
        var displaceMapSampler: sampler;
        @group(1) @binding(auto)
        var displaceMap: texture_2d<f32>;

        @group(1) @binding(auto)
        var aoMapSampler: sampler;
        @group(1) @binding(auto)
        var aoMap: texture_2d<f32>;
 
        @group(1) @binding(auto)
        var reflectMapSampler: sampler;
        @group(1) @binding(auto)
        var reflectMap: texture_2d<f32>;

        fn vert(inputData:VertexAttributes) -> VertexOutput {
            ORI_Vert(inputData) ;
            // let displaceDimensions = textureDimensions(displaceMap) ;
            // let displace = textureGather(0,displaceMap,displaceMapSampler,inputData.uv) ;
            // ORI_VertexOut.member.y += displace.r * 10.0;
            return ORI_VertexOut ;
        }

        fn frag(){
            var screenUV = ORI_VertexVarying.fragPosition.xy / ORI_VertexVarying.fragPosition.w;
            screenUV = (screenUV.xy + 1.0) * 0.5;
            screenUV.y = 1.0 - screenUV.y;

            let FrameMap = textureSample(rtColorTex,baseMapSampler,screenUV);

            let Albedo = textureSample(baseMap,baseMapSampler,ORI_VertexVarying.fragUV0);
            var Normal = textureSample(normalMap,normalMapSampler,ORI_VertexVarying.fragUV0).rgb ;
            Normal.y = 1.0 - Normal.y ;
            let Displace = textureSample(displaceMap,displaceMapSampler,ORI_VertexVarying.fragUV0).rgb ;
            let Ao = textureSample(aoMap,aoMapSampler,ORI_VertexVarying.fragUV0).r ;
            let ReflectMap = 1.0 - textureSample(reflectMap,reflectMapSampler,ORI_VertexVarying.fragUV0).r ;

            ORI_ShadingInput.BaseColor = FrameMap * materialUniform.baseColor * vec4<f32>(LinearToGammaSpace(Albedo.rgb),1.0);
            ORI_ShadingInput.Roughness = ReflectMap * materialUniform.roughness  ;
            ORI_ShadingInput.Metallic = materialUniform.metallic ;
            ORI_ShadingInput.Specular = 0.5 ;
            ORI_ShadingInput.AmbientOcclusion = Ao * materialUniform.ao ;
            ORI_ShadingInput.EmissiveColor = vec4<f32>(0.0);

            let normal = unPackRGNormal(Normal,Displace.r*materialUniform.normalScale,1.0) ;
            ORI_ShadingInput.Normal = normal ;

            BxDFShading();
        }
    `,bc=`
        #include "Common_vert"
        #include "Common_frag"
        #include "UnLit_frag"

        @group(1) @binding(auto) var pointShadowMapSampler: sampler;
        @group(1) @binding(auto) var pointShadowMap: texture_depth_cube ;

        struct MaterialUniform {
            center: vec3<f32>,
        };
      
        @group(2) @binding(0)
        var<uniform> materialUniform: MaterialUniform;

        fn vert(inputData:VertexAttributes) -> VertexOutput {
            ORI_Vert(inputData) ;
            return ORI_VertexOut ;
        }
 
        fn frag(){

            var center = materialUniform.center ; 

            var dir = normalize(ORI_VertexVarying.vWorldPos.xyz - center) ;
            var depth = textureSample(pointShadowMap,pointShadowMapSampler,dir.xyz) ;
            depth = depth * globalUniform.far ;

            ORI_ShadingInput.BaseColor = vec4<f32>(depth*255.0,0.0,0.0,1.0)  ;
            UnLit();
        }
    `,On=`
    #include "Common_vert"
    #include "Common_frag"
    #include "UnLit_frag"
    #include "UnLitMaterialUniform_frag"

    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_2d<f32>;

    fn vert(inputData:VertexAttributes) -> VertexOutput {
        ORI_Vert(inputData) ;
        return ORI_VertexOut ;
    }

    fn frag(){
        var transformUV1 = materialUniform.transformUV1;
        var transformUV2 = materialUniform.transformUV2;

        var uv = transformUV1.zw * ORI_VertexVarying.fragUV0 + transformUV1.xy; 
        let color = textureSample(baseMap,baseMapSampler,uv) ;
        if(color.w < 0.5){
            discard ;
        }
        
        ORI_ShadingInput.BaseColor = color * materialUniform.baseColor ;
        UnLit();
    }
`,Zg=`
    struct MaterialUniform{
       #if USE_BRDF
        #include "PhysicMaterialUniform_frag"
       #endif

       #if USE_ColorLit
       #endif

       #if USE_UnLit
       #endif
    }

    @group(2) @binding(0)
    var<uniform> materialUniform: MaterialUniform;
`,wc=`
    #include "MathShader"

    fn buildMatrix3x3() -> mat3x3<f32>{
        var mat3 = mat3x3<f32>(
            1.0,0.0,0.0,
            0.0,1.0,0.0,
            0.0,0.0,1.0,
        );
        return mat3 ;
    }

    fn buildMatrix4x4() -> mat4x4<f32>{
        var mat4 = mat4x4<f32>(
            1.0,0.0,0.0,0.0,
            0.0,1.0,0.0,0.0,
            0.0,0.0,1.0,0.0,
            0.0,0.0,0.0,1.0,
        );
        return mat4 ;
    }

    fn buildRotateXMat3(rad:f32) -> mat3x3<f32>{
        var xrot = mat3x3<f32>(
            1.0,0.0,0.0,
            0.0,cos(rad),-sin(rad),
            0.0,sin(rad),cos(rad)
        );
        return xrot;
    }

    fn buildRotateXMat4(rad:f32,x:f32,y:f32,z:f32) -> mat4x4<f32>{
        var xrot = mat4x4<f32>(
            1.0,0.0,0.0,0.0,
            0.0,cos(rad),-sin(rad),0.0,
            0.0,sin(rad),cos(rad),0.0,
            x,y,z,1.0,
        );
        return xrot;
    }

    fn buildRotateXYZMat4(radX:f32,radY:f32,radZ:f32,x:f32,y:f32,z:f32) -> mat4x4<f32>{
        var xRot = mat4x4<f32>(
            1.0,0.0,0.0,0.0,
            0.0,cos(radX),-sin(radX),0.0,
            0.0,sin(radX),cos(radX),0.0,
            0.0,0.0,0.0,1.0,
        );
        var yRot = mat4x4<f32>(
            cos(radY),0.0,sin(radY),0.0,
            0.0,1.0,0.0,0.0,
            -sin(radY),0.0,cos(radY),0.0,
            0.0,0.0,0.0,1.0,
        );
        var zRot = mat4x4<f32>(
            cos(radZ),-sin(radZ),0.0,0.0,
            sin(radZ), cos(radZ),0.0,0.0,
            0.0,0.0,1.0,0.0,
            0.0,0.0,0.0,1.0,
        );
        var fMat = xRot * yRot * zRot ;
        fMat[3].x = x;
        fMat[3].y = y;
        fMat[3].z = z;
        return fMat;
    }

    fn buildRotateYMat3(rad:f32) -> mat3x3<f32>{
        var yrot = mat3x3<f32>(
            cos(rad),0.0,sin(rad),
            0.0,1.0,0.0,
            -sin(rad),0.0,cos(rad)
        );
        return yrot ;
    }

    fn buildRotateZ(rad:f32) -> mat3x3<f32>{
        var zrot = mat3x3<f32>(
            cos(rad),-sin(rad),0.0,
            sin(rad), cos(rad),0.0,
            0.0,0.0,1.0
        );
        return zrot;
    }

    // fn buildRotateXMat4(rad:f32) -> mat4x4<f32>{
    //     var xrot = mat4x4<f32>(
    //         1.0,0.0,0.0,0.0,
    //         0.0,cos(rad),-sin(rad),0.0,
    //         0.0,sin(rad),cos(rad),0.0,
    //         0.0,0.0,0.0,1.0);
    //     return xrot;
    // }

    fn bulidTranslateMat4(x:f32,y:f32,z:f32) -> mat4x4<f32>{
        var trans = mat4x4<f32>(
            1.0,0.0,0.0,0.0,
            0.0,1.0,0.0,0.0,
            0.0,0.0,1.0,0.0,
            x,y,z,1.0);
        return trans;
    }

`,Sc=`
    struct FragmentOutput {
        @location(0) o_Target: vec4<f32>
    };

    var<private> varying_uv: vec2<f32>;
    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_2d<f32>;

    struct MaterialUniform{
        u_texel: vec2<f32>,
        u_strength: f32,
    }

    @group(2) @binding(0)
    var<uniform> materialUniform: MaterialUniform;


    fn LinearToGammaSpace(linRGB0: vec3<f32>) -> vec3<f32> {
        var linRGB = max(linRGB0, vec3(0.0, 0.0, 0.0));
        linRGB.r = pow(linRGB.r,0.416666667);
        linRGB.g = pow(linRGB.g,0.416666667);
        linRGB.b = pow(linRGB.b,0.416666667);
        return max(1.055 * linRGB - 0.055, vec3(0.0, 0.0, 0.0));
    }

    fn texture2D( uv:vec2<f32> , offset:vec2<f32> ) -> vec4<f32> {
        return textureSample(baseMap, baseMapSampler, uv.xy + offset ).rgba ;
    }

    @fragment
    fn main(@location(0) fragUV: vec2<f32>) -> FragmentOutput {
        var v_vTexcoord = fragUV ;
        // v_vTexcoord.x = 1.0 - v_vTexcoord.x ;
        v_vTexcoord.y = 1.0 - v_vTexcoord.y ;

        var reducemul = 1.0 / 8.0;
        var reducemin = 1.0 / 128.0;

        var basecol = texture2D(v_vTexcoord , vec2<f32>(0.0)).rgba;
        var baseNW = texture2D(v_vTexcoord , -materialUniform.u_texel).rgb;
        var baseNE = texture2D(v_vTexcoord , vec2<f32>(materialUniform.u_texel.x, -materialUniform.u_texel.y)).rgb;
        var baseSW = texture2D(v_vTexcoord , vec2<f32>(-materialUniform.u_texel.x, materialUniform.u_texel.y)).rgb;
        var baseSE = texture2D(v_vTexcoord , materialUniform.u_texel ).rgb;

        // var gray = vec3<f32>(0.299, 0.587, 0.114);
        var gray = vec3<f32>(0.213, 0.715, 0.072);
        var monocol = dot(basecol.rgb, gray);
        var monoNW = dot(baseNW, gray);
        var monoNE = dot(baseNE, gray);
        var monoSW = dot(baseSW, gray);
        var monoSE = dot(baseSE, gray);

        var monomin = min(monocol, min(min(monoNW, monoNE), min(monoSW, monoSE)));
        var monomax = max(monocol, max(max(monoNW, monoNE), max(monoSW, monoSE)));

        var dir = vec2<f32>(-((monoNW + monoNE) - (monoSW + monoSE)), ((monoNW + monoSW) - (monoNE + monoSE)));
        var dirreduce = max((monoNW + monoNE + monoSW + monoSE) * reducemul * 0.25, reducemin);
        var dirmin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirreduce);
        dir = min(vec2<f32>(materialUniform.u_strength), max(vec2<f32>(-materialUniform.u_strength), dir * dirmin)) * materialUniform.u_texel;

        var resultA = 0.5 * (texture2D(v_vTexcoord , dir * -0.166667).rgb  +
                            texture2D(v_vTexcoord , dir * 0.166667).rgb);
        var resultB = resultA * 0.5 + 0.25 * (texture2D( v_vTexcoord , dir * -0.5).rgb +
                                            texture2D( v_vTexcoord , dir * 0.5).rgb);
        var monoB = dot(resultB.rgb, gray);
        
        var color:vec3<f32> ;
        if(monoB < monomin || monoB > monomax) {
            color = resultA ;//* v_vColour;
        } else {
            color = resultB ;//* v_vColour;
        }
        return FragmentOutput(vec4<f32>(color.rgb,basecol.a));
    }
`,Ic=`
struct FragmentOutput {
    @location(0) o_Target: vec4<f32>
};

${Ta}

#include "FastMathShader" 
 
struct LightData {
    index:f32,
    lightType:i32,
    radius:f32,
    linear:f32,
    
    position:vec3<f32>,
    lightMatrixIndex:f32,

    direction:vec3<f32>,
    quadratic:f32,

    lightColor:vec3<f32>,
    intensity:f32,

    innerCutOff :f32,
    outerCutOff:f32,
    range :f32,
    castShadow:i32,

    lightTangent:vec3<f32>,
    ies:f32,
};

struct UniformData {
    fogColor : vec4<f32>,
    fogType : f32 ,
    fogHeightScale : f32 , 
    start: f32,
    end: f32,
    density : f32 ,
    ins : f32 ,
    falloff : f32 ,
    rayLength : f32 ,
    scatteringExponent : f32 ,
    dirHeightLine : f32 ,
    skyFactor: f32,
    skyRoughness: f32,
    overrideSkyFactor: f32,
    isSkyHDR: f32
};

@group(1) @binding(0)
var positionMapSampler: sampler;
@group(1) @binding(1)
var positionMap: texture_2d<f32>;

@group(1) @binding(2)
var colorMapSampler: sampler;
@group(1) @binding(3)
var colorMap: texture_2d<f32>;

@group(1) @binding(4)
var normalMapSampler: sampler;
@group(1) @binding(5)
var normalMap: texture_2d<f32>;

@group(1) @binding(6)
var prefilterMapSampler: sampler;
@group(1) @binding(7)
var prefilterMap: texture_cube<f32>;


@group(2) @binding(0)
var<uniform> global : UniformData;
var<private> varying_uv: vec2<f32>;

@group(2) @binding(1)
var<storage,read> lightBuffer: array<LightData>;

var<private> texPosition: vec4<f32>;
var<private> texNormal: vec4<f32>;
var<private> texColor: vec4<f32>;

fn LinearToGammaSpace(linRGB: vec3<f32>) -> vec3<f32>
{
    var linRGB1 = max(linRGB, vec3<f32>(0.0));
    linRGB1 = pow(linRGB1, vec3<f32>(0.4166666567325592));
    return max(((1.0549999475479126 * linRGB1) - vec3<f32>(0.054999999701976776)), vec3<f32>(0.0));
}

fn getSkyColor(worldPosition:vec3<f32>, skyRoughness:f32, isHDRTexture:bool) -> vec3<f32>
{
    let cameraPosition = vec3<f32>(globalUniform.cameraWorldMatrix[3].xyz);
    let rayDirection = normalize(vec3<f32>(worldPosition.xyz - cameraPosition));
    let calcRoughness = clamp(skyRoughness, 0.0, 1.0);
    let MAX_REFLECTION_LOD  = f32(textureNumLevels(prefilterMap)) ;
    var prefilterColor = textureSampleLevel(prefilterMap, prefilterMapSampler, rayDirection, calcRoughness * MAX_REFLECTION_LOD);
    if(isHDRTexture){
        prefilterColor = vec4<f32>(LinearToGammaSpace(vec3<f32>(prefilterColor.xyz)), prefilterColor.w);
    }
    return prefilterColor.xyz * globalUniform.skyExposure;
}

@fragment
fn main(@location(0) fragUV: vec2<f32>, @builtin(position) coord: vec4<f32>) -> FragmentOutput {
    var texCoord = vec2<f32>(fragUV.x, 1.0 - fragUV.y);
    texPosition = textureSample(positionMap, positionMapSampler, texCoord) ;
    texNormal = textureSample(normalMap, normalMapSampler, texCoord) ;
    texColor = textureSample(colorMap, colorMapSampler, texCoord) ;
  
    var opColor = vec3<f32>(0.0);
    if(texNormal.w <= 0.5){
        //for sky
        if(global.overrideSkyFactor > 0.01){
            opColor = blendSkyColor();
        }else{
            opColor = texColor.xyz;
        }
    }else{
        //for ground
        var fogFactor = calcFogFactor();
        if(global.skyFactor > 0.01 || global.overrideSkyFactor > 0.01){
            opColor = blendGroundColor(fogFactor);
        }else{
            opColor = mix(texColor.rgb, global.fogColor.xyz, fogFactor);
        }

        let sunLight = lightBuffer[0] ;
        var inScatteringValue = inScatterIng(sunLight.direction, texPosition.xyz, sunLight.lightColor);
        opColor += inScatteringValue;
    }
    return FragmentOutput(vec4<f32>(opColor.xyz, texColor.a));
}

fn calcFogFactor() -> f32 
{
    var cameraPos = globalUniform.cameraWorldMatrix[3].xyz  ;
    let dis = distance(cameraPos, texPosition.xyz);
    var heightFactor = computeFog(dis) + cFog(-texPosition.y);
    return clamp(global.ins * heightFactor,0.0,1.0);
}

    
fn blendGroundColor(fogFactor:f32) -> vec3<f32>
{
    var skyColorBlur = getSkyColor(texPosition.xyz, global.skyRoughness, global.isSkyHDR > 0.5);
    let skyFactor = clamp(global.skyFactor - global.overrideSkyFactor * 0.5, 0.0, 1.0);
    var fogColor = mix(global.fogColor.xyz, skyColorBlur, skyFactor);
    return mix(texColor.rgb, fogColor.rgb, fogFactor);
}

fn blendSkyColor() -> vec3<f32>
{
    let overrideSkyFactor = sqrt(global.overrideSkyFactor);
    var skyColorBlur = getSkyColor(texPosition.xyz, overrideSkyFactor * 0.3, global.isSkyHDR > 0.5);
    return mix(global.fogColor.xyz, skyColorBlur, 1.0 - overrideSkyFactor);
}


fn computeFog(z:f32) -> f32 
{
    var fog = 0.0;
    if( global.fogType < 0.5 ){
        fog = (global.end - z) / (global.end - global.start);
    }else if(global.fogType < 1.5 ){
        fog = exp2(-global.density * z);
    }else if(global.fogType == 2.5 ){
        fog = global.density * z;
        fog = exp2(-fog * fog);
    }
    return max(fog,0.0);
}

  fn cFog(y:f32) -> f32 
  {
     let fogDensity = global.density * exp(global.fogHeightScale * y);
     let fogFactor = (1.0 - exp2(-global.falloff)) / global.falloff ;
     let fog = fogDensity * fogFactor * max(global.rayLength - global.start, 0.0); 
     return max(fog,0.0);
  }

  fn inScatterIng(sunDir:vec3<f32>, worldPos:vec3<f32>, sunColor:vec3<f32>) -> vec3<f32> 
  {
    let viewDir = normalize(globalUniform.CameraPos.xyz - worldPos.xyz) ;
    let VoL = saturate(dot(viewDir,sunDir)) ;
    var scatter = pow(VoL,global.scatteringExponent);
    scatter *= (1.0-saturate(exp2(-global.dirHeightLine)));
    return vec3<f32>(scatter*sunColor);
  }

`;class Nn{}n(Nn,"cs",`
    #include 'ColorUtil'
    struct UniformData {
        width: f32,
        height: f32,
        sunU: f32,
        sunV: f32,
        eyePos: f32,
        sunRadius: f32,         // = 500.0;
        sunRadiance: f32,       // = 20.0;
        mieG: f32,              // = 0.76;
        mieHeight: f32,         // = 1200;
        sunBrightness: f32,     // = 1.0;
        displaySun: f32,        // > 0.5: true
        skyColor: vec4<f32>,        // sky color
      };

      @group(0) @binding(0) var<uniform> uniformBuffer: UniformData;
      @group(0) @binding(1) var outTexture : texture_storage_2d<rgba16float, write>;

      var<private> uv01: vec2<f32>;
      var<private> fragCoord: vec2<i32>;
      var<private> texSizeF32: vec2<f32>;

      var<private> PI:f32 = 3.1415926535;
      var<private> PI_2:f32 = 0.0;
      var<private> EPSILON:f32 = 0.0000001;
      var<private> SAMPLES_NUMS:i32 = 16;

      var<private> transmittance:vec3<f32>;
      var<private> insctrMie:vec3<f32>;
      var<private> insctrRayleigh:vec3<f32>;

      @compute @workgroup_size( 8 , 8 , 1 )
      fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
      {
        fragCoord = vec2<i32>(globalInvocation_id.xy);
        texSizeF32 = vec2<f32>( uniformBuffer.width, uniformBuffer.height);
        uv01 = vec2<f32>(globalInvocation_id.xy) / texSizeF32;
        uv01.y = 1.0 - uv01.y - EPSILON;
        PI_2 = PI * 2.0;
        textureStore(outTexture, fragCoord , mainImage(uv01));//vec4(uv01, 0.0, 1.0));
      }

      struct ScatteringParams
      {
        sunRadius:f32,
        sunRadiance:f32,

        mieG:f32,
        mieHeight:f32,

        rayleighHeight:f32,

        waveLambdaMie:vec3<f32>,
        waveLambdaOzone:vec3<f32>,
        waveLambdaRayleigh:vec3<f32>,

        earthRadius:f32,
        earthAtmTopRadius:f32,
        earthCenter:vec3<f32>,
      }

      fn ComputeSphereNormal(coord:vec2<f32>, phiStart:f32, phiLength:f32, thetaStart:f32, thetaLength:f32) -> vec3<f32>
      {
        var normal:vec3<f32>;
        normal.x = -sin(thetaStart + coord.y * thetaLength) * sin(phiStart + coord.x * phiLength);
        normal.y = -cos(thetaStart + coord.y * thetaLength);
        normal.z = -sin(thetaStart + coord.y * thetaLength) * cos(phiStart + coord.x * phiLength);
        return normalize(normal);
      }

      fn ComputeRaySphereIntersection(position:vec3<f32>, dir:vec3<f32>, center:vec3<f32>, radius:f32) -> vec2<f32>
      {
        var origin:vec3<f32> = position - center;
        var B = dot(origin, dir);
        var C = dot(origin, origin) - radius * radius;
        var D = B * B - C;

        var minimaxIntersections:vec2<f32>;
        if (D < 0.0)
        {
          minimaxIntersections = vec2<f32>(-1.0, -1.0);
        }
        else
        {
          D = sqrt(D);
          minimaxIntersections = vec2<f32>(-B - D, -B + D);
        }

        return minimaxIntersections;
      }

      fn ComputeWaveLambdaRayleigh(lambda: vec3<f32>) -> vec3<f32>
      {
        var n:f32 = 1.0003;
        var N:f32 = 2.545E25;
        var pn:f32 = 0.035;
        var n2:f32 = n * n;
        var pi3:f32 = PI * PI * PI;
        var rayleighConst:f32 = (8.0 * pi3 * pow(n2 - 1.0,2.0)) / (3.0 * N) * ((6.0 + 3.0 * pn) / (6.0 - 7.0 * pn));
        return vec3<f32>(rayleighConst) / (lambda * lambda * lambda * lambda);
      }

      fn ComputePhaseMie(theta: f32, g:f32) -> f32
      {
        var g2 = g * g;
        return (1.0 - g2) / pow(1.0 + g2 - 2.0 * g * saturate(theta), 1.5) / (4.0 * PI);
      }

      fn ComputePhaseRayleigh(theta: f32) -> f32
      {
        var theta2 = theta * theta;
        return (theta2 * 0.75 + 0.75) / (4.0 * PI);
      }

      fn ChapmanApproximation(X: f32, h: f32, cosZenith: f32) -> f32
      {
        var c = sqrt(X + h);
        var c_exp_h = c * exp(-h);

        if (cosZenith >= 0.0)
        {
          return c_exp_h / (c * cosZenith + 1.0);
        }
        else
        {
          var x0 = sqrt(1.0 - cosZenith * cosZenith) * (X + h);
          var c0 = sqrt(x0);

          return 2.0 * c0 * exp(X - x0) - c_exp_h / (1.0 - c * cosZenith);
        }
      }

      fn GetOpticalDepthSchueler(h: f32, H: f32, earthRadius: f32, cosZenith: f32) -> f32
      {
        return H * ChapmanApproximation(earthRadius / H, h / H, cosZenith);
      }

      fn GetTransmittance(setting: ScatteringParams, L:vec3<f32>, V: vec3<f32>) -> vec3<f32>
      {
        var ch = GetOpticalDepthSchueler(L.y, setting.rayleighHeight, setting.earthRadius, V.y);
        return exp(-(setting.waveLambdaMie + setting.waveLambdaRayleigh) * ch);
      }

      fn ComputeOpticalDepth(setting: ScatteringParams, samplePoint: vec3<f32>, V: vec3<f32>, L: vec3<f32>, neg: f32) -> vec2<f32>
      {
        var rl = length(samplePoint);
        var h = rl - setting.earthRadius;
        var r: vec3<f32> = samplePoint / rl;

        var cos_chi_sun = dot(r, L);
        var cos_chi_ray = dot(r, V * neg);

        var opticalDepthSun = GetOpticalDepthSchueler(h, setting.rayleighHeight, setting.earthRadius, cos_chi_sun);
        var opticalDepthCamera = GetOpticalDepthSchueler(h, setting.rayleighHeight, setting.earthRadius, cos_chi_ray) * neg;

        return vec2<f32>(opticalDepthSun, opticalDepthCamera);
      }

      fn AerialPerspective(setting:ScatteringParams, start: vec3<f32>, end: vec3<f32>, V: vec3<f32>, L: vec3<f32>, infinite:i32)
      {
        var inf_neg:f32 = 1.0;
        if( infinite == 0){
          inf_neg = -1.0;
        }

        var sampleStep: vec3<f32> = (end - start) / f32(SAMPLES_NUMS);
        var samplePoint: vec3<f32> = end - sampleStep;
        var sampleLambda: vec3<f32> = setting.waveLambdaMie + setting.waveLambdaRayleigh + setting.waveLambdaOzone;

        var sampleLength:f32 = length(sampleStep);

        var scattering:vec3<f32> = vec3<f32>(0.0);
        var lastOpticalDepth:vec2<f32> = ComputeOpticalDepth(setting, end, V, L, inf_neg);

        for (var i:i32 = 1; i < SAMPLES_NUMS; i = i + 1)
        {
          var opticalDepth: vec2<f32> = ComputeOpticalDepth(setting, samplePoint, V, L, inf_neg);

          var segment_s: vec3<f32> = exp(-sampleLambda * (opticalDepth.x + lastOpticalDepth.x));
          var segment_t: vec3<f32> = exp(-sampleLambda * (opticalDepth.y - lastOpticalDepth.y));

          transmittance *= segment_t;

          scattering = scattering * segment_t;
          scattering += exp(-(length(samplePoint) - setting.earthRadius) / setting.rayleighHeight) * segment_s;

          lastOpticalDepth = opticalDepth;
          samplePoint = samplePoint - sampleStep;
        }

        insctrMie = scattering * setting.waveLambdaMie * sampleLength;
        insctrRayleigh = scattering * setting.waveLambdaRayleigh * sampleLength;
      }

      fn ComputeSkyboxChapman(setting: ScatteringParams, eye:vec3<f32>, V:vec3<f32>, L:vec3<f32>) -> f32
      {
        var neg:i32 = 1;
        var outerIntersections: vec2<f32> = ComputeRaySphereIntersection(eye, V, setting.earthCenter, setting.earthAtmTopRadius);
        if (outerIntersections.y < 0.0){
          return 0.0;
        }
        var innerIntersections: vec2<f32> = ComputeRaySphereIntersection(eye, V, setting.earthCenter, setting.earthRadius);
        if (innerIntersections.x > 0.0)
        {
          neg = 0;
          outerIntersections.y = innerIntersections.x;
        }

        let eye0 = eye - setting.earthCenter;

        var start : vec3<f32> = eye0 + V * max(0.0, outerIntersections.x);
        var end : vec3<f32>= eye0 + V * outerIntersections.y;

        AerialPerspective(setting, start, end, V, L, neg);

        //bool intersectionTest = innerIntersections.x < 0.0 && innerIntersections.y < 0.0;
        //return intersectionTest ? 1.0 : 0.0;

        if(innerIntersections.x < 0.0 && innerIntersections.y < 0.0){
          return 1.0;
        }
        return 0.0;
      }

      fn ComputeSkyInscattering(setting: ScatteringParams, eye: vec3<f32>, V: vec3<f32>, L: vec3<f32>) -> vec4<f32>
      {
        transmittance = vec3<f32>(1.0);
        insctrMie = vec3<f32>(0.0);
        insctrRayleigh = vec3<f32>(0.0);
        var intersectionTest:f32 = ComputeSkyboxChapman(setting, eye, V, L);

        var phaseTheta = dot(V, L);
        var phaseMie = ComputePhaseMie(phaseTheta, setting.mieG);
        var phaseRayleigh = ComputePhaseRayleigh(phaseTheta);
        var phaseNight = 1.0 - saturate(transmittance.x * EPSILON);

        var insctrTotalMie: vec3<f32> = insctrMie * phaseMie;
        var insctrTotalRayleigh: vec3<f32> = insctrRayleigh * phaseRayleigh;

        var sky: vec3<f32> = (insctrTotalMie + insctrTotalRayleigh) * setting.sunRadiance;
        if(uniformBuffer.displaySun > 0.5){
          var angle:f32 = saturate((1.0 - phaseTheta) * setting.sunRadius);
          var cosAngle:f32 = cos(angle * PI * 0.5);
          var edge:f32 = 0.0;
          if(angle >= 0.9){
            edge = smoothstep(0.9, 1.0, angle);
          }

          var limbDarkening: vec3<f32> = GetTransmittance(setting, -L, V);
          limbDarkening *= pow(vec3<f32>(cosAngle), vec3<f32>(0.420, 0.503, 0.652)) * mix(vec3<f32>(1.0), vec3<f32>(1.2,0.9,0.5), edge) * intersectionTest;
          sky += limbDarkening * uniformBuffer.sunBrightness; 
        }
        return vec4<f32>(sky, phaseNight * intersectionTest);
      }

      fn TonemapACES(x: vec3<f32>) -> vec3<f32>
      {
        var A:f32 = 2.51f;
        var B:f32 = 0.03f;
        var C:f32 = 2.43f;
        var D:f32 = 0.59f;
        var E:f32 = 0.14f;
        return (x * (A * x + B)) / (x * (C * x + D) + E);
      }

      fn noise(uv:vec2<f32>) -> f32
      {
        return fract(dot(sin(vec3<f32>(uv.xyx) * vec3<f32>(uv.xyy) * 1024.0), vec3<f32>(341896.483, 891618.637, 602649.7031)));
      }

      fn mainImage( uv:vec2<f32> ) -> vec4<f32>
      {
        let eyePosition = uniformBuffer.eyePos;
        var sun = vec2<f32>(uniformBuffer.sunU, uniformBuffer.sunV);
        var V: vec3<f32> = ComputeSphereNormal(uv, 0.0, PI_2, 0.0, PI);
        var L: vec3<f32> = ComputeSphereNormal(vec2<f32>(sun.x, sun.y), 0.0, PI_2, 0.0, PI);

        var setting: ScatteringParams;
        setting.sunRadius = uniformBuffer.sunRadius;//500.0;
        setting.sunRadiance = uniformBuffer.sunRadiance;//20.0;
        setting.mieG = uniformBuffer.mieG;//0.76;
        setting.mieHeight = uniformBuffer.mieHeight;// 1200.0;
        setting.rayleighHeight = 8000.0;
        setting.earthRadius = 6360000.0;
        setting.earthAtmTopRadius = 6420000.0;
        setting.earthCenter = vec3<f32>(0, -setting.earthRadius, 0);
        setting.waveLambdaMie = vec3<f32>(0.0000002);

        // wavelength with 680nm, 550nm, 450nm
        setting.waveLambdaRayleigh = ComputeWaveLambdaRayleigh(vec3<f32>(0.000000680, 0.000000550, 0.000000450));

        // see https://www.shadertoy.com/view/MllBR2
        setting.waveLambdaOzone = vec3<f32>(1.36820899679147, 3.31405330400124, 0.13601728252538)* 0.0000006 * 2.504;

        var eye:vec3<f32> = vec3<f32>(0,eyePosition,0);
        var sky0:vec4<f32> = ComputeSkyInscattering(setting, eye, V, L);
        var sky = vec3<f32>(sky0.rgb);

        sky = TonemapACES(sky.rgb * 2.0);
        sky = pow(sky.rgb, vec3<f32>(1.0/1.2)); // gamma

        var fragColor:vec4<f32> = vec4<f32>((sky.rgb), 1.0);
        return fragColor;
      }
    `);class Ec{constructor(){n(this,"sunRadius",500),n(this,"sunRadiance",11),n(this,"mieG",.76),n(this,"mieHeight",1200),n(this,"eyePos",1500),n(this,"sunX",.71),n(this,"sunY",.56),n(this,"sunBrightness",1),n(this,"displaySun",!0),n(this,"defaultTextureCubeSize",512),n(this,"defaultTexture2DSize",1024),n(this,"skyColor",new z(1,1,1,1))}}class Bc extends hs{constructor(e){return super(),n(this,"_internalTexture"),n(this,"_cubeSize"),n(this,"setting"),this.setting=e,this._cubeSize=e.defaultTextureCubeSize,this._internalTexture=new $g(e.defaultTexture2DSize,e.defaultTexture2DSize*.5),this._internalTexture.update(this.setting),this.createFromTexture(this._cubeSize,this._internalTexture),this}get texture2D(){return this._internalTexture}apply(){return this._internalTexture.update(this.setting),this._faceData.uploadErpTexture(this._internalTexture),this}}class $g extends ne{constructor(e,t){super(e,t,G.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING),n(this,"_computeShader"),n(this,"_uniformBuffer"),this.initCompute(e,t)}initCompute(e,t){this._uniformBuffer=new Dt(16*4),this._uniformBuffer.apply(),this._computeShader=new be(Nn.cs),this._computeShader.setUniformBuffer("uniformBuffer",this._uniformBuffer),this._computeShader.setStorageTexture("outTexture",this),this._computeShader.workerSizeX=e/8,this._computeShader.workerSizeY=t/8}update(e){this._uniformBuffer.setFloat("width",this.width),this._uniformBuffer.setFloat("height",this.height),this._uniformBuffer.setFloat("sunU",e.sunX),this._uniformBuffer.setFloat("sunV",e.sunY),this._uniformBuffer.setFloat("eyePos",e.eyePos),this._uniformBuffer.setFloat("sunRadius",e.sunRadius),this._uniformBuffer.setFloat("sunRadiance",e.sunRadiance),this._uniformBuffer.setFloat("mieG",e.mieG),this._uniformBuffer.setFloat("mieHeight",e.mieHeight),this._uniformBuffer.setFloat("sunBrightness",e.sunBrightness),this._uniformBuffer.setFloat("displaySun",e.displaySun?1:0),this._uniformBuffer.setColor("skyColor",e.skyColor),this._uniformBuffer.apply();let t=w.beginCommandEncoder();return w.computeCommand(t,[this._computeShader]),w.endCommandEncoder(t),this}}class Tc extends vi{constructor(){super();let e=new He("sky_vs_frag_wgsl","sky_fs_frag_wgsl");this.defaultPass=e,e.setUniformVector3("eyesPos",new p),e.setUniformFloat("exposure",1),e.setUniformFloat("roughness",0);let t=e.shaderState;t.frontFace="cw",t.cullMode=ui.back,t.depthWriteEnabled=!1,t.depthCompare=_t.less}set baseMap(e){this.defaultPass.setTexture("baseMap",e);const t="IS_HDR_SKY";this.defaultPass.defineValue[t]!=e?.isHDRTexture&&this.defaultPass.setDefine(t,!!e?.isHDRTexture)}get baseMap(){return this.defaultPass.getTexture("baseMap")}set envMap(e){}set shadowMap(e){}get exposure(){return _.setting.sky.skyExposure}set exposure(e){_.setting.sky.skyExposure=e}get roughness(){return this.defaultPass.uniforms.roughness.value}set roughness(e){"roughness"in this.defaultPass.uniforms&&(this.defaultPass.uniforms.roughness.value=e)}}class na extends it{constructor(e,t,r,a,s,o,l){super(),n(this,"shape_vertices",[]),n(this,"shape_indices",[]),n(this,"radius"),n(this,"widthSegments"),n(this,"heightSegments"),n(this,"phiStart"),n(this,"phiLength"),n(this,"thetaStart"),n(this,"thetaLength"),this.radius=e,this.widthSegments=t,this.heightSegments=r,this.phiStart=a,this.phiLength=s,this.thetaStart=o,this.thetaLength=l,this.buildGeometry()}buildGeometry(){var e,t,r=0;let a=this.heightSegments,s=this.widthSegments,o=this.radius;var l=(a+1)*(s+1);let h=new Float32Array(l*3),u=new Float32Array(l*3),c=new Float32Array(l*2),d=new Uint16Array(s*a*2*3),g=0,m=0,A=0;for(t=0;t<=a;++t){var v=Math.PI*t/a,y=-o*Math.cos(v),C=o*Math.sin(v);for(e=0;e<=s;++e){var S=2*Math.PI*e/s,T=C*Math.cos(S),D=C*Math.sin(S),M=1/Math.sqrt(T*T+D*D+y*y);if(h[g++]=T,h[g++]=D,h[g++]=y,u[m++]=T*M,u[m++]=D*M,u[m++]=y*M,c[A++]=e/s,c[A++]=t/a,e>0&&t>0){var P=(s+1)*t+e,R=(s+1)*t+e-1,U=(s+1)*(t-1)+e-1,E=(s+1)*(t-1)+e;t==a?(d[r++]=P,d[r++]=U,d[r++]=E):t==1?(d[r++]=P,d[r++]=R,d[r++]=U):(d[r++]=P,d[r++]=R,d[r++]=U,d[r++]=P,d[r++]=U,d[r++]=E)}}}this.setIndices(d),this.setAttribute(X.position,h),this.setAttribute(X.normal,u),this.setAttribute(X.uv,c),this.setAttribute(X.TEXCOORD_1,c),this.addSubGeometry({indexStart:0,indexCount:d.length,vertexStart:0,index:0}),this.bounds=new Be(p.ZERO,new p(this.radius*2,this.radius*2,this.radius*2))}}class us extends ue{constructor(){super(...arguments),n(this,"skyMaterial")}init(){super.init(),this.castShadow=!1,this.castGI=!0,this.addRendererMask(Le.Sky),this.alwaysRender=!0,this.object3D.bound=new Be(p.ZERO.clone(),p.MAX),this.geometry=new na(_.setting.sky.defaultFar,20,20),this.skyMaterial||(this.skyMaterial=new Tc)}onEnable(){this._readyPipeline?(this.castNeedPass(),!this._inRenderer&&this.transform.scene3D&&(Q.instance.sky=this,this._inRenderer=!0)):this.initPipeline()}onDisable(){this._inRenderer&&this.transform.scene3D&&(this._inRenderer=!1,Q.instance.sky=null)}renderPass2(e,t,r,a,s,o=!1){super.renderPass2(e,t,r,a,s,o)}set map(e){this.skyMaterial.baseMap=e,this.skyMaterial.name==null&&(this.skyMaterial.name="skyMaterial"),this.material=this.skyMaterial}get map(){return this.skyMaterial.baseMap}get exposure(){return this.skyMaterial.exposure}set exposure(e){this.skyMaterial&&(this.skyMaterial.exposure=e)}get roughness(){return this.skyMaterial.roughness}set roughness(e){this.skyMaterial&&(this.skyMaterial.roughness=e)}}class ep{constructor(){n(this,"rotateX"),n(this,"rotateY"),n(this,"sunX"),n(this,"sunY"),this.reset()}reset(){return this.rotateX=this.rotateY=this.sunX=this.sunY=Number.MAX_VALUE,this}isRotateChange(e,t){return Math.abs(this.rotateX-e)>=.001||Math.abs(this.rotateY-t)>=.001}isSkyChange(e,t){return Math.abs(this.sunX-e)>=.001||Math.abs(this.sunY-t)>=.001}save(e,t,r,a){return this.sunX=e,this.sunY=t,this.rotateX=r,this.rotateY=a,this}}class tp extends us{constructor(){super(...arguments),n(this,"_atmosphericScatteringSky"),n(this,"_onChange",!0),n(this,"_relatedTransform"),n(this,"_historyData")}get sunX(){return this._atmosphericScatteringSky.setting.sunX}set sunX(e){this._atmosphericScatteringSky.setting.sunX!=e&&(this._atmosphericScatteringSky.setting.sunX=e,this._onChange=!0)}get sunY(){return this._atmosphericScatteringSky.setting.sunY}set sunY(e){this._atmosphericScatteringSky.setting.sunY!=e&&(this._atmosphericScatteringSky.setting.sunY=e,this._onChange=!0)}get eyePos(){return this._atmosphericScatteringSky.setting.eyePos}set eyePos(e){this._atmosphericScatteringSky.setting.eyePos!=e&&(this._atmosphericScatteringSky.setting.eyePos=e,this._onChange=!0)}get sunRadius(){return this._atmosphericScatteringSky.setting.sunRadius}set sunRadius(e){this._atmosphericScatteringSky.setting.sunRadius!=e&&(this._atmosphericScatteringSky.setting.sunRadius=e,this._onChange=!0)}get sunRadiance(){return this._atmosphericScatteringSky.setting.sunRadiance}set sunRadiance(e){this._atmosphericScatteringSky.setting.sunRadiance!=e&&(this._atmosphericScatteringSky.setting.sunRadiance=e,this._onChange=!0)}get sunBrightness(){return this._atmosphericScatteringSky.setting.sunBrightness}set sunBrightness(e){this._atmosphericScatteringSky.setting.sunBrightness!=e&&(this._atmosphericScatteringSky.setting.sunBrightness=e,this._onChange=!0)}get displaySun(){return this._atmosphericScatteringSky.setting.displaySun}set displaySun(e){this._atmosphericScatteringSky.setting.displaySun!=e&&(this._atmosphericScatteringSky.setting.displaySun=e,this._onChange=!0)}init(){super.init(),this._historyData=new ep,this._atmosphericScatteringSky=new Bc(new Ec);let e=this.transform.view3D,t=this.transform.scene3D;this.map=this._atmosphericScatteringSky,t.envMap=this._atmosphericScatteringSky,this.onUpdate(e)}start(e){let t=this.transform.scene3D;this.map=this._atmosphericScatteringSky,t.envMap=this._atmosphericScatteringSky,super.start()}get relativeTransform(){return this._relatedTransform}set relativeTransform(e){this._relatedTransform=e,this._historyData.reset()}onUpdate(e){this._relatedTransform&&(this._relatedTransform.rotationZ=0,this._historyData.isRotateChange(this._relatedTransform.rotationX,this._relatedTransform.rotationY)?(this.sunX=(this._relatedTransform.rotationY+90)/360,this.sunY=this._relatedTransform.rotationX/180+.5):this._historyData.isSkyChange(this.sunX,this.sunY)&&(this._relatedTransform.rotationY=this.sunX*360-90,this._relatedTransform.rotationX=(this.sunY-.5)*180),this._historyData.save(this.sunX,this.sunY,this._relatedTransform.rotationX,this._relatedTransform.rotationY)),this._onChange&&(this._onChange=!1,this._atmosphericScatteringSky.apply())}destroy(e){super.destroy(e),this._atmosphericScatteringSky.destroy(),this._atmosphericScatteringSky=null,this._onChange=null}}class oa extends Ee{constructor(){super(),n(this,"type"),n(this,"camera"),n(this,"_cameraPosition"),this._cameraPosition=new p}onUpdate(){this.enable&&this.transform.view3D.camera&&this.updateBillboardMatrix()}updateBillboardMatrix(){let e=this.transform.view3D.camera;this._cameraPosition.copyFrom(e.transform.back),this.type==yi.BillboardXYZ||this.type==yi.BillboardY&&(this._cameraPosition.y=0),this._cameraPosition.normalize(),this._cameraPosition.add(this.object3D.localPosition,this._cameraPosition),this.transform.lookAt(this.object3D.localPosition,this._cameraPosition,e.transform.up)}cloneTo(e){let t=e.addComponent(oa);t.type=this.type}}var mr=(i=>(i[i.None=0]="None",i[i.Box=1]="Box",i[i.Capsule=2]="Capsule",i[i.Sphere=3]="Sphere",i[i.Mesh=4]="Mesh",i))(mr||{});const zi=class{constructor(){n(this,"_center"),n(this,"_size"),n(this,"_halfSize"),n(this,"_shapeType",0),zi.v3_help_0||(zi.v3_help_0=new p),zi.helpMatrix||(zi.helpMatrix=new H),zi.helpRay||(zi.helpRay=new ci),this._center=new p,this._size=new p,this._halfSize=new p}get shapeType(){return this._shapeType}setFromCenterAndSize(i,e){return i&&this._center.copy(i),e&&this._size.copy(e),this}get center(){return this._center}set center(i){this._center.copy(i)}get size(){return this._size}set size(i){this._size.copy(i),this._halfSize.copy(i).multiplyScalar(.5)}get halfSize(){return this._halfSize}rayPick(i,e){return null}};let Ye=zi;n(Ye,"v3_help_0"),n(Ye,"helpMatrix"),n(Ye,"helpRay");class Dc extends Ye{constructor(){super(),n(this,"_pickRet"),n(this,"box"),this._shapeType=mr.Box,this.box=new Be(new p,new p)}rayPick(e,t){this.box.setFromCenterAndSize(this.center,this.size);let a=Ye.helpMatrix;a.copyFrom(t).invert();let s=Ye.helpRay.copy(e);s.applyMatrix(a);let o=s.intersectBox(this.box,Ye.v3_help_0);return o?(this._pickRet||(this._pickRet={intersectPoint:new p,distance:0}),this._pickRet.intersectPoint=o,this._pickRet.distance=p.distance(s.origin,Ye.v3_help_0),this._pickRet):null}}class ip extends Ee{constructor(){super(),n(this,"_shape"),this._shape=new Dc}start(){_.setting.pick.mode=="pixel"&&this.transform.scene3D.view.pickFire.mouseEnableMap.set(this.transform.worldMatrix.index,this)}onEnable(e){se.bindEnablePick(e,this,null)}onDisable(e){se.unBindEnablePick(e,this)}get shape(){return this._shape}set shape(e){this._shape=e}rayPick(e){return this._enable?this._shape.rayPick(e,this.transform.worldMatrix):null}beforeDestroy(e){_.setting.pick.mode=="pixel"&&this.transform.scene3D.view.pickFire.mouseEnableMap.delete(this.transform.worldMatrix.index),super.beforeDestroy(e)}}var Mc=(i=>(i[i.PingPong=0]="PingPong",i[i.Repeat=1]="Repeat",i[i.Clamp=2]="Clamp",i))(Mc||{});class Fn{constructor(e=0,t=0){n(this,"serializedVersion","2"),n(this,"time"),n(this,"value"),n(this,"inSlope",0),n(this,"outSlope",0),n(this,"tangentMode",0),this.time=e,this.value=t}unSerialized(e){this.serializedVersion=e.serializedVersion,this.time=e.time,this.value=e.value,this.tangentMode=e.tangentMode,this.inSlope=e.inSlope=="Infinity"?NaN:e.inSlope,this.outSlope=e.outSlope=="Infinity"?NaN:e.outSlope}unSerialized2(e){this.serializedVersion=e.serializedVersion,this.time=e.time,this.value=e.value,this.tangentMode=e.tangentMode,this.inSlope=e.inTangent=="Infinity"?NaN:e.inTangent,this.outSlope=e.outTangent=="Infinity"?NaN:e.outTangent}}class kn{constructor(){n(this,"index"),n(this,"time"),n(this,"timeEnd"),n(this,"coeff",[])}}class cs{constructor(e,t=1,r=1){if(n(this,"_totalTime",1),n(this,"_cache",new kn),n(this,"_cacheOut",{lhsIndex:0,rhsIndex:0}),n(this,"_InvalidateCache",!1),n(this,"curve",[]),n(this,"serializedVersion"),n(this,"preWarpMode"),n(this,"postWarpMode"),n(this,"rotationOrder"),e)for(let a=0;a<e.length;a++){const s=e[a];this.addKeyFrame(s)}this.preWarpMode=t,this.postWarpMode=r}get totalTime(){return this._totalTime}get first(){return this.curve[0]}get last(){return this.curve[this.curve.length-1]}addKeyFrame(e){this.curve.indexOf(e)==-1&&this.curve.push(e),this.calcTotalTime()}removeKeyFrame(e){let t=this.curve.indexOf(e);t!=-1&&this.curve.splice(t,1),this.calcTotalTime()}calculateCacheData(e,t,r,a=0){let s=this.curve,o=s[t],l=s[r];e.index=t,e.time=o.time+a,e.timeEnd=l.time+a,e.index=t;let h,u,c,d,g,m,A;h=l.time-o.time,h=Math.max(h,1e-4),c=l.value-o.value,u=1/(h*h),d=o.outSlope,g=l.inSlope,m=d*h,A=g*h,e.coeff[0]=(m+A-c-c)*u/h,e.coeff[1]=(c+c+c-m-m-A)*u,e.coeff[2]=d,e.coeff[3]=o.value,this.setupStepped(e.coeff,o,l)}getValue(e){return e=this.wrapTime(e),this.findCurve(e,this._cacheOut),this.calculateCacheData(this._cache,this._cacheOut.lhsIndex,this._cacheOut.rhsIndex,0),this.evaluateCache(this._cache,e)}getKeyCount(){return this.curve.length}getKey(e){return this.curve[e]}unSerialized(e){this.preWarpMode=e.m_PreInfinity,this.postWarpMode=e.m_PostInfinity,this.rotationOrder=e.m_RotationOrder;let t=e.m_Curve.length;for(let r=0;r<t;r++)this.curve[r]=new Fn,this.curve[r].unSerialized(e.m_Curve[r.toString()]);return this.calcTotalTime(),this}unSerialized2(e){this.preWarpMode=e.preWrapMode,this.postWarpMode=e.postWrapMode;let t=e.keyFrames||e.keys,r=t.length;for(let a=0;a<r;a++)this.curve[a]=new Fn,this.curve[a].unSerialized2(t[a.toString()]);return this.calcTotalTime(),this}wrapTime(e){let t=this.curve,r=t[0].time,a=t[t.length-1].time;return e<r?this.preWarpMode==2?e=r:this.preWarpMode==0?e=Ps(e,r,a):e=Rs(e,r,a):e>a&&(this.postWarpMode==2?e=a:this.postWarpMode==0?e=Ps(e,r,a):e=Rs(e,r,a)),e}evaluateCache(e,t){let r=t-e.time;return r*(r*(r*e.coeff[0]+e.coeff[1])+e.coeff[2])+e.coeff[3]}findCurve(e,t){let r=this.curve;for(let a=1;a<r.length;a++){let s=r[a-1],o=r[a];s.time<=e&&o.time>e&&(t.lhsIndex=a-1,t.rhsIndex=a)}}setupStepped(e,t,r){(isNaN(t.outSlope)||isNaN(r.inSlope))&&(e[0]=0,e[1]=0,e[2]=0,e[3]=t.value)}invalidateCache(){this._InvalidateCache=!0}calcTotalTime(){let e=0;for(let t of this.curve)e=Math.max(e,t.time);this._totalTime=e}static scaleCurveValue(e,t){if(!e._InvalidateCache)for(let r=0;r<e.curve.length;r++){let a=e.curve[r];a.value*=t,a.inSlope*=t,a.outSlope*=t}e.invalidateCache()}}class Pc extends cs{constructor(){super(),n(this,"attribute",""),n(this,"propertyList"),n(this,"path")}unSerialized(e){let{attribute:t,path:r}=e;return this.attribute=t,this.path=r,this.propertyList=t.split("."),super.unSerialized(e.curve),this}}class Rc{constructor(){n(this,"curve",{})}}var Ar=(i=>(i[i.Default=0]="Default",i[i.Clamp=1]="Clamp",i[i.Once=1]="Once",i[i.Loop=2]="Loop",i[i.PingPong=4]="PingPong",i[i.ClampForever=8]="ClampForever",i))(Ar||{});class rp{constructor(){n(this,"name"),n(this,"objAnimClip"),n(this,"totalTime",0),n(this,"time",0),n(this,"_stopTime",0),n(this,"_loopTime"),n(this,"_wrapMode"),n(this,"_sampleRate")}get wrapMode(){return this._wrapMode||(this._wrapMode=0),this._wrapMode}set wrapMode(e){this._wrapMode=e}parse(e){this.objAnimClip={};let t=e.AnimationClip,{m_Name:r,m_AnimationClipSettings:a,m_WrapMode:s,m_SampleRate:o}=t;this.name=r,this._wrapMode=s,this._sampleRate=o,this._loopTime=a.m_LoopTime;for(const l in t.m_EditorCurves)if(Object.prototype.hasOwnProperty.call(t.m_EditorCurves,l)){const h=t.m_EditorCurves[l];let u=h.attribute,c=new Pc;c.unSerialized(h),this.totalTime=Math.max(this.totalTime,c.totalTime);let d=this.objAnimClip[h.path];d||(d=new Rc,this.objAnimClip[h.path]=d),d.curve[u]=c}}}class Lc{constructor(){n(this,"transform"),n(this,"quaternion"),n(this,"materialColor")}}class Wt{static updatePropertyTag(e,t){e.quaternion||(e.quaternion=this.tag_quaternion[t]),e.transform||(e.transform=this.tag_transform[t]),e.materialColor||(e.materialColor=this.tag_materialColor[t])}}n(Wt,"Property",{"m_LocalPosition.x":"localPosition.x","m_LocalPosition.y":"localPosition.y","m_LocalPosition.z":"localPosition.z","m_LocalRotation.x":"localQuaternion.x","m_LocalRotation.y":"localQuaternion.y","m_LocalRotation.z":"localQuaternion.z","m_LocalRotation.w":"localQuaternion.w","localEulerAnglesRaw.x":"localRotation.x","localEulerAnglesRaw.y":"localRotation.y","localEulerAnglesRaw.z":"localRotation.z","m_LocalEulerAngles.x":"localRotation.x","m_LocalEulerAngles.y":"localRotation.y","m_LocalEulerAngles.z":"localRotation.z","m_LocalScale.x":"localScale.x","m_LocalScale.y":"localScale.y","m_LocalScale.z":"localScale.z","m_Color.r":"materialColor.r","m_Color.g":"materialColor.g","m_Color.b":"materialColor.b","m_Color.a":"materialColor.a","material._Color.r":"materialColor.r","material._Color.g":"materialColor.g","material._Color.b":"materialColor.b","material._Color.a":"materialColor.a","material._UnlitColor.r":"materialColor.r","material._UnlitColor.g":"materialColor.g","material._UnlitColor.b":"materialColor.b","material._UnlitColor.a":"materialColor.a","field of view":"camera3D.fov",m_IsActive:"active",m_Sprite:"sprite",m_FlipX:"flipX",m_FlipY:"flipY"}),n(Wt,"Scale",{"m_LocalPosition.x":1,"m_LocalPosition.y":1,"m_LocalPosition.z":-1,"localEulerAnglesRaw.x":-1,"localEulerAnglesRaw.y":1,"localEulerAnglesRaw.z":1,"m_LocalEulerAngles.x":-1,"m_LocalEulerAngles.y":1,"m_LocalEulerAngles.z":1,"m_LocalRotation.x":1,"m_LocalRotation.y":1,"m_LocalRotation.z":-1,"m_LocalRotation.w":-1,"field of view":1,m_IsActive:1,m_Sprite:1}),n(Wt,"tag_quaternion",{"m_LocalRotation.x":!0,"m_LocalRotation.y":!0,"m_LocalRotation.z":!0,"m_LocalRotation.w":!0}),n(Wt,"tag_materialColor",{"material._Color.r":!0,"material._Color.g":!0,"material._Color.b":!0,"material._Color.a":!0,"material._UnlitColor.r":!0,"material._UnlitColor.g":!0,"material._UnlitColor.b":!0,"material._UnlitColor.a":!0}),n(Wt,"tag_transform",{"m_LocalPosition.x":!0,"m_LocalPosition.y":!0,"m_LocalPosition.z":!0,"m_LocalRotation.x":!0,"m_LocalRotation.y":!0,"m_LocalRotation.z":!0,"m_LocalRotation.w":!0,"localEulerAnglesRaw.x":!0,"localEulerAnglesRaw.y":!0,"localEulerAnglesRaw.z":!0,"m_LocalEulerAngles.x":!0,"m_LocalEulerAngles.y":!0,"m_LocalEulerAngles.z":!0,"m_LocalScale.x":!0,"m_LocalScale.y":!0,"m_LocalScale.z":!0});const zn=class{constructor(i){n(this,"_rootObject3D"),n(this,"_animation"),n(this,"_propertyCache"),n(this,"_currentClip"),n(this,"_frame",0),n(this,"_time",0),n(this,"_isPlaying",!0),n(this,"speed",1),n(this,"_propertyTagDic"),this._rootObject3D=i.object3D,this._animation=i,this._propertyTagDic=new Map,this.reset()}reset(){this._propertyCache={},this._propertyTagDic.clear()}get time(){return this._time}get currentClip(){return this._currentClip}play(i,e=!0){this._isPlaying=!0,e&&(this._time=0),i!=this._currentClip&&i&&this.parseAnimClip(i),this._currentClip=i,this.validProperty()}parseAnimClip(i){var e;this.reset();for(const t in i.objAnimClip){let r=i.objAnimClip[t],a=this._rootObject3D,s={};if(t==""?a=this._rootObject3D:a=this._rootObject3D.getObjectByName(t),!a)continue;let o=new Lc;this._propertyTagDic.set(a,o);let l=r.curve;for(const h in l){Wt.updatePropertyTag(o,h);let u=(e=this._propertyCache)[t]||(e[t]={}),c=Wt.Property[h].split("."),d=c[0];if(c.length>1){let g=s[d];g||(g=s[d]=a[d]),u[h]={value:g,property:c[1]}}else u[h]={value:a,property:c[0]}}}return this}stop(){return this._isPlaying=!1,this}toggle(){return this._isPlaying=!this._isPlaying,this}get isPlaying(){return this._isPlaying}update(i,e){if(i=i*.001,e=e*.001,!this._currentClip||this._frame==i||!this._isPlaying)return;this._frame=i;let t=this._time;this._time=this.calcTime(t+e*this.speed),this.validProperty(),this._currentClip.wrapMode!=Ar.Loop&&this._currentClip.wrapMode!=Ar.Default&&(this.speed>0?this._time>=this._currentClip.totalTime:this._time<=0)&&(this._isPlaying=!1,this._animation.statusCall(zn.Complete,t,this._time)),this._animation.statusCall(zn.Seek,t,this._time)}seek(i){return this._time=this.calcTime(i),this._rootObject3D&&this.validProperty(),this}calcTime(i){return this._currentClip.wrapMode==Ar.Loop||this._currentClip.wrapMode==Ar.Default?i=Fs(i,this._currentClip.totalTime):i=J(i,0,this._currentClip.totalTime),i}validProperty(){for(const i in this._currentClip.objAnimClip){let t=this._currentClip.objAnimClip[i].curve;for(const r in t){const a=t[r];let s=this._propertyCache[i][r],o=a.getValue(this._time);r in Wt.Scale&&(o*=Wt.Scale[r]),s.value[s.property]=o}}this._propertyTagDic.forEach((i,e)=>{this.applyProperty(i,e)})}applyProperty(i,e){i.quaternion&&H.getEuler(e.transform.localRotation,e.transform.localRotQuat,!0,"ZYX"),i.transform&&(e.transform.localPosition=e.transform.localPosition,e.transform.localRotation=e.transform.localRotation,e.transform.localScale=e.transform.localScale);let t=e;i.materialColor&&t.notifyMaterialColorChange(0,"baseColor")}};let _r=zn;n(_r,"Complete",0),n(_r,"Seek",1);class ap{constructor(){n(this,"clipName"),n(this,"data"),n(this,"time")}}class Gi extends je{constructor(e,t){super(t),n(this,"animation"),n(this,"frame"),this.animation=e}}n(Gi,"SEEK","SEEK"),n(Gi,"COMPLETE","COMPLETE");class Gn extends Ee{constructor(){super(),n(this,"_animator"),n(this,"_clips",[]),n(this,"defaultClip"),n(this,"autoPlay"),n(this,"_seekEvent"),n(this,"_completeEvent"),n(this,"_keyFrameList"),this._seekEvent=new Gi(this,Gi.SEEK),this._completeEvent=new Gi(this,Gi.COMPLETE),this._keyFrameList={}}registerEventKeyFrame(e){let t=this._keyFrameList[e.clipName];t==null&&(this._keyFrameList[e.clipName]=t=[]),t.push(e)}init(){this._animator=new _r(this)}onUpdate(){this.enable&&this._animator.update(he.time,he.delta)}appendClip(e){this._clips.push(e),this.play(e.name)}statusCall(e,t,r){if(e==_r.Complete)this.eventDispatcher.dispatchEvent(this._completeEvent);else if(e==_r.Seek&&t!=r){let a=this._keyFrameList[this.currentClip.name];if(a)for(let s of a)s.time>t&&s.time<=r&&(this._seekEvent.data=this._seekEvent.frame=s,this.eventDispatcher.dispatchEvent(this._seekEvent))}}set speed(e){this._animator.speed=e}get speed(){return this._animator.speed}stop(){this._animator.stop()}toggle(){this._animator.toggle()}getClip(e){let t;for(let r of this._clips)if(r.name==e){t=r;break}return t}get currentClip(){return this._animator.currentClip}get time(){return this._animator.time}seek(e){this._animator.seek(e)}play(e,t=!0){let r=this.getClip(e);return r?(this._animator.play(r,t),r):null}start(){this.autoPlay&&this.play(this.defaultClip)}copyComponent(e){this.autoPlay=e.autoPlay,this.defaultClip=e.defaultClip;let t=e._clips;for(let r=0,a=t.length;r<a;r++)this.appendClip(t[r]);return this}cloneTo(e){e.addComponent(Gn).copyComponent(this)}}class sp extends Ee{constructor(){super(...arguments),n(this,"_targetRenderers",{}),n(this,"_vec3",new p),n(this,"_matrix4",new H),n(this,"_quaternion",new K)}init(e){let t=this.fetchMorphRenderers(this.object3D);for(const r of t){Bt.hasMask(r.rendererMask,Le.MorphTarget)&&r.selfCloneMaterials("MORPH_TARGET_UUID");for(const s in r.geometry.morphTargetDictionary){let o=this._targetRenderers[s]||[];o.push(r),this._targetRenderers[s]=o}}}getMorphRenderersByKey(e){return this._targetRenderers[e]}cloneMorphRenderers(){let e={};for(let t in this._targetRenderers)e[t]=this._targetRenderers[t];return e}applyBlendShape(e,t,r=1){if(!e){console.warn("blendShape is null");return}this._vec3.setFromArray(e.transform.transform[3]),this._vec3.multiplyScalar(r),this.object3D.transform.localPosition=this._vec3,this._vec3.setFromArray(e.transform.transform[2]),this._matrix4.copyColFrom(2,this._vec3),this._vec3.setFromArray(e.transform.transform[1]),this._matrix4.copyColFrom(1,this._vec3),this._vec3.setFromArray(e.transform.transform[0]),this._matrix4.copyColFrom(0,this._vec3),this._matrix4.transpose(),this._quaternion.fromMatrix(this._matrix4),this.object3D.localQuaternion=this._quaternion;for(let a in t){let s=this._targetRenderers[a],o=t[a],l=e.texture[o];this.applyMorphTargetInfluence(a,l,s)}}applyMorphTargetInfluence(e,t,r){for(let a of r)a.setMorphInfluence(e,t)}fetchMorphRenderers(e){let t=e.getComponentsInChild(ue),r=[];for(let a of t)a.hasMask(Le.MorphTarget)&&r.push(a);return r}}class np{constructor(){n(this,"texture"),n(this,"transform")}}class op{constructor(e,t){n(this,"_computePipeline"),n(this,"_computeBindGroup");let r=I.device;this._computePipeline=r.createComputePipeline({layout:"auto",compute:{module:r.createShaderModule({code:e}),entryPoint:"CsMain"}}),this._computeBindGroup=r.createBindGroup({layout:this._computePipeline.getBindGroupLayout(0),entries:t})}compute(e,t,r,a){let s=e.beginComputePass();return s.setPipeline(this._computePipeline),s.setBindGroup(0,this._computeBindGroup),s.dispatchWorkgroups(t,r,a),s.end(),this}}class lp extends Mr{constructor(){super(),n(this,"numJoint"),n(this,"numState"),n(this,"time"),n(this,"weight"),n(this,"argumentsData"),n(this,"_isDirty",!1),n(this,"_argumentsBuffer"),n(this,"_argumentsBufferEntries"),this.allocationMemorySet([{name:"numJoint",data:[0]},{name:"numState",data:[0]},{name:"retain1",data:[0]},{name:"retain2",data:[0]},{name:"time",data:[0,0]},{name:"weight",data:[0,0]}]),this.generateGPUBuffer()}getGPUBuffer(){return this._argumentsBuffer}getGPUBindGroupEntry(){return this._argumentsBufferEntries}updateGPUBuffer(){return this._isDirty&&(this._isDirty=!1,I.device.queue.writeBuffer(this._argumentsBuffer,0,this.shareDataBuffer)),this}allocationMemorySet(e){this.argumentsData={};let t=0;for(let a=0;a<e.length;a++){const s=e[a];t+=s.data.length}this.allocation(t*4);let r=this;for(let a=0;a<e.length;a++){const s=e[a],o=s.name;this.argumentsData[o]=this.allocation_node(s.data.length*4),r[o]=this.argumentsData[o]}}generateGPUBuffer(){let e=I.device;this._argumentsBuffer=e.createBuffer({size:this.shareDataBuffer.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,mappedAtCreation:!1}),this._argumentsBufferEntries={binding:0,resource:{buffer:this._argumentsBuffer,offset:0,size:this.shareDataBuffer.byteLength}}}}class hp extends Mr{constructor(){super(),n(this,"numJoint"),n(this,"numFrame"),n(this,"retain0"),n(this,"retain1"),n(this,"argumentsData"),n(this,"_isDirty",!1),n(this,"_argumentsBuffer"),n(this,"_argumentsBufferEntries"),this.allocationMemorySet([{name:"numJoint",data:[0]},{name:"numFrame",data:[0]},{name:"retain0",data:[0]},{name:"retain1",data:[0]}]),this.generateGPUBuffer()}getGPUBuffer(){return this._argumentsBuffer}getGPUBindGroupEntry(){return this._argumentsBufferEntries}updateGPUBuffer(){this._isDirty&&(this._isDirty=!1,I.device.queue.writeBuffer(this._argumentsBuffer,0,this.shareDataBuffer))}allocationMemorySet(e){this.argumentsData={};let t=0;for(let a=0;a<e.length;a++){const s=e[a];t+=s.data.length}this.allocation(t*4);let r=this;for(let a=0;a<e.length;a++){const s=e[a],o=s.name;this.argumentsData[o]=this.allocation_node(s.data.length*4),r[o]=this.argumentsData[o]}}generateGPUBuffer(){let e=I.device;this._argumentsBuffer=e.createBuffer({size:this.shareDataBuffer.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,mappedAtCreation:!1}),this._argumentsBufferEntries={binding:0,resource:{buffer:this._argumentsBuffer,offset:0,size:this.shareDataBuffer.byteLength}}}}let up=`
  ${Ba}

  struct Arguments {
    numJoint: f32,
    numState: f32,
    retain1: f32,
    retain2: f32,
    time: vec2<f32>,
    weight: vec2<f32>,
  };

  struct JointData {
    scale: vec4<f32>,
    rotation: vec4<f32>,
    translation: vec4<f32>,
  };

  @group(0) @binding(0) var<storage, read_write> args: Arguments;
  @group(0) @binding(1) var<storage, read_write> jointsFinalMatrix: array<mat4x4<f32>>;
  @group(0) @binding(2) var<storage, read_write> jointsWorldMatrix: array<mat4x4<f32>>;

  @compute @workgroup_size(1)
  fn CsMain(@builtin(workgroup_id) workgroup_id: vec3<u32>, @builtin(local_invocation_index) local_index: u32) {
    let numJoint = i32(args.numJoint);
    let numState = i32(args.numState);
    let nJointIndex = i32(workgroup_id.x);

    jointsFinalMatrix[nJointIndex] = mixMatrix4x4(jointsWorldMatrix[0 * numJoint + nJointIndex], jointsWorldMatrix[1 * numJoint + nJointIndex], args.time[0]) * args.weight[0];

    for (var i = 1; i < numState; i++) {
      jointsFinalMatrix[nJointIndex] += mixMatrix4x4(jointsWorldMatrix[(i * 2 + 0) * numJoint + nJointIndex], jointsWorldMatrix[(i * 2 + 1) * numJoint + nJointIndex], args.time[i]) * args.weight[i];
    }
  }
`,cp=`
  ${Ba}

  struct Arguments {
    numJoint: f32,
    numFrame: f32,
    retain0: f32,
    retain1: f32,
  };

  struct JointData {
    scale: vec4<f32>,
    rotation: vec4<f32>,
    translation: vec4<f32>,
  };

  @group(0) @binding(0) var<storage, read_write> args: Arguments;
  @group(0) @binding(1) var<storage, read_write> jointsKeyframe: array<JointData>;
  @group(0) @binding(2) var<storage, read_write> jointsWorldMatrix: array<mat4x4<f32>>;
  @group(0) @binding(3) var<storage, read_write> jointsParentIndex: array<f32>;

  @compute @workgroup_size(1)
  fn CsMain(@builtin(workgroup_id) workgroup_id: vec3<u32>, @builtin(local_invocation_index) local_index: u32) {
    let numJoint = i32(args.numJoint);
    let nFrameIndex = i32(workgroup_id.x);
    for (var nJointIndex = 0; nJointIndex < numJoint; nJointIndex++) {
      let dataIndex = nFrameIndex * numJoint + nJointIndex;
      let joint = jointsKeyframe[dataIndex];
      let jointLocalMatrix = MakeMatrix4x4(joint.scale.xyz, joint.rotation, joint.translation.xyz);

      let nParentIndex = i32(jointsParentIndex[nJointIndex]);
      if (nParentIndex < 0) {
        jointsWorldMatrix[dataIndex] = jointLocalMatrix;
      } else {
        jointsWorldMatrix[dataIndex] = jointsWorldMatrix[nFrameIndex * numJoint + nParentIndex] * jointLocalMatrix;
      }
    }
  }
`;class fp extends Ee{constructor(){super(),n(this,"context"),n(this,"gain"),this.context=new AudioContext,this.gain=this.context.createGain(),this.gain.connect(this.context.destination)}start(){}onUpdate(){if(!this.context)return;const e=this.context.listener,t=this.object3D.transform.worldPosition,r=this.object3D.transform.forward,a=this.object3D.transform.up;if(!isNaN(r.x))if(e.positionX){const s=this.context.currentTime;e.positionX.linearRampToValueAtTime(t.x,s),e.positionY.linearRampToValueAtTime(t.y,s),e.positionZ.linearRampToValueAtTime(t.z,s),e.forwardX.linearRampToValueAtTime(r.x,s),e.forwardY.linearRampToValueAtTime(r.y,s),e.forwardZ.linearRampToValueAtTime(r.z,s),e.upX.linearRampToValueAtTime(a.x,s),e.upY.linearRampToValueAtTime(a.y,s),e.upZ.linearRampToValueAtTime(a.z,s)}else e.setPosition(t.x,t.y,t.z),e.setOrientation(r.x,r.y,r.z,a.x,a.y,a.z)}destroy(){this.gain.disconnect(),this.context.close(),super.destroy()}}class la extends vi{constructor(){super();let e=new He("UnLit","UnLit");this.defaultPass=e,e.setShaderEntry("VertMain","FragMain"),e.setUniformVector4("transformUV1",new q(0,0,1,1)),e.setUniformVector4("transformUV2",new q(0,0,1,1)),e.setUniformColor("baseColor",new z(1,1,1,1)),e.setUniformFloat("alphaCutoff",.5);let t=e.shaderState;t.acceptShadow=!1,t.castShadow=!1,t.receiveEnv=!1,t.acceptGI=!1,t.useLight=!1,this.defaultPass=e,this.baseMap=_.res.whiteTexture}set baseMap(e){this.defaultPass.setTexture("baseMap",e)}get baseMap(){return this.defaultPass.getTexture("baseMap")}set baseColor(e){this.defaultPass.setUniformColor("baseColor",e)}get baseColor(){return this.defaultPass.uniforms.baseColor.color}set envMap(e){}set shadowMap(e){}}class ha extends it{constructor(e=1,t=1,r=1){super(),n(this,"width"),n(this,"height"),n(this,"depth"),this.width=e,this.height=t,this.depth=r,this.initVertex()}initVertex(){let e=this.width/2,t=this.height/2,r=this.depth/2;this.bounds=new Be(p.ZERO.clone(),new p(this.width,this.height,this.depth));let a=new Float32Array([-e,t,r,e,t,r,e,t,-r,-e,t,-r,-e,t,r,e,t,-r,e,-t,r,-e,-t,r,-e,-t,-r,e,-t,-r,e,-t,r,-e,-t,-r,-e,-t,r,-e,t,r,-e,t,-r,-e,-t,-r,-e,-t,r,-e,t,-r,e,t,r,e,-t,r,e,-t,-r,e,t,-r,e,t,r,e,-t,-r,e,t,r,-e,t,r,-e,-t,r,-e,-t,r,e,-t,r,e,t,r,e,-t,-r,-e,-t,-r,-e,t,-r,e,t,-r,e,-t,-r,-e,t,-r]),s=new Float32Array([0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1]),o=new Float32Array([1,1,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,0,0,1,0,1,1,0,0]),l=[0,2,1,3,5,4,6,8,7,9,11,10,12,14,13,15,17,16,18,20,19,21,23,22,24,26,25,27,29,28,30,32,31,33,35,34],h=new Uint16Array(l.reverse());this.setIndices(h),this.setAttribute(X.position,a),this.setAttribute(X.normal,s),this.setAttribute(X.uv,o),this.setAttribute(X.TEXCOORD_1,o),this.addSubGeometry({indexStart:0,indexCount:l.length,vertexStart:0,index:0})}}class Uc extends Ee{constructor(){super(),n(this,"listener",null),n(this,"context",null),n(this,"gainNode",null),n(this,"source",null),n(this,"_options",{loop:!0,volume:1}),n(this,"playing",!1),n(this,"_currentTime",0),n(this,"_buffer",null)}setLister(e){return this.listener=e,this.context=e.context,this.gainNode=this.context.createGain(),this.gainNode.connect(this.listener.gain),this.context.addEventListener("statechange",()=>{var t,r;((t=this.context)==null?void 0:t.state)==="closed"&&(console.warn("AudioListener removed"),this.stop(),(r=this.gainNode)==null||r.disconnect(),this.listener=null,this.context=null,this.gainNode=null)}),this}async load(e,t={}){var r;Object.assign(this._options,t);let s=await(await fetch(e)).arrayBuffer();this._buffer=await((r=this.context)==null?void 0:r.decodeAudioData(s))}async loadBuffer(e,t={}){var r;Object.assign(this._options,t),this._buffer=await((r=this.context)==null?void 0:r.decodeAudioData(e))}play(){if(!this.context)return console.warn("no audio source yet"),this;if(this.playing)return console.warn("Audio is alredy playing"),this;if(!this._buffer)return console.warn("Audio is not ready"),this;const e=this.context.createBufferSource();return e.buffer=this._buffer,e.loop=this._options.loop,this.source=e,this.connect(),this.source.start(0,this._currentTime),this.setVolume(this._options.volume),this.playing=!0,this}pause(){var e,t,r;return this.playing?(this._currentTime=((e=this.context)==null?void 0:e.currentTime)||0,(t=this.source)==null||t.stop(),(r=this.source)==null||r.disconnect(),this.playing=!1,this):(console.warn("Audio is not playing"),this)}stop(){return this.pause(),this._currentTime=0,this}setVolume(e){var t;return this.context?((t=this.gainNode)==null||t.gain.setTargetAtTime(e,this.context?this.context.currentTime:0,.01),this):(console.warn("no audio source yet"),this)}connect(){var e;(e=this.source)==null||e.connect(this.gainNode)}onUpdate(){super.onUpdate()}destroy(e){var t;this.stop(),(t=this.gainNode)==null||t.disconnect(),super.destroy(e)}}class dp extends Uc{constructor(){super(),n(this,"panner"),n(this,"_helper",!1),n(this,"_thickness",.1),n(this,"_step",16),n(this,"_lines",[])}setLister(e){var t;return super.setLister(e),this.panner=(t=this.context)==null?void 0:t.createPanner(),this.panner.panningModel="HRTF",this.panner.connect(this.gainNode),this}showHelper(e,t){this._helper=!0,e&&(this._thickness=e),t&&(this._step=t);const r=this.panner.coneInnerAngle,a=this.panner.coneOuterAngle,s=(a-r)/2;let o=this.panner.refDistance,l=this.panner.maxDistance,h=new ha(1,1,1),u=new la;u.baseColor=new z(1,0,0);let c=new la;c.baseColor=new z(0,0,1);let d=new la;d.baseColor=new z(0,1,0);let g=new la;g.baseColor=new z(1,1,0);for(let m=0;m<this._step;m++){let A=new f.Object3D,v=m*a/(this._step-1),y=v<s||v>r+s;{let C=new f.Object3D,S=C.addComponent(ue);S.geometry=h,S.material=y?c:u,S.castShadow=!1,S.castGI=!1,C.localScale=new p(o,this._thickness,this._thickness),C.x=o/2,A.addChild(C)}{let C=new f.Object3D,S=C.addComponent(ue);S.geometry=h,S.material=y?g:d,S.castShadow=!1,S.castGI=!1,C.localScale=new p(l,this._thickness/2,this._thickness/2),C.x=l/2,A.addChild(C)}A.rotationY=-90+a/2-v,this.object3D.addChild(A),this._lines.push(A)}}hideHelper(){this._helper=!1;for(let e of this._lines)e.removeAllChild(),e.removeFromParent(),e.destroy();this._lines.length=0}toggleHelper(){this._helper?this.hideHelper():this.showHelper()}updateHeler(){this.hideHelper(),this.showHelper()}get refDistance(){return this.panner.refDistance}set refDistance(e){this.panner.refDistance=e,this._helper&&this.updateHeler()}get rolloffFactor(){return this.panner.rolloffFactor}set rolloffFactor(e){this.panner.rolloffFactor=e}get distanceModel(){return this.panner.distanceModel}set distanceModel(e){this.panner.distanceModel=e}get maxDistance(){return this.panner.maxDistance}set maxDistance(e){this.panner.maxDistance=e,this._helper&&this.updateHeler()}setDirectionalCone(e,t,r){return this.panner.coneInnerAngle=e,this.panner.coneOuterAngle=t,this.panner.coneOuterGain=r,this._helper&&this.updateHeler(),this}connect(){var e;(e=this.source)==null||e.connect(this.panner)}start(){}stop(){return super.stop()}onUpdate(){if(!this.playing)return;const e=this.panner,t=this.object3D.transform.worldPosition,r=this.object3D.transform.forward;if(!isNaN(r.x))if(e.positionX&&this.context){const a=this.context.currentTime;e.positionX.linearRampToValueAtTime(t.x,a),e.positionY.linearRampToValueAtTime(t.y,a),e.positionZ.linearRampToValueAtTime(t.z,a),e.orientationX.linearRampToValueAtTime(r.x,a),e.orientationY.linearRampToValueAtTime(r.y,a),e.orientationZ.linearRampToValueAtTime(r.z,a)}else e.setPosition(t.x,t.y,t.z),e.setOrientation(r.x,r.y,r.z)}destroy(e){this.panner.disconnect(),this.hideHelper(),super.destroy(e)}}class gp{constructor(e=null,t=null){n(this,"_autoUpdate",!0),n(this,"_target"),n(this,"_lookAtObject"),n(this,"_origin",new p(0,0,0)),n(this,"_speed",300),this._target=e,this._lookAtObject=t}get target(){return this._target}set target(e){this._target!=e&&(this._target=e)}get lookAtObject(){return this._lookAtObject}set lookAtObject(e){this._lookAtObject!=e&&(this._lookAtObject=e)}get speed(){return this._speed}set speed(e){this._speed=e}update(){}}class pp extends Ee{constructor(){super(),n(this,"focus"),n(this,"distance",5),n(this,"_camera")}start(){if(this._camera=this.object3D.getOrAddComponent(Zi),!this._camera){console.error("FirstPersonCameraController need camera");return}if(!this.focus){console.error("FirstPersonCameraController need target");return}_.inputSystem.addEventListener(L.POINTER_WHEEL,this.mouseWheel,this),_.inputSystem.addEventListener(L.POINTER_UP,this.mouseUp,this),_.inputSystem.addEventListener(L.POINTER_DOWN,this.mouseDown,this)}mouseDown(e){_.inputSystem.addEventListener(L.POINTER_MOVE,this.mouseMove,this)}mouseUp(e){_.inputSystem.removeEventListener(L.POINTER_MOVE,this.mouseMove,this)}mouseMove(e){let t=this.transform.localRotation;t.y+=e.movementX*.01,t.x+=e.movementY*.01,this.transform.localRotation=t}mouseWheel(e){this.distance+=_.inputSystem.wheelDelta*.1}onUpdate(){let e=new p;this._camera.transform.forward.scaleToRef(this.distance,e);var t=this.focus.transform.worldPosition;this._camera.transform.localPosition=t}destroy(e){_.inputSystem.removeEventListener(L.POINTER_WHEEL,this.mouseWheel,this),_.inputSystem.removeEventListener(L.POINTER_UP,this.mouseUp,this),_.inputSystem.removeEventListener(L.POINTER_DOWN,this.mouseDown,this),super.destroy(e)}}var Ze=(i=>(i[i.Key_BackSpace=8]="Key_BackSpace",i[i.Key_Tab=9]="Key_Tab",i[i.Key_Clear=12]="Key_Clear",i[i.Key_Enter=13]="Key_Enter",i[i.Key_Shift_L=16]="Key_Shift_L",i[i.Key_Control_L=17]="Key_Control_L",i[i.Key_Alt_L=18]="Key_Alt_L",i[i.Key_Pause=19]="Key_Pause",i[i.Key_CapsLock=20]="Key_CapsLock",i[i.Key_Escape=21]="Key_Escape",i[i.Key_Esc=27]="Key_Esc",i[i.Key_Space=32]="Key_Space",i[i.Key_Prior=33]="Key_Prior",i[i.Key_Next=34]="Key_Next",i[i.Key_End=35]="Key_End",i[i.Key_Home=36]="Key_Home",i[i.Key_Left=37]="Key_Left",i[i.Key_Up=38]="Key_Up",i[i.Key_Right=39]="Key_Right",i[i.Key_Down=40]="Key_Down",i[i.Key_Select=41]="Key_Select",i[i.Key_Print=42]="Key_Print",i[i.Key_Execute=43]="Key_Execute",i[i.Key_Insert=45]="Key_Insert",i[i.Key_Delete=46]="Key_Delete",i[i.Key_Help=47]="Key_Help",i[i.Key_0=48]="Key_0",i[i.Key_1=49]="Key_1",i[i.Key_2=50]="Key_2",i[i.Key_3=51]="Key_3",i[i.Key_4=52]="Key_4",i[i.Key_5=53]="Key_5",i[i.Key_6=54]="Key_6",i[i.Key_7=55]="Key_7",i[i.Key_8=56]="Key_8",i[i.Key_9=57]="Key_9",i[i.Key_A=65]="Key_A",i[i.Key_B=66]="Key_B",i[i.Key_C=67]="Key_C",i[i.Key_D=68]="Key_D",i[i.Key_E=69]="Key_E",i[i.Key_F=70]="Key_F",i[i.Key_G=71]="Key_G",i[i.Key_H=72]="Key_H",i[i.Key_I=73]="Key_I",i[i.Key_J=74]="Key_J",i[i.Key_K=75]="Key_K",i[i.Key_L=76]="Key_L",i[i.Key_M=77]="Key_M",i[i.Key_N=78]="Key_N",i[i.Key_O=79]="Key_O",i[i.Key_P=80]="Key_P",i[i.Key_Q=81]="Key_Q",i[i.Key_R=82]="Key_R",i[i.Key_S=83]="Key_S",i[i.Key_T=84]="Key_T",i[i.Key_U=85]="Key_U",i[i.Key_V=86]="Key_V",i[i.Key_W=87]="Key_W",i[i.Key_X=88]="Key_X",i[i.Key_Y=89]="Key_Y",i[i.Key_Z=90]="Key_Z",i[i.Key_KP_0=96]="Key_KP_0",i[i.Key_KP_1=97]="Key_KP_1",i[i.Key_KP_2=98]="Key_KP_2",i[i.Key_KP_3=99]="Key_KP_3",i[i.Key_KP_4=100]="Key_KP_4",i[i.Key_KP_5=101]="Key_KP_5",i[i.Key_KP_6=102]="Key_KP_6",i[i.Key_KP_7=103]="Key_KP_7",i[i.Key_KP_8=104]="Key_KP_8",i[i.Key_KP_9=105]="Key_KP_9",i[i.Key_Multiply=106]="Key_Multiply",i[i.Key_Add=107]="Key_Add",i[i.Key_Separator=108]="Key_Separator",i[i.Key_Subtract=109]="Key_Subtract",i[i.Key_Decimal=110]="Key_Decimal",i[i.Key_Divide=111]="Key_Divide",i[i.Key_F1=112]="Key_F1",i[i.Key_F2=113]="Key_F2",i[i.Key_F3=114]="Key_F3",i[i.Key_F4=115]="Key_F4",i[i.Key_F5=116]="Key_F5",i[i.Key_F6=117]="Key_F6",i[i.Key_F7=118]="Key_F7",i[i.Key_F8=119]="Key_F8",i[i.Key_F9=120]="Key_F9",i[i.Key_F10=121]="Key_F10",i[i.Key_F11=122]="Key_F11",i[i.Key_F12=123]="Key_F12",i[i.Key_F13=124]="Key_F13",i[i.Key_F14=125]="Key_F14",i[i.Key_F15=126]="Key_F15",i[i.Key_F16=127]="Key_F16",i[i.Key_F17=128]="Key_F17",i[i.Key_F18=129]="Key_F18",i[i.Key_F19=130]="Key_F19",i[i.Key_F20=131]="Key_F20",i[i.Key_F21=132]="Key_F21",i[i.Key_F22=133]="Key_F22",i[i.Key_F23=134]="Key_F23",i[i.Key_F24=135]="Key_F24",i[i.Key_Num_Lock=136]="Key_Num_Lock",i[i.Key_Scroll_Lock=137]="Key_Scroll_Lock",i))(Ze||{});class mp extends Ee{constructor(){super(),n(this,"moveSpeed",2),n(this,"targetPos",new p(0,0,10)),n(this,"lookAtPos",new p(0,0,0)),n(this,"config",{shiftMoveScale:20}),n(this,"_moveScale",1),n(this,"_dir"),n(this,"_mouseFactory",25),n(this,"_factory",1.5),n(this,"_mouseDown",!1),n(this,"_lastPos"),n(this,"_keyState"),this._lastPos=new p,this._keyState={front:!1,back:!1,left:!1,right:!1,q:!1,e:!1},this.setCamera(new p(0,0,100),new p(0,0,0))}setCamera(e,t){this.targetPos.copyFrom(e),this.lookAtPos.copyFrom(t),this.Reset()}start(){_.inputSystem.addEventListener(L.POINTER_WHEEL,this.mouseWheel,this),_.inputSystem.addEventListener(L.POINTER_UP,this.mouseUp,this),_.inputSystem.addEventListener(L.POINTER_DOWN,this.mouseDown,this),_.inputSystem.addEventListener(Qt.KEY_UP,this.keyUp,this),_.inputSystem.addEventListener(Qt.KEY_DOWN,this.keyDown,this),this.transform.lookAt(this.targetPos,this.lookAtPos)}mouseWheel(e){}keyUp(e){switch(e.keyCode){case Ze.Key_W:this._keyState.front=!1;break;case Ze.Key_S:this._keyState.back=!1;break;case Ze.Key_A:this._keyState.left=!1;break;case Ze.Key_D:this._keyState.right=!1;break;case Ze.Key_Shift_L:this._moveScale=1;break;case Ze.Key_Q:this._keyState.q=!1;break;case Ze.Key_E:this._keyState.e=!1;break;case Ze.Key_F:this.transform.lookAt(this.targetPos,this.lookAtPos);break}}keyDown(e){switch(e.keyCode){case Ze.Key_W:this._keyState.front=!0;break;case Ze.Key_S:this._keyState.back=!0;break;case Ze.Key_A:this._keyState.left=!0;break;case Ze.Key_D:this._keyState.right=!0;break;case Ze.Key_Q:this._keyState.q=!0;break;case Ze.Key_E:this._keyState.e=!0;break;case Ze.Key_Shift_L:this._moveScale=this.config.shiftMoveScale}}Reset(){this._lastPos.x=_.inputSystem.mouseLastX,this._lastPos.y=_.inputSystem.mouseLastY}mouseDown(e){this.Reset(),this._mouseDown=!0}mouseUp(e){this.Reset(),this._mouseDown=!1}get factory(){return this._factory}set factory(e){this._factory=e}get mouseFactory(){return this._mouseFactory}set mouseFactory(e){this._mouseFactory=e}internal(e,t,r){return(t-e)*r}onUpdate(){let e=this.transform,t=J(he.delta,0,.016);if(this._mouseDown&&(e.rotationY-=this.internal(e.rotationY+(_.inputSystem.mouseLastX-this._lastPos.x)*.25,e.rotationY,t*this._mouseFactory),e.rotationX-=this.internal(e.rotationX+(_.inputSystem.mouseLastY-this._lastPos.y)*.25,e.rotationX,t*this._mouseFactory),this.Reset()),this._keyState.front){let r=e.forward;e.x-=this.internal(e.x+r.x*this.moveSpeed*this._moveScale,e.x,t*this._factory),e.y-=this.internal(e.y+r.y*this.moveSpeed*this._moveScale,e.y,t*this._factory),e.z-=this.internal(e.z+r.z*this.moveSpeed*this._moveScale,e.z,t*this._factory)}if(this._keyState.back){let r=e.forward;e.x+=this.internal(e.x+r.x*this.moveSpeed*this._moveScale,e.x,t*this._factory),e.y+=this.internal(e.y+r.y*this.moveSpeed*this._moveScale,e.y,t*this._factory),e.z+=this.internal(e.z+r.z*this.moveSpeed*this._moveScale,e.z,t*this._factory)}if(this._keyState.left){let r=e.left;e.x+=this.internal(e.x+r.x*this.moveSpeed*this._moveScale,e.x,t*this._factory),e.y+=this.internal(e.y+r.y*this.moveSpeed*this._moveScale,e.y,t*this._factory),e.z+=this.internal(e.z+r.z*this.moveSpeed*this._moveScale,e.z,t*this._factory)}if(this._keyState.right){let r=e.left;e.x-=this.internal(e.x+r.x*this.moveSpeed*this._moveScale,e.x,t*this._factory),e.y-=this.internal(e.y+r.y*this.moveSpeed*this._moveScale,e.y,t*this._factory),e.z-=this.internal(e.z+r.z*this.moveSpeed*this._moveScale,e.z,t*this._factory)}this._keyState.q&&(e.y=Ii(e.y,e.y-this.moveSpeed*this._moveScale,t*this._factory)),this._keyState.e&&(e.y=Ii(e.y,e.y+this.moveSpeed*this._moveScale,t*this._factory))}destroy(e){_.inputSystem.removeEventListener(L.POINTER_WHEEL,this.mouseWheel,this),_.inputSystem.removeEventListener(L.POINTER_UP,this.mouseUp,this),_.inputSystem.removeEventListener(L.POINTER_DOWN,this.mouseDown,this),_.inputSystem.removeEventListener(Qt.KEY_UP,this.keyUp,this),_.inputSystem.removeEventListener(Qt.KEY_DOWN,this.keyDown,this),super.destroy(e)}}class Qi{static add(e,t,r){return r||(r=new p),r.x=e.x+t.x,r.y=e.y+t.y,r.z=e.z+t.z,r}static sub(e,t,r){return r||(r=new p),r.x=e.x-t.x,r.y=e.y-t.y,r.z=e.z-t.z,r}static mul(e,t,r){return r||(r=new p),r.x=e.x*t.x,r.y=e.y*t.y,r.z=e.z*t.z,r}static mulScale(e,t,r){return r||(r=new p),r.x=e.x*t,r.y=e.y*t,r.z=e.z*t,r}static div(e,t,r){return r||(r=new p),r.x=e.x/t.x,r.y=e.y/t.y,r.z=e.z/t.z,r}static normalize(e){return e.clone().normalize()}static dot(e,t){let r=p.HELP_0;return r.copyFrom(e),r.dotProduct(t)}static calculateVectorAngle_xz(e,t){return Math.acos((e.x*t.x+e.y*t.y)/Math.sqrt((e.x*e.x+e.y*e.y)*(t.x*t.x+t.y*t.y)))}static distance(e,t){return p.distance(e,t)}static getRandomXYZ(e=-100,t=100){return new p(Math.random()*(t-e)+e,Math.random()*(t-e)+e,Math.random()*(t-e)+e)}static getRandomV3(e=-100,t=100,r,a){return new p(Math.random()*t+e,Math.random()*a+r,Math.random()*t+e)}static sphere(e){let t=e*Math.random(),r=new p(Math.random()*1-.5,Math.random()*1-.5,Math.random()*1-.5);return r.normalize(),r.scaleBy(t),r}static sphereXYZ(e,t,r=1,a=1,s=1){let o=e+(t-e)*Math.random(),l=new p(Math.random()*r-r*.5,Math.random()*a-a*.5,Math.random()*s-s*.5);return l.normalize(),l.scaleBy(o),l}}class Ap extends Ee{constructor(){super(),n(this,"camera"),n(this,"minDistance",.1),n(this,"maxDistance",500),n(this,"rollSmooth",15),n(this,"dragSmooth",20),n(this,"wheelSmooth",10),n(this,"wheelStep",.002),n(this,"mouseRightFactor",.5),n(this,"mouseLeftFactor",20),n(this,"smooth",!0),n(this,"_wheelStep",.002),n(this,"_distance",0),n(this,"distance",10),n(this,"_roll",0),n(this,"roll",0),n(this,"_pitch",0),n(this,"pitch",0),n(this,"_currentPos"),n(this,"_targetPos"),n(this,"_mouseLeftDown",!1),n(this,"_mouseRightDown",!1),n(this,"_bottomClamp",89.99),n(this,"_topClamp",-89.99),n(this,"_tempDir",new p),n(this,"_tempPos",new p),this._currentPos=new f.Object3D,this._targetPos=new f.Object3D}start(){this.camera=this.object3D.getOrAddComponent(Zi),_.inputSystem.addEventListener(L.POINTER_DOWN,this.onMouseDown,this),_.inputSystem.addEventListener(L.POINTER_MOVE,this.onMouseMove,this),_.inputSystem.addEventListener(L.POINTER_UP,this.onMouseUp,this),_.inputSystem.addEventListener(L.POINTER_WHEEL,this.onMouseWheel,this)}setCamera(e,t,r,a){this.roll=e,this.pitch=t,this.distance=r,this.maxDistance<r*1.5&&(this.maxDistance=r*1.5),a&&this._targetPos.transform.localPosition.copy(a)}focusByBounds(e){let t=Kt.genMeshBounds(e);this.target=t.center}set target(e){this._targetPos.transform.localPosition.copy(e)}get target(){return this._targetPos.transform.localPosition}onMouseWheel(e){this.enable&&(this._wheelStep=this.wheelStep*Qi.distance(this._currentPos.transform.worldPosition,this.camera.transform.worldPosition)/10,this.distance-=_.inputSystem.wheelDelta*this._wheelStep,this.distance=J(this.distance,this.minDistance,this.maxDistance))}onMouseDown(e){if(this.enable)switch(e.mouseCode){case 0:this._mouseLeftDown=!0;break;case 1:break;case 2:this._mouseRightDown=!0;break}}onMouseUp(e){this._mouseLeftDown=!1,this._mouseRightDown=!1}onMouseMove(e){if(this.enable){if(this._mouseRightDown){let t=.25,r=this.camera.transform.forward;Qi.mulScale(r,e.movementY*t*this.camera.aspect,p.HELP_1),this._targetPos.x+=p.HELP_1.x*this.mouseRightFactor,this._targetPos.z+=p.HELP_1.z*this.mouseRightFactor;let a=this.camera.transform.right;Qi.mulScale(a,-e.movementX*t,p.HELP_1),this._targetPos.x-=p.HELP_1.x*this.mouseRightFactor,this._targetPos.z-=p.HELP_1.z*this.mouseRightFactor}this._mouseLeftDown&&(this.roll-=e.movementX*he.delta*.001*this.mouseLeftFactor,this.pitch-=e.movementY*he.delta*.001*this.mouseLeftFactor,this.pitch=J(this.pitch,this._topClamp,this._bottomClamp))}}onBeforeUpdate(e){if(!this.enable)return;let t=J(he.delta,0,.016);this.smooth?(this._currentPos.x+=(this._targetPos.x-this._currentPos.x)*t*this.dragSmooth,this._currentPos.y+=(this._targetPos.y-this._currentPos.y)*t*this.dragSmooth,this._currentPos.z+=(this._targetPos.z-this._currentPos.z)*t*this.dragSmooth,this._distance+=(this.distance-this._distance)*t*this.wheelSmooth,this._roll+=(this.roll-this._roll)*t*this.rollSmooth,this._pitch+=(this.pitch-this._pitch)*t*this.rollSmooth):(this._currentPos.x=this._targetPos.x,this._currentPos.y=this._targetPos.y,this._currentPos.z=this._targetPos.z,this._distance=this.distance,this._roll=this.roll,this._pitch=this.pitch),this._tempDir.set(0,0,1);let r=K.HELP_0;r.fromEulerAngles(this._pitch,this._roll,0),this._tempDir.applyQuaternion(r),this._tempPos=Qi.mulScale(this._tempDir,this._distance,this._tempPos),this._tempPos.add(this._currentPos.transform.localPosition,this._tempPos),this.transform.lookAt(this._tempPos,this._currentPos.transform.localPosition,p.UP),this.camera.lookTarget.copy(this._currentPos.transform.localPosition)}destroy(e){_.inputSystem.removeEventListener(L.POINTER_DOWN,this.onMouseDown,this),_.inputSystem.removeEventListener(L.POINTER_MOVE,this.onMouseMove,this),_.inputSystem.removeEventListener(L.POINTER_UP,this.onMouseUp,this),_.inputSystem.removeEventListener(L.POINTER_WHEEL,this.onMouseWheel,this),super.destroy(e),this.camera=null}}class _p extends Ee{constructor(){super(),n(this,"_camera"),n(this,"autoRotate",!1),n(this,"autoRotateSpeed",.1),n(this,"rotateFactor",.5),n(this,"zoomFactor",.1),n(this,"panFactor",.25),n(this,"_smooth",5),n(this,"_minDistance",1),n(this,"_maxDistance",1e5),n(this,"_maxPolarAngle",90),n(this,"_minPolarAngle",-90),n(this,"_target",new p(0,0,0)),n(this,"_cTarget",new p(0,0,0)),n(this,"_position",new p(0,0,0)),n(this,"_cPosition",new p(0,0,0)),n(this,"_spherical",new vp),n(this,"_isMouseDown",!1),n(this,"_lastMouseX",-1),n(this,"_lastMouseY",-1),n(this,"_isPanning",!1)}get target(){return this._target}set target(e){this._target=e}get smooth(){return this._smooth}set smooth(e){this._smooth=Math.max(e,1)}get minDistance(){return this._minDistance}set minDistance(e){this._minDistance=J(e,2e-6,this._maxDistance)}get maxDistance(){return this._maxDistance}set maxDistance(e){this._maxDistance=J(e,this._minDistance,1/0)}get minPolarAngle(){return this._minPolarAngle}set minPolarAngle(e){this._minPolarAngle=J(e,-90,this._maxPolarAngle)}get maxPolarAngle(){return this._maxPolarAngle}set maxPolarAngle(e){this._maxPolarAngle=J(e,this._minPolarAngle,90)}start(){this._camera=this.object3D.getComponent(Zi),this._position=this.object3D.transform.localPosition.clone(),this._cPosition=this._position.clone(),this._target=this._camera.lookTarget.clone(),this._cTarget=this._target.clone(),this._spherical.setCoords(this._position.x-this._target.x,this._position.y-this._target.y,this._position.z-this._target.z),this._camera.lookAt(this._cPosition,this._cTarget,p.UP),this.addEventListener()}onEnable(){this.addEventListener()}onDisable(){this.removeEventListener()}onUpdate(){let e=this._isPanning?1:this.smooth,t=!1;this._cPosition.equals(this.object3D.transform.localPosition)||(this._position.copyFrom(this.object3D.transform.localPosition),e=1,t=!0),this._cTarget.equals(this._target)||(this._cTarget.copyFrom(this._target),e=1,t=!0),t?this._spherical.setCoords(this._position.x-this._target.x,this._position.y-this._target.y,this._position.z-this._target.z):!this._isMouseDown&&this.autoRotate&&(this._spherical.theta-=this.autoRotateSpeed*Math.PI/180,this.updateCamera());let r=(this._position.x-this._cPosition.x)/e,a=(this._position.y-this._cPosition.y)/e,s=(this._position.z-this._cPosition.z)/e;this._cPosition.x=Math.abs(r)>1e-10?this._cPosition.x+r:this._position.x,this._cPosition.y=Math.abs(a)>1e-10?this._cPosition.y+a:this._position.y,this._cPosition.z=Math.abs(s)>1e-10?this._cPosition.z+s:this._position.z,this._camera.lookAt(this._cPosition,this._cTarget,p.UP)}onWheel(e){e.deltaY=J(e.deltaY,-this._spherical.radius,this._spherical.radius),this._spherical.radius+=e.deltaY*this.zoomFactor,this._spherical.radius=J(this._spherical.radius,this.minDistance,this.maxDistance),this.updateCamera()}onPointerDown(e){this._isMouseDown=!0,this._lastMouseX=e.mouseX,this._lastMouseY=e.mouseY,e.mouseCode===2&&(this._isPanning=!0)}onPointerMove(e){if(!this._isMouseDown||!this.enable)return;let t=e.mouseX,r=e.mouseY;if(e.mouseCode===0&&this._lastMouseX>0&&this._lastMouseY>0){const a=-(t-this._lastMouseX)*this.rotateFactor,s=(r-this._lastMouseY)*this.rotateFactor;this._spherical.theta+=a*Math.PI/180,this._spherical.phi-=s*Math.PI/180,this._spherical.phi=J(this._spherical.phi,this.minPolarAngle,this.maxPolarAngle),this.updateCamera()}else e.mouseCode===2&&(Qi.mulScale(this.object3D.transform.up,e.movementY*this.panFactor*this._camera.aspect,p.HELP_1),this._target.y+=p.HELP_1.y,Qi.mulScale(this.object3D.transform.right,-e.movementX*this.panFactor,p.HELP_1),this._target.x-=p.HELP_1.x,this._target.z-=p.HELP_1.z,this._cTarget.copyFrom(this._target),this.updateCamera());this._lastMouseX=t,this._lastMouseY=r}onPointerUp(e){this._isMouseDown=!1,e.mouseCode===2&&(this._isPanning=!1)}onPointerLeave(){this._isMouseDown=!1,this._isPanning=!1}updateCamera(){this._spherical.makeSafe();let e=this._spherical.getCoords();this._position.set(e.x+this._target.x,e.y+this._target.y,e.z+this._target.z)}addEventListener(){_.inputSystem.addEventListener(L.POINTER_WHEEL,this.onWheel,this),_.inputSystem.addEventListener(L.POINTER_DOWN,this.onPointerDown,this),_.inputSystem.addEventListener(L.POINTER_MOVE,this.onPointerMove,this),_.inputSystem.addEventListener(L.POINTER_UP,this.onPointerUp,this),_.inputSystem.addEventListener(L.POINTER_OUT,this.onPointerLeave,this)}removeEventListener(){_.inputSystem.removeEventListener(L.POINTER_WHEEL,this.onWheel,this),_.inputSystem.removeEventListener(L.POINTER_DOWN,this.onPointerDown,this),_.inputSystem.removeEventListener(L.POINTER_MOVE,this.onPointerMove,this),_.inputSystem.removeEventListener(L.POINTER_UP,this.onPointerUp,this),_.inputSystem.removeEventListener(L.POINTER_OUT,this.onPointerLeave,this)}}class vp{constructor(e=1,t=0,r=0){return n(this,"radius"),n(this,"phi"),n(this,"theta"),n(this,"coords"),this.radius=e,this.phi=t,this.theta=r,this.coords=new p,this}set(e,t,r){return this.radius=e,this.phi=t,this.theta=r,this}makeSafe(){return this.phi=Math.max(2e-4,Math.min(Math.PI-2e-4,this.phi)),this}setFromVector3(e){return this.setCoords(e.x,e.y,e.z)}setCoords(e,t,r){return this.radius=Math.sqrt(e*e+t*t+r*r),this.radius===0?(this.theta=0,this.phi=0):(this.theta=Math.atan2(e,r),this.phi=Math.acos(J(t/this.radius,-1,1))),this}getCoords(){const e=Math.sin(this.phi)*this.radius;return this.coords.x=e*Math.sin(this.theta),this.coords.y=Math.cos(this.phi)*this.radius,this.coords.z=e*Math.cos(this.theta),this.coords}}class xp extends Ee{constructor(){super(),n(this,"focus"),n(this,"_rotation",new p(45,0,0)),n(this,"distance",5),n(this,"_camera")}start(){if(this._camera=this.object3D.getOrAddComponent(Zi),!this._camera){console.error("ThirdPersonCameraController need camera");return}if(!this.focus){console.error("ThirdPersonCameraController need target");return}_.inputSystem.addEventListener(L.POINTER_WHEEL,this.mouseWheel,this),_.inputSystem.addEventListener(L.POINTER_UP,this.mouseUp,this),_.inputSystem.addEventListener(L.POINTER_DOWN,this.mouseDown,this)}mouseDown(e){_.inputSystem.addEventListener(L.POINTER_MOVE,this.mouseMove,this)}mouseUp(e){_.inputSystem.removeEventListener(L.POINTER_MOVE,this.mouseMove,this)}mouseMove(e){this._rotation.y+=e.movementX*.01,this._rotation.x+=e.movementY*.01}mouseWheel(e){this.distance+=_.inputSystem.wheelDelta*.1}onUpdate(){let e=new p;this._camera.transform.forward.scaleToRef(this.distance,e);var t=this.focus.transform.worldPosition;this._camera.transform.localPosition=t.subtract(e)}destroy(e){_.inputSystem.removeEventListener(L.POINTER_WHEEL,this.mouseWheel,this),_.inputSystem.removeEventListener(L.POINTER_UP,this.mouseUp,this),_.inputSystem.removeEventListener(L.POINTER_DOWN,this.mouseDown,this),super.destroy(e)}}var Me=(i=>(i[i.NORMAL=0]="NORMAL",i[i.DOWN=1]="DOWN",i[i.OVER=2]="OVER",i[i.DISABLE=3]="DISABLE",i))(Me||{});let Oc=Math.PI*2;class Vi{constructor(e=1,t=0,r=0,a=1,s=0,o=0){n(this,"a"),n(this,"b"),n(this,"c"),n(this,"d"),n(this,"tx"),n(this,"ty"),this.a=e,this.b=t,this.c=r,this.d=a,this.tx=s,this.ty=o}clone(){return new Vi(this.a,this.b,this.c,this.d,this.tx,this.ty)}concat(e){let t=this.a,r=this.c,a=this.tx;this.a=t*e.a+this.b*e.c,this.b=t*e.b+this.b*e.d,this.c=r*e.a+this.d*e.c,this.d=r*e.b+this.d*e.d,this.tx=a*e.a+this.ty*e.c+e.tx,this.ty=a*e.b+this.ty*e.d+e.ty}copyFrom(e){return this.a=e.a,this.b=e.b,this.c=e.c,this.d=e.d,this.tx=e.tx,this.ty=e.ty,this}identity(){return this.a=this.d=1,this.b=this.c=this.tx=this.ty=0,this}invert(){this._invertInto(this)}rotate(e){if(e=+e,e!==0){e=e*_e;let t=Math.cos(e),r=Math.sin(e),a=this.a,s=this.b,o=this.c,l=this.d,h=this.tx,u=this.ty;this.a=a*t-s*r,this.b=a*r+s*t,this.c=o*t-l*r,this.d=o*r+l*t,this.tx=h*t-u*r,this.ty=h*r+u*t}}scale(e,t){e!==1&&(this.a*=e,this.c*=e,this.tx*=e),t!==1&&(this.b*=t,this.d*=t,this.ty*=t)}setTo(e,t,r,a,s,o){return this.a=e,this.b=t,this.c=r,this.d=a,this.tx=s,this.ty=o,this}transformPoint(e,t,r){let a=this.a*e+this.c*t+this.tx,s=this.b*e+this.d*t+this.ty;return r?(r.setTo(a,s,0,1),r):new p(a,s,0,1)}setTranslate(e,t){this.tx=e,this.ty=t}translate(e,t){this.tx+=e,this.ty+=t}mul(e){let t=this,r=e,a=t.a,s=t.b,o=t.c,l=t.d,h=t.tx,u=t.ty,c=r.a,d=r.b,g=r.c,m=r.d,A=r.tx,v=r.ty;d!==0||g!==0?(this.a=a*c+s*g,this.b=a*d+s*m,this.c=o*c+l*g,this.d=o*d+l*m,this.tx=c*h+g*u+A,this.ty=d*h+m*u+v):(this.a=a*c,this.b=s*m,this.c=o*c,this.d=l*m,this.tx=c*h+A,this.ty=m*u+v)}equals(e){return this.a==e.a&&this.b==e.b&&this.c==e.c&&this.d==e.d&&this.tx==e.tx&&this.ty==e.ty}prepend(e,t,r,a,s,o){let l=this.tx;if(e!=1||t!=0||r!=0||a!=1){let h=this.a,u=this.c;this.a=h*e+this.b*r,this.b=h*t+this.b*a,this.c=u*e+this.d*r,this.d=u*t+this.d*a}return this.tx=l*e+this.ty*r+s,this.ty=l*t+this.ty*a+o,this}append(e){let t=this.a,r=this.b,a=this.c,s=this.d;return(e.a!=1||e.b!=0||e.c!=0||e.d!=1)&&(this.a=e.a*t+e.b*a,this.b=e.a*r+e.b*s,this.c=e.c*t+e.d*a,this.d=e.c*r+e.d*s),this.tx=e.tx*t+e.ty*a+this.tx,this.ty=e.tx*r+e.ty*s+this.ty,this}deltaTransformPoint(e){let t=this,r=t.a*e.x+t.c*e.y,a=t.b*e.x+t.d*e.y;return new p(r,a)}toString(){return"(a="+this.a+", b="+this.b+", c="+this.c+", d="+this.d+", tx="+this.tx+", ty="+this.ty+")"}createBox(e,t,r=0,a=0,s=0){let o=this;if(r!==0){r=r*_e;let l=Math.cos(r),h=Math.sin(r);o.a=l*e,o.b=h*t,o.c=-h*e,o.d=l*t}else o.a=e,o.b=0,o.c=0,o.d=t;o.tx=a,o.ty=s}createGradientBox(e,t,r=0,a=0,s=0){this.createBox(e/1638.4,t/1638.4,r,a+e/2,s+t/2)}_invertInto(e){let t=this.a,r=this.b,a=this.c,s=this.d,o=this.tx,l=this.ty;if(r==0&&a==0){e.b=e.c=0,t==0||s==0?e.a=e.d=e.tx=e.ty=0:(t=e.a=1/t,s=e.d=1/s,e.tx=-t*o,e.ty=-s*l);return}let h=t*s-r*a;if(h==0){e.identity();return}h=1/h;let u=e.a=s*h;r=e.b=-r*h,a=e.c=-a*h,s=e.d=t*h,e.tx=-(u*o+a*l),e.ty=-(r*o+s*l)}getScaleX(){let e=this;if(e.a==1&&e.b==0)return 1;let t=Math.sqrt(e.a*e.a+e.b*e.b);return this.getDeterminant()<0?-t:t}getScaleY(){let e=this;if(e.c==0&&e.d==1)return 1;let t=Math.sqrt(e.c*e.c+e.d*e.d);return this.getDeterminant()<0?-t:t}getSkewX(){return Math.atan2(this.d,this.c)-Math.PI/2}getSkewY(){return Math.atan2(this.b,this.a)}updateScaleAndRotation(e,t,r,a){if((r==0||r==Oc)&&(a==0||a==Oc)){this.a=e,this.b=this.c=0,this.d=t;return}r=r*_e,a=a*_e;let s=Math.cos(r),o=Math.sin(r);r==a?(this.a=s*e,this.b=o*e):(this.a=Math.cos(a)*e,this.b=Math.sin(a)*e),this.c=-o*t,this.d=s*t}preMultiplyInto(e,t){let r=e.a*this.a,a=0,s=0,o=e.d*this.d,l=e.tx*this.a+this.tx,h=e.ty*this.d+this.ty;(e.b!==0||e.c!==0||this.b!==0||this.c!==0)&&(r+=e.b*this.c,o+=e.c*this.b,a+=e.a*this.b+e.b*this.d,s+=e.c*this.a+e.d*this.c,l+=e.ty*this.c,h+=e.tx*this.b),t.a=r,t.b=a,t.c=s,t.d=o,t.tx=l,t.ty=h}$transformBounds(e){let t=this.a,r=this.b,a=this.c,s=this.d,o=this.tx,l=this.ty,h=e.x,u=e.y,c=h+e.width,d=u+e.height,g=t*h+a*u+o,m=r*h+s*u+l,A=t*c+a*u+o,v=r*c+s*u+l,y=t*c+a*d+o,C=r*c+s*d+l,S=t*h+a*d+o,T=r*h+s*d+l,D=0;g>A&&(D=g,g=A,A=D),y>S&&(D=y,y=S,S=D),e.x=Math.floor(g<y?g:y),e.width=Math.ceil((A>S?A:S)-e.x),m>v&&(D=m,m=v,v=D),C>T&&(D=C,C=T,T=D),e.y=Math.floor(m<C?m:C),e.height=Math.ceil((v>T?v:T)-e.y)}getDeterminant(){return this.a*this.d-this.b*this.c}}class ua extends Ee{constructor(){super(...arguments),n(this,"isGUICanvas",!0),n(this,"index",0)}addChild(e){return this.object3D.addChild(e),this}removeChild(e){return this.object3D.removeChild(e),this}cloneTo(e){e.getOrAddComponent(ua).copyComponent(this)}copyComponent(e){return e.index=e.index,this}}var Pe=(i=>(i[i.NONE=0]="NONE",i[i.POSITION=1]="POSITION",i[i.SPRITE=2]="SPRITE",i[i.COLOR=4]="COLOR",i[i.MAX=7]="MAX",i))(Pe||{});class Qn{constructor(e){n(this,"array"),n(this,"buffer"),this.buffer=new fe(e,0),this.array=new Float32Array(this.buffer.memory.shareDataBuffer)}}class Nc extends it{constructor(e){super(),n(this,"_attributeUV"),n(this,"_attributeVIndex"),n(this,"_faceIndexes"),n(this,"_uvSize",2),n(this,"_vIndexSize",1),n(this,"_posAttribute"),n(this,"_spriteAttribute"),n(this,"_colorAttribute"),n(this,"_onPositionChange",!0),n(this,"_onSpriteChange",!0),n(this,"_onColorChange",!0),n(this,"maxQuadCount"),this.maxQuadCount=e}updateBounds(e,t){let r=Number.MAX_VALUE*.1;return e=new p(-r,-r,-r),t=new p(r,r,r),this.bounds.setFromMinMax(e,t),this}get vPositionBuffer(){return this._onPositionChange&&(this._posAttribute.buffer.apply(),this._onPositionChange=!1),this._posAttribute.buffer}get vSpriteBuffer(){return this._onSpriteChange&&(this._spriteAttribute.buffer.apply(),this._onSpriteChange=!1),this._spriteAttribute.buffer}get vColorBuffer(){return this._onColorChange&&(this._colorAttribute.buffer.apply(),this._onColorChange=!1),this._colorAttribute.buffer}create(){this.createBuffer(),this.updateBounds();let e=this.maxQuadCount,t=[],r=[];for(let s=0;s<e;s++)t.push(...si.attUV);for(let s=0,o=this.maxQuadCount*si.vertexCount;s<o;s++)r[s]=s;this._attributeUV=new Float32Array(si.vertexCount*e*this._uvSize),this._attributeVIndex=new Float32Array(si.vertexCount*e*this._vIndexSize),this._attributeUV.set(t,0),this._attributeVIndex.set(r,0);let a=[];for(let s=0;s<e;s++)for(let o=0;o<si.indecies.length;o++){const l=si.indecies[o]+s*4;a.push(l)}return this._faceIndexes=new Uint32Array(e*6),this._faceIndexes.set(a,0),this.setIndices(this._faceIndexes),this.setAttribute(X.uv,this._attributeUV),this.setAttribute(X.vIndex,this._attributeVIndex),this.addSubGeometry({indexStart:0,indexCount:this._faceIndexes.length,vertexStart:0,index:0}),this}createBuffer(){let e=this.maxQuadCount;this._posAttribute=new Qn(e*4),this._spriteAttribute=new Qn(e*(4+4+2+2)),this._colorAttribute=new Qn(e*4)}fillQuad(e,t){e.dirtyAttributes&Pe.POSITION&&this.fillQuadPosition(e,t),e.dirtyAttributes&Pe.COLOR&&this.fillQuadColor(e,t),e.dirtyAttributes&Pe.SPRITE&&this.fillQuadSprite(e,t)}fillQuadPosition(e,t){Fc.setXYZW(this._posAttribute.array,e.z,e.left,e.bottom,e.right,e.top),this._onPositionChange=!0}fillQuadColor(e,t){let r=e.color,a=this._colorAttribute.array;Fc.setXYZW(a,e.z,r.r,r.g,r.b,r.a),this._onColorChange=!0}fillQuadSprite(e,t){let r=e.sprite,a=0,s=0;r.isSliced&&e.imageType==pr.Sliced&&(a=r.trimSize.x,a=(t.width-(r.offsetSize.z-r.trimSize.x))/a,s=r.trimSize.y,s=(t.height-(r.offsetSize.w-r.trimSize.y))/s);let o=r.guiTexture.dynamicId,l=r.uvRec,h=r.uvBorder,u=this._spriteAttribute.array,c=(4+4+2+2)*e.z;u[c+0]=l.x,u[c+1]=l.y,u[c+2]=l.z,u[c+3]=l.w,u[c+4]=h.x,u[c+5]=h.y,u[c+6]=h.z,u[c+7]=h.w,u[c+8]=a,u[c+9]=s,u[c+10]=o,u[c+11]=e.visible?1:0,this._onSpriteChange=!0}}class yp{static set(e,t,r,a,...s){let o=t*a+r;for(let l=0,h=s.length;l<h;l++)e[o+l]=s[l]}}class Fc extends yp{static setXYZW(e,t,r,a,s,o){this.set(e,t,0,4,r,a,s,o)}static setXYZ(e,t,r,a,s){this.set(e,t,0,4,r,a,s)}static setZ(e,t,r){this.set(e,t,3,4,r)}}class si{}n(si,"vertexCount",4),n(si,"attUV",[0,0,1,0,1,1,0,1]),n(si,"indecies",[0,1,2,0,2,3]);class kc{constructor(){n(this,"_textureMap",new Map),n(this,"_textureList",[])}build(e,t,r){let a=-1,s=-1;this._textureMap.clear(),this._textureList.length=0;let o=[],l=t.quadMaxCount-1,h;for(let u of e){let c=u.needUpdateQuads;o.length=0;const d=this.collectQuads(u.object3D,o);for(let g of d){g.z=++a;let m=g.sprite.guiTexture;if(!this._textureMap.has(m.staticId)&&(++s,this._textureMap.set(m.staticId,m),m.dynamicId=s,this._textureList[s]=m.texture,s>7)){console.warn("texture Count Exceeded the maximum limit of 7");break}if(g.cacheTextureId!=m.dynamicId&&(g.dirtyAttributes=Pe.MAX,g.cacheTextureId=m.dynamicId),(c||r)&&(g.dirtyAttributes=Pe.MAX),g.dirtyAttributes&Pe.POSITION&&g.applyTransform(u),g.dirtyAttributes&&g.writeToGeometry(t._geometry,u),a==l){h=!0;break}}if(h)break}return t._uiMaterial.setTextures(this._textureList),t._limitVertexCount=(a+1)*4,!h}collectQuads(e,t){t||(t=[]);let r=e.components.values();for(let a of r){let s=a;if(s.isUIShadow||!s.mainQuads)continue;let o=s.getShadowRender();o&&this.push(o.mainQuads,t),this.push(s.mainQuads,t)}return t}push(e,t){e&&e.length>0&&t.push(...e)}}const pt=class{static bindTextureArray(){let i="";for(let e=0;e<7;e++)i+=`
        @group(1) @binding(auto)
        var tex_${e}Sampler: sampler;
        @group(1) @binding(auto)
#if VideoTexture${e}
        var tex_${e}: texture_external;
#else
        var tex_${e}: texture_2d<f32>;
#endif
`;return i}static sampleTexture(i){return`
#if VideoTexture${i}
            let size = textureDimensions(tex_${i}).xy - 1;
            uv.y = 1.0 - uv.y;
            let iuv = vec2<i32>(uv * vec2<f32>(size));
            color = textureLoad(tex_${i}, iuv) ;
#else
            color = textureSampleLevel(tex_${i}, tex_${i}Sampler, uv, 0.0);
#endif        `}};let Hi=pt;n(Hi,"fs",`
        ${Bs}
        ${pt.bindTextureArray()}

        var<private> fragmentOutput: FragmentOutput;
        var<private> uvSlice: vec2<f32>;
        var<private> EPSILON: f32 = 0.001;
        
        fn sliceBorder(uv:f32, scale:f32, border:vec2<f32>) -> f32 
        {
            var s = uv * scale;
            if(s > border.x){
                s -= border.x;
                let centerPartMax = scale - border.x - border.y;
                let centerPartMin = 1.0 - border.x - border.y;
                if(s < centerPartMax){
                    s = border.x + (s / centerPartMax) * centerPartMin;
                }else{
                    s = s - centerPartMax + border.x + centerPartMin;
                }
            }
            return s;
        }

        fn isInsideAlpha(coord:vec2<f32>, rect:vec4<f32>, cornerRadius0:f32, fadeOutSize0:f32) -> f32
        {
            var minX = min(rect.x, rect.z);
            var maxX = max(rect.x, rect.z);
            var minY = min(rect.y, rect.w);
            var maxY = max(rect.y, rect.w);

            var cornerRadius = max(EPSILON, cornerRadius0);

            var center = vec2<f32>(minX + maxX, minY + maxY) * 0.5;
            var extents = vec2<f32>(maxX - minX, maxY - minY) * 0.5;

            cornerRadius = min(extents.x, cornerRadius);
            cornerRadius = min(extents.y, cornerRadius);
            
            var extendsMin = max(vec2<f32>(0.0), extents - cornerRadius);
            
            var toCenter = abs(coord - center);
            var outerDist = toCenter - extents;
            var innerDist = toCenter - extendsMin;
            
            if(innerDist.x <= 0 && innerDist.y <= 0){
                return 1.0;
            }else if(outerDist.x <= 0 && outerDist.y <= 0){
                var fadeOutPercent = clamp(fadeOutSize0, EPSILON, cornerRadius) / cornerRadius;
                innerDist = max(vec2(EPSILON), innerDist);
                var distance = min(cornerRadius, length(innerDist));
                var alpha = 1.0 - distance / cornerRadius;
                alpha /= fadeOutPercent;
                alpha = clamp(alpha, 0.0, 1.0);
                return alpha;
            }
            return 0.0;
        }
        
        @fragment
        fn FragMain( 
            @location(0) vUV: vec2<f32>,
            @location(1) vColor4: vec4<f32>,
            @location(2) vLocalPos: vec2<f32>,
            @location(3) vUvRec: vec4<f32>,
            @location(4) vUvBorder: vec4<f32>,
            @location(5) vUvSlice: vec2<f32>,
            @location(6) vTextureID: f32,
            @builtin(front_facing) face: bool,
            @builtin(position) fragCoord : vec4<f32> 
        ) -> FragmentOutput {

            var scissorAlpha = 1.0;
#if SCISSOR_ENABLE
            scissorAlpha = isInsideAlpha(
                vLocalPos.xy,
                materialUniform.scissorRect,
                materialUniform.scissorCornerRadius,
                materialUniform.scissorFadeOutSize);

            if(scissorAlpha < EPSILON){
                discard;
            }
#endif

            uvSlice = vUvSlice;
            
            var uv:vec2<f32> = vUV;
            if(uvSlice.x > 1.0){ uv.x = sliceBorder(uv.x, uvSlice.x, vUvBorder.xz);}
            if(uvSlice.y > 1.0){ uv.y = sliceBorder(uv.y, uvSlice.y, vUvBorder.yw);}
            uv = uv * vUvRec.zw + vUvRec.xy;
            
            var color = vec4<f32>(0.0,0.0,0.0,1.0);
            let texId = i32(vTextureID + 0.5);
            
            var texSize = vec2<i32>(0);
            var coord = vec2<i32>(0);
            
            if(texId == 0){
                ${pt.sampleTexture(0)}
            }else if(texId == 1){
                ${pt.sampleTexture(1)}
            }else if(texId == 2){
                ${pt.sampleTexture(2)}
            }else if(texId == 3){            
                ${pt.sampleTexture(3)}
            }else if(texId == 4){            
                ${pt.sampleTexture(4)}
            }else if(texId == 5){            
                ${pt.sampleTexture(5)}
            }else if(texId == 6){            
                ${pt.sampleTexture(6)}
            }
            color *= vColor4;
            color.a *= scissorAlpha;
            if(color.a < EPSILON)
            { 
                discard;
            }

            fragmentOutput.color = color;
            return fragmentOutput ;
        }`),n(Hi,"GUI_common_vs",`
        ${Es}
        ${Ta}

        struct VertexSpriteBuffer {
            vUvRec: vec4<f32>,
            vUvBorder: vec4<f32>,
            vUvSlice: vec2<f32>,
            vTextureID: f32,
            vVisible: f32
        }
                
        struct MaterialUniform{
            scissorRect:vec4<f32>,

            screenSize:vec2<f32>,
            guiSolution:vec2<f32>,
            
            scissorCornerRadius:f32,
            scissorFadeOutSize:f32,

            limitVertex:f32,
            pixelRatio:f32,
        }
        
        struct VertexOutput {
            @location(0) vUV: vec2<f32>,
            @location(1) vColor4: vec4<f32>,
            @location(2) vLocalPos: vec2<f32>,
            @location(3) vUvRec: vec4<f32>,
            @location(4) vUvBorder: vec4<f32>,
            @location(5) vUvSlice: vec2<f32>,
            @location(6) vTextureID: f32,
            
            @builtin(position) member: vec4<f32>
        };
        
         struct VertexInput{
            @builtin(instance_index) index : u32,
            @location(0) uv: vec2<f32>,
            @location(1) vIndex: f32,
        }

        @group(2) @binding(0)
        var<uniform> materialUniform : MaterialUniform;
        @group(3) @binding(1)
        var<storage, read> vPositionBuffer: array<vec4<f32>>;
        @group(3) @binding(2)
        var<storage, read> vSpriteBuffer: array<VertexSpriteBuffer>;
        @group(3) @binding(3)
        var<storage, read> vColorBuffer: array<vec4<f32>>;

        var<private> vertexOut: VertexOutput ;

        //quad: (left, bottom, right, top)
        //index: 0~3
        fn getVertexXY(quad:vec4<f32>, index:u32) -> vec2<f32>
        {
            var ret = vec2<f32>(0.0);
            if(index == 0 || index == 3){
                ret.x = quad.x;
            }else{
                ret.x = quad.z;
            }
            if(index == 0 || index == 1){
                ret.y = quad.w;
            }else{
                ret.y = quad.y;
            }
            return ret;
        }
    `),n(Hi,"GUI_shader_view",`
        ${pt.GUI_common_vs}

        @vertex
        fn VertMain( vertex:VertexInput ) -> VertexOutput {
            var _m = models.matrix[0];
            var _n = globalUniform.frame;
            
            let vertexIndex = vertex.vIndex;
            let quadIndex = u32(vertex.vIndex * 0.25);
            let vertexPosition = getVertexXY(vPositionBuffer[quadIndex], u32(vertexIndex) % 4u);
            var vSpriteData = vSpriteBuffer[quadIndex];
            
            var op = vec2<f32>(0.0001);
            let isValidVertex = vSpriteData.vVisible > 0.5 && vertexIndex < materialUniform.limitVertex;
            if(isValidVertex){
                op = 2.0 * vertexPosition * materialUniform.pixelRatio  / materialUniform.screenSize;
            }

            vertexOut.vLocalPos = vertexPosition;
            vertexOut.member = vec4<f32>(op.x, op.y, vertexIndex * 0.0001, 1.0);

            vertexOut.vUV = vec2<f32>(vertex.uv);
            vertexOut.vUvRec = vSpriteData.vUvRec;
            vertexOut.vUvBorder = vSpriteData.vUvBorder;
            vertexOut.vUvSlice = vSpriteData.vUvSlice;
            vertexOut.vTextureID = vSpriteData.vTextureID;
            vertexOut.vColor4 = vColorBuffer[quadIndex];

            return vertexOut;
         }
         
         ${pt.fs}
        `),n(Hi,"GUI_shader_world",`
        ${pt.GUI_common_vs}
        @vertex
        fn VertMain( vertex:VertexInput ) -> VertexOutput {
            var modelMatrix = models.matrix[vertex.index];
            
            let vertexIndex = vertex.vIndex;
            let quadIndex = u32(vertex.vIndex * 0.25);
            let vertexPosition = getVertexXY(vPositionBuffer[quadIndex], u32(vertexIndex) % 4u);
            var localPos = vec4<f32>(vertexPosition.xy, vertexIndex * 0.0001, 1.0) ;
            var op = vec4<f32>(0.0001);
            var vSpriteData = vSpriteBuffer[quadIndex];

            let isValidVertex = vSpriteData.vVisible > 0.5 && vertexIndex < materialUniform.limitVertex;
            if(isValidVertex){
                op = globalUniform.projMat * globalUniform.viewMat * modelMatrix * localPos ;
            }

            vertexOut.vLocalPos = vertexPosition;
            vertexOut.member = op;

            vertexOut.vUV = vec2<f32>(vertex.uv);
            vertexOut.vUvRec = vSpriteData.vUvRec;
            vertexOut.vUvBorder = vSpriteData.vUvBorder;
            vertexOut.vUvSlice = vSpriteData.vUvSlice;
            vertexOut.vTextureID = vSpriteData.vTextureID;
            vertexOut.vColor4 = vColorBuffer[quadIndex];

            return vertexOut;
         }
         
         ${pt.fs}

        `);class zc extends vi{constructor(e){super(),n(this,"_scissorRect"),n(this,"_screenSize",new $(1024,768)),n(this,"_scissorEnable",!1),n(this,"_videoTextureFlags",{}),N.register("GUI_shader_view",Hi.GUI_shader_view),N.register("GUI_shader_world",Hi.GUI_shader_world);let t=e==Nt.View?"GUI_shader_view":"GUI_shader_world",r=new He(t,t);r.setShaderEntry("VertMain","FragMain"),r.setUniformVector2("screenSize",this._screenSize),r.setUniformVector2("guiSolution",this._screenSize),r.setUniformVector4("scissorRect",new q),r.setUniformFloat("scissorCornerRadius",0),r.setUniformFloat("scissorFadeOutSize",0),r.setUniformFloat("limitVertex",0),r.setUniformFloat("pixelRatio",1);let a=r.shaderState;a.depthWriteEnabled=!1,r.blendMode=ve.ALPHA,r.depthCompare=e==Nt.View?_t.always:_t.less_equal,r.cullMode=ui.back,this.defaultPass=r}setLimitVertex(e){this.defaultPass.setUniformFloat("limitVertex",e)}setGUISolution(e,t){this.defaultPass.setUniformVector2("guiSolution",e),this.defaultPass.setUniformFloat("pixelRatio",t)}setScissorRect(e,t,r,a){this._scissorRect||(this._scissorRect=new q),this._scissorRect.set(e,t,r,a),this.defaultPass.setUniformVector4("scissorRect",this._scissorRect)}setScissorEnable(e){this._scissorEnable!=e&&(this._scissorEnable=e,e?this.defaultPass.setDefine("SCISSOR_ENABLE",!0):this.defaultPass.deleteDefine("SCISSOR_ENABLE"),this.defaultPass.noticeValueChange())}setScissorCorner(e,t){this.defaultPass.setUniformFloat("scissorCornerRadius",e),this.defaultPass.setUniformFloat("scissorFadeOutSize",t)}setScreenSize(e,t){return this._screenSize.set(e,t),this.defaultPass.setUniformVector2("screenSize",this._screenSize),this}setTextures(e){for(let t=0;t<7;t++){let r=e[t]||_.res.whiteTexture;this.defaultPass.setTexture(`tex_${t}`,r),this.setVideoTextureDefine(t,r.isVideoTexture)}}setVideoTextureDefine(e,t){let r=!1;t!=this._videoTextureFlags[e]&&(t?this.defaultPass.setDefine(`VideoTexture${e}`,!0):this.defaultPass.deleteDefine(`VideoTexture${e}`),this._videoTextureFlags[e]=t,r=!0),r&&this.defaultPass.noticeValueChange()}set envMap(e){}set shadowMap(e){}set baseMap(e){}set normalMap(e){}set emissiveMap(e){}set irradianceMap(e){}set irradianceDepthMap(e){}}class Gc extends ue{constructor(){super(...arguments),n(this,"_guiGeometry")}init(e){super.init(),this.addRendererMask(Le.UI),this.removeRendererMask(Le.Default),this.castGI=!1,this.castShadow=!1,this.alwaysRender=!0,this._ignoreEnvMap=this._ignorePrefilterMap=!0}get geometry(){return super.geometry}set geometry(e){super.geometry=e,this._guiGeometry=e}nodeUpdate(e,t,r,a){for(let s=0;s<this.materials.length;s++){let l=this.materials[s].getPass(t),h=this._guiGeometry.vPositionBuffer,u=this._guiGeometry.vSpriteBuffer,c=this._guiGeometry.vColorBuffer;if(l)for(let d=0;d<l.length;d++){const g=l[d];g.pipeline||(g.setStorageBuffer("vPositionBuffer",h),g.setStorageBuffer("vSpriteBuffer",u),g.setStorageBuffer("vColorBuffer",c))}}super.nodeUpdate(e,t,r,a)}onUpdate(e){}}class Qc{constructor(){n(this,"_use"),n(this,"_unUse"),this._use=[],this._unUse=[]}pushBack(e){let t=this._use.indexOf(e);t!=-1&&(this._use.splice(t,1),this._unUse.push(e))}getUseList(){return this._use}getOne(e,t){let r;return this._unUse.length>0?(r=this._unUse[0],this._unUse.splice(0,1),this._use.push(r),r):(r=new e(t),this._use.push(r),r)}hasFree(){return this._unUse.length>0}}let vr;const fs=class{constructor(){n(this,"x",0),n(this,"y",0),n(this,"z",0),n(this,"width",1),n(this,"height",1),n(this,"_globalX",0),n(this,"_globalY",0),n(this,"_globalWidth",0),n(this,"_globalHeight",0),n(this,"_visible",!0),n(this,"_offsetX",0),n(this,"_offsetY",0),n(this,"_sprite",_.res.defaultGUISprite),n(this,"_color",new z(1,1,1,1)),n(this,"_imageType",pr.Simple),n(this,"dirtyAttributes",Pe.MAX),n(this,"cacheTextureId",-1)}static get quadPool(){return this.textPool||(this.textPool=new Qc),this.textPool}static recycleQuad(i){i.sprite=null,i.dirtyAttributes=Pe.MAX,i.x=0,i.y=0,i.z=-1,i.cacheTextureId=-1,fs.quadPool.pushBack(i)}static spawnQuad(){return fs.quadPool.getOne(fs)}get imageType(){return this._imageType}set imageType(i){this._imageType=i,this.setAttrChange(Pe.SPRITE|Pe.POSITION)}get color(){return this._color}set color(i){this._color.copyFrom(i),this.setAttrChange(Pe.COLOR)}get visible(){return this._visible}set visible(i){i!=this._visible&&(this._visible=i,this.setAttrChange(Pe.SPRITE))}get sprite(){return this._sprite}set sprite(i){this._sprite!=i&&(this._sprite=i,this.setAttrChange(Pe.SPRITE|Pe.POSITION))}get left(){return this._globalX-this._offsetX}get right(){return this.left+this._globalWidth}get top(){return this._globalY-this._offsetY}get bottom(){return this.top+this._globalHeight}setSize(i,e){this.width=i,this.height=e,this.setAttrChange(Pe.POSITION)}setXY(i,e){this.x=i,this.y=e,this.setAttrChange(Pe.POSITION)}setAttrChange(i){this.dirtyAttributes=this.dirtyAttributes|i}applyTransform(i){this.setAttrChange(Pe.POSITION);let e=this._sprite,t=i.getWorldMatrix();(this.x!=0||this.y!=0)&&(t=this.getQuadMatrix(t));let r=t.getScaleX(),a=t.getScaleY(),s=e.isSliced&&this._imageType==pr.Sliced;if(this._offsetX=i.width*.5*r,this._offsetY=i.height*.5*a,s)this._globalWidth=r*(i.width-(e.offsetSize.z-e.trimSize.x)),this._globalHeight=a*(i.height-(e.offsetSize.w-e.trimSize.y)),this._globalX=t.tx+e.offsetSize.x*r,this._globalY=t.ty+e.offsetSize.y*a;else{let o=this.width/e.offsetSize.z,l=this.height/e.offsetSize.w;this._globalWidth=r*e.trimSize.x*o,this._globalHeight=a*e.trimSize.y*l,this._globalX=t.tx+e.offsetSize.x*o*r,this._globalY=t.ty+e.offsetSize.y*l*a}return this}getQuadMatrix(i){return vr||(vr=new Vi),vr.identity(),vr.setTranslate(this.x,this.y),vr.mul(i),vr}writeToGeometry(i,e){return i.fillQuad(this,e),this.dirtyAttributes=Pe.NONE,this}};let Yi=fs;n(Yi,"textPool");class Vn extends Ee{constructor(){super(...arguments),n(this,"_uiTransform"),n(this,"_visible",!0)}destroy(){this._uiTransform.setNeedUpdateUIPanel(),super.destroy()}get uiTransform(){return this._uiTransform}get visible(){return this._visible}set visible(e){var t;this._visible!=e&&(this._visible=e,(t=this.onUIComponentVisible)==null||t.call(this,this._visible))}init(e){var t;(t=super.init)==null||t.call(this,e),this._uiTransform=this.object3D.getOrAddComponent(ni),this._uiTransform.setNeedUpdateUIPanel()}copyComponent(e){return this.visible=e.visible,this}}class ca extends Vn{constructor(){super(...arguments),n(this,"_mainQuads"),n(this,"_shadowRender"),n(this,"_shadowSource"),n(this,"isUIShadow"),n(this,"isShadowless"),n(this,"needUpdateShadow")}init(e){var t;(t=super.init)==null||t.call(this,e),this._mainQuads=[]}destroy(){var e,t;this.detachQuads(),(e=this._shadowRender)==null||e.setShadowSource(null),(t=this._shadowSource)==null||t.setShadowRenderer(null),super.destroy(),this._shadowRender=null,this._shadowSource=null}start(){var e;(e=super.start)==null||e.call(this),this.isUIShadow?this.autoBindShadow(null,this):this.isShadowless||this.autoBindShadow(this,null),this.setShadowDirty()}setShadowDirty(){this._shadowRender&&(this._shadowRender.needUpdateShadow=!0)}get mainQuads(){return this._mainQuads}setShadowRenderer(e){this._shadowRender=e}setShadowSource(e){this._shadowSource=e}getShadowRender(){return this._shadowRender}autoBindShadow(e,t){let r=this.object3D.components.values();if(!e)for(let a of r){let s=a;if(!(s.isShadowless||s.isUIShadow)&&s.mainQuads){e=s;break}}if(!t)for(let a of r){let s=a;if(s.isUIShadow&&s.mainQuads){t=s;break}}return e&&t?(e.setShadowRenderer(t),t.setShadowSource(e),!0):!1}recycleQuad(e){if(e&&this._mainQuads){let t=this._mainQuads.indexOf(e);t>=0?(this._mainQuads.splice(t,1),Yi.recycleQuad(e)):e=null}return e}attachQuad(e){return this._mainQuads&&this._mainQuads.push(e),this}detachQuads(){if(this._mainQuads)for(;this._mainQuads.length>0;){let e=this._mainQuads.shift();this.recycleQuad(e)}return this}copyComponent(e){return super.copyComponent(e),this.isUIShadow=e.isUIShadow,this.isShadowless=e.isShadowless,this}}class Xi extends ca{init(e){var t;(t=super.init)==null||t.call(this,e),this.attachQuad(Yi.spawnQuad()),this.sprite=_.res.defaultGUISprite}cloneTo(e){e.getOrAddComponent(Xi).copyComponent(this)}copyComponent(e){return super.copyComponent(e),this.sprite=e.sprite,this.color=e.color,this.imageType=e.imageType,this}set sprite(e){e||(e=_.res.defaultGUISprite);for(let t of this._mainQuads)t.sprite=e,t.setSize(this._uiTransform.width,this._uiTransform.height);this.setShadowDirty()}onTransformResize(){this.applyTransformSize()}applyTransformSize(){for(let e of this._mainQuads)e.setSize(this._uiTransform.width,this._uiTransform.height);this.setShadowDirty()}get sprite(){return this._mainQuads[0].sprite}onUIComponentVisible(e){this.applyComponentVisible()}onUITransformVisible(e){this.applyComponentVisible()}applyComponentVisible(){let e=!this._visible||!this._uiTransform.globalVisible;for(let t of this._mainQuads)t.visible=!e;this.setShadowDirty()}get color(){return this._mainQuads[0].color}set color(e){for(let t of this._mainQuads)t.color=e;this.setShadowDirty()}get imageType(){return this._mainQuads[0].imageType}set imageType(e){for(let t of this._mainQuads)t.imageType=e;this.setShadowDirty()}}class fa extends Xi{constructor(){super(...arguments),n(this,"space",Nt.World),n(this,"needUpdateGeometry",!0),n(this,"panelOrder",0),n(this,"needSortOnCameraZ"),n(this,"_billboard"),n(this,"_rebuild"),n(this,"scissorEnable",!1),n(this,"scissorCornerRadius",0),n(this,"scissorFadeOutSize",0),n(this,"_uiRenderer"),n(this,"_uiMaterial"),n(this,"_geometry"),n(this,"_limitVertexCount",0),n(this,"_maxCount",128),n(this,"isUIPanel",!0),n(this,"_collectTransform",[])}cloneTo(e){e.getOrAddComponent(fa).copyComponent(this)}copyComponent(e){return super.copyComponent(e),this.panelOrder=e.panelOrder,this.needSortOnCameraZ=e.needSortOnCameraZ,this.cullMode=e.cullMode,this.billboard=e.billboard,this.scissorEnable=e.scissorEnable,this.scissorCornerRadius=e.scissorCornerRadius,this.scissorFadeOutSize=e.scissorFadeOutSize,this}init(e){super.init(e),this.create(this.space),this.visible=!1}create(e){this._maxCount=this.space==Nt.World?ye.quadMaxCountForWorld:ye.quadMaxCountForView,this._uiRenderer=this.object3D.addComponent(Gc),this._geometry=this._uiRenderer.geometry=new Nc(this._maxCount).create(),this._uiMaterial=this._uiRenderer.material=new zc(e),this._uiRenderer.renderOrder=ye.SortOrderStartWorld,this._rebuild=new kc,this.object3D.bound=new Be(new p,new p(1,1,1).multiplyScalar(Number.MAX_VALUE*.1))}get quadMaxCount(){return this._maxCount}set billboard(e){this.space==Nt.View?e=yi.None:console.warn("Cannot enable billboard in view space"),e==yi.BillboardXYZ||e==yi.BillboardY?(this._billboard=this.object3D.getOrAddComponent(oa),this._billboard.type=e):(this.object3D.removeComponent(oa),this._billboard=null)}get billboard(){return this._billboard?this._billboard.type:yi.None}set cullMode(e){this.space==Nt.World?this._uiRenderer.material.cullMode=e:console.warn("Cannot change cullMode in view space")}get cullMode(){return this._uiRenderer.material.cullMode}onUpdate(e){var t;(t=super.onUpdate)==null||t.call(this,e),this.rebuildGUIMesh(e)}rebuildGUIMesh(e){let t=this,r=t._collectTransform;if(r.length=0,t.object3D.getComponents(ni,r),r.length>0){t._rebuild.build(r,t,t.needUpdateGeometry);for(const h of r)h.needUpdateQuads=!1}let a=t.object3D.getComponentFromParent(ua),s=a?a.index:0;t._uiRenderer.enable=r.length>0;let o=t.isViewPanel?ye.SortOrderStartView:ye.SortOrderStartWorld;t._uiRenderer.renderOrder=s*ye.SortOrderCanvasSpan+o+t.panelOrder,t._uiRenderer.needSortOnCameraZ=t.needSortOnCameraZ;let l=t._uiMaterial;if(l.setGUISolution(ye.solution,ye.pixelRatio),l.setScreenSize(I.canvas.clientWidth,I.canvas.clientHeight),l.setLimitVertex(t._limitVertexCount),l.setScissorEnable(t.scissorEnable),t.scissorEnable){let h=t.mainQuads[0];l.setScissorRect(h.left,h.bottom,h.right,h.top),l.setScissorCorner(t.scissorCornerRadius,t.scissorFadeOutSize)}t.needUpdateGeometry=!1}}class ds extends fa{constructor(){super(),n(this,"isViewPanel",!0),n(this,"space",Nt.View)}cloneTo(e){e.getOrAddComponent(ds).copyComponent(this)}}class gs extends fa{constructor(){super(),n(this,"isWorldPanel",!0),n(this,"space",Nt.World),n(this,"_depthTest",!0)}cloneTo(e){e.getOrAddComponent(gs).copyComponent(this)}copyComponent(e){return super.copyComponent(e),this.depthTest=e.depthTest,this}get depthTest(){return this._depthTest}set depthTest(e){if(this._depthTest!=e){this._depthTest=e;let t=this.depthTest?_t.less_equal:_t.always;this._uiRenderer.material.depthCompare=t}}}let Hn;class ni extends Ee{constructor(){super(),n(this,"useParentPivot",!1),n(this,"parent"),n(this,"pivotX",.5),n(this,"pivotY",.5),n(this,"_width",100),n(this,"_height",100),n(this,"_localVisible",!0),n(this,"_globalVisible",!0),n(this,"_uiInteractiveList"),n(this,"_localMatrix"),n(this,"_worldMatrix"),n(this,"_onChange",!0),n(this,"needUpdateQuads",!0),n(this,"_tempTransforms",[]),this._localMatrix=new Vi,this._worldMatrix=new Vi}get uiInteractiveList(){return this._uiInteractiveList}init(e){var t;super.init(e),this.transform.eventDispatcher.addEventListener(this.transform.eventLocalChange.type,this.onTransformChange,this),this.onParentChange(null,(t=this.object3D.parent)==null?void 0:t.object3D)}onTransformChange(e){this.onChange=!0}addUIInteractive(e){return this._uiInteractiveList||(this._uiInteractiveList=[]),this._uiInteractiveList.push(e),this}removeUIInteractive(e){if(this._uiInteractiveList){let t=this._uiInteractiveList.indexOf(e);if(t>=0)return this._uiInteractiveList.slice(t,1),e}return null}get globalVisible(){return this._globalVisible}set visible(e){if(this._localVisible!=e){this._localVisible=e;let t=this.parent?this.parent._globalVisible:!0;this.onUITransformVisible(this._localVisible&&t)}}get visible(){return this._localVisible}onUITransformVisible(e){let t=this._localVisible&&e;t!=this._globalVisible&&(this._globalVisible=t,this.object3D.components.forEach((r,a)=>{let s=r;if(s.onUITransformVisible)if(s==this)for(let o of this.object3D.entityChildren){let l=o.getComponent(ni);l&&l.onUITransformVisible(this._globalVisible)}else s.onUITransformVisible(this._globalVisible)}))}onParentChange(e,t){var r,a;(r=this.parent)==null||r.setNeedUpdateUIPanel(),this.parent=t?.getComponent(ni),(a=this.parent)==null||a.setNeedUpdateUIPanel()}get width(){return this._width}get height(){return this._height}resize(e,t){var r;if(this._width!=e||this._height!=t){this._width=e,this._height=t,this.onChange=!0;for(let a of this.object3D.components.values())(r=a.onTransformResize)==null||r.call(a);return!0}return!1}get x(){return this.object3D.x}set x(e){e!=this.object3D.x&&(this.object3D.x=e,this.onChange=!0)}get y(){return this.object3D.y}set y(e){e!=this.object3D.y&&(this.object3D.y=e,this.onChange=!0)}setXY(e,t){let r=this.object3D.localPosition;r.set(e,t,r.z),this.object3D.localPosition=r,this.onChange=!0}get z(){return this.object3D.z}set z(e){e!=this.object3D.z&&(this.object3D.z=e,this.onChange=!0)}get scaleX(){return this.object3D.scaleX}set scaleX(e){this.onChange=!0,this.object3D.scaleX=e}get scaleY(){return this.object3D.scaleY}set scaleY(e){this.onChange=!0,this.object3D.scaleY=e}get scaleZ(){return this.object3D.scaleZ}set scaleZ(e){this.onChange=!0,this.object3D.scaleZ=e}get onChange(){return this._onChange}set onChange(e){if(this._onChange!=e&&(this._onChange=e,e)){this._tempTransforms.length=0;let t=this.object3D.getComponents(ni,this._tempTransforms,!0);for(let r of t)r._onChange=!0,r.needUpdateQuads=!0}}onEnable(){this.setNeedUpdateUIPanel(),this.onChange=!0}onDisable(){this.setNeedUpdateUIPanel(),this.onChange=!0}setNeedUpdateUIPanel(){let e;e=this.object3D.getComponentFromParent(gs),e||(e=this.object3D.getComponentFromParent(ds)),e&&(e.needUpdateGeometry=!0)}cloneTo(e){let t=e.getOrAddComponent(ni);t.visible=this.visible,t.x=this.x,t.y=this.y,t.z=this.z,t.resize(this.width,this.height),t.pivotX=this.pivotX,t.pivotY=this.pivotY,t.scaleX=this.scaleX,t.scaleY=this.scaleY}matrix(){let e=this._localMatrix,t=this.object3D.rotationZ;return this.parent?(e.updateScaleAndRotation(this.object3D.scaleX,this.object3D.scaleY,t,t),e.tx=this.object3D.x,e.ty=this.object3D.y):e.updateScaleAndRotation(1,1,0,0),(this.pivotX!=.5||this.pivotY!=.5)&&(Hn||(Hn=new Vi().identity()),e.mul(Hn.setTo(1,0,0,1,-(this.pivotX-.5)*this.width,-(this.pivotY-.5)*this.height))),e}getWorldMatrix(){let e=this,t=e._worldMatrix;return this._onChange&&(t.copyFrom(e.matrix()),e.parent&&t.mul(e.parent.getWorldMatrix()),e._onChange=!1),t}beforeDestroy(e){var t;this.transform.eventDispatcher.addEventListener(this.transform.eventLocalChange.type,this.onTransformChange,this),(t=super.beforeDestroy)==null||t.call(this,e)}}class Vc{constructor(){n(this,"_ray"),n(this,"_mouseCode"),n(this,"_clickEvent"),n(this,"_outEvent"),n(this,"_overEvent"),n(this,"_upEvent"),n(this,"_downEvent"),n(this,"_view"),n(this,"_lastDownTarget"),n(this,"_lastOverTarget"),n(this,"_lastDownPosition",new $),n(this,"_calcDistanceVec2",new $),n(this,"_lastDownTime",0),n(this,"_clickTimeSpan",200),n(this,"_clickDistanceSpan",10),n(this,"_colliderOut",[]),n(this,"_transformList",[]),n(this,"_sortWorldPanelList",[]),n(this,"_iteractive2PanelDict",new Map)}init(e){this._view=e,this._ray=new ci,this._clickEvent=new L(L.PICK_CLICK_GUI),this._outEvent=new L(L.PICK_OUT_GUI),this._overEvent=new L(L.PICK_OVER_GUI),this._upEvent=new L(L.PICK_UP_GUI),this._downEvent=new L(L.PICK_DOWN_GUI),_.inputSystem.addEventListener(L.POINTER_DOWN,this.onTouchDown,this,null,1),_.inputSystem.addEventListener(L.POINTER_UP,this.onTouchUp,this,null,1),_.inputSystem.addEventListener(L.POINTER_MOVE,this.onTouchMove,this,null,1),_.inputSystem.addEventListener(L.POINTER_CLICK,this.onTouchClick,this,null,1)}onTouchClick(e){this._lastOverTarget&&e.stopImmediatePropagation()}onTouchMove(e){this._mouseCode=e.mouseCode,this.collectEntities();let t=this.pick(this._colliderOut);t&&e.stopImmediatePropagation();let r=t?t.collider:null;r!=this._lastOverTarget&&(this._lastOverTarget&&this._lastOverTarget.enable&&(this._lastOverTarget.mouseStyle=Me.NORMAL,this._outEvent.data=this._lastOverTarget,this._lastOverTarget.object3D.dispatchEvent(this._outEvent)),r&&(r.mouseStyle=Me.OVER,this._overEvent.data=r,r.object3D.dispatchEvent(this._overEvent)),this._lastOverTarget=r)}onTouchDown(e){this._lastDownTime=he.time,this._lastDownPosition.set(e.mouseX,e.mouseY),this._mouseCode=e.mouseCode,this.collectEntities();let t=this.pick(this._colliderOut);t&&e.stopImmediatePropagation();let r=t?t.collider:null;r&&(r.mouseStyle=Me.DOWN,this._overEvent.data=r,r.object3D.dispatchEvent(this._overEvent)),this._lastDownTarget=r}onTouchUp(e){this._calcDistanceVec2.set(e.mouseX,e.mouseY),this._mouseCode=e.mouseCode,this.collectEntities();let t=this.pick(this._colliderOut);t&&e.stopImmediatePropagation();let r=t?t.collider:null;this._lastDownTarget&&this._lastDownTarget.enable&&(this._lastDownTarget.mouseStyle=Me.NORMAL),r&&r==this._lastDownTarget&&he.time-this._lastDownTime<=this._clickTimeSpan&&(this._calcDistanceVec2.set(e.mouseX,e.mouseY),this._calcDistanceVec2.distance(this._lastDownPosition)<=this._clickDistanceSpan&&(this._clickEvent.data={pick:r,pickInfo:t,mouseCode:this._mouseCode},r.object3D.dispatchEvent(this._clickEvent))),this._lastDownTarget=null}collectEntities(){return this._colliderOut.length=0,this._sortWorldPanelList.length=0,this._iteractive2PanelDict.clear(),this._view.canvasList.slice().reverse().forEach(t=>{if(t&&t.transform&&t.transform.parent){let r=t.object3D.getComponentsByProperty("isUIPanel",!0,!0);r.sort((a,s)=>{let o=a._uiRenderer.__renderOrder,l=s._uiRenderer.__renderOrder;return o>l?-1:1});for(let a of r){this._transformList.length=0,a.object3D.getComponents(ni,this._transformList),this._transformList.reverse();for(const s of this._transformList){let o=s.uiInteractiveList;if(o&&o.length>0)for(let l of o)this._colliderOut.push(l),this._iteractive2PanelDict.set(l,a)}}}}),this._colliderOut}pick(e){this._ray=this._view.camera.screenPointToRay(_.inputSystem.mouseX,_.inputSystem.mouseY);let t=new $(_.inputSystem.mouseX,_.inputSystem.mouseY),r=new $(I.canvas.clientWidth,I.canvas.clientHeight),a;for(const s of e)if(s.interactive&&s.enable&&s.interactiveVisible){let o=this._iteractive2PanelDict.get(s);if(a=s.rayPick(this._ray,o,t,r),a)return a.collider=s,a}return null}}var Hc=(i=>(i[i.COLLINEAR=0]="COLLINEAR",i[i.LINES_INTERSECT=1]="LINES_INTERSECT",i[i.SEGMENTS_INTERSECT=2]="SEGMENTS_INTERSECT",i[i.A_BISECTS_B=3]="A_BISECTS_B",i[i.B_BISECTS_A=4]="B_BISECTS_A",i[i.PARALELL=5]="PARALELL",i))(Hc||{}),Yc=(i=>(i[i.ON_LINE=0]="ON_LINE",i[i.LEFT_SIDE=1]="LEFT_SIDE",i[i.RIGHT_SIDE=2]="RIGHT_SIDE",i))(Yc||{});const mt=class{constructor(i,e){n(this,"start"),n(this,"end"),n(this,"color",new z(1,1,1,1)),n(this,"_normal"),n(this,"_normalCalculated",!1),this.start=i,this.end=e}set(i,e){this.start=i,this.end=e}getCenter(){let i=p.HELP_0;return this.start.subtract(this.end,i),i.scaleBy(.5),i.add(this.end),i}inverse(){let i=this.start;this.start=this.end,this.end=i}equals(i){return this.start==i.start&&this.end==i.end||this.start==i.end&&this.end==i.start}toArray(){return[this.start.x,this.start.y,this.start.z,this.end.x,this.end.y,this.end.z]}static getLines(i){let e=[];for(let t=0;t<i.length;t++){let r=t,a=Fs(t+1,i.length),s=i[r],o=i[a];e.push(new mt(s,o))}return e}intersection(i,e=null){var t=(i.end.z-i.start.z)*(this.end.x-this.start.x)-(i.end.x-i.start.x)*(this.end.z-this.start.z),r=(i.end.x-i.start.x)*(this.start.z-i.start.z)-(i.end.z-i.start.z)*(this.start.x-i.start.x),a=(i.start.x-this.start.x)*(this.end.z-this.start.z)-(i.start.z-this.start.z)*(this.end.x-this.start.x);if(t==0)return r==0&&a==0?0:5;r=r/t,a=a/t;var s=this.start.x+r*(this.end.x-this.start.x),o=this.start.z+r*(this.end.z-this.start.z);return e!=null&&(e.x=s,e.y=0,e.z=o),r>=0&&r<=1&&a>=0&&a<=1?2:a>=0&&a<=1?3:r>=0&&r<=1?4:1}getDirection(){var i=this.end.subtract(this.start),e=new p(i.x,i.y);return e.normalize()}copyFrom(i){this.start||(this.start=new p),this.end||(this.end=new p),this.start.copyFrom(i.start),this.end.copyFrom(i.end)}static IsEqual(i,e){return Math.abs(i-e)<1e-7}static squreDistanceSegmentToSegment(i,e,t){let r=i.start,a=i.end,s=e.start,o=e.end,l=r.x,h=r.y,u=r.z,c=a.x,d=a.y,g=a.z,m=s.x,A=s.y,v=s.z,y=o.x,C=o.y,S=o.z,T=c-l,D=d-h,M=g-u,P=y-m,R=C-A,U=S-v,E=l-m,F=h-A,V=u-v,Y=T*T+D*D+M*M,j=T*P+D*R+M*U,oe=P*P+R*R+U*U,pe=T*E+D*F+M*V,we=P*E+R*F+U*V,Xe=Y*oe-j*j,ke=Xe,ce=Xe,me=0,We=0;this.IsEqual(Xe,0)?(me=0,ke=1,We=we,ce=oe):(me=j*we-oe*pe,We=Y*we-j*pe,me<0?(me=0,We=we,ce=oe):me>ke&&(me=ke,We=we+j,ce=oe)),We<0?(We=0,-pe<0?me=0:-pe>Y?me=ke:(me=-pe,ke=Y)):We>ce&&(We=ce,-pe+j<0?me=0:-pe+j>Y?me=ke:(me=-pe+j,ke=Y));let lt=0,ht=0;this.IsEqual(me,0)?lt=0:lt=me/ke,this.IsEqual(We,0)?ht=0:ht=We/ce;let Gt=E+lt*T-ht*P,St=F+lt*D-ht*R,It=V+lt*M-ht*U;return Gt*Gt+St*St+It*It}isNear(i,e=0,t){let r=p.HELP_0,a=p.HELP_1;r.copyFrom(i.origin),a.copyFrom(i.direction),a.scaleBy(9999),a.add(r,a),mt.cacluteLine0.set(r,a),mt.cacluteLine1.copyFrom(this),t&&(t.perspectiveMultiplyPoint3(mt.cacluteLine1.start,mt.cacluteLine1.start),t.perspectiveMultiplyPoint3(mt.cacluteLine1.end,mt.cacluteLine1.end));let s=mt.squreDistanceSegmentToSegment(mt.cacluteLine0,mt.cacluteLine1,t);return s+1e-4<=e?(i.length=s,!0):(i.length=-999999,!1)}};let xr=mt;n(xr,"cacluteLine0",new mt(null,null)),n(xr,"cacluteLine1",new mt(null,null));const Xc=class{constructor(i,e,t){n(this,"v1"),n(this,"v2"),n(this,"v3"),n(this,"u1"),n(this,"u2"),n(this,"u3"),n(this,"n1"),n(this,"n2"),n(this,"n3"),n(this,"t0"),n(this,"t"),n(this,"u"),n(this,"v"),n(this,"min",new p),n(this,"max",new p),n(this,"id",0),this.id=Xc.ID+++200,i&&e&&t&&this.set(i,e,t)}set(i,e,t){this.v1=i,this.v2=e,this.v3=t;let r=this.min,a=this.max;return r.x=Math.min(this.v1.x,this.v2.x,this.v3.x),r.y=Math.min(this.v1.y,this.v2.y,this.v3.y),r.z=Math.min(this.v1.z,this.v2.z,this.v3.z),a.x=Math.max(this.v1.x,this.v2.x,this.v3.x),a.y=Math.max(this.v1.y,this.v2.y,this.v3.y),a.z=Math.max(this.v1.z,this.v2.z,this.v3.z),this}getNormal(){let i=this.v1,e=this.v2,t=this.v3,r=new p(e.x-i.x,e.y-i.y,e.z-i.z),s=new p(t.x-i.x,t.y-i.y,t.z-i.z).crossProduct(r);return s.normalize(),s}turnBack(){let i=this.v3;this.v3=this.v1,this.v1=i}getLines(){let i=this.v1,e=this.v2,t=this.v3;return[new xr(i,e),new xr(e,t),new xr(t,i)]}equals(i){let e=this.getLines(),t=i.getLines(),r=0;for(let a=0;a<e.length;a++)for(let s=0;s<t.length;s++)e[a].equals(t[s])&&r++;return r==3}getCenter(){let i=this.min,e=this.max,t=new p;return t.x=(i.x+e.x)*.5,t.y=(i.y+e.y)*.5,t.z=(i.z+e.z)*.5,t}intersects(i){var e=this.max,t=this.min,r=i.max,a=i.min;return t.x<=r.x&&e.x>=a.x&&t.y<=r.y&&e.y>=a.y&&t.z<=r.z&&e.z>=a.z}sign2D(i,e,t){return(i.x-t.x)*(e.z-t.z)-(e.x-t.x)*(i.z-t.z)}pointInTriangle2D(i){let e=this.v1,t=this.v2,r=this.v3,a,s,o,l,h;return a=this.sign2D(i,e,t),s=this.sign2D(i,t,r),o=this.sign2D(i,r,e),l=a<0||s<0||o<0,h=a>0||s>0||o>0,!(l&&h)}toArray(){return[this.v1.x,this.v1.y,this.v1.z,this.v2.x,this.v2.y,this.v2.z,this.v3.x,this.v3.y,this.v3.z]}};let ps=Xc;n(ps,"ID",-1);class Ft{static init(){this._pt0=new p,this._pt1=new p,this._pt2=new p,this._pt3=new p,this._ray=new ci,this._triangle=new ps,this._hitPoint=new p,this._worldMatrix=new H}static rayPick(e,t,r,a,s,o){this._isInit||(this.init(),this._isInit=!0);let l=this._worldMatrix;if(a==Nt.World){let h;this.calculateHotArea_World(s,this._pt0,this._pt1,this._pt2,this._pt3),l.copyFrom(o).invert();let u=this._ray;if(u.copy(e).applyMatrix(l),this._triangle.set(this._pt0,this._pt1,this._pt2),h=u.intersectTriangle(u.origin,u.direction,this._triangle),h||(this._triangle.set(this._pt1,this._pt2,this._pt3),h=u.intersectTriangle(u.origin,u.direction,this._triangle)),h)return{distance:0,intersectPoint:h}}else{this.calculateHotArea_View(s,this._pt0,this._pt1,this._pt2,this._pt3);let h=r.x,u=r.y,c=Math.min(this._pt0.x,this._pt1.x,this._pt2.x,this._pt3.x)+h*.5,d=Math.min(this._pt0.y,this._pt1.y,this._pt2.y,this._pt3.y)+u*.5,g=Math.max(this._pt0.x,this._pt1.x,this._pt2.x,this._pt3.x)+h*.5,m=Math.max(this._pt0.y,this._pt1.y,this._pt2.y,this._pt3.y)+u*.5;return t.x<=g&&t.x>=c&&t.y<=m&&t.y>=d?(this._hitPoint.set(t.x,t.y,0),{distance:0,intersectPoint:this._hitPoint}):null}return null}static calculateHotArea_View(e,t,r,a,s){let o=e.getWorldMatrix(),l=o.getScaleX(),h=o.getScaleY(),u=e.width*.5*l,c=e.height*.5*h;t.set(-u,-c,0),r.set(u,-c,0),a.set(-u,c,0),s.set(u,c,0);let d=o.tx;t.x+=d,r.x+=d,a.x+=d,s.x+=d,d=o.ty,t.y-=d,r.y-=d,a.y-=d,s.y-=d,t.multiplyScalar(ye.pixelRatio),r.multiplyScalar(ye.pixelRatio),a.multiplyScalar(ye.pixelRatio),s.multiplyScalar(ye.pixelRatio)}static calculateHotArea_World(e,t,r,a,s){let o=e.getWorldMatrix(),l=o.getScaleX(),h=o.getScaleY(),u=e.width*.5*l,c=e.height*.5*h;t.set(-u,c,0),r.set(u,c,0),a.set(-u,-c,0),s.set(u,-c,0);let d=o.tx;t.x+=d,r.x+=d,a.x+=d,s.x+=d,d=o.ty,t.y+=d,r.y+=d,a.y+=d,s.y+=d}}n(Ft,"_pt0"),n(Ft,"_pt1"),n(Ft,"_pt2"),n(Ft,"_pt3"),n(Ft,"_hitPoint"),n(Ft,"_worldMatrix"),n(Ft,"_ray"),n(Ft,"_triangle"),n(Ft,"_isInit");var Wc=(i=>(i[i.UpperLeft=0]="UpperLeft",i[i.UpperCenter=1]="UpperCenter",i[i.UpperRight=2]="UpperRight",i[i.MiddleLeft=3]="MiddleLeft",i[i.MiddleCenter=4]="MiddleCenter",i[i.MiddleRight=5]="MiddleRight",i[i.LowerLeft=6]="LowerLeft",i[i.LowerCenter=7]="LowerCenter",i[i.LowerRight=8]="LowerRight",i))(Wc||{}),jc=(i=>(i[i.Upper=0]="Upper",i[i.Middle=1]="Middle",i[i.Lower=2]="Lower",i))(jc||{}),qc=(i=>(i[i.Left=0]="Left",i[i.Center=1]="Center",i[i.Right=2]="Right",i))(qc||{});class Kc{constructor(){n(this,"charList",[]),n(this,"quadList",[]),n(this,"width",0),n(this,"index",0)}}class Jc{layout(e){let t=[],r=e.originSize,a=gr.getFontData(e.font,r),s=e.fontSize/r;return this.makeTextLine(e.uiTransform,e.alignment,t,e.font,a,e.text,s,r,e.lineSpacing),t}makeTextLine(e,t,r,a,s,o,l,h,u){let c=-1,d=0,g=h*l,m=g*.5,A=e.width/l,v=e.height/l,y=0,C=e.height,S=()=>{d=0,c++;let P=new Kc;return P.index=c,r.push(P),P},T=(P,R)=>{const U=P.charCodeAt(0).toString();let E=gr.getFnt(a,h,U),F=null;return E?(F=Yi.spawnQuad(),F.sprite=E,F.x=(d+E.xoffset)*l-y,F.y=(s.base-E.height-E.yoffset-s.base)*l+C,F.width=E.offsetSize.width*l,F.height=E.offsetSize.height*l,d+=E.xadvance):P==`
`||(P=="	"?d+=g:d+=m),R.width=d,R.quadList.push(F),R.charList.push(P),F},D=()=>{let P=this.getAlignment(t);switch(P.v){case 0:for(let R=0,U=r.length;R<U;R++){let E=r[R];if(R>0){let F=R*g*u;for(let V=0,Y=E.quadList.length;V<Y;V++){let j=E.quadList[V];j&&(j.y-=F)}}}break;case 1:for(let R=0,U=r.length;R<U;R++){let E=r[R],F=(v-U*h*u)*.5*l+R*g*u;for(let V=0,Y=E.quadList.length;V<Y;V++){let j=E.quadList[V];j&&(j.y-=F)}}break;case 2:for(let R=0,U=r.length;R<U;R++){let E=r[R],F=(v-U*h*u)*l+R*g*u;for(let V=0,Y=E.quadList.length;V<Y;V++){let j=E.quadList[V];j&&(j.y-=F)}}break}switch(P.h){case 0:break;case 1:for(let R=0,U=r.length;R<U;R++){let E=r[R],F=(A-E.width)*.5*l;for(let V=0,Y=E.quadList.length;V<Y;V++){let j=E.quadList[V];j&&(j.x+=F)}}break;case 2:for(let R=0,U=r.length;R<U;R++){let E=r[R],F=(A-E.width)*l;for(let V=0,Y=E.quadList.length;V<Y;V++){let j=E.quadList[V];j&&(j.x+=F)}}break}};(()=>{let P=null,R=o.length,U=!1;for(let E=0;E<R;E++){P==null&&(P=S());let F=o.charAt(E);F==`
`||U?(P=null,U=!1):(T(F,P),U=P.width+g>=A)}})(),D()}getAlignment(e){let t={v:0,h:0};switch(e){case 1:t.v=0,t.h=1;break;case 0:t.v=0,t.h=0;break;case 2:t.v=0,t.h=2;break;case 4:t.v=1,t.h=1;break;case 3:t.v=1,t.h=0;break;case 5:t.v=1,t.h=2;break;case 7:t.v=2,t.h=1;break;case 6:t.v=2,t.h=0;break;case 8:t.v=2,t.h=2;break}return t}}class ms extends Vn{constructor(){super(...arguments),n(this,"_style",Me.NORMAL),n(this,"_interactive",!1)}set interactive(e){this._interactive=e}get interactive(){return this._interactive}set mouseStyle(e){this._style=e}get interactiveVisible(){return this._uiTransform.globalVisible&&this._visible}init(e){super.init(e),this._uiTransform.addUIInteractive(this)}destroy(){this._uiTransform.removeUIInteractive(this),super.destroy()}rayPick(e,t,r,a){return Ft.rayPick(e,r,a,t.space,this._uiTransform,t.transform.worldMatrix)}cloneTo(e){e.getOrAddComponent(ms).copyComponent(this)}copyComponent(e){return super.copyComponent(e),this.enable=e._enable,this.interactive=e._interactive,this.mouseStyle=e._style,this}}var Zc=(i=>(i[i.NONE=0]="NONE",i[i.COLOR=1]="COLOR",i[i.SPRITE=2]="SPRITE",i))(Zc||{});class Yn extends ms{constructor(){super(...arguments),n(this,"_spriteMap"),n(this,"_colorMap"),n(this,"_image"),n(this,"_isCreateImage"),n(this,"_transition",2)}init(e){super.init(e),this._interactive=!0,this._spriteMap=new Map,this._colorMap=new Map,this._image=this.object3D.getComponent(Xi),this._isCreateImage=this._image==null,this._image||(this._image=this.object3D.addComponent(Xi)),this.imageType=pr.Sliced}onEnable(){this.mouseStyle=Me.NORMAL}onDisable(){this.mouseStyle=Me.DISABLE}set transition(e){this._transition!=e&&(this._transition=e,this.validateStyle(this._style,!0))}get transition(){return this._transition}get imageType(){return this._image.imageType}set imageType(e){this._image.imageType=e}setStyleColor(e,t){return this._colorMap.set(e,t),this._style==e&&this.validateStyle(this._style,!0),this}getStyleColor(e){return this._colorMap.get(e)}set mouseStyle(e){super.mouseStyle=e,this.validateStyle(e,!0)}get normalSprite(){return this._spriteMap.get(Me.NORMAL)}set normalSprite(e){this._spriteMap.set(Me.NORMAL,e),this._style==Me.NORMAL&&this.validateStyle(this._style,!0)}get overSprite(){return this._spriteMap.get(Me.OVER)}set overSprite(e){this._spriteMap.set(Me.OVER,e),this._style==Me.OVER&&this.validateStyle(this._style,!0)}set downSprite(e){this._spriteMap.set(Me.DOWN,e),this._style==Me.DOWN&&this.validateStyle(this._style,!0)}get downSprite(){return this._spriteMap.get(Me.DOWN)}set disableSprite(e){this._spriteMap.set(Me.DISABLE,e),this._style==Me.DISABLE&&this.validateStyle(this._style,!0)}get disableSprite(){return this._spriteMap.get(Me.DISABLE)}validateStyle(e,t){if(this._transition&2){let r=this._spriteMap.get(e);this._image.sprite=r}if(this._transition&1){let r=this._colorMap.get(e);r&&(this._image.color=r)}}cloneTo(e){e.getOrAddComponent(Yn).copyComponent(this)}copyComponent(e){return super.copyComponent(e),this.imageType=e.imageType,this.transition=e.transition,e._spriteMap.forEach((t,r)=>{t&&this._spriteMap.set(r,t)}),e._colorMap.forEach((t,r)=>{t&&this._colorMap.set(r,t.clone())}),this.mouseStyle=e.mouseStyle,this}destroy(){this._isCreateImage&&this._image&&(this.object3D.removeComponent(Xi),this._image=null),super.destroy()}}class Xn extends ca{constructor(){super(),n(this,"_count",0)}init(e){var t;(t=super.init)==null||t.call(this,e),this._count=e?e.count:1;for(let r=0;r<this._count;r++)this.attachQuad(Yi.spawnQuad());this._uiTransform.resize(0,0)}getQuad(e){return this._mainQuads[e]}cloneTo(e){e.addComponent(Xn,{count:this._count}).copyComponent(this)}copyComponent(e){super.copyComponent(e);for(let t=0;t<e._count;t++)this.setSprite(t,e.getSprite(t)),this.setColor(t,e.getColor(t)),this.setImageType(t,e.getImageType(t));return this}setSprite(e,t){this._mainQuads[e].sprite=t||_.res.defaultGUISprite,this.setShadowDirty()}getSprite(e){return this._mainQuads[e].sprite}onUIComponentVisible(e){this.applyComponentVisible()}onUITransformVisible(e){this.applyComponentVisible()}applyComponentVisible(){let e=!this._visible||!this._uiTransform.globalVisible;for(let t of this._mainQuads)t.visible=!e;this.setShadowDirty()}getColor(e){return this._mainQuads[e].color}setColor(e,t){this._mainQuads[e].color=t,this.setShadowDirty()}getImageType(e){return this._mainQuads[e].imageType}setImageType(e,t){this._mainQuads[e].imageType=t,this.setShadowDirty()}setSize(e,t,r){this._mainQuads[e].setSize(t,r),this.setShadowDirty()}setXY(e,t,r){this._mainQuads[e].setXY(t,r),this.setShadowDirty()}getXY(e,t){t||(t=new $);let r=this._mainQuads[e];return t.x=r.x,t.y=r.y,t}}class Wn extends ca{constructor(){super(...arguments),n(this,"_shadowQuality",1),n(this,"_shadowOffset"),n(this,"_shadowRadius"),n(this,"_shadowColor"),n(this,"_subShadowColor"),n(this,"needUpdateShadow",!1)}init(e){var t;(t=super.init)==null||t.call(this,e),this._shadowRadius=2,this._shadowQuality=1,this._shadowOffset=new $(4,-4),this._shadowColor=new z(.1,.1,.1,.8),this._subShadowColor=this._shadowColor.clone(),this.isUIShadow=!0}cloneTo(e){e.getOrAddComponent(Wn).copyComponent(this)}copyComponent(e){return super.copyComponent(this),this._shadowColor=e._shadowColor,this._shadowOffset=e._shadowOffset,this._shadowRadius=e._shadowRadius,this._shadowQuality=e.shadowQuality,this}get shadowColor(){return this._shadowColor}set shadowColor(e){this._shadowColor.copyFrom(e),this.needUpdateShadow=!0}set shadowQuality(e){e=J(e,0,4),this._shadowQuality!=e&&(this._shadowQuality=e,this.needUpdateShadow=!0)}get shadowQuality(){return this._shadowQuality}set shadowOffset(e){this._shadowOffset=e,this.needUpdateShadow=!0}get shadowOffset(){return this._shadowOffset||(this._shadowOffset=new $(4,-4)),this._shadowOffset}set shadowRadius(e){this._shadowRadius!=e&&(this._shadowRadius=e,this.applyShadow())}get shadowRadius(){return this._shadowRadius}onUpdate(e){this.needUpdateShadow&&(this.applyShadow(),this.needUpdateShadow=!1)}applyShadow(){if(this.detachQuads(),this._shadowSource&&this._shadowQuality>0){let e=this._shadowSource.mainQuads;if(e.length>0)for(let t of e)this.createQuadShadow(t)}this._uiTransform.setNeedUpdateUIPanel()}createQuadShadow(e){let t=this._shadowQuality,r=Math.PI*2;this._subShadowColor.copyFrom(this._shadowColor),this._subShadowColor.a=1/Math.max(1,t);for(let a=0;a<t;a++){let s=Yi.spawnQuad(),o=0,l=0;if(a==0)s.color=this._shadowColor;else{let h=r*(a-1)/(t-1);o=Math.sin(h)*this._shadowRadius,l=Math.cos(h)*this._shadowRadius,s.color=this._subShadowColor}s.setXY(o+this._shadowOffset.x+e.x,l+this._shadowOffset.y+e.y),s.setSize(e.width,e.height),s.sprite=e.sprite,s.visible=e.visible,s.imageType=e.imageType,this.attachQuad(s)}}}class jn extends ca{constructor(){super(),n(this,"_font","\u5FAE\u8F6F\u96C5\u9ED1"),n(this,"_fontSize",14),n(this,"_originSize",42),n(this,"_alignment",0),n(this,"_lineSpacing",1),n(this,"_text",""),n(this,"_color",new z(1,1,1,1)),n(this,"textLine",null),n(this,"layoutProxy",new Jc)}cloneTo(e){e.getOrAddComponent(jn).copyComponent(this)}copyComponent(e){return super.copyComponent(e),this._font=e._font,this._fontSize=e._fontSize,this._originSize=e._originSize,this._alignment=e._alignment,this._lineSpacing=e._lineSpacing,this._color.copyFrom(e._color),this.text=e.text,this}get originSize(){return this._originSize}get font(){return this._font}set font(e){this._font=e}get fontSize(){return this._fontSize}set fontSize(e){this._fontSize!=e&&(this._fontSize=e,this.layoutText())}get text(){return this._text}set text(e){this._text!=e&&(e||(e=""),this._text=e,this.layoutText())}layoutText(){this.detachQuads(),this.textLine=this.layoutProxy.layout(this);for(let e=0,t=this.textLine.length;e<t;e++){let r=this.textLine[e];for(let a=0,s=r.quadList.length;a<s;a++){let o=r.quadList[a];o&&this.attachQuad(o)}}this.color=this._color,this._uiTransform.setNeedUpdateUIPanel(),this.onUIComponentVisible(this._visible),this.setShadowDirty()}onUIComponentVisible(e){this.applyComponentVisible()}onUITransformVisible(e){this.applyComponentVisible()}applyComponentVisible(){let e=!this._visible||!this._uiTransform.globalVisible;for(let t of this._mainQuads)t&&(t.visible=!e);this.setShadowDirty()}onTransformResize(){this.layoutText()}get color(){return this._color}set color(e){this._color.copyFrom(e);for(let t of this._mainQuads)t.color=e;this.setShadowDirty()}get alignment(){return this._alignment}set alignment(e){this._alignment!=e&&(this._alignment=e,this.layoutText())}get lineSpacing(){return this._lineSpacing}set lineSpacing(e){this._lineSpacing!=e&&(this._lineSpacing=e,this.layoutText())}}class Cp extends Ee{constructor(){super(...arguments),n(this,"_postList")}init(e){this._postList=new Map}start(){}stop(){}onEnable(){this.activePost()}onDisable(){this.unActivePost()}activePost(){let e=this.transform.view3D,t=_.getRenderJob(e);this._postList.forEach(r=>{t.addPost(r)})}unActivePost(){let e=this.transform.view3D,t=_.getRenderJob(e);this._postList.forEach(r=>{t.removePost(r)})}addPost(e){if(this._postList.has(e.prototype))return;let t=new e;return this._postList.set(e.prototype,t),this._enable&&this.activePost(),t}removePost(e){if(!this._postList.has(e.prototype))return;let t=this._postList.get(e.prototype);this._postList.delete(e.prototype);let r=this.transform.view3D;_.getRenderJob(r).removePost(t)}getPost(e){return this._postList.has(e.prototype)?this._postList.get(e.prototype):null}}class $c extends f.Object3D{constructor(){super(),n(this,"index",0),n(this,"drawCallFrame",-1)}}var qn=(i=>(i[i.CastGI=0]="CastGI",i[i.ReceiveGI=1]="ReceiveGI",i[i.CastDepth=2]="CastDepth",i[i.Other=3]="Other",i))(qn||{});class Kn extends aa{constructor(e=0,t=0){super(),N.register("GIProbeShader",xc),this.defaultPass=new He("GIProbeShader","GIProbeShader"),this.defaultPass.setDefine("USE_BRDF",!0),this.defaultPass.setShaderEntry("VertMain","FragMain"),this.defaultPass.setUniformVector4("probeUniform",new q(t,e,0,0));let r=this.defaultPass.shaderState;r.acceptShadow=!1,r.castShadow=!1,r.receiveEnv=!1,r.acceptGI=!1,r.useLight=!1;let a=_.res.getTexture("BRDFLUT");this.brdfLUT=a,this.baseMap=_.res.whiteTexture,this.normalMap=_.res.normalTexture,this.emissiveMap=_.res.blackTexture}debug(){}}n(Kn,"count",0);class bp extends Ee{constructor(){super(...arguments),n(this,"_probes"),n(this,"_volume"),n(this,"_debugMr",[])}init(){_.setting.gi.enable=!0}start(){this._volume=de.getLightEntries(this.transform.scene3D).irradianceVolume,this.initProbe()}initProbe(){let e=this._volume.setting.probeXCount,t=this._volume.setting.probeYCount,r=this._volume.setting.probeZCount,a=new na(4,16,16),s=new p;this._probes=[];for(let o=0;o<e;o++)for(let l=0;l<t;l++)for(let h=0;h<r;h++){let u=o+h*e+l*(e*r),c=new $c;c.index=u,c.name=`${o}_${l}_${h}`;let d=c.addComponent(ue);d.material=new Kn(qn.CastGI,u),d.geometry=a,d.castGI=!1,d.castShadow=!1,this._debugMr.push(d),this.object3D.addChild(c),this._volume.calcPosition(o,l,h,s),c.x=s.x,c.y=s.y,c.z=s.z,this._probes[u]=c,this._debugMr.push(d)}for(let o=0;o<this._probes.length;o++)Q.instance.addGIProbe(this.transform.scene3D,this._probes[o]);this.object3D.transform.enable=!1,this._volume.setting.debug&&this.debug()}debug(){}debugProbeRay(e,t){const r=_.setting.gi.rayNumber;let a=new K(0,-.7071067811865475,.7071067811865475,0);for(let s=0;s<r;s++){let o=e*r+s,l=new p(-t[o*4+0],-t[o*4+1],-t[o*4+2],0);a.transformVector(l,l);let h=t[o*4+3],u=this._probes[e].transform.worldPosition.clone(),c=l.scaleBy(h);c.add(u,c)}}changeProbesVolumeData(){this._volume.setVolumeDataChange()}changeProbesPosition(){this._volume.setVolumeDataChange();let e=this._volume.setting.probeXCount,t=this._volume.setting.probeYCount,r=this._volume.setting.probeZCount,a=new p;for(let s=0;s<e;s++)for(let o=0;o<t;o++)for(let l=0;l<r;l++){let h=s+l*e+o*(e*r),u=this._probes[h];this._volume.calcPosition(s,o,l,a),u.x=a.x,u.y=a.y,u.z=a.z}}onUpdate(){_.setting.gi.maxDistance=_.setting.gi.probeSpace*1.5;let e=this.transform.scene3D.view.camera,t=p.distance(e.transform.worldPosition,e.transform.targetPos)/300;if(this._debugMr&&this._debugMr.length>0)for(let r=0;r<this._debugMr.length;r++){const a=this._debugMr[r].transform;a.scaleX=t,a.scaleY=t,a.scaleZ=t}}}class wp extends Jt{constructor(){super(...arguments),n(this,"_keyRenderGroup"),n(this,"_keyBufferGroup"),n(this,"_keyIdsGroup")}init(e){this._keyRenderGroup=new Map,this._keyBufferGroup=new Map,this._keyIdsGroup=new Map}start(){let e=[];this.object3D.getComponents(ue,e,!0);for(let t=0;t<e.length;t++){const r=e[t];r.transform.updateWorldMatrix(!0),r.enable=!1;let a=r.geometry.instanceID;for(let s=0;s<r.materials.length;s++){const o=r.materials[s];a+=o.instanceID}if(this._keyRenderGroup.has(a))this._keyRenderGroup.get(a).push(r),this._keyIdsGroup.get(a).push(r.transform.worldMatrix.index);else{let s=new fe(e.length);s.visibility=GPUShaderStage.VERTEX,this._keyRenderGroup.set(a,[r]),this._keyBufferGroup.set(a,s),this._keyIdsGroup.set(a,[r.transform.worldMatrix.index])}}this._keyBufferGroup.forEach((t,r)=>{let a=this._keyIdsGroup.get(r),s=this._keyBufferGroup.get(r);s.setInt32Array("matrixIDs",new Int32Array(a)),s.apply()})}stop(){}nodeUpdate(e,t,r,a){this._keyRenderGroup.forEach((s,o)=>{let l=this._keyBufferGroup.get(o),h=s[0];for(let u=0;u<h.materials.length;u++){let d=h.materials[u].getPass(t);if(d)for(let g=0;g<d.length;g++){const m=d[g];m.setDefine("USE_INSTANCEDRAW",!0),m.setStorageBuffer("instanceDrawID",l)}}h.nodeUpdate(e,t,r,a)}),this.preInit=!1}renderPass(e,t,r){this._keyRenderGroup.forEach((a,s)=>{let o=a[0];o.instanceCount=a.length,this.renderItem(e,t,o,r)})}renderItem(e,t,r,a){let s=r.transform._worldMatrix;for(let o=0;o<r.materials.length;o++){let h=r.materials[o].getPass(t);if(!(!h||h.length==0))for(let u=0;u<h.length;u++){if(!h||h.length==0)continue;let c=h[u];w.bindGeometryBuffer(a.encoder,r.geometry);const d=c;d.shaderState.splitTexture&&(a.endRenderPass(),Ne.WriteSplitColorTexture(r.instanceID),a.beginRenderPass(),w.bindCamera(a.encoder,e.camera),w.bindGeometryBuffer(a.encoder,r.geometry)),w.bindPipeline(a.encoder,d);let v=r.geometry.subGeometries[o].lodLevels[r.lodLevel];r.instanceCount>0?w.drawIndexed(a.encoder,v.indexCount,r.instanceCount,v.indexStart,0,0):w.drawIndexed(a.encoder,v.indexCount,1,v.indexStart,0,s.index)}}}}class Sp extends Ye{constructor(){super(),n(this,"radius",2.5),n(this,"height",10),this._shapeType=mr.Capsule}}const As=class extends Ye{constructor(){super(),n(this,"mesh"),n(this,"_pickRet"),this._shapeType=mr.Mesh}rayPick(i,e){if(this.mesh){As.triangle||(As.triangle=new ps(new p,new p,new p));let t=this.mesh.getAttribute("position"),r=this.mesh.getAttribute("indices"),a=Ye.helpMatrix;a.copyFrom(e).invert();let s=Ye.helpRay.copy(i);if(s.applyMatrix(a),s.intersectBox(this.mesh.bounds),!s.intersectBox(this.mesh.bounds,Ye.v3_help_0))return null;if(r&&t&&r.data.length>0){let l=t.data;for(let h=0,u=r.data.length/3;h<u;h++){let c=h*3;const d=r.data[c+0]*3,g=r.data[c+1]*3,m=r.data[c+2]*3;let A=As.triangle,v=A.v1.set(l[d+0],l[d+1],l[d+2]),y=A.v2.set(l[g+0],l[g+1],l[g+2]),C=A.v3.set(l[m+0],l[m+1],l[m+2]);A.set(v,y,C);let S=s.intersectTriangle(s.origin,s.direction,A);if(S)return this._pickRet||(this._pickRet={intersectPoint:new p,distance:0}),this._pickRet.intersectPoint=S,this._pickRet.distance=p.distance(s.origin,S),this._pickRet}}}return null}};let ef=As;n(ef,"triangle");class _s{constructor(e,t){n(this,"center",new p),n(this,"extents"),n(this,"max"),n(this,"min"),n(this,"size"),n(this,"tmpVecA",new p),n(this,"tmpVecB",new p),n(this,"tmpVecC",new p),n(this,"tmpVecD",new p),n(this,"radius",0),n(this,"diffBetweenPoints",new p),n(this,"owner"),n(this,"forward",new p(0,0,1)),n(this,"worldCenter"),n(this,"worldSize"),n(this,"_center",new p),this.center=e||new p(0,0,0),this.radius=t===void 0?.5:t}updateBound(){throw new Error("Method not implemented.")}containsPoint(e){var t=this.tmpVecA.subtract(e,this.center).lengthSquared,r=this.radius;return t<r*r}intersectsRay(e,t){var r=this.tmpVecA.copyFrom(e.origin).subtract(this.center),a=r.dotProduct(this.tmpVecB.copyFrom(e.direction).normalize()),s=r.dotProduct(r)-this.radius*this.radius;if(s>0&&a>0)return null;var o=a*a-s;if(o<0)return!1;var l=Math.abs(-a-Math.sqrt(o));return t&&t.copyFrom(e.direction).scaleBy(l).add(e.origin),!0}intersectsBoundingSphere(e){this.tmpVecA.subtract(e.center,this.center);var t=e.radius+this.radius;return this.tmpVecA.lengthSquared<=t*t}calculateTransform(e){this.update(e)}inFrustum(e,t){return t.containsSphere(e)}clone(){return new _s(this.center.clone(),this.radius)}update(e){this.owner=e,this._center.add(e.transform.worldMatrix.position,this.center),this.forward=e.transform.forward}merge(e){throw new Error("BoundingSphere merge is not ready!")}setFromCenterAndSize(e,t){this.center.copy(e),this.radius=t}}class Ip extends Ye{constructor(e){super(),n(this,"_pickRet"),n(this,"box"),n(this,"radius",.5),this._shapeType=mr.Sphere,this.radius=e,this.box=new _s(new p,1)}rayPick(e,t){this.box.setFromCenterAndSize(this.center,this.radius);let a=Ye.helpMatrix;a.copyFrom(t).invert();let s=Ye.helpRay.copy(e);s.applyMatrix(a);let o=s.intersectSphere(s.origin,s.direction,this.box.center,this.box.radius);return o?(this._pickRet||(this._pickRet={intersect:!1,intersectPoint:new p,distance:0}),this._pickRet.intersect=!0,this._pickRet.intersectPoint=o,this._pickRet.distance=p.distance(s.origin,Ye.v3_help_0),this._pickRet):null}}class Ep extends f.Object3D{constructor(){super(),n(this,"_envMap"),n(this,"skyObject"),n(this,"envMapChange",!0),n(this,"view"),this.transform.scene3D=this,this.skyObject=new f.Object3D,this.addChild(this.skyObject),this._isScene3D=!0,this.envMap||(this.envMap=_.res.defaultSky)}get envMap(){return this._envMap}set envMap(e){this._envMap!=e&&(this.envMapChange=!0),this._envMap=e,Q.instance.sky&&"map"in Q.instance.sky&&(Q.instance.sky.map=e)}get exposure(){return Q.instance.sky&&"exposure"in Q.instance.sky?Q.instance.sky.exposure:0}set exposure(e){Q.instance.sky&&"exposure"in Q.instance.sky&&(Q.instance.sky.exposure=e,_.setting.sky.skyExposure=e)}get roughness(){if(Q.instance.sky&&"roughness"in Q.instance.sky)return Q.instance.sky.roughness}set roughness(e){Q.instance.sky&&"roughness"in Q.instance.sky&&(Q.instance.sky.roughness=e)}}class tf extends Ua{constructor(){super(3,Da.triangle_list)}}class rf extends Ua{constructor(){super(2,Da.line_list)}}class af extends f.Object3D{constructor(){super(),n(this,"mLineRender"),n(this,"mFillRender"),this.mLineRender=this.addComponent(rf),this.mFillRender=this.addComponent(tf)}drawAxis(e,t=new p(0,0,0),r=10){this.createCustomShape(e).buildAxis(t,r)}drawLines(e,t,r=z.COLOR_WHITE){this.createCustomShape(e).buildLines(t,r)}drawCurve(e,t,r=10,a=.5,s=z.COLOR_WHITE){var o=[];let l=new p,h=new p;for(let u=0;u<t.length-1;++u){o.push(t[u]);const c=t[Math.max(u-1,0)],d=t[u],g=t[u+1],m=t[Math.min(u+2,t.length-1)];g.subtract(c,l).multiplyScalar(a/3).add(d,l),d.subtract(m,h).multiplyScalar(a/3).add(g,h),o.push(...this.calculateBezierCurve(d,l,h,g,r))}o.push(t[t.length-1]),this.drawLines(e,o,s)}calculateBezierCurve(e,t,r,a,s){var o=new Array(s);for(let l=0;l<s;++l){let h=(l+1)/(s+1),u=1-h,c=e.mul(u*u*u),d=t.mul(3*h*u*u),g=r.mul(3*h*h*u),m=a.mul(h*h*h);o[l]=c.add(d).add(g).add(m)}return o}drawRect(e,t,r,a,s=z.COLOR_WHITE){this.drawLines(e,[t,new p(t.x+r,t.y,t.z),new p(t.x+r,t.y+a,t.z),new p(t.x,t.y+a,t.z),t],s)}drawCircle(e,t,r,a=32,s=p.Y_AXIS,o=z.COLOR_WHITE){this.createCustomShape(e).buildCircle(t,r,a,s,o)}drawSector(e,t,r,a,s,o=16,l=p.Y_AXIS,h=z.COLOR_WHITE){const u=(s-a)*_e;a*=_e;var c=[];c.push(t);for(let A=0;A<=o;++A){A>0&&c.push(c[c.length-1]);var d=u*(A/o)+a,g=r*Math.cos(d),m=r*Math.sin(d);switch(l){case p.X_AXIS:c.push(t.add(new p(0,g,m)));break;case p.Y_AXIS:c.push(t.add(new p(g,0,m)));break;case p.Z_AXIS:c.push(t.add(new p(g,m,0)));break;default:c.push(t.add(new p(g,m,0)));break}}c.push(c[c.length-1]),c.push(t),this.mLineRender.fillShapeData(e,"line",h,c)}drawArcLine(e,t,r,a,s,o=16,l=p.Y_AXIS,h=z.COLOR_WHITE){this.mLineRender.allocGraphics3DShape(e,this.transform._worldMatrix.index).buildArcLine(t,r,a,s,o,l,h)}createCustomShape(e,t=this.transform){return this.mLineRender.allocGraphics3DShape(e,t._worldMatrix.index)}drawBox(e,t,r,a=z.COLOR_WHITE){var s=[];s.push(t),s.push(new p(r.x,t.y,t.z)),s.push(s[s.length-1]),s.push(new p(r.x,r.y,t.z)),s.push(s[s.length-1]),s.push(new p(t.x,r.y,t.z)),s.push(s[s.length-1]),s.push(t),s.push(s[s.length-1]),s.push(new p(t.x,t.y,r.z)),s.push(s[s.length-1]),s.push(new p(r.x,t.y,r.z)),s.push(s[s.length-1]),s.push(new p(r.x,r.y,r.z)),s.push(s[s.length-1]),s.push(new p(t.x,r.y,r.z)),s.push(s[s.length-1]),s.push(new p(t.x,t.y,r.z)),s.push(new p(t.x,r.y,t.z)),s.push(new p(t.x,r.y,r.z)),s.push(new p(r.x,r.y,t.z)),s.push(new p(r.x,r.y,r.z)),s.push(new p(r.x,t.y,t.z)),s.push(new p(r.x,t.y,r.z)),this.mLineRender.fillShapeData(e,"line",a,s)}drawFillRect(e,t,r,a,s=z.COLOR_WHITE){this.mFillRender.fillShapeData(e,"fill",s,[t,new p(t.x+r,t.y,t.z),new p(t.x+r,t.y+a,t.z),new p(t.x+r,t.y+a,t.z),new p(t.x,t.y+a,t.z),t])}drawFillCircle(e,t,r,a=32,s=p.Y_AXIS,o=z.COLOR_WHITE){var l=[];l.push(t);for(let d=0;d<=a;++d){d>=2&&(l.push(t),l.push(l[l.length-2]));var h=2*Math.PI*d/a,u=r*Math.cos(h),c=r*Math.sin(h);switch(s){case p.X_AXIS:l.push(t.add(new p(0,u,c)));break;case p.Y_AXIS:l.push(t.add(new p(u,0,c)));break;case p.Z_AXIS:l.push(t.add(new p(u,c,0)));break;default:l.push(t.add(new p(u,c,0)));break}}this.mFillRender.fillShapeData(e,"fill",o,l)}drawMeshWireframe(e,t,r,a=z.COLOR_WHITE){t&&this.createCustomShape(e,r||this.transform).fillShapeData(t.genWireframe(),a)}drawFillSector(e,t,r,a,s,o=16,l=p.Y_AXIS,h=z.COLOR_WHITE){const u=(s-a)*_e;a*=_e;var c=[];c.push(t);for(let A=0;A<=o;++A){A>=2&&(c.push(t),c.push(c[c.length-2]));var d=u*(A/o)+a,g=r*Math.cos(d),m=r*Math.sin(d);switch(l){case p.X_AXIS:c.push(t.add(new p(0,g,m)));break;case p.Y_AXIS:c.push(t.add(new p(g,0,m)));break;case p.Z_AXIS:c.push(t.add(new p(g,m,0)));break;default:c.push(t.add(new p(g,m,0)));break}}this.mFillRender.fillShapeData(e,"fill",h,c)}drawBoundingBox(e,t,r=z.COLOR_WHITE){this.drawBox(e,t.min,t.max,r)}drawCameraFrustum(e,t=z.COLOR_WHITE){if(e.type==Ie.perspective){let r=Math.tan(e.fov/2*_e),a=r*e.aspect,s=e.transform._worldMatrix,o=s.transformVector(new p(-a,-r,1)),l=s.transformVector(new p(-a,r,1)),h=s.transformVector(new p(a,-r,1)),u=s.transformVector(new p(a,r,1)),c=e.far,d=e.near,g=e.transform.worldPosition,m=new p().copyFrom(o).multiplyScalar(c).add(g),A=new p().copyFrom(l).multiplyScalar(c).add(g),v=new p().copyFrom(h).multiplyScalar(c).add(g),y=new p().copyFrom(u).multiplyScalar(c).add(g),C=new p().copyFrom(o).multiplyScalar(d).add(g),S=new p().copyFrom(l).multiplyScalar(d).add(g),T=new p().copyFrom(h).multiplyScalar(d).add(g),D=new p().copyFrom(u).multiplyScalar(d).add(g),M=this.createCustomShape(`CameraFrustum_${e.object3D.instanceID}`);M.buildLines([S,A],t),M.buildLines([C,m],t),M.buildLines([D,y],t),M.buildLines([T,v],t),M.buildLines([A,y,v,m,A],t),M.buildLines([S,D,T,C,S],t)}else if(e.type==Ie.ortho){e.viewPort,e.viewPort.height;let r=e.transform.worldMatrix,a=r.transformVector(new p(e.viewPort.width*-.5,e.viewPort.height*.5,e.far)),s=r.transformVector(new p(e.viewPort.width*-.5,e.viewPort.height*-.5,e.far)),o=r.transformVector(new p(e.viewPort.width*.5,e.viewPort.height*.5,e.far)),l=r.transformVector(new p(e.viewPort.width*.5,e.viewPort.height*-.5,e.far)),h=r.transformVector(new p(e.viewPort.width*-.5,e.viewPort.height*.5,e.near)),u=r.transformVector(new p(e.viewPort.width*-.5,e.viewPort.height*-.5,e.near)),c=r.transformVector(new p(e.viewPort.width*.5,e.viewPort.height*.5,e.near)),d=r.transformVector(new p(e.viewPort.width*.5,e.viewPort.height*-.5,e.near)),g=this.createCustomShape(`CameraFrustum_${e.object3D.instanceID}`);g.buildLines([h,a],t),g.buildLines([u,s],t),g.buildLines([c,o],t),g.buildLines([d,l],t),g.buildLines([a,o,l,s,a],t),g.buildLines([h,c,d,u,h],t)}}drawObjectBoundingBox(e,t=z.COLOR_WHITE){let r=Kt.genMeshBounds(e);this.drawBox(`Bounds_${e.instanceID}`,r.min,r.max,t)}Clear(e){this.mLineRender.shapes.has(e)?this.mLineRender.removeShape(e):this.mFillRender.shapes.has(e)&&this.mFillRender.removeShape(e)}ClearAll(){this.mLineRender.shapes.clear(),this.mFillRender.shapes.clear()}ChangeColor(e,t){var r;if(this.mLineRender.shapes.has(e))r=this.mLineRender.shapes.get(e);else if(this.mFillRender.shapes.has(e))r=this.mFillRender.shapes.get(e);else return;const a=r.shapeData;for(let s=0;s<a.length;s+=Zt.ShapeVertexSize)a[s+4]=t.r,a[s+5]=t.g,a[s+6]=t.b,a[s+7]=t.a}}class sf{constructor(){n(this,"_computeShader"),n(this,"_outBuffer")}init(){let e=yt.getGBufferFrame("ColorPassGBuffer");this._computeShader=new be(ic),this._outBuffer=new ir(32),this._computeShader.setStorageBuffer("outBuffer",this._outBuffer),this._computeShader.setSamplerTexture("visibleMap",e.getPositionMap())}compute(e){let t=de.getCameraGroup(e.camera);this._computeShader.setStorageBuffer("globalUniform",t.uniformGPUBuffer);let r=w.beginCommandEncoder();w.computeCommand(r,[this._computeShader]),w.endCommandEncoder(r),this._outBuffer.readBuffer()}getPickMeshID(){var e=this._outBuffer.outFloat32Array[0]+.1;return Math.floor(e)}getPickWorldPosition(e){e||(e=new p);var t=this._outBuffer.outFloat32Array[4],r=this._outBuffer.outFloat32Array[5],a=this._outBuffer.outFloat32Array[6];return e.set(t,r,a),e}getPickScreenUV(e){e||(e=new $);var t=this._outBuffer.outFloat32Array[2],r=this._outBuffer.outFloat32Array[3];return e.set(t,r),e}}class nf extends hi{constructor(e){super(),n(this,"ray"),n(this,"isTouching",!1),n(this,"_mouseCode"),n(this,"_pickEvent"),n(this,"_outEvent"),n(this,"_overEvent"),n(this,"_upEvent"),n(this,"_downEvent"),n(this,"_mouseMove"),n(this,"_pickCompute"),n(this,"_lastDownTarget"),n(this,"mouseEnableMap"),n(this,"_view"),n(this,"_lastFocus"),n(this,"_interestList",[]),this._view=e,this.init()}init(){this.ray=new ci,this.mouseEnableMap=new Map,this._pickEvent=new L(L.PICK_CLICK),this._outEvent=new L(L.PICK_OUT),this._overEvent=new L(L.PICK_OVER),this._mouseMove=new L(L.PICK_MOVE),this._upEvent=new L(L.PICK_UP),this._downEvent=new L(L.PICK_DOWN)}start(){_.setting.pick.enable&&(_.inputSystem.addEventListener(L.POINTER_DOWN,this.onTouchStart,this),_.inputSystem.addEventListener(L.POINTER_UP,this.onTouchEnd,this),_.inputSystem.addEventListener(L.POINTER_CLICK,this.onTouchOnce,this),_.inputSystem.addEventListener(L.POINTER_MOVE,this.onTouchMove,this)),_.setting.pick.mode=="pixel"&&(this._pickCompute=new sf,this._pickCompute.init())}stop(){_.inputSystem.removeEventListener(L.POINTER_DOWN,this.onTouchStart,this),_.inputSystem.removeEventListener(L.POINTER_UP,this.onTouchEnd,this),_.inputSystem.removeEventListener(L.POINTER_CLICK,this.onTouchOnce,this),_.inputSystem.removeEventListener(L.POINTER_MOVE,this.onTouchMove,this)}onTouchStart(e){this.isTouching=!0,this._mouseCode=e.mouseCode,this.pick(this._view.camera);let t=this.findNearestObj(this._interestList,this._view.camera);this._lastDownTarget=t,t&&(this._downEvent.target=t.object3D,this._downEvent.ctrlKey=e.ctrlKey,this._downEvent.data={pick:t,pickInfo:this.getPickInfo(),mouseCode:this._mouseCode},this.dispatchEvent(this._downEvent),t.object3D.containEventListener(L.PICK_DOWN)&&t.object3D.dispatchEvent(this._downEvent))}onTouchEnd(e){this.isTouching=!1,this._mouseCode=e.mouseCode,this.pick(this._view.camera);let t=this.findNearestObj(this._interestList,this._view.camera);t&&(this._upEvent.target=t.object3D,this._upEvent.ctrlKey=e.ctrlKey,this._upEvent.data={pick:t,pickInfo:this.getPickInfo(),mouseCode:this._mouseCode},this.dispatchEvent(this._upEvent),t.object3D.containEventListener(L.PICK_UP)&&t.object3D.dispatchEvent(this._upEvent))}getPickInfo(){return{worldPos:this._pickCompute.getPickWorldPosition(),screenUv:this._pickCompute.getPickScreenUV(),meshID:this._pickCompute.getPickMeshID()}}onTouchMove(e){this.isTouching=!0,this._mouseCode=e.mouseCode,this.pick(this._view.camera);let t=this.findNearestObj(this._interestList,this._view.camera);t&&(this._mouseMove.target=t.object3D,this._mouseMove.ctrlKey=e.ctrlKey,this._mouseMove.data={pick:t,pickInfo:this.getPickInfo(),mouseCode:this._mouseCode},this.dispatchEvent(this._mouseMove),t.object3D.containEventListener(L.PICK_MOVE)&&t.object3D.dispatchEvent(this._mouseMove)),t!=this._lastFocus&&(this._lastFocus&&this._lastFocus.object3D&&(this._outEvent.target=this._lastFocus.object3D,this._outEvent.data={pick:this._lastFocus,pickInfo:this.getPickInfo(),mouseCode:this._mouseCode},this._outEvent.ctrlKey=e.ctrlKey,this.dispatchEvent(this._outEvent),this._lastFocus.object3D.containEventListener(L.PICK_OUT)&&this._lastFocus.object3D.dispatchEvent(this._outEvent)),t&&(this._overEvent.target=t.object3D,this._overEvent.ctrlKey=e.ctrlKey,this._overEvent.data={pick:t,pickInfo:this.getPickInfo(),mouseCode:this._mouseCode},this.dispatchEvent(this._overEvent),t.object3D.containEventListener(L.PICK_OVER)&&t.object3D.dispatchEvent(this._overEvent))),this._lastFocus=t}onTouchOnce(e){this.isTouching=!0,this._mouseCode=e.mouseCode,this.pick(this._view.camera);let t=this.findNearestObj(this._interestList,this._view.camera);if(t){let r=_.setting.pick.mode=="pixel"?this.getPickInfo():null;this._pickEvent.target=t.object3D,this._pickEvent.ctrlKey=e.ctrlKey,this._pickEvent.data={pick:t,pickInfo:r,mouseCode:this._mouseCode},this.dispatchEvent(this._pickEvent),t===this._lastDownTarget&&t.object3D.containEventListener(L.PICK_CLICK)&&t.object3D.dispatchEvent(this._pickEvent)}this._lastDownTarget=null}findNearestObj(e,t){var r;return e.sort((a,s)=>a.distance>s.distance?1:-1),(r=e[0])==null?void 0:r.collider}pick(e){if(this._interestList.length=0,_.setting.pick.mode=="pixel"){this._pickCompute.compute(this._view);let t=this._pickCompute.getPickMeshID(),r=this.mouseEnableMap.get(t);if(r){let a=this._pickCompute.getPickWorldPosition(),s=p.distance(a,this.ray.origin);this._interestList.push({distance:s,collider:r,intersectPoint:a})}}else if(_.setting.pick.mode=="bound"){this.ray=e.screenPointToRay(_.inputSystem.mouseX,_.inputSystem.mouseY);let t,r=se.componentsEnablePickerList.get(this._view);if(r)for(const a of r){let s=a[0];s.enable&&(t=s.rayPick(this.ray),t&&(t.collider=s,this._interestList.push(t)))}}}}class Bp extends Sr{constructor(e=0,t=0,r=0,a=0){super(),n(this,"_camera"),n(this,"_scene"),n(this,"_viewPort"),n(this,"_enablePick",!1),n(this,"_enable",!0),n(this,"pickFire"),n(this,"guiPick"),n(this,"canvasList"),n(this,"graphic3D"),this.canvasList=[],this._viewPort=new q(e,t,r,a),this.enablePick=!0,this.graphic3D=new af}get enable(){return this._enable}set enable(e){this._enable=e}get enablePick(){return this._enablePick}set enablePick(e){this._enablePick!=e&&(this.pickFire=new nf(this),this.pickFire.start()),this._enablePick=e}get scene(){return this._scene}set scene(e){this._scene=e,e.view=this,Ge.createBuffer(e),this.graphic3D&&e.addChild(this.graphic3D),e&&this.canvasList.forEach(t=>{t&&e.addChild(t.object3D)})}get camera(){return this._camera}set camera(e){this._camera=e}get viewPort(){return this._viewPort}set viewPort(e){this._viewPort=e}enableUICanvas(e=0){let t=this.canvasList[e];if(!t){let r=new f.Object3D;r.name="Canvas "+e,t=r.addComponent(ua),t.index=e,this.canvasList[e]=t}return this.scene.addChild(t.object3D),this.guiPick||(this.guiPick=new Vc,this.guiPick.init(this)),t}disableUICanvas(e=0){let t=this.canvasList[e];t&&t.object3D&&t.object3D.removeFromParent()}}class Tp{constructor(e){n(this,"normal"),n(this,"fixNormal"),n(this,"center"),n(this,"rotateShape"),n(this,"distance",0),n(this,"index"),this.index=e,this.rotateShape=[]}}class Dp extends it{constructor(){super(...arguments),n(this,"vScale"),n(this,"uNegate"),n(this,"sections")}build(e,t,r,a=1,s=!0){if(r.length<2)throw new Error("path length is not enough");return this.vScale=a,this.uNegate=s,e=e.slice(),t&&e.push(e[0]),this.sections=this.buildSections(e,r),this.buildGeometry(e,this.sections),this.bounds=new Be(p.ZERO.clone(),new p(100,100,100)),this}buildSections(e,t){let r,a,s,o=[],l=t.length;for(let u=0;u<l;u++){let c=new Tp(u);r=t[u],a=t[u+1],c.center=r.clone(),a==null?(c.normal=s.clone(),c.distance=0):(s=a.subtract(r),c.distance=s.length,c.normal=s.normalize()),o.push(c)}o[0].fixNormal=o[0].normal.clone();for(let u=1;u<l;u++){let c=o[u-1],d=o[u];d.fixNormal=d.normal.add(c.normal).normalize()}let h=new H().identity();for(let u=0;u<l;u++){let c=o[u],d,g;if(u==0)d=p.UP,g=e;else{let m=o[u-1];d=m.fixNormal,g=m.rotateShape}H.fromToRotation(d,c.fixNormal,h);for(let m=0,A=e.length;m<A;m++){let v=h.multiplyPoint3(g[m]);c.rotateShape.push(v)}}return o}buildGeometry(e,t){let r=t.length,a=e.length,s=r*a,o=r-1,l=new Float32Array(s*3),h=new Float32Array(s*3),u=new Float32Array(s*2),c=new Uint32Array(o*(a-1)*6),d=a-1,g=0,m=0,A=[0];for(let y=1;y<a;y++)m+=e[y-1].subtract(e[y]).length,A.push(m);for(let y=0;y<r;y++){let C=t[y];for(let S=0;S<a;S++){let T=(y*a+S)*3,D=C.rotateShape[S].add(C.center);l[T]=D.x,l[T+1]=D.y,l[T+2]=D.z,h[T+1]=1;let M=(y*a+S)*2,P=A[S]/m;u[M]=this.uNegate?1-P:P,u[M+1]=g*this.vScale}g+=C.distance}let v=0;for(let y=0;y<o;y++){let C=y*a;for(let S=0;S<d;S++){let T=S,D=S+1,M=T+a,P=D+a;c[v++]=T+C,c[v++]=D+C,c[v++]=M+C,c[v++]=D+C,c[v++]=P+C,c[v++]=M+C}}return this.setIndices(c),this.setAttribute(X.position,l),this.setAttribute(X.normal,h),this.setAttribute(X.uv,u),this.setAttribute(X.TEXCOORD_1,u),this.addSubGeometry({indexStart:0,indexCount:c.length,vertexStart:0,index:0}),this.computeNormals(),this}}class Mp{constructor(){n(this,"name"),n(this,"offset"),n(this,"size"),n(this,"arrayStride"),n(this,"stepMode"),n(this,"attributes")}}class Pp{constructor(){n(this,"name"),n(this,"format"),n(this,"offset"),n(this,"shaderLocation"),n(this,"stride")}}var of=(i=>(i[i.position=3]="position",i[i.normal=3]="normal",i[i.TANGENT=4]="TANGENT",i[i.uv=2]="uv",i[i.TEXCOORD_1=2]="TEXCOORD_1",i[i.color=4]="color",i[i.joints0=4]="joints0",i[i.weights0=4]="weights0",i[i.joints1=4]="joints1",i[i.weights1=4]="weights1",i[i.vIndex=1]="vIndex",i[i.weight=1]="weight",i[i.a_morphPositions_0=3]="a_morphPositions_0",i))(of||{});class Rp{constructor(){}}class Lp{constructor(){n(this,"entity")}get data(){return null}}class lf{constructor(){n(this,"min",0),n(this,"max",0)}set(e,t){return this.max=t,this.min=e,this}copy(e){return this.max=e.max,this.min=e.min,this}isInterestRange(e){return!(this.max>e.min||e.max<this.min)}}class hf{constructor(){n(this,"_spaceDesc")}getRange(e){return this._spaceDesc[e]}initSpace(e){this._spaceDesc={};for(let t of e)(this._spaceDesc[t]=new lf).set(-Number.MAX_VALUE,Number.MAX_VALUE);return this}isContain(e,t){let r=this._spaceDesc[e];return t>=r.min&&t<r.max}isInterestRange(e,t){let r=this._spaceDesc[e];return r?t.isInterestRange(r):!1}splitSpace(e,t,r){let a=this._spaceDesc[e];return t?a.max=r:a.min=r,this}copySpace(e){for(let t in e._spaceDesc){let r=e._spaceDesc[t];this._spaceDesc[t].copy(r)}return this}}const uf=class{};let yr=uf;n(yr,"MaxEntityCountInLeaf",4),n(yr,"MaxLayer",10),n(yr,"ClearLeafLayer",uf.MaxLayer-4);const cf=class{constructor(){n(this,"uuid","0"),this.uuid=(cf.UUID++).toString()}};let vs=cf;n(vs,"UUID",0);class Up{constructor(){n(this,"map",{}),n(this,"_count",0)}get count(){return this._count}push(e){return this.map[e.uuid]?!1:(this.map[e.uuid]=e,this._count++,!0)}remove(e){return this.map[e]?(delete this.map[e],this._count--,!0):!1}}const Wi=class extends vs{constructor(i=0){super(),n(this,"_dimensionIndex",0),n(this,"_dimensions"),n(this,"_dimension"),n(this,"_left"),n(this,"_right"),n(this,"_space"),n(this,"_parent"),n(this,"_entities"),n(this,"layer"),n(this,"_splitEntityList",[]),n(this,"pointIntersect",new p),this.layer=i,Wi.nodeCount++}get dimension(){return this._dimension}initNode(i,e,t){return this._dimensions=e,this._dimensionIndex=t,this._dimension=e[t],this._space=new hf().initSpace(e),i&&this._space.copySpace(i._space),this._parent=i,this._entities=new Up,this}updateEntity(i){if(i.isInNode(this,this._dimension)&&(i.attachTreeNode(this),this.autoSplit(),this._left&&this._right)){let e=(this._dimensionIndex+1)%this._dimensions.length,t=this._dimensions[e];i.isInNode(this._right,t)?this._right.updateEntity(i):i.isInNode(this._left,t)&&this._left.updateEntity(i)}}buildRoot(i){for(const e of i)e.entity.attachTreeNode(this);this.autoSplit()}autoSplit(){if(this._entities.count>yr.MaxEntityCountInLeaf&&!this._right&&!this._left&&this.layer<yr.MaxLayer){let i=this._splitEntityList,e=(this._dimensionIndex+1)%this._dimensions.length,t=this._dimensions[e],r=0;for(const a in this._entities.map){let s=this._entities.map[a];r+=s.centerValue(t),i.push(s)}r/=this._entities.count,this._left=new Wi(this.layer+1),this._right=new Wi(this.layer+1),this._left.initNode(this,this._dimensions,e),this._right.initNode(this,this._dimensions,e),this._left.setSpace(!0,r),this._right.setSpace(!1,r);for(let a of i)a.isInNode(this._right,t)?a.attachTreeNode(this._right):a.isInNode(this._left,t)&&a.attachTreeNode(this._left)}this._left&&this._left.autoSplit(),this._right&&this._right.autoSplit()}setSpace(i,e){return this._parent&&this._space.splitSpace(this._dimension,i,e),this}isEmpty(){return this._left==null&&this._right==null&&this._entities.count==0}pushEntity(i){return this._entities.push(i)}removeEntity(i){return this._entities.remove(i.uuid)}autoClear(){let i=this;for(;i&&i.layer>yr.ClearLeafLayer&&i.clearLeaf();)i=i._parent}clearLeaf(){let i=!this._left&&!this._right,e=!i&&this._left.isEmpty()&&this._right.isEmpty();return e&&(this._left=this._right=null,Wi.nodeCount-=2),i||e}isContain(i){return this._space.isContain(this._dimension,i)}nodeIntersectsBox(i){let e=this._space.getRange("x"),t=this._space.getRange("y"),r=this._space.getRange("z"),a=Wi.rangeBox;return a.min.set(e.min,t.min,r.min),a.max.set(e.max,t.max,r.max),a.intersectsBox(i)}nodeIntersectsRay(i){let e=this._space.getRange("x"),t=this._space.getRange("y"),r=this._space.getRange("z"),a=Wi.rangeBox;return a.min.set(e.min,t.min,r.min),a.max.set(e.max,t.max,r.max),!0}pointCast(i,e=0,t){if(t=t||[],this._entities.count>0){let r=this._entities.map;for(let a in r){let s=r[a],o=s.entityContainPoint(i);!o&&e>0&&(o=s.squareDistanceTo(i,this._dimensions)<=e),o&&t.push(s)}}this._left&&this._left.isContain(i[this._left.dimension])&&this._left.pointCast(i,e,t),this._right&&this._right.isContain(i[this._right.dimension])&&this._right.pointCast(i,e,t)}boxCast(i,e){if(e=e||[],this._entities.count>0){let t=this._entities.map;for(let r in t){let a=t[r];a.entityIntersectsBox(i)&&e.push(a)}}this._left&&this._left.nodeIntersectsBox(i)&&this._left.boxCast(i,e),this._right&&this._right.nodeIntersectsBox(i)&&this._right.boxCast(i,e)}rayCast(i,e,t){e=e||[],t=t||[];let r=this.pointIntersect;if(this._entities.count>0){let a=this._entities.map;for(let s in a){let o=a[s];o.entityIntersectsRay(i,r)&&(t.push(new p().copyFrom(r)),e.push(o))}}this._left&&this._left.nodeIntersectsRay(i)&&this._left.rayCast(i,e,t),this._right&&this._right.nodeIntersectsRay(i)&&this._right.rayCast(i,e,t)}};let Jn=Wi;n(Jn,"nodeCount",0),n(Jn,"rangeBox",new Be(new p(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),new p(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE)));class Op extends vs{constructor(e){super(),n(this,"userData"),n(this,"node"),this.userData=e}centerValue(e){return 0}isInNode(e,t){return!1}entityContainPoint(e){return!1}squareDistanceTo(e,t){return Number.MAX_VALUE}entityIntersectsBox(e){return!1}entityIntersectsRay(e,t){return!1}attachTreeNode(e){return this.node&&this.detachTreeNode(),this.node=e,this.node.pushEntity(this)}detachTreeNode(){let e=this.node.removeEntity(this);return this.node=null,e}updateNode(e){let t=this.node;t&&this.detachTreeNode(),e.updateEntity(this),t&&t.autoClear()}}class ff extends je{}n(ff,"RESIZE","resize");var df=(i=>(i[i.MOUSE_LEFT=0]="MOUSE_LEFT",i[i.MOUSE_MID=1]="MOUSE_MID",i[i.MOUSE_RIGHT=2]="MOUSE_RIGHT",i))(df||{});class Zn extends je{}n(Zn,"LOADER_PROGRESS","loaderProgress"),n(Zn,"LOADER_COMPLETE","loaderComplete");class da extends je{}n(da,"ADDED","added"),n(da,"REMOVED","removed"),n(da,"CHILD_ADD_EVENT","childAddEvent"),n(da,"CHILD_REMOVED","childRemoved");class xs extends je{}n(xs,"SHOW","show"),n(xs,"HIDE","hide"),n(xs,"UPDATE","update");class Np{static merge(e,t,r,a){let s=0,o=0;s=Math.max(e.width,s),s=Math.max(t.width,s),s=Math.max(r.width,s),s=Math.max(a.width,s),o=Math.max(e.height,o),o=Math.max(t.height,o),o=Math.max(r.height,o),o=Math.max(a.height,o);let l=new ne(s,o,G.rgba8unorm),h=new be(Zu);h.setSamplerTexture("textureR",e),h.setSamplerTexture("textureG",t),h.setSamplerTexture("textureB",r),h.setSamplerTexture("textureA",a),h.setStorageTexture("outTex",l),h.workerSizeX=Math.ceil(s/8),h.workerSizeY=Math.ceil(o/8);let u=w.beginCommandEncoder();return w.computeCommand(u,[h]),w.endCommandEncoder(u),l}}class Fp extends qt{constructor(e,t,r=0){super(),this.bufferType=Tt.StructStorageGPUBuffer,this.createBufferByStruct(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|r,e,t)}}class ga{static createMipmap(e,t){const r=I.device;this._pipelineMax||(this._pipelineMax=r.createComputePipeline({layout:"auto",compute:{module:r.createShaderModule({code:this.codeMax}),entryPoint:"main"}})),this._pipelineMin||(this._pipelineMin=r.createComputePipeline({layout:"auto",compute:{module:r.createShaderModule({code:this.codeMin}),entryPoint:"main"}}));let a=Math.ceil(e.width*.5),s=Math.ceil(e.height*.5),o={mipmapCount:t,texture:e,srcView:null,mipLevel:1,dstHeight:s,dstWidth:a};o.srcView=e.getGPUTexture().createView({format:e.format,dimension:"2d",baseMipLevel:0,mipLevelCount:1}),e.width>1024&&e.height>1024?this.mipmap(this._pipelineMax,o):this.mipmap(this._pipelineMin,o)}static mipmap(e,t){const r=I.device,a=w.beginCommandEncoder();let s=e==this._pipelineMax,o,l;for(let h=t.mipLevel;h<t.mipmapCount;h++){let u=[],c=0;u.push({binding:c++,resource:t.srcView}),u.push({binding:c++,resource:t.texture.gpuSampler}),o=t.texture.getGPUTexture().createView({format:t.texture.format,dimension:"2d",baseMipLevel:h,mipLevelCount:1}),u.push({binding:c++,resource:o});const d=r.createBindGroup({layout:e.getBindGroupLayout(0),entries:u}),g=a.beginComputePass();g.setPipeline(e),g.setBindGroup(0,d);let m=t.dstWidth,A=t.dstHeight;if(s&&(m=Math.max(1,Math.floor(t.dstWidth/8)),A=Math.max(1,Math.floor(t.dstHeight/8))),g.dispatchWorkgroups(m,A),t.dstHeight*=.5,t.dstWidth*=.5,t.srcView=o,t.mipLevel=h+1,l=s&&(t.dstWidth<8||t.dstHeight<8),g.end(),l)break}w.endCommandEncoder(a),l&&this.mipmap(this._pipelineMin,t)}}n(ga,"codeMax",`
        @group(0) @binding(0) var inputTexture : texture_2d<f32>;
        @group(0) @binding(1) var inputTextureSampler : sampler;
        @group(0) @binding(2) var outputTexture : texture_storage_2d<rgba8unorm, write>;
        
        @compute @workgroup_size(8, 8)
        fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
            let dstSize = textureDimensions(outputTexture).xy;
            let uv01 = vec2<f32>(f32(GlobalInvocationID.x) / f32(dstSize.x - 1), f32(GlobalInvocationID.y) / f32(dstSize.y - 1));
            var fromColor = textureSampleLevel(inputTexture, inputTextureSampler, uv01, 0.0);
            let dstCoord = vec2<i32>(i32(GlobalInvocationID.x), i32(GlobalInvocationID.y));
            
            //fromColor = vec4<f32>(0.0, 0.0, 0.0, 1.0);
            //if(dstSize.x == 512){
            //    fromColor.x = 1.0;
            //}else  if(dstSize.x == 256){
            //    fromColor.y = 1.0;
            //}else if(dstSize.x == 128){
            //    fromColor.z = 1.0;
            //}
            
            textureStore(outputTexture, dstCoord, fromColor);
        }
    `),n(ga,"codeMin",`
        @group(0) @binding(0) var inputTexture : texture_2d<f32>;
        @group(0) @binding(1) var inputTextureSampler : sampler;
        @group(0) @binding(2) var outputTexture : texture_storage_2d<rgba8unorm, write>;
        
        @compute @workgroup_size(1, 1)
        fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
            let dstSize = textureDimensions(outputTexture).xy;
            let uv01 = vec2<f32>(f32(GlobalInvocationID.x) / f32(dstSize.x - 1), f32(GlobalInvocationID.y) / f32(dstSize.y - 1));
            var fromColor = textureSampleLevel(inputTexture, inputTextureSampler, uv01, 0.0);
            let dstCoord = vec2<i32>(i32(GlobalInvocationID.x), i32(GlobalInvocationID.y));
            
            textureStore(outputTexture, dstCoord, fromColor);
        }
    `),n(ga,"_pipelineMax"),n(ga,"_pipelineMin");class gf{constructor(){n(this,"name",""),n(this,"passMap",new Map)}}class pf{constructor(){n(this,"passType",""),n(this,"shaderState",new Map),n(this,"vertexShader",""),n(this,"fragmentShader","")}}class Cr{static parser(e,t){e=ut.filterComment(e);let r=new gf,a=e.indexOf(this.shaderKeyword),s=e.indexOf("{",a),o=e.substring(a+this.shaderKeyword.length,s).trim();r.name=o.substring(1,o.length-1),o=e.substring(e.indexOf("{")+1,e.lastIndexOf("}"));let l=this.splitPassBlock(o);for(let h of l){let u=this.parserPassBlock(h),c;r.passMap.has(u.passType)?c=r.passMap.get(u.passType):(c=[],r.passMap.set(u.passType,c)),c.push(u),u.vertexShader.length>0&&(u.vertexShader=ut.parse(u.vertexShader,t)),u.fragmentShader.length>0&&(u.fragmentShader=ut.parse(u.fragmentShader,t))}return r}static splitPassBlock(e){let t=0,r=[];for(;t<e.length;){let a=e.indexOf(this.passKeyword,t);if(a==-1){r.push(e.substring(t));break}t!=0&&r.push(e.substring(t,a)),t=a+this.passKeyword.length}return r}static parserPassBlock(e){let t=new pf,r=e.indexOf(this.passTypeKeyword),a=e.indexOf('"',r);return r=e.indexOf('"',a+1),t.passType=e.substring(r+1,a).trim(),this.parserShaderState(t,e),r=e.indexOf(this.vertexKeyword),r!=-1&&(t.vertexShader=this.extractBlock(e.substring(r+this.vertexKeyword.length),"{","}")),r=e.indexOf(this.fragmentKeyword),r!=-1&&(t.fragmentShader=this.extractBlock(e.substring(r+this.fragmentKeyword.length),"{","}")),t}static parserShaderState(e,t){let r=t.indexOf("ShaderState");if(r==-1)return!1;r=t.indexOf("{",r);let a=t.indexOf("}",r),o=t.substring(r+1,a).split(",");for(let l of o){let h=l.split(":"),u=h[0].trim(),c=this.convertValue(h[1].trim());e.shaderState.set(u,c)}return!0}static convertValue(e){return e.length==4&&e.toLowerCase()=="true"?!0:e.length==5&&e.toLowerCase()=="false"?!1:e[0]=='"'?e.substring(1,e.length-1):Number.parseInt(e)}static extractBlock(e,t,r){let a=e.indexOf(t);if(a==-1)return"";let s=0,o=0;e=e.substring(a);for(let h of e){if(h==t?s++:h==r&&s--,s<=0)break;o++}return e.substring(1,o).trim()}}n(Cr,"passKeyword","pass"),n(Cr,"shaderKeyword","Shader"),n(Cr,"vertexKeyword","vertex"),n(Cr,"fragmentKeyword","fragment"),n(Cr,"passTypeKeyword","PassType");let mf=new je("IrradianceDataReaderCompleteEvent");class pa extends hi{constructor(){super(...arguments),n(this,"readFlag",!1),n(this,"probeRenderer"),n(this,"opColorBuffer"),n(this,"opDepthBuffer"),n(this,"srcColorMap"),n(this,"srcDepthMap"),n(this,"opDepthArray"),n(this,"opColorArray")}initReader(e,t,r){this.probeRenderer=e,this.srcColorMap=t,this.srcDepthMap=r;let a=_.setting.gi,s=a.octRTMaxSize*a.octRTMaxSize;this.opColorBuffer=I.device.createBuffer({size:s*4*4,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ,mappedAtCreation:!1}),this.opColorArray=new Float32Array(s*4),this.opDepthBuffer=I.device.createBuffer({size:s*4*4,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ,mappedAtCreation:!1}),this.opDepthArray=new Float32Array(s*4),this.probeRenderer.addEventListener(rn.type,()=>{this.onProbeRenderComplete()},this),this.probeRenderer.addEventListener(Ha.type,()=>{console.log("GIRenderStartEvent")},this)}async onProbeRenderComplete(){if(console.log("GIRenderCompleteEvent"),this.readFlag)console.log("irradianceDataReader is reading yet!!!");else{this.readFlag=!0;let e=Date.now();console.log("irradianceDataReader start reading "),await pa.read(this.srcColorMap.getGPUTexture(),this.opColorBuffer,this.opColorArray),await pa.read(this.srcDepthMap.getGPUTexture(),this.opDepthBuffer,this.opDepthArray),this.readFlag=!1,console.log("process time :",Date.now()-e),console.log("irradianceDataReader read complete"),this.dispatchEvent(mf)}}static async read(e,t,r){let a=w.beginCommandEncoder();a.copyTextureToBuffer({texture:e},{buffer:t,bytesPerRow:e.width*16},[e.width,e.height]),w.endCommandEncoder(a),await t.mapAsync(GPUMapMode.READ);const s=t.getMappedRange();r.set(new Float32Array(s),0),t.unmap()}}let kp=new pa;class zp{constructor(){n(this,"computeShader"),n(this,"visibleBuffer"),n(this,"texture"),this.computeShader=new be(gc),this.visibleBuffer=new ir(8192*2),this.computeShader.setStorageBuffer("visibleBuffer",this.visibleBuffer),this.texture=Ne.getTexture(Ae.zBufferTexture_NAME),this.computeShader.setSamplerTexture("zBufferTexture",this.texture),this.computeShader.workerSizeX=Math.ceil(this.texture.width/8),this.computeShader.workerSizeY=Math.ceil(this.texture.height/8),this.computeShader.workerSizeZ=1}compute(e,t){this.visibleBuffer.reset(!0,0),this.visibleBuffer.apply();let r=w.beginCommandEncoder();w.computeCommand(r,[this.computeShader]),this.visibleBuffer.readBuffer(),t.zVisibleList=this.visibleBuffer.outFloat32Array}}class Gp extends xt{constructor(){super(),n(this,"blurTexture1"),n(this,"blurTexture2"),n(this,"rendererPassState"),n(this,"blurComputes"),n(this,"blurSettings"),n(this,"outTexture"),n(this,"rtFrame")}onAttach(e){_.setting.render.postProcessing.depthOfView.enable=!0}onDetach(e){_.setting.render.postProcessing.depthOfView.enable=!1}createGUI(){}get pixelOffset(){return _.setting.render.postProcessing.depthOfView.pixelOffset}set pixelOffset(e){e=Math.max(0,e);let t=_.setting.render.postProcessing.depthOfView;t.pixelOffset=e}get near(){return _.setting.render.postProcessing.depthOfView.near}set near(e){e=Math.max(0,e);let t=_.setting.render.postProcessing.depthOfView;t.near=e}get far(){return _.setting.render.postProcessing.depthOfView.far}set far(e){e=Math.max(0,e);let t=_.setting.render.postProcessing.depthOfView;t.far=e}createBlurCompute(){this.blurSettings=[],this.blurComputes=[];let e=_.setting.render.postProcessing.depthOfView;for(let t=0;t<e.iterationCount;t++){let r=new Dt(4),a=new be(qu);this.blurComputes.push(a),this.blurSettings.push(r),a.setUniformBuffer("blurSetting",r);let s=yt.getGBufferFrame("ColorPassGBuffer");a.setSamplerTexture(Ae.positionBufferTex_NAME,s.attachments[1]),a.setSamplerTexture(Ae.normalBufferTex_NAME,s.attachments[2]);let o=t%2==0?this.blurTexture1:this.blurTexture2,l=t%2==1?this.blurTexture1:this.blurTexture2;a.setSamplerTexture("inTex",o),a.setStorageTexture("outTex",l),a.workerSizeX=Math.ceil(this.blurTexture1.width/8),a.workerSizeY=Math.ceil(this.blurTexture1.height/8),a.workerSizeZ=1,this.outTexture=l}}createResource(){let e=I.presentationSize,t=e[0],r=e[1];this.blurTexture1=new ne(t,r,G.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.TEXTURE_BINDING),this.blurTexture1.name="dof1";let a=new Ce;a.clearValue=[0,0,0,1],a.loadOp="clear",this.blurTexture2=new ne(t,r,G.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.TEXTURE_BINDING),this.blurTexture2.name="dof2";let s=new Ce;s.clearValue=[0,0,0,1],s.loadOp="clear",this.rtFrame=new Ke([this.blurTexture1,this.blurTexture2],[a,s])}render(e,t){if(!this.blurComputes){this.createResource(),this.createBlurCompute(),this.createGUI();let a=de.getCameraGroup(e.camera);for(let s=0;s<this.blurComputes.length;s++)this.blurComputes[s].setUniformBuffer("standUniform",a.uniformGPUBuffer);this.rendererPassState=Qe.createRendererPassState(this.rtFrame,null)}this.autoSetColorTexture("inTex",this.blurComputes[0]);let r=_.setting.render.postProcessing.depthOfView;r.far=Math.max(r.near,r.far)+1e-4;for(let a=0;a<r.iterationCount;a++){let s=this.blurComputes[a],o=this.blurSettings[a];o.setFloat("near",r.near),o.setFloat("far",r.far),o.setFloat("pixelOffset",(a+1)*r.pixelOffset),o.apply(),s.setStorageBuffer("blurSetting",o)}w.computeCommand(t,this.blurComputes),w.lastRenderPassState=this.rendererPassState}}class Qp extends xt{constructor(){super(),n(this,"gtaoTexture"),n(this,"rendererPassState"),n(this,"gtaoCompute"),n(this,"gtaoSetting"),n(this,"aoBuffer"),n(this,"directionsBuffer"),n(this,"directionsArray"),n(this,"rtFrame"),n(this,"Render"),n(this,"randomCount",0)}onAttach(e){_.setting.render.postProcessing.gtao.enable=!0,this.createGUI()}onDetach(e){_.setting.render.postProcessing.gtao.enable=!1,this.removeGUI()}get maxDistance(){return _.setting.render.postProcessing.gtao.maxDistance}set maxDistance(e){e=J(e,.1,50);let t=_.setting.render.postProcessing.gtao;t.maxDistance=e}get maxPixel(){return _.setting.render.postProcessing.gtao.maxPixel}set maxPixel(e){e=J(e,5,100);let t=_.setting.render.postProcessing.gtao;t.maxPixel=e}get darkFactor(){return _.setting.render.postProcessing.gtao.darkFactor}set darkFactor(e){e=J(e,.01,1);let t=_.setting.render.postProcessing.gtao;t.darkFactor=e}get rayMarchSegment(){return _.setting.render.postProcessing.gtao.rayMarchSegment}set rayMarchSegment(e){e=J(e,4,10);let t=_.setting.render.postProcessing.gtao;t.rayMarchSegment=e}get multiBounce(){return _.setting.render.postProcessing.gtao.multiBounce}set multiBounce(e){let t=_.setting.render.postProcessing.gtao;t.multiBounce=e}get blendColor(){return _.setting.render.postProcessing.gtao.blendColor}set blendColor(e){let t=_.setting.render.postProcessing.gtao;t.blendColor=e}get usePosFloat32(){return _.setting.render.postProcessing.gtao.usePosFloat32}set usePosFloat32(e){let t=_.setting.render.postProcessing.gtao;t.usePosFloat32=e}createGUI(){}removeGUI(){}createCompute(){_.setting.render.postProcessing.gtao,this.gtaoCompute=new be(Ku);let e=new Dt(4*2);this.gtaoCompute.setUniformBuffer("gtaoData",e),this.directionsArray=new Float32Array(8*2),this.directionsBuffer=new fe(8*2),this.directionsBuffer.setFloat32Array("array",this.randomDirection()),this.directionsBuffer.apply(),this.gtaoCompute.setStorageBuffer("directions",this.directionsBuffer),this.aoBuffer=new fe(this.gtaoTexture.width*this.gtaoTexture.height),this.gtaoCompute.setStorageBuffer("aoBuffer",this.aoBuffer);let t=yt.getGBufferFrame("ColorPassGBuffer"),r=t.attachments[1];this.gtaoCompute.setSamplerTexture("posTex",r),this.gtaoCompute.setSamplerTexture("normalTex",t.attachments[2]),this.autoSetColorTexture("inTex",this.gtaoCompute),this.gtaoCompute.setStorageTexture("outTex",this.gtaoTexture),this.gtaoCompute.workerSizeX=Math.ceil(this.gtaoTexture.width/8),this.gtaoCompute.workerSizeY=Math.ceil(this.gtaoTexture.height/8),this.gtaoCompute.workerSizeZ=1,this.gtaoSetting=e}createResource(){let e=I.presentationSize,t=e[0],r=e[1];this.gtaoTexture=new ne(t,r,G.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.TEXTURE_BINDING),this.gtaoTexture.name="gtaoTex";let a=new Ce;a.loadOp="load",this.rtFrame=new Ke([this.gtaoTexture],[a])}randomDirection(){this.randomCount++,this.randomCount>1&&(this.randomCount=0);let e=Math.PI*2*this.randomCount/16,t=Math.PI*2/8;for(let r=0;r<8;r++){let a=e+r*t;this.directionsArray[r*2]=Math.sin(a),this.directionsArray[r*2+1]=Math.cos(a)}return this.directionsArray}render(e,t){if(!this.gtaoCompute){this.createResource(),this.createCompute(),this.rendererPassState=Qe.createRendererPassState(this.rtFrame,null),this.rendererPassState.label="GTAO";let h=de.getCameraGroup(e.camera);this.gtaoCompute.setUniformBuffer("globalUniform",h.uniformGPUBuffer)}let r=_.setting.render.postProcessing.gtao;this.directionsBuffer.setFloat32Array("array",this.randomDirection()),this.directionsBuffer.apply();let a=1-.2*(he.frame%2),s=r.maxDistance*a,o=r.maxPixel*a;this.gtaoSetting.setFloat("maxDistance",s),this.gtaoSetting.setFloat("maxPixel",o),this.gtaoSetting.setFloat("darkFactor",r.darkFactor),this.gtaoSetting.setFloat("rayMarchSegment",r.rayMarchSegment);let l=e.camera;this.gtaoSetting.setFloat("cameraNear",l.near),this.gtaoSetting.setFloat("cameraFar",l.far),this.gtaoSetting.setFloat("multiBounce",r.multiBounce?1:0),this.gtaoSetting.setFloat("blendColor",r.blendColor?1:0),this.gtaoSetting.apply(),w.computeCommand(t,[this.gtaoCompute]),w.lastRenderPassState=this.rendererPassState}}class Vp extends xt{constructor(){super(),n(this,"viewQuad"),n(this,"rtTexture"),n(this,"_globalFog"),n(this,"_lastSkyTexture");let e=this._globalFog=_.setting.render.postProcessing.globalFog,t=yt.getGBufferFrame("ColorPassGBuffer"),r=I.presentationSize;N.register("GlobalFog_shader",Ic);let a={fogColor:new ee(new z(e.fogColor.r,e.fogColor.g,e.fogColor.b,e.fogColor.a)),fogType:new ee(e.fogType),fogHeightScale:new ee(e.fogHeightScale),start:new ee(e.start),end:new ee(e.end),density:new ee(e.density),ins:new ee(e.ins),falloff:new ee(e.falloff),rayLength:new ee(e.rayLength),scatteringExponent:new ee(e.scatteringExponent),dirHeightLine:new ee(e.dirHeightLine),skyFactor:new ee(e.skyFactor),skyRoughness:new ee(e.skyRoughness),overrideSkyFactor:new ee(e.overrideSkyFactor),isSkyHDR:new ee(0)};this.rtTexture=this.createRTTexture("GlobalFog",r[0],r[1],G.rgba16float),this.viewQuad=this.createViewQuad("GlobalFog","GlobalFog_shader",this.rtTexture,a);let s=t.getPositionMap(),o=t.getNormalMap();this.setInputTexture(s,o)}onAttach(e){_.setting.render.postProcessing.globalFog.enable=!0}onDetach(e){_.setting.render.postProcessing.globalFog.enable=!1}set fogType(e){this._globalFog.fogType=e,this.viewQuad.uniforms.fogType.value=e}get fogType(){return this._globalFog.fogType}set fogHeightScale(e){this._globalFog.fogHeightScale=e,this.viewQuad.uniforms.fogHeightScale.value=e}get fogHeightScale(){return this.viewQuad.uniforms.fogHeightScale.value}set start(e){this._globalFog.start=e,this.viewQuad.uniforms.start.value=e}get start(){return this.viewQuad.uniforms.start.value}set end(e){this._globalFog.end=e,this.viewQuad.uniforms.end.value=e}get end(){return this.viewQuad.uniforms.end.value}set ins(e){this._globalFog.ins=e,this.viewQuad.uniforms.ins.value=e}get ins(){return this.viewQuad.uniforms.ins.value}set density(e){this._globalFog.density=e,this.viewQuad.uniforms.density.value=e}get density(){return this.viewQuad.uniforms.density.value}set skyRoughness(e){this._globalFog.skyRoughness=e,this.viewQuad.uniforms.skyRoughness.value=e}get skyRoughness(){return this._globalFog.skyRoughness}set skyFactor(e){this._globalFog.skyFactor=e,this.viewQuad.uniforms.skyFactor.value=e}get skyFactor(){return this._globalFog.skyFactor}set overrideSkyFactor(e){this._globalFog.overrideSkyFactor=e,this.viewQuad.uniforms.overrideSkyFactor.value=e}get overrideSkyFactor(){return this._globalFog.overrideSkyFactor}get fogColor(){return this._globalFog.fogColor}set fogColor(e){this._globalFog.fogColor.copyFrom(e),this.viewQuad.uniforms.fogColor.color=e,this.viewQuad.uniforms.fogColor.onChange()}set falloff(e){this._globalFog.falloff=e,this.viewQuad.uniforms.falloff.value=e}get falloff(){return this.viewQuad.uniforms.falloff.value}set rayLength(e){this._globalFog.rayLength=e,this.viewQuad.uniforms.rayLength.value=e}get rayLength(){return this._globalFog.rayLength}set scatteringExponent(e){this._globalFog.scatteringExponent=e,this.viewQuad.uniforms.scatteringExponent.value=e}get scatteringExponent(){return this._globalFog.scatteringExponent}set dirHeightLine(e){this._globalFog.dirHeightLine=e,this.viewQuad.uniforms.dirHeightLine.value=e}get dirHeightLine(){return this._globalFog.dirHeightLine}setInputTexture(e,t){const r=this.viewQuad.pass;r.setTexture("positionMap",e),r.setTexture("normalMap",t),this._lastSkyTexture=this.getSkyTexture(),r.setTexture("prefilterMap",this._lastSkyTexture)}getSkyTexture(){let e=_.res.defaultSky;return Q.instance.sky instanceof us&&(e=Q.instance.sky.map),e}render(e,t){const r=this.viewQuad.pass;let a=this.getSkyTexture();a!=this._lastSkyTexture&&(this._lastSkyTexture=a,r.setTexture("prefilterMap",this._lastSkyTexture)),r.setTexture("colorMap",this.getOutTexture()),r.setUniformFloat("isSkyHDR",a.isHDRTexture?1:0),this.viewQuad.renderTarget(e,this.viewQuad,t)}}class Hp extends xt{constructor(){super(),n(this,"godRayTexture"),n(this,"rendererPassState"),n(this,"godRayCompute"),n(this,"historyGodRayData"),n(this,"godRaySetting"),n(this,"rtFrame"),n(this,"Render"),n(this,"blendColor",!0),n(this,"rayMarchCount",16),n(this,"scatteringExponent",5),n(this,"intensity",.5)}onAttach(e){this.createGUI()}onDetach(e){this.removeGUI()}createGUI(){}removeGUI(){}createCompute(e){_.setting.render.postProcessing.gtao,this.godRayCompute=new be(Ju);let t=new Dt(4*3);this.godRayCompute.setUniformBuffer("godRayUniform",t),this.historyGodRayData=new fe(4*this.godRayTexture.width*this.godRayTexture.height),this.godRayCompute.setStorageBuffer("historyGodRayData",this.historyGodRayData);let r=yt.getGBufferFrame("ColorPassGBuffer");this.godRayCompute.setSamplerTexture("posTex",r.attachments[1]),this.godRayCompute.setSamplerTexture("normalTex",r.attachments[2]),this.autoSetColorTexture("inTex",this.godRayCompute),this.godRayCompute.setStorageTexture("outTex",this.godRayTexture);let a=_.getRenderJob(e).shadowMapPassRenderer;this.godRayCompute.setSamplerTexture("shadowMap",a.depth2DArrayTexture),this.godRayCompute.workerSizeX=Math.ceil(this.godRayTexture.width/8),this.godRayCompute.workerSizeY=Math.ceil(this.godRayTexture.height/8),this.godRayCompute.workerSizeZ=1,this.godRaySetting=t}createResource(){let e=I.presentationSize,t=e[0],r=e[1];this.godRayTexture=new ne(t,r,G.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.TEXTURE_BINDING),this.godRayTexture.name="godRayTexture";let a=new Ce;a.loadOp="load",this.rtFrame=new Ke([this.godRayTexture],[a])}render(e,t){if(!this.godRayCompute){this.createResource(),this.createCompute(e);let a=de.getLightEntries(e.scene);this.godRayCompute.setStorageBuffer("lightBuffer",a.storageGPUBuffer),this.godRayCompute.setStorageBuffer("models",de.modelMatrixBindGroup.matrixBufferDst),this.rendererPassState=Qe.createRendererPassState(this.rtFrame,null),this.rendererPassState.label="GodRay";let s=de.getCameraGroup(e.camera);this.godRayCompute.setUniformBuffer("globalUniform",s.uniformGPUBuffer),Ct.addFolder("GodRay"),Ct.add(this,"blendColor",0,1,.1),Ct.add(this,"scatteringExponent",1,10,.1),Ct.add(this,"rayMarchCount",10,30,1),Ct.add(this,"intensity",.01,2,.01),Ct.endFolder()}this.godRaySetting.setFloat("intensity",this.intensity),this.godRaySetting.setFloat("rayMarchCount",this.rayMarchCount);let r=e.camera;this.godRaySetting.setFloat("viewPortWidth",r.viewPort.width),this.godRaySetting.setFloat("viewPortHeight",r.viewPort.height),this.godRaySetting.setFloat("blendColor",this.blendColor?1:0),this.godRaySetting.setFloat("scatteringExponent",this.scatteringExponent),this.godRaySetting.apply(),w.computeCommand(t,[this.godRayCompute]),w.lastRenderPassState=this.rendererPassState}}class Yp extends xt{constructor(){super(),n(this,"brightnessView"),n(this,"compositeView"),n(this,"blurList"),n(this,"blurX",1),n(this,"blurY",1);const e=_.setting.render.postProcessing.bloom;e.enable=!0;let t=I.presentationSize,r=this.createRTTexture("HDRBloomPost-outTextures",t[0],t[1],G.rgba16float,!1);Ne.createRTTexture(Ae.colorBufferTex_NAME,t[0],t[1],G.rgba16float,!1);{let l=this.createRTTexture("brightnessTextures",t[0],t[1],G.rgba16float,!1);this.brightnessView=this.createViewQuad("brightnessView","Bloom_Brightness_frag_wgsl",l,{luminosityThreshold:new ee(e.luminosityThreshold)})}let a=5,s=t[0],o=t[1];this.blurList=[];for(let l=0;l<a;l++){let h=this.createRTTexture(`tex_l${l}`,s,o,G.rgba16float),u=this.createRTTexture(`tex_r${l}`,s,o,G.rgba16float),c=this.createViewQuad(`ql${l}`,"Bloom_blur_frag_wgsl",h,{texSize:new ee(new $(s*2,o*2)),hScale:new ee(l),vScale:new ee(l),horizontal:new ee(.5)}),d=this.createViewQuad(`qr${l}`,"Bloom_blur_frag_wgsl",u,{texSize:new ee(new $(s*2,o*2)),hScale:new ee(l),vScale:new ee(l),horizontal:new ee(1)});this.blurList.push({ql:c,qr:d}),s/=2,o/=2}this.compositeView=this.createViewQuad("compositeView","Bloom_composite_frag_wgsl",r,{tintColor:new ee(new z(1,1,1)),bloomStrength:new ee(e.strength),exposure:new ee(e.exposure),bloomRadius:new ee(1)}),this.blurX=e.blurX,this.blurY=e.blurY,this.luminosityThreshold=e.luminosityThreshold,this.strength=e.strength,this.radius=e.radius}onAttach(e){this.debug()}onDetach(e){}debug(){}get tintColor(){return this.compositeView.uniforms.tintColor.color}set tintColor(e){this.compositeView.uniforms.tintColor.color=e}get strength(){return this.compositeView.uniforms.bloomStrength.value}set strength(e){this.compositeView.uniforms.bloomStrength.value=e}get exposure(){return this.compositeView.uniforms.exposure.value}set exposure(e){this.compositeView.uniforms.exposure.value=e}get radius(){return this.compositeView.uniforms.bloomRadius.value}set radius(e){this.compositeView.uniforms.bloomRadius.value=e}get luminosityThreshold(){return this.brightnessView.uniforms.luminosityThreshold.value}set luminosityThreshold(e){this.brightnessView.uniforms.luminosityThreshold.value=e}render(e,t){{let r=this.getOutTexture();this.brightnessView.renderToViewQuad(e,this.brightnessView,t,r);{let a=this.brightnessView.rendererPassState.renderTargets[0];for(let s=0;s<this.blurList.length;s++){let o=this.blurList[s].ql,l=this.blurList[s].qr;o.pass.setUniformFloat("horizontal",.5),o.pass.setUniformFloat("vScale",s*this.blurX),o.renderToViewQuad(e,o,t,a),a=o.rendererPassState.renderTargets[0],l.pass.setUniformFloat("horizontal",2),l.pass.setUniformFloat("hScale",s*this.blurY),l.renderToViewQuad(e,l,t,a),a=l.rendererPassState.renderTargets[0]}}{let a=this.compositeView.pass;a.setTexture("blurTex1",this.blurList[0].qr.rendererPassState.renderTargets[0]),a.setTexture("blurTex2",this.blurList[1].qr.rendererPassState.renderTargets[0]),a.setTexture("blurTex3",this.blurList[2].qr.rendererPassState.renderTargets[0]),a.setTexture("blurTex4",this.blurList[3].qr.rendererPassState.renderTargets[0]),a.setTexture("blurTex5",this.blurList[4].qr.rendererPassState.renderTargets[0]),this.compositeView.renderToViewQuad(e,this.compositeView,t,r)}}}}class Af{constructor(){n(this,"indexList"),n(this,"color"),n(this,"count")}}class _f{constructor(){n(this,"SlotCount",8),n(this,"MaxEntities",16),n(this,"defaultColor",new z(.2,1,1,1)),n(this,"slots",[]),n(this,"dataDirty",!0);let e=_.setting.render.postProcessing.outline.groupCount;this.SlotCount=Math.max(1,Math.min(e,this.SlotCount));for(let t=0;t<this.SlotCount;t++){let r=this.slots[t]=new Af;r.indexList=new Float32Array(this.MaxEntities),r.color=this.defaultColor.clone(),r.count=0}}clear(){for(let e=0;e<this.SlotCount;e++)this.clearAt(e)}clearAt(e){this.dataDirty=!0;let t=this.slots[e];return t.color.copyFrom(this.defaultColor),t.indexList.fill(-1),t.count=0,this}fillDataAt(e,t,r){this.dataDirty=!0;let a=this.slots[e];if(a){a.indexList.fill(-1);for(let s=0,o=t.length;s<o;s++)a.indexList[s]=t[s];a.count=t.length,a.color.copyFrom(r)}return this}fetchData(e){return e.dirty=this.dataDirty,e.slots=this.slots,this.dataDirty=!1,this}}let kt=new _f;class Xp extends xt{constructor(){super(),n(this,"outlineTex"),n(this,"lowTex"),n(this,"rendererPassState"),n(this,"calcWeightCompute"),n(this,"outlineCompute"),n(this,"blendCompute"),n(this,"outlineSetting"),n(this,"slotsBuffer"),n(this,"slotsArray"),n(this,"entitiesArray"),n(this,"entitiesBuffer"),n(this,"weightBuffer"),n(this,"lowTexSize"),n(this,"oldOutlineColor"),n(this,"rtFrame"),n(this,"fetchData"),n(this,"computeList")}onAttach(e){_.setting.render.postProcessing.outline.enable=!0}onDetach(e){_.setting.render.postProcessing.outline.enable=!1}set outlinePixel(e){e=J(e,0,8);let t=_.setting.render.postProcessing.outline;t.outlinePixel!=e&&(t.outlinePixel=e)}get outlinePixel(){return _.setting.render.postProcessing.outline.outlinePixel}set fadeOutlinePixel(e){let t=_.setting.render.postProcessing.outline;e=J(e,0,8),t.fadeOutlinePixel!=e&&(t.fadeOutlinePixel=e)}get fadeOutlinePixel(){return _.setting.render.postProcessing.outline.fadeOutlinePixel}set strength(e){e=J(e,0,1);let t=_.setting.render.postProcessing.outline;t.strength!=e&&(t.strength=e)}get strength(){return _.setting.render.postProcessing.outline.strength}set useAddMode(e){_.setting.render.postProcessing.outline.useAddMode=e}get useAddMode(){return _.setting.render.postProcessing.outline.useAddMode}createGUI(){}createCompute(){let t=yt.getGBufferFrame("ColorPassGBuffer").getPositionMap();this.calcWeightCompute=new be(ec),this.calcWeightCompute.setStorageBuffer("outlineSetting",this.outlineSetting),this.calcWeightCompute.setStorageBuffer("slotsBuffer",this.slotsBuffer),this.calcWeightCompute.setStorageBuffer("weightBuffer",this.weightBuffer),this.calcWeightCompute.setStorageBuffer("entitiesBuffer",this.entitiesBuffer),this.calcWeightCompute.setSamplerTexture("indexTexture",t),this.calcWeightCompute.workerSizeX=Math.ceil(this.lowTex.width/8),this.calcWeightCompute.workerSizeY=Math.ceil(this.lowTex.height/8),this.calcWeightCompute.workerSizeZ=1,this.outlineCompute=new be(tc),this.outlineCompute.setStorageBuffer("outlineSetting",this.outlineSetting),this.outlineCompute.setStorageBuffer("slotsBuffer",this.slotsBuffer),this.outlineCompute.setStorageBuffer("weightBuffer",this.weightBuffer),this.outlineCompute.setStorageBuffer("oldOutlineColor",this.oldOutlineColor),this.outlineCompute.setStorageTexture("lowTex",this.lowTex),this.outlineCompute.workerSizeX=Math.ceil(this.lowTex.width/8),this.outlineCompute.workerSizeY=Math.ceil(this.lowTex.height/8),this.outlineCompute.workerSizeZ=1,this.blendCompute=new be($u),this.blendCompute.setStorageBuffer("outlineSetting",this.outlineSetting),this.autoSetColorTexture("inTex",this.blendCompute),this.blendCompute.setSamplerTexture("lowTex",this.lowTex),this.blendCompute.setStorageTexture("outlineTex",this.outlineTex),this.blendCompute.workerSizeX=Math.ceil(this.outlineTex.width/8),this.blendCompute.workerSizeY=Math.ceil(this.outlineTex.height/8),this.blendCompute.workerSizeZ=1}createResource(){let e=I.presentationSize,t=e[0],r=e[1],a=_.setting.render.postProcessing.outline.textureScale;this.lowTexSize=new $(Math.ceil(t*a),Math.ceil(r*a)),this.lowTex=new ne(this.lowTexSize.x,this.lowTexSize.y,G.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.TEXTURE_BINDING),this.lowTex.name="lowTex";let s=new Ce;s.clearValue=[0,0,0,1],s.loadOp="clear",this.outlineTex=new ne(t,r,G.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.TEXTURE_BINDING),this.outlineTex.name="outlineTex";let o=new Ce;o.clearValue=[0,0,0,1],o.loadOp="clear",this.rtFrame=new Ke([this.outlineTex],[o]),this.outlineSetting=new Dt(8),this.weightBuffer=new fe(this.lowTexSize.x*this.lowTexSize.y*4,GPUBufferUsage.COPY_SRC),this.oldOutlineColor=new fe(this.lowTexSize.x*this.lowTexSize.y*4,GPUBufferUsage.COPY_SRC),this.slotsArray=new Float32Array(kt.SlotCount*4),this.slotsBuffer=new fe(this.slotsArray.length),this.slotsBuffer.setFloat32Array("slotsArray",this.slotsArray),this.slotsBuffer.apply(),this.entitiesArray=new Float32Array(kt.SlotCount*kt.MaxEntities),this.entitiesBuffer=new fe(this.entitiesArray.length),this.entitiesBuffer.setFloat32Array("entitiesArray",this.entitiesArray),this.slotsBuffer.apply(),this.fetchData||(this.fetchData={})}fetchOutlineData(){if(kt.fetchData(this.fetchData),this.fetchData.dirty){let e=kt.SlotCount,t=kt.MaxEntities;for(let r=0;r<e;r++){let a=4*r,s=this.fetchData.slots[r];this.slotsArray[a+0]=s.color.r,this.slotsArray[a+1]=s.color.g,this.slotsArray[a+2]=s.color.b,this.slotsArray[a+3]=s.count,a=t*r,this.entitiesArray.set(s.indexList,a)}this.slotsBuffer.setFloat32Array("slotsArray",this.slotsArray),this.slotsBuffer.apply(),this.entitiesBuffer.setFloat32Array("entitiesArray",this.entitiesArray),this.entitiesBuffer.apply()}}render(e,t){this.calcWeightCompute||(this.createResource(),this.createCompute(),this.createGUI(),this.rendererPassState=Qe.createRendererPassState(this.rtFrame,null)),this.computeList||(this.computeList=[this.calcWeightCompute,this.outlineCompute,this.blendCompute]);let r=_.setting.render.postProcessing.outline;this.outlineSetting.setFloat("strength",r.strength),this.outlineSetting.setFloat("useAddMode",r.useAddMode?1:0),this.outlineSetting.setFloat("outlinePixel",r.outlinePixel),this.outlineSetting.setFloat("fadeOutlinePixel",r.fadeOutlinePixel),this.outlineSetting.setFloat("lowTexWidth",this.lowTexSize.x),this.outlineSetting.setFloat("lowTexHeight",this.lowTexSize.y),this.outlineSetting.apply(),this.fetchOutlineData(),w.computeCommand(t,this.computeList),w.lastRenderPassState=this.rendererPassState}}class Wp extends xt{constructor(){super(),n(this,"SSR_RayTraceCompute"),n(this,"SSR_IS_Compute"),n(this,"SSR_Blend_Compute"),n(this,"isRetTexture"),n(this,"finalTexture"),n(this,"rendererPassState"),n(this,"ssrUniformBuffer"),n(this,"rayTraceData"),n(this,"ssrColorData"),n(this,"isKernelFloat32Array"),n(this,"rtFrame"),n(this,"historyPosition"),n(this,"reflectionRatio",.5)}onAttach(e){_.setting.render.postProcessing.ssr.enable=!0,this.debug()}onDetach(e){_.setting.render.postProcessing.ssr.enable=!1}get fadeEdgeRatio(){return _.setting.render.postProcessing.ssr.fadeEdgeRatio}set fadeEdgeRatio(e){e=J(e,0,1);let t=_.setting.render.postProcessing.ssr;t.fadeEdgeRatio=e}get rayMarchRatio(){return _.setting.render.postProcessing.ssr.rayMarchRatio}set rayMarchRatio(e){e=J(e,0,1);let t=_.setting.render.postProcessing.ssr;t.rayMarchRatio=e}get roughnessThreshold(){return _.setting.render.postProcessing.ssr.roughnessThreshold}set roughnessThreshold(e){e=J(e,0,1);let t=_.setting.render.postProcessing.ssr;t.roughnessThreshold=e}get fadeDistanceMin(){return _.setting.render.postProcessing.ssr.fadeDistanceMin}set fadeDistanceMin(e){e=J(e,0,1e4);let t=_.setting.render.postProcessing.ssr;t.fadeDistanceMin=e}get fadeDistanceMax(){return _.setting.render.postProcessing.ssr.fadeDistanceMax}set fadeDistanceMax(e){e=J(e,0,1e4);let t=_.setting.render.postProcessing.ssr;t.fadeDistanceMax=e}get powDotRN(){return _.setting.render.postProcessing.ssr.powDotRN}set powDotRN(e){e=J(e,0,1);let t=_.setting.render.postProcessing.ssr;t.powDotRN=e}debug(){}createRayTraceShader(){this.SSR_RayTraceCompute=new be(sc),this.SSR_RayTraceCompute.setStorageBuffer("ssrUniform",this.ssrUniformBuffer),this.SSR_RayTraceCompute.setStorageBuffer("rayTraceBuffer",this.rayTraceData),this.SSR_RayTraceCompute.setStorageBuffer("historyPosition",this.historyPosition);let e=yt.getGBufferFrame("ColorPassGBuffer");this.SSR_RayTraceCompute.setSamplerTexture("zBufferTexture",e.getPositionMap()),this.SSR_RayTraceCompute.setSamplerTexture(Ae.normalBufferTex_NAME,e.attachments[2]),this.SSR_RayTraceCompute.setSamplerTexture(Ae.materialBufferTex_NAME,e.attachments[3]),Q.instance.sky instanceof us&&this.SSR_RayTraceCompute.setSamplerTexture("prefilterMap",Q.instance.sky.map),this.SSR_RayTraceCompute.workerSizeX=Math.ceil(this.isRetTexture.width/8),this.SSR_RayTraceCompute.workerSizeY=Math.ceil(this.isRetTexture.height/8),this.SSR_RayTraceCompute.workerSizeZ=1}createISShader(){this.SSR_IS_Compute=new be(ac),this.SSR_IS_Compute.setStorageBuffer("ssrUniform",this.ssrUniformBuffer),this.SSR_IS_Compute.setStorageBuffer("rayTraceBuffer",this.rayTraceData),this.SSR_IS_Compute.setStorageBuffer("ssrColorData",this.ssrColorData),this.SSR_IS_Compute.setStorageBuffer("historyPosition",this.historyPosition),this.autoSetColorTexture("colorMap",this.SSR_IS_Compute),this.SSR_IS_Compute.setStorageTexture("outTex",this.isRetTexture),this.SSR_IS_Compute.workerSizeX=Math.ceil(this.isRetTexture.width/8),this.SSR_IS_Compute.workerSizeY=Math.ceil(this.isRetTexture.height/8),this.SSR_IS_Compute.workerSizeZ=1}createBlendShader(e){this.SSR_Blend_Compute=new be(rc),this.SSR_Blend_Compute.setStorageBuffer("rayTraceBuffer",this.rayTraceData),this.autoSetColorTexture("colorMap",this.SSR_Blend_Compute),this.SSR_Blend_Compute.setSamplerTexture("ssrMap",e),this.SSR_Blend_Compute.setStorageTexture("outTex",this.finalTexture),this.SSR_Blend_Compute.workerSizeX=Math.ceil(this.finalTexture.width/8),this.SSR_Blend_Compute.workerSizeY=Math.ceil(this.finalTexture.height/8),this.SSR_Blend_Compute.workerSizeZ=1}createResource(){let e=I.presentationSize,t=e[0],r=e[1];this.finalTexture=new ne(t,r,G.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING),this.finalTexture.name="ssrOutTex";let a=new Ce;a.clearValue=[0,0,0,0],a.loadOp="clear";let s=Math.ceil(t*_.setting.render.postProcessing.ssr.pixelRatio),o=Math.ceil(r*_.setting.render.postProcessing.ssr.pixelRatio);this.isRetTexture=new ne(s,o,G.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING),this.isRetTexture.name="ssrTextureIn";let l=new Ce;l.clearValue=[0,0,0,0],l.loadOp="clear",this.rtFrame=new Ke([this.finalTexture,this.isRetTexture],[a,l]),this.rayTraceData=new fe(s*o*8,GPUBufferUsage.COPY_SRC),this.ssrColorData=new fe(s*o*4,GPUBufferUsage.COPY_SRC),this.historyPosition=new fe(s*o*4,GPUBufferUsage.COPY_SRC),this.ssrUniformBuffer=new Dt(4*8),this.ssrUniformBuffer.setFloat("ssrBufferSizeX",this.isRetTexture.width),this.ssrUniformBuffer.setFloat("ssrBufferSizeY",this.isRetTexture.height),this.ssrUniformBuffer.setFloat("colorMapSizeX",this.finalTexture.width),this.ssrUniformBuffer.setFloat("colorMapSizeY",this.finalTexture.height),this.ssrUniformBuffer.apply()}render(e,t){if(!this.SSR_RayTraceCompute){this.createResource(),this.createISShader(),this.createRayTraceShader(),this.createBlendShader(this.isRetTexture),this.finalTexture,this.rendererPassState=Qe.createRendererPassState(this.rtFrame,null);let s=de.getCameraGroup(e.camera);this.SSR_RayTraceCompute.setUniformBuffer("standUniform",s.uniformGPUBuffer)}let r=_.setting.render.postProcessing.ssr;this.ssrUniformBuffer.setFloat("fadeEdgeRatio",r.fadeEdgeRatio),this.ssrUniformBuffer.setFloat("rayMarchRatio",r.rayMarchRatio),this.ssrUniformBuffer.setFloat("fadeDistanceMin",r.fadeDistanceMin),this.ssrUniformBuffer.setFloat("fadeDistanceMax",r.fadeDistanceMax),this.ssrUniformBuffer.setFloat("mixThreshold",r.mixThreshold),this.ssrUniformBuffer.setFloat("roughnessThreshold",r.roughnessThreshold),this.ssrUniformBuffer.setFloat("reflectionRatio",this.reflectionRatio),this.ssrUniformBuffer.setFloat("powDotRN",r.powDotRN),this.ssrUniformBuffer.setFloat("randomSeedX",Math.random()),this.ssrUniformBuffer.setFloat("randomSeedY",Math.random()),this.ssrUniformBuffer.apply();let a=[this.SSR_RayTraceCompute,this.SSR_IS_Compute,this.SSR_Blend_Compute];w.computeCommand(t,a),w.lastRenderPassState=this.rendererPassState}}class jp{static createSeeds(){let e=20,t=32,r=[new p(0,0,e)],a=0,s=.02;for(let o=1;o<t;o++){let l=new p;r.push(l),a+=1-(1-.618)*o/t,s+=o*.01,l.x=Math.sin(a)*s,l.y=Math.cos(a)*s,l.z=1-o/t,l.multiplyScalar(e)}return r}}class qp extends xt{constructor(){super(),n(this,"taaTexture"),n(this,"outTexture"),n(this,"rendererPassState"),n(this,"taaCompute"),n(this,"copyTexCompute"),n(this,"sharpCompute"),n(this,"taaSetting"),n(this,"preColorBuffer"),n(this,"preColorTex"),n(this,"preProjMatrix"),n(this,"preViewMatrix"),n(this,"rtFrame")}onAttach(e){_.setting.render.postProcessing.taa.enable=!0,e.camera.enableJitterProjection(!0),this.createGUI()}onDetach(e){_.setting.render.postProcessing.taa.enable=!1,e.camera.enableJitterProjection(!1)}get jitterSeedCount(){return _.setting.render.postProcessing.taa.jitterSeedCount}set jitterSeedCount(e){e=J(e,2,8),e=Math.round(e);let t=_.setting.render.postProcessing.taa;t.jitterSeedCount=e}get blendFactor(){return _.setting.render.postProcessing.taa.blendFactor}set blendFactor(e){e=J(e,0,1);let t=_.setting.render.postProcessing.taa;t.blendFactor=e}get sharpFactor(){return _.setting.render.postProcessing.taa.sharpFactor}set sharpFactor(e){e=J(e,.1,.9);let t=_.setting.render.postProcessing.taa;t.sharpFactor=e}get sharpPreBlurFactor(){return _.setting.render.postProcessing.taa.sharpPreBlurFactor}set sharpPreBlurFactor(e){e=J(e,.1,.9);let t=_.setting.render.postProcessing.taa;t.sharpPreBlurFactor=e}get temporalJitterScale(){return _.setting.render.postProcessing.taa.temporalJitterScale}set temporalJitterScale(e){e=J(e,0,1);let t=_.setting.render.postProcessing.taa;t.temporalJitterScale=e}createGUI(){}createCompute(e){let t=new be(lc);_.setting.render.postProcessing.taa;let r=new Dt(16*2+4*3),a=de.getCameraGroup(e.camera);t.setUniformBuffer("standUniform",a.uniformGPUBuffer),t.setUniformBuffer("taaData",r),t.setStorageBuffer("preColorBuffer",this.preColorBuffer);let s=yt.getGBufferFrame("ColorPassGBuffer");t.setSamplerTexture("preColorTex",this.preColorTex),t.setSamplerTexture("posTex",s.getPositionMap()),this.autoSetColorTexture("inTex",t),t.setStorageTexture("outTex",this.taaTexture),t.workerSizeX=Math.ceil(this.taaTexture.width/8),t.workerSizeY=Math.ceil(this.taaTexture.height/8),t.workerSizeZ=1,this.taaCompute=t,this.taaSetting=r,this.copyTexCompute=new be(nc),this.copyTexCompute.setStorageBuffer("preColor",this.preColorBuffer),this.copyTexCompute.setStorageTexture("preColorTex",this.preColorTex),this.copyTexCompute.workerSizeX=Math.ceil(this.taaTexture.width/8),this.copyTexCompute.workerSizeY=Math.ceil(this.taaTexture.height/8),this.copyTexCompute.workerSizeZ=1,this.sharpCompute=new be(oc),this.sharpCompute.setUniformBuffer("taaData",r),this.sharpCompute.setSamplerTexture("inTex",this.taaTexture),this.sharpCompute.setStorageTexture("outTex",this.outTexture),this.sharpCompute.workerSizeX=Math.ceil(this.outTexture.width/8),this.sharpCompute.workerSizeY=Math.ceil(this.outTexture.height/8),this.sharpCompute.workerSizeZ=1}createResource(){this.preProjMatrix=new H().identity(),this.preViewMatrix=new H().identity();let e=I.presentationSize,t=e[0],r=e[1];this.preColorBuffer=new fe(t*r*4,GPUBufferUsage.COPY_SRC),this.preColorTex=new ne(t,r,G.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.TEXTURE_BINDING),this.preColorTex.name="taaTex";let a=new Ce;a.clearValue=[0,0,0,1],a.loadOp="clear",this.taaTexture=new ne(t,r,G.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.TEXTURE_BINDING),this.taaTexture.name="taaTex";let s=new Ce;s.clearValue=[0,0,0,1],s.loadOp="clear",this.outTexture=new ne(t,r,G.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.TEXTURE_BINDING),this.outTexture.name="sharpTaaTex";let o=new Ce;o.clearValue=[0,0,0,1],o.loadOp="clear",this.rtFrame=new Ke([this.preColorTex,this.taaTexture,this.outTexture],[a,s,o])}render(e,t){this.taaCompute||(this.createResource(),this.createCompute(e),this.rendererPassState=Qe.createRendererPassState(this.rtFrame,null));let r=_.setting.render.postProcessing.taa;this.taaSetting.setMatrix("preProjMatrix",this.preProjMatrix),this.taaSetting.setMatrix("preViewMatrix",this.preViewMatrix),this.taaSetting.setFloat("jitterFrameIndex",e.camera.jitterFrameIndex),this.taaSetting.setFloat("blendFactor",r.blendFactor),this.taaSetting.setFloat("sharpFactor",r.sharpFactor),this.taaSetting.setFloat("sharpPreBlurFactor",r.sharpPreBlurFactor),this.taaSetting.setFloat("jitterX",e.camera.jitterX),this.taaSetting.setFloat("jitterY",e.camera.jitterY),this.taaSetting.apply(),w.computeCommand(t,[this.copyTexCompute,this.taaCompute,this.sharpCompute]),w.lastRenderPassState=this.rendererPassState,this.preProjMatrix.copyFrom(e.camera.projectionMatrix),this.preViewMatrix.copyFrom(e.camera.viewMatrix)}}class vf{constructor(){n(this,"_tempIndexArray",[]),n(this,"_rendererList",[])}setOutline(e,t){this.setOutlineList([e],t?[t]:null)}setOutlineList(e,t){e||(e=[]);let r=kt.defaultColor,a=kt.SlotCount;for(let s=0;s<a;s++){this._tempIndexArray.length=0;let o=e[s],l=(t?t[s]:null)||r;if(o)for(const h of o)this.getEntityIdList(h,this._tempIndexArray);kt.fillDataAt(s,this._tempIndexArray,l)}}clearOutline(){return kt.clear(),this}getEntityIdList(e,t){this._rendererList.length=0;let r=e.getComponents(ue,this._rendererList);for(const a of r)t.push(a.object3D.transform._worldMatrix.index)}}let Kp=new vf;class xf{constructor(){n(this,"localPosition",new p),n(this,"worldPosition",new p),n(this,"uv",new $),n(this,"faceIndex"),n(this,"isIn",!1),n(this,"t",0),n(this,"u",0),n(this,"v",0),n(this,"triangle"),n(this,"v0"),n(this,"v1"),n(this,"v2"),n(this,"pickList"),n(this,"color")}}const ma=class{static distPtTri(i,e,t,r){let a=new p,s=new p,o=new p;r.subtract(e,a),t.subtract(e,s),i.subtract(e,o);let l=tt(a,a),h=tt(a,s),u=tt(a,o),c=tt(s,s),d=tt(s,o),g=1/(l*c-h*h),m=(c*u-h*d)*g,A=(l*d-h*u)*g;if(m>=-ma.EPS&&A>=-ma.EPS&&m+A<=1+ma.EPS){let v=e[1]+a[1]*m+s[1]*A;return Math.abs(v-i[1])}return ma.FLT_MAX}static IntersectTriangle(i,e,t){let r=e.v1,a=e.v2,s=e.v3,o=a.subtract(r,p.HELP_3),l=s.subtract(r,p.HELP_4),h=i.direction.crossProduct(l,p.HELP_5),u=tt(o,h),c;if(u>0){if(t)return null;c=i.origin.subtract(r,p.HELP_2)}else c=r.subtract(i.origin,p.HELP_2),u=-u;if(u<1e-4)return this._info.isIn=!1,this._info.t=0,this._info.u=0,this._info.v=0,this._info;let d=tt(c,h);if(d<0||d>u)return this._info.isIn=!1,this._info.t=0,this._info.u=0,this._info.v=0,this._info;let g=c.crossProduct(o,p.HELP_1),m=tt(i.direction,g);if(m<0||d+m>u)return this._info.isIn=!1,this._info.t=0,this._info.u=0,this._info.v=0,this._info;let A=tt(l,g),v=1/u;A*=v,d*=v,m*=v,this._info.isIn=!0,this._info.t=A,this._info.u=d,this._info.v=m;let y=1-d-m;return this._u0.copyFrom(e.u1),this._u0.scale(y),this._u1.copyFrom(e.u2),this._u1.scale(d),this._u2.copyFrom(e.u3),this._u2.scale(m),this._info.uv.copyFrom(this._u0),this._info.uv.add(this._u1,this._info.uv),this._info.uv.add(this._u2,this._info.uv),this._info.localPosition.copyFrom(i.direction).multiplyScalar(A),this._info.localPosition.add(i.origin,this._info.localPosition),this._info}};let ji=ma;n(ji,"EPS",1e-4),n(ji,"FLT_MAX",3402823466e29),n(ji,"_info",new xf),n(ji,"_u0",new $),n(ji,"_u1",new $),n(ji,"_u2",new $);const $n=class extends hi{constructor(){if(super(),n(this,"_maxRetry",3),$n._instance)throw new Error("LoadManager is singleton class...")}loadAll(i,e){return new Promise((t,r)=>{let a=i.length,s=[];i.forEach((o,l)=>{let h=new e;this.load(o,e).then(u=>{h.parse(u),s.push(h),a--,a===0&&t(s)})})})}static getInstance(){return this._instance||(this._instance=new $n)}loadUrls(i,e){return new Promise((t,r)=>{let a=i.length,s=[];i.forEach((o,l)=>{this.load(o,e).then(h=>{s.push(h),a--,a===0&&t(s),a<0&&console.error(`loadUrls ${i} error`)})})})}get maxRetry(){return this._maxRetry}set maxRetry(i){this._maxRetry=i}load(i,e){return new Promise((t,r)=>{switch(e.format){}})}};let yf=$n;n(yf,"_instance");class Jp{}class Zp{}class $p{}class em{}class tm{}class im{}class rm{}class am{}class sm{}class nm{}class om{constructor(){n(this,"asset"),n(this,"extras"),n(this,"geometricError"),n(this,"properties"),n(this,"refine"),n(this,"root")}}class lm{constructor(){n(this,"boundingVolume"),n(this,"children"),n(this,"geometricError"),n(this,"transform")}}class hm{constructor(){n(this,"boundingVolume"),n(this,"geometricError"),n(this,"refine"),n(this,"content"),n(this,"contents")}}class um{constructor(){n(this,"uri"),n(this,"group"),n(this,"metadata")}}class cm{constructor(){n(this,"class"),n(this,"properties")}}class eo{constructor(){n(this,"group"),n(this,"_modelList"),n(this,"_tileSet"),n(this,"_rootPath"),this.group=new f.Object3D}async loadTileSet(e,t){this._modelList=[],this._rootPath=e;let r=e+"/"+t;if(this._tileSet=await _.res.loadJSON(r),this._tileSet.root.transform){let l=new H;for(let h=0;h<16;h++)l.rawData[h]=this._tileSet.root.transform[h]}let a=new H;switch((this._tileSet.asset&&this._tileSet.asset.gltfUpAxis||"y").toLowerCase()){case"x":a.makeRotationAxis(p.Y_AXIS,-Math.PI/2);break;case"y":a.makeRotationAxis(p.X_AXIS,Math.PI/2);break;case"z":a.identity();break}let o=a.clone();o.invert(),this.applyTransform(this.group.transform,o);for(let l of this._tileSet.root.children){let h=[];if(l.content&&l.content.uri&&h.push(l.content.uri),l.contents)for(let u of l.contents)h.push(u.uri);for(let u of h){let c=this._rootPath+"/"+u,d={onProgress:m=>this.onLoadProgress(m),onComplete:m=>this.onComplete(m)},g;if(c.endsWith(".glb"))g=await _.res.loadGltf(c,d),this.applyTransform(g.transform,a);else if(c.endsWith("tileset.json")){let m=c.replace("/tileset.json",""),A=new eo;await A.loadTileSet(m,"tileset.json"),g=A.group}else c.endsWith(".i3dm")?g=await _.res.loadI3DM(c,d,a):c.endsWith(".b3dm")&&(g=await _.res.loadB3DM(c,d,a));g&&(this._modelList.push(g),this.group.addChild(g))}}}onLoadProgress(e){}onComplete(e){}applyTransform(e,t){let r=t.decompose(vt.QUATERNION);e.localRotQuat.copyFrom(r[1]),e.localRotQuat=e.localRotQuat,e.localPosition.copyFrom(r[0]),e.localPosition=e.localPosition,e.localScale.copyFrom(r[2]),e.localScale=e.localScale}}class Cf extends aa{constructor(){super(),N.register("ColorLitShader",Un.Ori_AllShader);let e=new He("ColorLitShader","ColorLitShader");e.setDefine("USE_BRDF",!0),e.setShaderEntry("VertMain","FragMain"),e.setUniformColor("baseColor",new z),e.setUniformColor("emissiveColor",new z),e.setUniformFloat("envIntensity",1),e.setUniformFloat("normalScale",1),e.setUniformFloat("roughness",0),e.setUniformFloat("metallic",0),e.setUniformFloat("ao",1),e.setUniformFloat("alphaCutoff",0);let t=e.shaderState;t.acceptShadow=!0,t.receiveEnv=!0,t.acceptGI=!0,t.useLight=!0,e.setTexture("normalMap",_.res.normalTexture),e.setTexture("emissiveMap",_.res.blackTexture)}clone(){return null}debug(){}}n(Cf,"count",0);function fm(i,e){}class to extends aa{constructor(){super(),N.register("GlassShader",yc);let e=new He("GlassShader","GlassShader");this.defaultPass=e,e.setDefine("USE_BRDF",!0),e.setShaderEntry("VertMain","FragMain");let t=e.shaderState;t.acceptShadow=!0,t.castShadow=!0,t.receiveEnv=!0,t.acceptGI=!0,t.useLight=!0;let r=_.res.getTexture("BRDFLUT");this.brdfLUT=r,this.baseMap=_.res.whiteTexture,this.normalMap=_.res.normalTexture,this.emissiveMap=_.res.blackTexture}clone(){console.log(`clone material ${this.name}`);let e=new to;return e.baseMap=this.baseMap,e.normalMap=this.normalMap,e.aoMap=this.aoMap,this.maskMap&&(e.maskMap=this.maskMap),e.emissiveMap=this.emissiveMap,this.uvTransform_1&&(e.uvTransform_1=new q().copyFrom(this.uvTransform_1)),this.uvTransform_2&&(e.uvTransform_2=new q().copyFrom(this.uvTransform_2)),e.baseColor=this.baseColor.clone(),e.emissiveColor=this.emissiveColor.clone(),this.materialF0&&(e.materialF0=new q().copyFrom(this.materialF0)),e.envIntensity=this.envIntensity,e.normalScale=this.normalScale,e.roughness=this.roughness,e.metallic=this.metallic,e.ao=this.ao,e.roughness_min=this.roughness_min,e.roughness_max=this.roughness_max,e.metallic_min=this.metallic_min,e.metallic_max=this.metallic_max,e.emissiveIntensity=this.emissiveIntensity,e.alphaCutoff=this.alphaCutoff,e.ior=this.ior,e.clearcoatFactor=this.clearcoatFactor,e.clearcoatRoughnessFactor=this.clearcoatRoughnessFactor,e}}class dm extends vi{constructor(){super();let e=new He("LambertShader","LambertShader");e.setShaderEntry("VertMain","FragMain"),e.setUniformVector4("transformUV1",new q(0,0,1,1)),e.setUniformVector4("transformUV2",new q(0,0,1,1)),e.setUniformColor("baseColor",new z(1,1,1,1)),e.setUniformFloat("alphaCutoff",.5);let t=e.shaderState;t.acceptShadow=!1,t.castShadow=!1,t.receiveEnv=!1,t.acceptGI=!1,t.useLight=!1,this.defaultPass=e,this.baseMap=_.res.grayTexture}set baseMap(e){this.defaultPass.setTexture("baseMap",e)}get baseMap(){return this.defaultPass.getTexture("baseMap")}set baseColor(e){this.defaultPass.setUniformColor("baseColor",e)}get baseColor(){return this.defaultPass.uniforms.baseColor.color}set envMap(e){}set shadowMap(e){}}class gm extends vi{constructor(){super(),N.register("UnLitShader",On),N.register("PointShadowDebug",bc);let e=new He("UnLitShader","PointShadowDebug");this.defaultPass=e,e.setShaderEntry("VertMain","FragMain"),e.setUniformVector4("transformUV1",new q(0,0,1,1)),e.setUniformVector4("transformUV2",new q(0,0,1,1)),e.setUniformColor("baseColor",new z),e.setUniformFloat("alphaCutoff",.5);let t=e.shaderState;t.acceptShadow=!1,t.receiveEnv=!1,t.acceptGI=!1,t.useLight=!1,this.baseMap=_.res.whiteTexture}set baseMap(e){this.defaultPass.setTexture("baseMap",e)}set envMap(e){}set shadowMap(e){}debug(){}}class bf extends He{constructor(){super("castPointShadowMap_vert","shadowCastMap_frag"),this.setShaderEntry("main","main"),this.setUniformFloat("cameraFar",5e3),this.setUniformVector3("lightWorldPos",p.ZERO),this.shaderState.receiveEnv=!1,this.shaderState.castShadow=!1,this.shaderState.acceptShadow=!1,this.setDefine("USE_ALPHACUT",!0)}}class wf extends He{constructor(){super("shadowCastMap_vert","directionShadowCastMap_frag"),this.setShaderEntry("main"),this.setUniformFloat("cameraFar",5e3),this.setUniformVector3("lightWorldPos",p.ZERO),this.shaderState.receiveEnv=!1,this.shaderState.castShadow=!1,this.shaderState.acceptShadow=!1,this.setDefine("USE_ALPHACUT",!0)}setTexture(e,t){super.setTexture(e,t)}}class Sf extends He{constructor(){super("ZPass_shader_vs","ZPass_shader_vs"),this.setShaderEntry("main"),this.useRz=!1;let e=this.shaderState;e.receiveEnv=!1}}class If extends He{constructor(){super("gbuffer_vs","gbuffer_fs"),n(this,"transparency"),this.setShaderEntry("VertMain","FragMain"),this.shaderState,this.setUniformColor("baseColor",new z),this.setUniformColor("emissiveColor",new z),this.setUniformFloat("emissiveIntensity",1),this.setUniformFloat("normalScale",1),this.setUniformFloat("alphaCutoff",1),this.blendMode=ve.NONE,this.setTexture("normalMap",_.res.normalTexture)}}class Ef extends He{constructor(){super("sky_vs_frag_wgsl","SkyGBuffer_fs"),this.setUniformFloat("exposure",1),this.setUniformFloat("roughness",0);let e=this.shaderState;e.frontFace="ccw",e.cullMode=ui.front,e.depthWriteEnabled=!1,e.depthCompare=_t.less}}class ys{constructor(e=[]){n(this,"_points"),n(this,"_cacheValue"),this.points=e,this._cacheValue=new $}get points(){return this._points}set points(e){this._points=e}getValue(e){e<0&&(e=0),e>1&&(e=1);let t=this.points.length-1,r=Math.floor(t*e),a=r+1,s=et.fract((t+1)*e);return a>=t&&(a=r,s=0),this._cacheValue.x=this.points[r].x+(this.points[a].x-this.points[r].x)*s,this._cacheValue.y=this.points[r].y+(this.points[a].y-this.points[r].y)*s,this._cacheValue}static createBezierPoints(e,t){for(var r=new ys,a=0;a<t;a++){var s=ys.multiPointBezier(e,a/t);r.points.push(s)}return r}static multiPointBezier(e,t){for(var r=e.length,a=0,s=0,o=function(u,c){for(var d=1,g=1;c>0;)d*=u,g*=c,u--,c--;return d/g},l=0;l<r;l++){var h=e[l];a+=h.x*Math.pow(1-t,r-1-l)*Math.pow(t,l)*o(r-1,l),s+=h.y*Math.pow(1-t,r-1-l)*Math.pow(t,l)*o(r-1,l)}return new $(a,s)}}class Bf{static calculateCubicBezierPoint(e,t,r,a,s){e>1&&(e=1),e<0&&(e=0);let o=1-e,l=o*o,h=o*o*o,u=e*e,c=e*e*e,d=t.mul(h),g=r.mul(3);g=g.mul(e),g=g.mul(l);let m=a.mul(3);m=m.mul(u),m=m.mul(o);let A=s.mul(c);return d=d.add(g),d=d.add(m),d=d.add(A),d}static bezierPoint(e,t,r,a){e>1&&(e=1),e<0&&(e=0);let s=1-e,o=s*s,l=e*e,h=t.mul(o),u=r.mul(2);u.scaleBy(s),u.scaleBy(e);let c=a.mul(l);return h=h.add(u),h=h.add(c),h}static calculateCubicBezierPoints(e,t,r){e>1&&(e=1),e<0&&(e=0);let a=1-e,s=a*a,o=a*a*a,l=e*e,h=e*e*e,u=t[r].mul(o),c=t[r+1].mul(3);c=c.mul(e),c=c.mul(s);let d=t[r+2].mul(3);d=d.mul(l),d=d.mul(a);let g=t[r+3].mul(h);return u=u.add(c),u=u.add(d),u=u.add(g),u}static bezierPathValue(e,t){e>1&&(e=1),e<0&&(e=0);let r=t.length,a=this.tmp_points;a.length=0;for(let s=1;s<r;++s)for(let o=0;o<r-s;++o){if(s==1){let h=new p;h.x=t[o].x*(1-e)+t[o+1].x*e,h.y=t[o].y*(1-e)+t[o+1].y*e,h.z=t[o].z*(1-e)+t[o+1].z*e,this.tmp_points.push(h);continue}let l=new p;l.x=a[o].x*(1-e)+a[o+1].x*e,l.y=a[o].y*(1-e)+a[o+1].y*e,l.z=a[o].z*(1-e)+a[o+1].z*e,a.push(l)}return a[0]}}n(Bf,"tmp_points",[]);class Cs{constructor(e){n(this,"controlVertices"),this.setControlVertices(e)}setControlVertices(e){e.length==4&&(this.controlVertices=e.concat())}getPoint(e){if(!(e>=0&&e<=1))return p.ZERO;let t=1-e,r=t*t*t,a=3*e*t*t,s=3*e*e*t,o=e*e*e;return this.controlVertices[0].mul(r).add(this.controlVertices[1].mul(a)).add(this.controlVertices[2].mul(s)).add(this.controlVertices[3].mul(o))}getTangent(e){if(!(e>=0&&e<=1))return p.ZERO;let t=this.controlVertices,r=t[0].add(t[1].add(t[0]).mul(e)),a=t[1].add(t[2].add(t[1]).mul(e)),s=t[2].add(t[3].add(t[2]).mul(e)),o=r.add(a.subtract(r).mul(e));return a.add(s.subtract(a).mul(e)).subtract(o)}getClosestParam(e,t=1e-6){return this.getClosestParamRec(e,0,1,t)}getClosestParamRec(e,t,r,a){let s=(t+r)/2;if(r-t<a)return s;let o=(t+s)/2,l=(s+r)/2,h=this.getPoint(o),u=this.getPoint(l),c=h.subtract(e).lengthSquared,d=u.subtract(e).lengthSquared;return c<d?r=s:t=s,this.getClosestParamRec(e,t,r,a)}}var Tf=(i=>(i[i.Open=0]="Open",i[i.Closed=1]="Closed",i))(Tf||{});class pm{constructor(e,t=0){n(this,"type",0),n(this,"numCurveSegments",0),n(this,"numControlVertices",0),n(this,"controlVertices",[]),this.setControlVertices(e,t)}getPathType(){return this.type}isClosed(){return this.type==1}isValid(){return this.numCurveSegments>0}clear(){this.controlVertices.length=0,this.type=0,this.numCurveSegments=0,this.numControlVertices=0}computeApproxLength(){if(!this.isValid())return 0;let e=this.numCurveSegments+1;if(e<2)return 0;let t=0,r=this.controlVertices;for(let a=1;a<e;a++){let s=r[(a-1)*3],o=r[a*3];t+=s.subtract(o).lengthSquared}return t==0?0:t}computeApproxParamPerUnitLength(){let e=this.computeApproxLength();return this.numCurveSegments/e}computeApproxNormParamPerUnitLength(){return 1/this.computeApproxLength()}interpolatePoints(e,t){let r=e.length;r<2&&console.error("point count must great 1"),this.clear(),this.type=t;let a=this.controlVertices;switch(t){case 0:{this.numCurveSegments=r-1,this.numControlVertices=3*r-2,a.length=this.numControlVertices;for(let l=0;l<r;l++)a[l*3]=e[l];let s=e[1].subtract(e[0]).mul(.25);a[1]=e[0].add(s);let o=e[r-2].subtract(e[r-1]).mul(.25);a[this.numControlVertices-2]=e[r-1].add(o);for(let l=1;l<this.numCurveSegments;l++){let h=e[l-1].subtract(e[l]),u=e[l+1].subtract(e[l]),c=h.lengthSquared,d=u.lengthSquared;if(c>0&&d>0){let g=(c+d)/8,m=u.div(d).subtract(h.div(c));m.normalize(),m=m.mul(g),a[l*3-1]=e[l].subtract(m),a[l*3+1]=e[l].add(m)}else a[l*3-1]=e[l],a[l*3+1]=e[l]}break}case 1:{this.numCurveSegments=r,this.numControlVertices=3*r+1,a.length=this.numControlVertices;for(let s=0;s<r;s++)a[s*3]=e[s];a[this.numControlVertices-1]=e[0];for(let s=1;s<=this.numCurveSegments;s++){let o=s-1,l=(s+1)%this.numCurveSegments,h=s%this.numCurveSegments,u=e[o].subtract(e[h]),c=e[l].subtract(e[h]),d=u.lengthSquared,g=c.lengthSquared,m=3*s-1,A=(3*s+1)%(this.numControlVertices-1);if(d>0&&g>0){let v=(d+g)/8,y=c.div(g).subtract(u.div(d));y.normalize(),y=y.mul(v),a[m]=e[h].subtract(y),a[A]=e[h].add(y)}else a[m]=e[h],a[A]=e[h]}break}}}setControlVertices(e,t){let r=e.length;r<=0||t==0&&r<4||t==1&&r<7||(r-1)%3==0&&(this.clear(),this.type=t,this.numControlVertices=r,this.numCurveSegments=(r-1)/3,this.controlVertices=e)}getPoint(e){if(this.type==1){for(;e<0;)e+=this.numCurveSegments;for(;e>this.numCurveSegments;)e-=this.numCurveSegments}else e=et.clampf(e,0,this.numCurveSegments);if(!(e>=0)&&e<=this.numCurveSegments)return;let t=Math.floor(e);t>=this.numCurveSegments&&(t=this.numCurveSegments-1);let r=[],a=this.controlVertices;return r[0]=a[3*t+0],r[1]=a[3*t+1],r[2]=a[3*t+2],r[3]=a[3*t+3],new Cs(r).getPoint(e-t)}getPointNorm(e){return this.getPoint(e*this.numCurveSegments)}getTangent(e){if(this.type==1){for(;e<0;)e+=this.numCurveSegments;for(;e>this.numCurveSegments;)e-=this.numCurveSegments}else e=et.clampf(e,0,this.numCurveSegments);if(!(e>=0)&&e<=this.numCurveSegments)return;let t=Math.floor(e);t>=this.numCurveSegments&&(t=this.numCurveSegments-1);let r=this.controlVertices,a=[];return a[0]=r[3*t+0],a[1]=r[3*t+1],a[2]=r[3*t+2],a[3]=r[3*t+3],new Cs(a).getTangent(e-t)}getTangentNorm(e){return this.getTangent(e*this.numCurveSegments)}computeClosestParam(e,t){let r=Number.MAX_SAFE_INTEGER,a=0,s=[],o=new Cs(s);for(let l=0;l<this.controlVertices.length-1;l+=3){for(let d=0;d<4;d++)s[d]=this.controlVertices[l+d];o.setControlVertices(s);let h=o.getClosestParam(e,t),c=o.getPoint(h).subtract(e).lengthSquared;c<r&&(r=c,a=l/3+h)}return a}computeClosestNormParam(e,t){return this.computeClosestParam(e,t*this.numCurveSegments)}}var Df=(i=>(i[i.kParticleSystemClampVelocityCurveId=322376503]="kParticleSystemClampVelocityCurveId",i[i.kParticleSystemForceCurveId=306581307]="kParticleSystemForceCurveId",i[i.kParticleSystemRotationCurveId=1793934638]="kParticleSystemRotationCurveId",i[i.kParticleSystemRotationBySpeedCurveId=3737431713]="kParticleSystemRotationBySpeedCurveId",i[i.kParticleSystemStartSpeedCurveId=2527743459]="kParticleSystemStartSpeedCurveId",i[i.kParticleSystemSizeCurveId=2368504881]="kParticleSystemSizeCurveId",i[i.kParticleSystemSizeBySpeedCurveId=4085612399]="kParticleSystemSizeBySpeedCurveId",i[i.kParticleSystemVelocityCurveId=3774601268]="kParticleSystemVelocityCurveId",i[i.kParticleSystemUVCurveId=326370691]="kParticleSystemUVCurveId",i[i.kParticleSystemColorGradientId=1494990940]="kParticleSystemColorGradientId",i[i.kParticleSystemColorByVelocityGradientId=1089181156]="kParticleSystemColorByVelocityGradientId",i[i.kParticleSystemMeshSelectionId=3159510623]="kParticleSystemMeshSelectionId",i[i.kParticleSystemUVRowSelectionId=2941263940]="kParticleSystemUVRowSelectionId",i))(Df||{});const mm=3.141592653589793;class Am{}function Mf(i,e,t){let r=.3333333333333333,a=.5,s=i*r,o=s*s,h=o*s-s*e*a+t*a,u=-o+e*r,c=u*u*u,d=c+h*h;if(d>=0){let A=Math.sqrt(d)-h;return A=A>0?Math.pow(A,r):-Math.pow(-A,r),-s-u/A+A}let g=Math.sqrt(-c),m=Math.acos(-h/g);return g=Math.pow(g,r),g=g-u/g,m=-s+g*Math.cos(m*r),m}function bs(i,e,t,r){let a=1e-5;if(Math.abs(i)<a)return Math.abs(e)>a?(r.r0=-t/e,1):0;let s=e*e-4*i*t;if(s<0)return 0;let o=.5/i,l=Math.sqrt(s);return r.r0=(l-e)*o,r.r1=(-l-e)*o,2}function Pf(i,e,t,r,a){let s=0;if(Math.abs(e)>=1e-4){let o=t/e,l=r/e,h=a/e;i[0]=Mf(o,l,h),s++;let u=e,c=t+e*i[0],d=r+t*i[0]+e*i[0]*i[0];s+=bs(u,c,d,{r0:i[1],r1:i[2]})}else s+=bs(t,r,a,{r0:i[1],r1:i[2]});return s}class jt{constructor(){n(this,"coeff",[])}static EvalSegment(e,t){return e*(e*(e*t[0]+t[1])+t[2])+t[3]}}const br=class{constructor(){n(this,"segments",[]),n(this,"integrationCache",[]),n(this,"doubleIntegrationCache",[]),n(this,"times",[]),n(this,"segmentCount"),this.segments[br.kMaxNumSegments]=new jt,this.integrationCache[br.kMaxNumSegments]=0,this.doubleIntegrationCache[br.kMaxNumSegments]=0,this.times[br.kMaxNumSegments]=0}calculateMinMax(i,e){i.x=Math.min(i.x,e),i.y=Math.max(i.y,e)}findMinMaxDoubleIntegrated(){let i=$.ZERO.clone(),e=20,t=1/e,r=t;for(let a=0;a<e;a++)this.calculateMinMax(i,this.evaluateDoubleIntegrated(r)),r+=t;return i}findMinMaxIntegrated(){let i=$.ZERO.clone(),e=[],t=[];for(let r=0;r<this.segmentCount;r++){let a=4*this.segments[r].coeff[0],s=3*this.segments[r].coeff[1],o=2*this.segments[r].coeff[2],l=1*this.segments[r].coeff[3],h=[],u=Pf(h,a,s,o,l);for(let c=0;c<u;c++){let d=h[c]+e[r];d>=e[r]&&d<t[r]&&this.calculateMinMax(i,this.evaluateIntegrated(d))}this.calculateMinMax(i,this.evaluateIntegrated(t[r])),this.times[r]}return i}generateIntegrationCache(i){i.integrationCache[0]=0;let e=i.times[0],t=0;for(let r=1;r<i.segmentCount;r++){let a=i.segments[r-1].coeff;io(a);let s=e-t;i.integrationCache[r]=i.integrationCache[r-1]+jt.EvalSegment(s,a)*s,t=e,e=i.times[r]}}generateDoubleIntegrationCache(i){let e=0,t=0;for(let r=0;r<i.segmentCount;r++){i.doubleIntegrationCache[r]=e;let a=i.times[r]-t;a=Math.max(a,0),e+=jt.EvalSegment(a,i.segments[r].coeff)*a*a+i.integrationCache[r]*a,t=i.times[r]}}integrate(){this.generateIntegrationCache(this);for(let i=0;i<this.segmentCount;i++)io(this.segments[i].coeff)}doubleIntegrate(){this.generateIntegrationCache(this);for(let i=0;i<this.segmentCount;i++)Rf(this.segments[i].coeff);this.generateDoubleIntegrationCache(this)}static isValidCurve(i){let e=i.getKeyCount(),t=e-1;return i.getKey(0).time!=0&&t++,i.getKey(e-1).time!=1&&t++,t<=br.kMaxNumSegments}evaluateDoubleIntegrated(i){let e=0;for(let t=0;t<this.segmentCount;t++){if(i<=this.times[t]){let r=i-e;return this.doubleIntegrationCache[t]+this.integrationCache[t]*r+jt.EvalSegment(r,this.segments[t].coeff)*r*r}e=this.times[t]}return 1}evaluateIntegrated(i){let e=0;for(let t=0;t<this.segmentCount;t++){if(i<=this.times[t]){let r=i-e;return this.integrationCache[t]+jt.EvalSegment(r,this.segments[t].coeff)*r}e=this.times[t]}return 1}evaluate(i){let e=0;for(let t=0;t<this.segmentCount;t++){if(i<=this.times[t])return jt.EvalSegment(i-e,this.segments[t].coeff);e=this.times[t]}return 1}buildCurve(i,e){let t=i.getKeyCount();this.segmentCount=1;let r=1.01;if(this.segments.length=0,this.integrationCache.length=0,this.doubleIntegrationCache.length=0,this.times.length=0,this.times[0]=r,t!=0)if(t==1)this.segments[0]=new jt,this.segments[0].coeff[3]=i.getKey(0).value*e;else{this.segmentCount=t-1;let a=0;i.getKey(0).time!=0&&(this.segments[0].coeff[3]=i.getKey(0).value,this.times[0]=i.getKey(0).time,a=1);for(let s=0;s<this.segmentCount;s++){let o;i.calculateCacheData(o,s,s+1,0),this.segments[s+a].coeff=o.coeff.concat(),this.times[s+a]=i.getKey(s+1).time}this.segmentCount+=a,i.getKey(t-1).time!=1&&(this.segments[this.segmentCount].coeff[3]=i.getKey(t-1).value,this.segmentCount++),this.times[this.segmentCount-1]=r;for(let s=0;s<this.segmentCount;s++)this.segments[s].coeff[0]*=e,this.segments[s].coeff[1]*=e,this.segments[s].coeff[2]*=e,this.segments[s].coeff[3]*=e}return!0}};let ws=br;n(ws,"kMaxNumSegments",8);function Rf(i){i[0]/=20,i[1]/=12,i[2]/=6,i[3]/=2}function io(i){i[0]/=4,i[1]/=3,i[2]/=2,i[3]/=1}var Lf=(i=>(i[i.kEMScalar=0]="kEMScalar",i[i.kEMOptimized=1]="kEMOptimized",i[i.kEMOptimizedMinMax=2]="kEMOptimizedMinMax",i[i.kEMSlow=3]="kEMSlow",i))(Lf||{}),Uf=(i=>(i[i.kMMCScalar=0]="kMMCScalar",i[i.kMMCCurve=1]="kMMCCurve",i[i.kMMCTwoCurves=2]="kMMCTwoCurves",i[i.kMMCTwoConstants=3]="kMMCTwoConstants",i))(Uf||{});class _m{constructor(){n(this,"max"),n(this,"min")}}class vm{constructor(){n(this,"max"),n(this,"min")}integrate(){this.max.integrate(),this.min.integrate()}doubleIntegrate(){this.max.doubleIntegrate(),this.min.doubleIntegrate()}findMinMaxIntegrated(){return null}findMinMaxDoubleIntegrated(){return null}}class Of{constructor(e=1){n(this,"minMaxState"),n(this,"minCurve"),n(this,"maxCurve"),n(this,"_scalar",1),n(this,"_minScalar"),this._scalar=e,this.minMaxState=0,this.minCurve=new cs,this.maxCurve=new cs}setScalar(e){this._scalar=e}getScalar(){return this._scalar}static evaluateSlow(e,t,r){let a=e.maxCurve.getValue(t)*e.getScalar();return e.minMaxState==2?Ii(e.minCurve.getValue(t)*e.getScalar(),a,r):a}static evaluate(e,t,r=1){if(e.minMaxState==0)return e.getScalar();let a=e.maxCurve.getValue(t)*e.getScalar();return e.minMaxState==1?Ii(e.minCurve.getValue(t)*e.getScalar(),a,r):e.minMaxState==3?Ii(e._minScalar,e._scalar,r):e.minMaxState==2?Ii(e.minCurve.getValue(t)*e.getScalar(),a,1*Math.random()):this.evaluateSlow(e,t,1)}unSerialized(e){this.minMaxState=e.minMaxState,this._scalar=e.scalar,this._minScalar=e.minScalar,this.maxCurve.unSerialized(e.maxCurve),this.minCurve.unSerialized(e.minCurve)}}class xm{constructor(){n(this,"value",0),n(this,"mode",0),n(this,"spread",0),n(this,"speed",new Of)}unSerialized(e){this.value=e.value,this.mode=e.mode,this.spread=e.spread,this.speed.unSerialized(e.speed)}}function ym(i,e){let t=ws.isValidCurve(i.max);return e!=2&&e!=3?t:t&&ws.isValidCurve(i.min)}function Cm(i,e,t,r){i.max.buildCurve(e.max,t),r!=2&&r!=3?i.min.buildCurve(e.max,t):i.min.buildCurve(e.min,t)}function bm(i,e){let t=e.getKeyCount();if(t!=0)if(t==1)Aa(i,e.getKey(0).value);else{let r=t-1;Aa(i,e.getKey(0).value);for(let a=0;a<r;a++){let s=new kn;e.calculateCacheData(s,a,a+1,0);let o=3*s.coeff[0],l=2*s.coeff[1],h=1*s.coeff[2],u=e.getKey(a).time,c=e.getKey(a+1).time,d=[],g=bs(o,l,h,{r0:d[0],r1:d[1]});for(let m=0;m<g;m++)d[m]>=0&&d[m]+u<c&&Aa(i,jt.EvalSegment(d[m],s.coeff));Aa(i,jt.EvalSegment(c-u,s.coeff))}}}function Aa(i,e){i.x=Math.min(i.x,e),i.y=Math.max(i.y,e)}class ro{constructor(e,t){n(this,"point",new p),n(this,"normal",p.UP),n(this,"_tmpVecA",new p),this.point=e,this.normal=t}clone(){return new ro(this.point.clone(),this.normal.clone())}intersectsLine(e,t,r){var a=-this.normal.dotProduct(this.point),s=this.normal.dotProduct(e)+a,o=this.normal.dotProduct(t)+a,l=s/(s-o),h=l>=0&&l<=1;return h&&r&&r.lerp(e,t,l),h}intersectsRay(e,t){t||(t=this._tmpVecA),t.copy(this.point).subtract(e.origin,t);var r=this.normal.dotProduct(t)/this.normal.dotProduct(e.direction),a=r>=0;return a&&t.copyFrom(e.direction).multiplyScalar(r).add(e.origin,t),a}}function wm(i,e){return Math.random()*e+Math.random()*i+(e-i)*Math.random()}function Sm(i,e,t){let r=t*Math.random();return Math.random()*e*r+Math.random()*i*r+(e-i)*Math.random()*r}function Nf(i,e,t){let r=0,a=0;for(;r===0;)r=Math.random();for(;a===0;)a=Math.random();let s=Math.sqrt(-2*Math.log(r))*Math.cos(2*Math.PI*a);return s=s/10+.5,(s>1||s<0)&&(s=Nf(i,e,t)),s=Math.pow(s,t),s*=e-i,s+=i,s}function zt(i){return i>0?Math.floor(i):Math.floor(i)-1}let Z=[151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180,151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];function ao(i,e){let t=i&15,r=1+(t&7);return t&8&&(r=-r),r*e}function Ss(i,e,t){let r=i&7,a=r<4?e:t,s=r<4?t:e;return(r&1?-a:a)+(r&2?-2*s:2*s)}function _a(i,e,t,r){let a=i&15,s=a<8?e:t,o=a<4?t:a==12||a==14?e:r;return(a&1?-s:s)+(a&2?-o:o)}function wr(i,e,t,r,a){let s=i&31,o=s<24?e:t,l=s<16?t:r,h=s<8?r:a;return(s&1?-o:o)+(s&2?-l:l)+(s&4?-h:h)}let At=[[0,1,2,3],[0,1,3,2],[0,0,0,0],[0,2,3,1],[0,0,0,0],[0,0,0,0],[0,0,0,0],[1,2,3,0],[0,2,1,3],[0,0,0,0],[0,3,1,2],[0,3,2,1],[0,0,0,0],[0,0,0,0],[0,0,0,0],[1,3,2,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[1,2,0,3],[0,0,0,0],[1,3,0,2],[0,0,0,0],[0,0,0,0],[0,0,0,0],[2,3,0,1],[2,3,1,0],[1,0,2,3],[1,0,3,2],[0,0,0,0],[0,0,0,0],[0,0,0,0],[2,0,3,1],[0,0,0,0],[2,1,3,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[2,0,1,3],[0,0,0,0],[0,0,0,0],[0,0,0,0],[3,0,1,2],[3,0,2,1],[0,0,0,0],[3,1,2,0],[2,1,0,3],[0,0,0,0],[0,0,0,0],[0,0,0,0],[3,1,0,2],[0,0,0,0],[3,2,0,1],[3,2,1,0]];function Im(i){let e=zt(i),t=e+1,r=i-e,a=r-1,s,o,l=1-r*r;l*=l,s=l*l*ao(Z[e&255],r);let h=1-a*a;return h*=h,o=h*h*ao(Z[t&255],a),.25*(s+o)}function Em(i,e){const t=.366025403,r=.211324865;let a,s,o,l=(i+e)*t,h=i+l,u=e+l,c=zt(h),d=zt(u),g=(c+d)*r,m=c-g,A=d-g,v=i-m,y=e-A,C,S;v>y?(C=1,S=0):(C=0,S=1);let T=v-C+r,D=y-S+r,M=v-1+2*r,P=y-1+2*r,R=c&255,U=d&255,E=.5-v*v-y*y;E<0?a=0:(E*=E,a=E*E*Ss(Z[R+Z[U]],v,y));let F=.5-T*T-D*D;F<0?s=0:(F*=F,s=F*F*Ss(Z[R+C+Z[U+S]],T,D));let V=.5-M*M-P*P;return V<0?o=0:(V*=V,o=V*V*Ss(Z[R+1+Z[U+1]],M,P)),40*(a+s+o)}function Bm(i,e,t){const r=.333333333,a=.166666667;let s,o,l,h,u=(i+e+t)*r,c=i+u,d=e+u,g=t+u,m=zt(c),A=zt(d),v=zt(g),y=(m+A+v)*a,C=m-y,S=A-y,T=v-y,D=i-C,M=e-S,P=t-T,R,U,E,F,V,Y;D>=M?M>=P?(R=1,U=0,E=0,F=1,V=1,Y=0):D>=P?(R=1,U=0,E=0,F=1,V=0,Y=1):(R=0,U=0,E=1,F=1,V=0,Y=1):M<P?(R=0,U=0,E=1,F=0,V=1,Y=1):D<P?(R=0,U=1,E=0,F=0,V=1,Y=1):(R=0,U=1,E=0,F=1,V=1,Y=0);let j=D-R+a,oe=M-U+a,pe=P-E+a,we=D-F+2*a,Xe=M-V+2*a,ke=P-Y+2*a,ce=D-1+3*a,me=M-1+3*a,We=P-1+3*a,lt=m&255,ht=A&255,Gt=v&255,St=.6-D*D-M*M-P*P;St<0?s=0:(St*=St,s=St*St*_a(Z[lt+Z[ht+Z[Gt]]],D,M,P));let It=.6-j*j-oe*oe-pe*pe;It<0?o=0:(It*=It,o=It*It*_a(Z[lt+R+Z[ht+U+Z[Gt+E]]],j,oe,pe));let oi=.6-we*we-Xe*Xe-ke*ke;oi<0?l=0:(oi*=oi,l=oi*oi*_a(Z[lt+F+Z[ht+V+Z[Gt+Y]]],we,Xe,ke));let li=.6-ce*ce-me*me-We*We;return li<0?h=0:(li*=li,h=li*li*_a(Z[lt+1+Z[ht+1+Z[Gt+1]]],ce,me,We)),32*(s+o+l+h)}function Tm(i,e,t,r){const a=.309016994,s=.138196601;let o,l,h,u,c,d=(i+e+t+r)*a,g=i+d,m=e+d,A=t+d,v=r+d,y=zt(g),C=zt(m),S=zt(A),T=zt(v),D=(y+C+S+T)*s,M=y-D,P=C-D,R=S-D,U=T-D,E=i-M,F=e-P,V=t-R,Y=r-U,j=E>F?32:0,oe=E>V?16:0,pe=F>V?8:0,we=E>Y?4:0,Xe=F>Y?2:0,ke=V>Y?1:0,ce=j+oe+pe+we+Xe+ke,me,We,lt,ht,Gt,St,It,oi,li,so,no,oo;me=At[ce][0]>=3?1:0,We=At[ce][1]>=3?1:0,lt=At[ce][2]>=3?1:0,ht=At[ce][3]>=3?1:0,Gt=At[ce][0]>=2?1:0,St=At[ce][1]>=2?1:0,It=At[ce][2]>=2?1:0,oi=At[ce][3]>=2?1:0,li=At[ce][0]>=1?1:0,so=At[ce][1]>=1?1:0,no=At[ce][2]>=1?1:0,oo=At[ce][3]>=1?1:0;let lo=E-me+s,ho=F-We+s,uo=V-lt+s,co=Y-ht+s,fo=E-Gt+2*s,go=F-St+2*s,po=V-It+2*s,mo=Y-oi+2*s,Ao=E-li+3*s,_o=F-so+3*s,vo=V-no+3*s,xo=Y-oo+3*s,yo=E-1+4*s,Co=F-1+4*s,bo=V-1+4*s,wo=Y-1+4*s,va=y&255,xa=C&255,ya=S&255,Ca=T&255,ba=.6-E*E-F*F-V*V-Y*Y;ba<0?o=0:(ba*=ba,o=ba*ba*wr(Z[va+Z[xa+Z[ya+Z[Ca]]]],E,F,V,Y));let wa=.6-lo*lo-ho*ho-uo*uo-co*co;wa<0?l=0:(wa*=wa,l=wa*wa*wr(Z[va+me+Z[xa+We+Z[ya+lt+Z[Ca+ht]]]],lo,ho,uo,co));let Sa=.6-fo*fo-go*go-po*po-mo*mo;Sa<0?h=0:(Sa*=Sa,h=Sa*Sa*wr(Z[va+Gt+Z[xa+St+Z[ya+It+Z[Ca+oi]]]],fo,go,po,mo));let Ia=.6-Ao*Ao-_o*_o-vo*vo-xo*xo;Ia<0?u=0:(Ia*=Ia,u=Ia*Ia*wr(Z[va+li+Z[xa+so+Z[ya+no+Z[Ca+oo]]]],Ao,_o,vo,xo));let Ea=.6-yo*yo-Co*Co-bo*bo-wo*wo;return Ea<0?c=0:(Ea*=Ea,c=Ea*Ea*wr(Z[va+1+Z[xa+1+Z[ya+1+Z[Ca+1]]]],yo,Co,bo,wo)),27*(o+l+h+u+c)}const Ff=class extends ${constructor(i=0,e=0){super(i,e),n(this,"u",0),n(this,"v",0),this.u=i,this.v=e}length(){return 0}};let kf=Ff;n(kf,"uv_0",new Ff);class Dm extends it{constructor(e=1,t=1,r=1,a=8,s=8,o=!1,l=0,h=Math.PI*2){super(),n(this,"radiusTop"),n(this,"radiusBottom"),n(this,"height"),n(this,"radialSegments"),n(this,"heightSegments"),n(this,"openEnded"),n(this,"thetaStart"),n(this,"thetaLength"),this.radiusTop=e,this.radiusBottom=t,this.height=r,this.radialSegments=a,this.heightSegments=s,this.openEnded=o,this.thetaStart=l,this.thetaLength=h,this.instanceID=Mt(),this.buildGeometry()}addGroup(e,t,r){this.addSubGeometry({indexStart:e,indexCount:t,vertexStart:e,index:r})}buildGeometry(){const e=this;this.radialSegments=Math.floor(this.radialSegments),this.heightSegments=Math.floor(this.heightSegments);const t=[],r=[],a=[],s=[];let o=0;const l=[],h=this.height/2;let u=0;A(),this.openEnded===!1&&(this.radiusTop>0&&v(!0),this.radiusBottom>0&&v(!1));let c=new Float32Array(t),d=new Float32Array(r),g=new Float32Array(a),m=new Uint16Array(s);this.setAttribute(X.position,c),this.setAttribute(X.normal,d),this.setAttribute(X.uv,g),this.setAttribute(X.TEXCOORD_1,g),this.setIndices(m);function A(){const y=new p,C=new p;let S=0;const T=(e.radiusBottom-e.radiusTop)/e.height;for(let D=0;D<=e.heightSegments;D++){const M=[],P=D/e.heightSegments,R=P*(e.radiusBottom-e.radiusTop)+e.radiusTop;for(let U=0;U<=e.radialSegments;U++){const E=U/e.radialSegments,F=E*e.thetaLength+e.thetaStart,V=Math.sin(F),Y=Math.cos(F);C.x=R*V,C.y=-P*e.height+h,C.z=R*Y,t.push(C.x,C.y,C.z),y.set(V,T,Y).normalize(),r.push(y.x,y.y,y.z),a.push(E,1-P),M.push(o++)}l.push(M)}for(let D=0;D<e.radialSegments;D++)for(let M=0;M<e.heightSegments;M++){const P=l[M][D],R=l[M+1][D],U=l[M+1][D+1],E=l[M][D+1];s.push(P,R,E),s.push(R,U,E),S+=6}e.addGroup(u,S,0),u+=S}function v(y){const C=o,S=new $,T=new p;let D=0;const M=y===!0?e.radiusTop:e.radiusBottom,P=y===!0?1:-1;for(let U=1;U<=e.radialSegments;U++)t.push(0,h*P,0),r.push(0,P,0),a.push(.5,.5),o++;const R=o;for(let U=0;U<=e.radialSegments;U++){const F=U/e.radialSegments*e.thetaLength+e.thetaStart,V=Math.cos(F),Y=Math.sin(F);T.x=M*Y,T.y=h*P,T.z=M*V,t.push(T.x,T.y,T.z),r.push(0,P,0),S.x=V*.5+.5,S.y=Y*.5*P+.5,a.push(S.x,S.y),o++}for(let U=0;U<e.radialSegments;U++){const E=C+U,F=R+U;y===!0?s.push(F,F+1,E):s.push(F+1,F,E),D+=3}e.addGroup(u,D,y===!0?1:2),u+=D}}}class Mm extends it{constructor(e=.4,t=.1,r=32,a=32){super(),n(this,"radius"),n(this,"tube"),n(this,"radialSegments"),n(this,"tubularSegments"),this.radius=e,this.tube=t,this.radialSegments=r,this.tubularSegments=a,this.initVertex()}initVertex(){const e=2*Math.PI,t=this.radius,r=this.tube,a=this.radialSegments,s=this.tubularSegments;this.bounds=new Be(p.ZERO.clone(),new p(t*2,r*2,t*2));var o=(a+1)*(s+1);let l=new Float32Array(o*3),h=new Float32Array(o*3),u=new Float32Array(o*2),c=new Uint16Array(a*s*2*3),d=0,g=0,m=0,A=0;for(let v=0;v<=a;v++)for(let y=0;y<=s;y++){const C=y/s,S=v/a,T=C*e,D=S*Math.PI*2;if(l[d++]=(t+r*Math.cos(D))*Math.sin(T),l[d++]=r*Math.sin(D),l[d++]=(t+r*Math.cos(D))*Math.cos(T),h[g++]=Math.sin(T)*Math.cos(D),h[g++]=Math.sin(D),h[g++]=Math.cos(T)*Math.cos(D),u[m++]=C,u[m++]=S,y<s&&v<a){const M=s+1,P=M*v+y,R=M*(v+1)+y,U=M*(v+1)+y+1,E=M*v+y+1;c[A++]=P,c[A++]=E,c[A++]=R,c[A++]=E,c[A++]=U,c[A++]=R}}this.setIndices(c),this.setAttribute(X.position,l),this.setAttribute(X.normal,h),this.setAttribute(X.uv,u),this.setAttribute(X.TEXCOORD_1,u),this.addSubGeometry({indexStart:0,indexCount:c.length,vertexStart:0,index:0})}}class Pm extends st{constructor(e,t){super(e,t,6),n(this,"width",4),n(this,"height",4),n(this,"depthOrArrayLayers",6),n(this,"visibility",GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE),this.format=G.depth24plus,this.mipmapCount=1,this.init()}internalCreateBindingLayoutDesc(){this.samplerBindingLayout.type="non-filtering",this.textureBindingLayout.sampleType="unfilterable-float",this.textureBindingLayout.viewDimension="cube"}internalCreateTexture(){this.textureDescriptor={format:"depth24plus",size:{width:this.width,height:this.height,depthOrArrayLayers:6},dimension:"2d",usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING},this.gpuTexture=I.device.createTexture(this.textureDescriptor)}internalCreateView(){this.viewDescriptor={dimension:"cube"},this.view=this.gpuTexture.createView(this.viewDescriptor)}internalCreateSampler(){this.gpuSampler=I.device.createSampler({}),this.gpuSampler_comparison=I.device.createSampler({compare:"less",label:"sampler_comparison"})}}class zf extends st{constructor(){super(...arguments),n(this,"uint16Array"),n(this,"floatArray"),n(this,"_dataBuffer")}create(e,t,r=null,a=!0){if(r==null){r=[];for(let s=0,o=e*t*4;s<o;s++)r[s]=0}return this.updateTexture(e,t,r,a),this}updateTexture(e,t,r,a=!0){(e!=this.width||t!=this.height)&&(this._dataBuffer&&this._dataBuffer.destroy(),this._dataBuffer=null,this.gpuTexture&&this.gpuTexture.destroy(),this.gpuTexture=null),this.floatArray=r;let s=I.device;const o=e*4*2;this.format=G.rgba16float,this.mipmapCount=Math.floor(a?Math.log2(e):1),this.createTextureDescriptor(e,t,this.mipmapCount,this.format),(!this.uint16Array||this.uint16Array.length!=r.length)&&(this.uint16Array=new Uint16Array(r.length));let l=this.uint16Array;for(let c=0,d=l.length;c<d;c++)l[c]=ur(r[c]);const h=this._dataBuffer=s.createBuffer({size:l.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC});s.queue.writeBuffer(h,0,l);const u=w.beginCommandEncoder();u.copyBufferToTexture({buffer:h,bytesPerRow:o},{texture:this.getGPUTexture()},{width:e,height:t,depthOrArrayLayers:1}),this.useMipmap||(this.samplerBindingLayout.type="filtering",this.textureBindingLayout.sampleType="float"),w.endCommandEncoder(u),this.gpuSampler=s.createSampler(this),this.gpuTexture=this.getGPUTexture(),this.mipmapCount>1&&Ht.webGPUGenerateMipmap(this)}}class Rm extends st{create(e,t,r,a=!0){let s=I.device;const o=e*4*4;this.format=G.rgba32float;let l=1;this.createTextureDescriptor(e,t,l,this.format);const h=s.createBuffer({size:r.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC});s.queue.writeBuffer(h,0,r);const u=w.beginCommandEncoder();u.copyBufferToTexture({buffer:h,bytesPerRow:o},{texture:this.getGPUTexture()},{width:e,height:t,depthOrArrayLayers:1}),w.endCommandEncoder(u),a&&(this.samplerBindingLayout.type="non-filtering",this.textureBindingLayout.sampleType="unfilterable-float"),this.gpuSampler=s.createSampler({})}fromBuffer(e,t,r){let a=I.device;const s=e*4*4;this.format=G.rgba32float,this.mipmapCount=1,this.createTextureDescriptor(e,t,this.mipmapCount,this.format);const o=w.beginCommandEncoder();return o.copyBufferToTexture({buffer:r,bytesPerRow:s},{texture:this.getGPUTexture()},{width:e,height:t,depthOrArrayLayers:1}),w.endCommandEncoder(o),this.samplerBindingLayout.type="non-filtering",this.textureBindingLayout.sampleType="unfilterable-float",this.gpuSampler=a.createSampler({}),this}}class Lm extends hs{constructor(e){super(),n(this,"_internalTexture"),n(this,"_minSize",32),n(this,"_skyColor"),this._skyColor=e,this._internalTexture=new zf;let t=[];return _.res.fillColor(t,this._minSize,this._minSize,this.color.r,this.color.g,this.color.b,this.color.a),this._internalTexture.create(this._minSize,this._minSize,t,!1),this.createFromTexture(this._minSize,this._internalTexture),this}changeColor(e){return this._skyColor=e,_.res.fillColor(this._internalTexture.floatArray,this._minSize,this._minSize,this.color.r,this.color.g,this.color.b,this.color.a),this._internalTexture.updateTexture(this._minSize,this._minSize,this._internalTexture.floatArray,!1),this._faceData.uploadTexture(0,this._internalTexture),this}get color(){return this._skyColor}set color(e){this.changeColor(e)}}class Um extends st{create(e,t,r,a=!0){let s=I.device;const o=e*4*4;this.format=G.rgba16float,this.mipmapCount=Math.floor(a?Math.log2(e):1),this.createTextureDescriptor(e,t,this.mipmapCount,this.format);const l=s.createBuffer({size:r.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC});s.queue.writeBuffer(l,0,r);const h=w.beginCommandEncoder();h.copyBufferToTexture({buffer:l,bytesPerRow:o},{texture:this.getGPUTexture()},{width:e,height:t,depthOrArrayLayers:1}),w.endCommandEncoder(h),this.minFilter="nearest",this.magFilter="nearest",this.mipmapFilter="nearest",this.samplerBindingLayout.type="non-filtering",this.textureBindingLayout.sampleType="unfilterable-float",this.minFilter="linear",this.magFilter="linear",this.mipmapFilter="nearest",this.samplerBindingLayout.type="filtering",this.textureBindingLayout.sampleType="float",this.gpuSampler=s.createSampler(this),this.mipmapCount>1&&Ht.webGPUGenerateMipmap(this)}}class Om extends f.Object3D{constructor(e,t=.1){super(),n(this,"length",100),n(this,"thickness",.1),this.length=e,this.thickness=t}}class Nm extends DataView{constructor(e,t,r){super(e,t,r),n(this,"position",0)}}class Fm{static merge(e,t,r){}static generateNormal(){}static generateTangent(){}static packUV(){}}class km{static color_temperature_to_rgb(e){e<1e3?e=1e3:e>4e4&&(e=4e4);let t=e/100,r=this.get_red(t),a=this.get_green(t),s=this.get_blue(t);return new z(r/255,a/255,s/255,1)}static get_red(e){if(e<=66)return 255;let t=329.698727446*Math.pow(e-60,-.1332047592);return this.bound(t)}static get_green(e){let t=0;return e<=66?t=99.4708025861*Math.log(e)-161.1195681661:t=288.1221695283*Math.pow(e-60,-.0755148492),this.bound(t)}static get_blue(e){let t=0;return e>=66?255:e<=19?0:(t=138.5177312231*Math.log(e-10)-305.0447927307,this.bound(t))}static bound(e,t=0,r=255){let a=Math.max(e,t);return Math.min(a,r)}}class Is{static initHeap(){this.boxGeo||(this.boxGeo=new ha),this.sphere||(this.sphere=new na(1,35,35)),this.material||(this.material=new xi)}static get CubeMesh(){return this.initHeap(),this.boxGeo}static get SphereMesh(){return this.initHeap(),this.sphere}static GetCube(){this.initHeap();let e=new f.Object3D,t=e.addComponent(ue);return t.geometry=this.boxGeo,t.material=this.material.clone(),t.castShadow=!0,e}static GetSingleCube(e,t,r,a,s,o){this.initHeap();let l=new xi;l.baseColor=new z(a,s,o,1);let h=new f.Object3D,u=h.addComponent(ue);return u.castGI=!0,u.geometry=new ha(e,t,r),u.material=l,h}static GetSingleSphere(e,t,r,a){this.initHeap();let s=new xi;s.baseColor=new z(t,r,a,1);let o=new f.Object3D,l=o.addComponent(ue);return l.castGI=!0,l.geometry=new na(e,20,20),l.material=s,o}static get Sphere(){this.initHeap();let e=new f.Object3D,t=e.addComponent(ue);return t.geometry=this.sphere,t.material=this.material,e}static GetSingleCube2(e,t=10){this.initHeap();let r=new f.Object3D,a=r.addComponent(ue);return a.castShadow=!1,a.geometry=new ha(t,t,t),a.material=e,r}}n(Is,"boxGeo"),n(Is,"sphere"),n(Is,"material");class zm extends Number{}class Gm extends Number{}class Qm extends Number{}class Vm extends bi{constructor(){super(...arguments),n(this,"x",0),n(this,"y",0),n(this,"z",0),n(this,"w",0)}}f.AccelerateDecelerateInterpolator=Vh,f.AccelerateInterpolator=Gh,f.AnimationCurve=cs,f.AnimationMonitor=_r,f.AnimatorEventKeyframe=ap,f.AnticipateInterpolator=Xh,f.AnticipateOvershootInterpolator=qr,f.ArrayHas=Kf,f.ArrayItemIndex=Jf,f.AtlasParser=Rn,f.AtmosphericComponent=tp,f.AtmosphericScatteringSky=Bc,f.AtmosphericScatteringSkySetting=Ec,f.AtmosphericScatteringSky_shader=Nn,f.AttributeAnimCurve=Pc,f.AudioListener=fp,f.AxisObject=Om,f.B3DMLoader=Fi,f.B3DMLoaderBase=Lu,f.B3DMParseUtil=Tn,f.B3DMParser=En,f.BLUR_CsShader=Hg,f.BRDFLUT=zu,f.BRDFLUTGenerate=Gu,f.BRDF_frag=jo,f.BatchTable=Sn,f.Bezier2D=ys,f.Bezier3D=Bf,f.BillboardComponent=oa,f.BillboardType=yi,f.BitmapTexture2D=ei,f.BitmapTexture2DArray=Bl,f.BitmapTextureCube=xn,f.Blend=Dl,f.BlendFactor=Qs,f.BlendMode=ve,f.Bloom_shader=Ci,f.BlurEffectCreatorBlur_cs=wu,f.BlurEffectCreatorSample_cs=bu,f.BlurTexture2DBufferCreator=Su,f.BounceInterpolator=gt,f.BoundUtil=Kt,f.BoundingBox=Be,f.BoundingSphere=_s,f.BoxColliderShape=Dc,f.BoxGeometry=ha,f.BrdfLut_frag=Fo,f.BxDF_frag=qo,f.BxdfDebug_frag=$o,f.BytesStream=Nm,f.CEvent=je,f.CEventDispatcher=hi,f.CEventListener=Sr,f.CResizeEvent=ff,f.CSM=nt,f.Camera3D=Zi,f.CameraControllerBase=gp,f.CameraType=Ie,f.CameraUtil=Oe,f.CapsuleColliderShape=Sp,f.CastPointShadowMaterialPass=bf,f.CastShadowMaterialPass=wf,f.Clearcoat_frag=Ko,f.ClusterBoundsSource_cs=th,f.ClusterConfig=Fe,f.ClusterDebug_frag=Eo,f.ClusterLight=Ac,f.ClusterLightingBuffer=eh,f.ClusterLightingRender=Ch,f.ClusterLighting_cs=ih,f.CollectInfo=Ll,f.ColliderComponent=ip,f.ColliderShape=Ye,f.ColliderShapeType=mr,f.Color=z,f.ColorLitMaterial=Cf,f.ColorLitShader=Un,f.ColorPassFragmentOutput=Bs,f.ColorPassRenderer=$l,f.ColorUtil=Ts,f.Common_frag=Oo,f.Common_vert=No,f.ComponentBase=Ee,f.ComponentCollect=se,f.ComputeGPUBuffer=ir,f.ComputeShader=be,f.CubeCamera=Ph,f.CubeMapFaceEnum=Eu,f.CubeSky_Shader=Ir,f.CubicBezierCurve=Cs,f.CubicBezierPath=pm,f.CubicBezierType=Tf,f.CycleInterpolator=Wh,f.CylinderGeometry=Dm,f.DDGIIrradianceComputePass=Uh,f.DDGIIrradianceGPUBufferReader=pa,f.DDGIIrradianceVolume=Fl,f.DDGIIrradiance_shader=Lh,f.DDGILightingPass=kh,f.DDGILighting_shader=Fh,f.DDGIMultiBouncePass=Nh,f.DDGIProbeRenderer=zh,f.DEGREES_TO_RADIANS=_e,f.DecelerateInterpolator=Qh,f.Depth2DTextureArray=Ih,f.DepthCubeArrayTexture=wh,f.DepthCubeTexture=Pm,f.DepthMaterialPass=Sf,f.DepthOfFieldPost=Gp,f.DepthOfView_cs=qu,f.DirectLight=su,f.EditorInspector=Vt,f.Engine3D=_,f.Entity=bl,f.EntityBatchCollect=Ul,f.EntityCollect=Q,f.EnvMap_frag=ko,f.ErpImage2CubeMap=Ni,f.ErpImage2CubeMapCreateCube_cs=Bu,f.ErpImage2CubeMapRgbe2rgba_cs=Tu,f.ExtrudeGeometry=Dp,f.FASTFLOOR=zt,f.FXAAPost=Ys,f.FXAAShader=Sc,f.FastMathShader=Go,f.FeatureTable=os,f.FileLoader=ot,f.FirstPersonCameraController=pp,f.Float16ArrayTexture=zf,f.Float32ArrayTexture=Rm,f.FlyCameraController=mp,f.FontChar=Yu,f.FontInfo=Vu,f.FontPage=Hu,f.FontParser=Pn,f.ForwardRenderJob=an,f.FragmentVarying=Vo,f.FrameCache=kn,f.Frustum=xl,f.FrustumCSM=yl,f.FrustumCulling_cs=Xg,f.FullQuad_vert_wgsl=el,f.GBufferFrame=yt,f.GBufferPass=If,f.GBuffer_pass=Ln,f.GILighting=Wa,f.GIProbeMaterial=Kn,f.GIProbeMaterialType=qn,f.GIProbeShader=xc,f.GIRenderCompleteEvent=rn,f.GIRenderStartEvent=Ha,f.GLBChunk=du,f.GLBHeader=fu,f.GLBParser=Ja,f.GLSLLexer=gu,f.GLSLLexerToken=$r,f.GLSLPreprocessor=pu,f.GLSLSyntax=vu,f.GLTFBinaryExtension=Nu,f.GLTFParser=Je,f.GLTFSubParser=Ka,f.GLTFSubParserCamera=Kh,f.GLTFSubParserConverter=cu,f.GLTFSubParserMaterial=$h,f.GLTFSubParserMesh=Zh,f.GLTFSubParserSkeleton=pn,f.GLTFSubParserSkin=eu,f.GLTFType=le,f.GLTF_Accessors=yg,f.GLTF_Info=Ya,f.GLTF_Light=Ag,f.GLTF_Mesh=xg,f.GLTF_Node=_g,f.GLTF_Primitives=vg,f.GLTF_Scene=mg,f.GPUAddressMode=Et,f.GPUBlendFactor=Xf,f.GPUBufferBase=qt,f.GPUBufferType=Tt,f.GPUCompareFunction=_t,f.GPUContext=w,f.GPUCullMode=ui,f.GPUFilterMode=Br,f.GPUPrimitiveTopology=Da,f.GPUTextureFormat=G,f.GPUVertexFormat=Tr,f.GPUVertexStepMode=qf,f.GTAOPost=Qp,f.GTAO_cs=Ku,f.GUIAtlasTexture=Wu,f.GUICanvas=ua,f.GUIConfig=ye,f.GUIGeometry=Nc,f.GUIGeometryRebuild=kc,f.GUIMaterial=zc,f.GUIPick=Vc,f.GUIPickHelper=Ft,f.GUIQuad=Yi,f.GUIQuadAttrEnum=Pe,f.GUIRenderer=Gc,f.GUIShader=Hi,f.GUISpace=Nt,f.GUISprite=fr,f.GUITexture=dr,f.GenerayRandomDir=sl,f.GeometryBase=it,f.GeometryIndicesBuffer=ql,f.GeometryUtil=Fm,f.GeometryVertexBuffer=Wl,f.GeometryVertexType=$t,f.GetCountInstanceID=Ds,f.GetRepeat=sd,f.GlassMaterial=to,f.GlassShader=yc,f.GlobalBindGroup=de,f.GlobalBindGroupLayout=Nr,f.GlobalFog=Vp,f.GlobalFog_shader=Ic,f.GlobalIlluminationComponent=bp,f.GlobalUniform=Ta,f.GlobalUniformGroup=wl,f.GodRayPost=Hp,f.GodRay_cs=Ju,f.Graphic3D=af,f.Graphic3DBatchRenderer=Ua,f.Graphic3DFillRenderer=tf,f.Graphic3DFixedRenderPipeline=Rl,f.Graphic3DLineBatchRenderer=rf,f.Graphic3DShader_fs=Pl,f.Graphic3DShader_vs=Ml,f.GraphicConfig=Zt,f.Graphics3DShape=Vs,f.HDRBloomPost=Yp,f.HDRTexture=Cn,f.HDRTextureCube=ns,f.HaltonSeq=La,f.Horizontal=qc,f.HoverCameraController=Ap,f.I3DMLoader=ai,f.I3DMLoaderBase=Fu,f.I3DMParser=Dn,f.IBLEnvMapCreator=cr,f.IBLEnvMapCreator_cs=Pu,f.IESProfiles=Bi,f.IESProfiles_frag=Yo,f.IKDTreeUserData=Lp,f.ImageType=pr,f.IndicesGPUBuffer=jl,f.Inline_vert=Uo,f.InputSystem=Io,f.InstanceDrawComponent=wp,f.InstanceUniform=zo,f.InstancedMesh=ku,f.Interpolator=nn,f.InterpolatorEnum=sn,f.IrradianceDataReaderCompleteEvent=mf,f.IrradianceVolumeData_frag=Lo,f.Irradiance_frag=Wo,f.IsEditorInspector=Gd,f.IsNonSerialize=zd,f.Joint=tu,f.JointPose=gn,f.JumperInterpolator=Yh,f.KDTreeEntity=Op,f.KDTreeNode=Jn,f.KDTreeRange=lf,f.KDTreeSpace=hf,f.KDTreeUUID=vs,f.KHR_draco_mesh_compression=Jr,f.KHR_lights_punctual=Jp,f.KHR_materials_clearcoat=lu,f.KHR_materials_emissive_strength=hu,f.KHR_materials_ior=Zp,f.KHR_materials_sheen=$p,f.KHR_materials_specular=em,f.KHR_materials_transmission=tm,f.KHR_materials_unlit=uu,f.KHR_materials_variants=im,f.KHR_materials_volume=rm,f.KHR_mesh_quantization=am,f.KHR_texture_basisu=sm,f.KHR_texture_transform=nm,f.KelvinUtil=km,f.KeyCode=Ze,f.KeyEvent=Qt,f.Keyframe=Fn,f.LDRTextureCube=hs,f.LUT_glsl=qg,f.LambertMaterial=dm,f.LambertShader=Cc,f.LightBase=ja,f.LightData=Rr,f.LightEntries=kl,f.LightType=ze,f.LightingFunction_frag=Bo,f.Line=xr,f.LineClassification=Hc,f.LinearInterpolator=Hh,f.LitMaterial=xi,f.LitShader=Jo,f.LoaderBase=Mi,f.LoaderEvent=Zn,f.LoaderManager=yf,f.MAX_VALUE=ed,f.MIN_VALUE=td,f.Material=vi,f.MaterialDataUniformGPUBuffer=Cu,f.MaterialUniform=Zg,f.MathShader=Ba,f.MathUtil=et,f.Matrix3=Vi,f.Matrix4=H,f.MatrixBindGroup=Ql,f.MatrixDO=Rp,f.MatrixGPUBuffer=Gl,f.MatrixShader=wc,f.MemoryDO=Mr,f.MemoryInfo=nl,f.MergeRGBACreator=Np,f.MergeRGBA_cs=Zu,f.MeshColliderShape=ef,f.MeshRenderer=ue,f.MinMaxAnimationCurves=_m,f.MinMaxCurve=Of,f.MinMaxCurveState=Uf,f.MinMaxPolyCurves=vm,f.MorePassParser=Cr,f.MorePassShader=gf,f.MorphTargetBlender=sp,f.MorphTargetData=Hl,f.MorphTargetFrame=np,f.MorphTarget_shader=Re,f.MouseCode=df,f.MultiBouncePass_cs=Oh,f.NonSerialize=kd,f.NormalMap_frag=Qo,f.OAnimationEvent=ru,f.OBJParser=vn,f.Object3DEvent=da,f.Object3DUtil=Is,f.ObjectAnimClip=Rc,f.OcclusionSystem=ka,f.Octree=er,f.OctreeEntity=Tl,f.OrbitController=_p,f.Orientation3D=vt,f.OutLineBlendColor_cs=$u,f.OutlineCalcOutline_cs=ec,f.OutlinePass=Kg,f.OutlinePost=Xp,f.OutlinePostData=_f,f.OutlinePostManager=vf,f.OutlinePostSlot=Af,f.Outline_cs=tc,f.OvershootInterpolator=jh,f.PBRLItShader=Zo,f.ParserBase=Xt,f.ParticleSystemCurveEvalMode=Lf,f.ParticleSystemRandomnessIds=Df,f.PassGenerate=kr,f.PassShader=pf,f.PavementShader=Jg,f.PhysicMaterial=aa,f.PhysicMaterialUniform_frag=To,f.PickCompute=sf,f.PickFire=nf,f.PickResult=xf,f.Picker_cs=ic,f.PingPong=Ps,f.PipelinePool=rs,f.Plane=ro,f.PlaneGeometry=Jl,f.PointClassification=Yc,f.PointLight=nu,f.PointLightShadowRenderer=Sh,f.PointMaterial=gm,f.PointShadowCubeCamera=bh,f.PointShadowDebug=bc,f.PointerEvent3D=L,f.Polynomial=jt,f.PolynomialCurve=ws,f.Polynomials=Am,f.PoolNode=Qc,f.PositionAudio=dp,f.PostBase=xt,f.PostProcessingComponent=Cp,f.PostRenderer=Dh,f.PreDepthPassRenderer=Bh,f.Preprocessor=ut,f.Probe=$c,f.ProbeEntries=zl,f.ProbeGBufferFrame=Rh,f.ProfilerUtil=ft,f.PropertyAnimClip=rp,f.PropertyAnimTag=Lc,f.PropertyAnimation=Gn,f.PropertyAnimationEvent=Gi,f.PropertyHelp=Wt,f.QuadGlsl_fs=vc,f.QuadGlsl_vs=_c,f.Quad_depth2dArray_frag_wgsl=Yf,f.Quad_depth2d_frag_wgsl=rl,f.Quad_depthCube_frag_wgsl=al,f.Quad_frag_wgsl=il,f.Quad_vert_wgsl=tl,f.Quaternion=K,f.RADIANS_TO_DEGREES=qi,f.RGBEErrorCode=Mu,f.RGBEHeader=bn,f.RGBEParser=ss,f.RTDescriptor=Ce,f.RTFrame=Ke,f.RTResourceConfig=Ae,f.RTResourceMap=Ne,f.Rand=Pr,f.RandomSeed=nd,f.Ray=ci,f.RayCastMeshDetail=ji,f.Reader=or,f.Rect=Lr,f.Reference=ae,f.RegisterComponent=Qd,f.RenderContext=Zl,f.RenderLayer=Fr,f.RenderLayerUtil=Gs,f.RenderNode=Jt,f.RenderShader=He,f.RenderShaderCollect=Ol,f.RendererBase=di,f.RendererJob=Mh,f.RendererMap=Th,f.RendererMask=Le,f.RendererMaskUtil=Bt,f.RendererPassState=Xl,f.RendererType=re,f.RepeatSE=Rs,f.Res=ju,f.SN_ArrayConstant=ea,f.SN_BinaryOperation=_i,f.SN_Break=kg,f.SN_CodeBlock=Lt,f.SN_Constant=ri,f.SN_Continue=es,f.SN_Declaration=Te,f.SN_Discard=zg,f.SN_DoWhileLoop=Fg,f.SN_Expression=ie,f.SN_ForLoop=Ri,f.SN_Function=Za,f.SN_FunctionArgs=$a,f.SN_FunctionCall=Pi,f.SN_IFBranch=Ui,f.SN_Identifier=ii,f.SN_IndexOperation=Oi,f.SN_Layout=ra,f.SN_ParenExpression=Au,f.SN_Precision=ts,f.SN_Return=ta,f.SN_SelectOperation=ia,f.SN_Struct=ti,f.SN_TernaryOperation=_u,f.SN_UnaryOperation=lr,f.SN_WhileLoop=Li,f.SSAO_cs=Yg,f.SSRPost=Wp,f.SSR_BlendColor_cs=rc,f.SSR_IS_Kernel=jp,f.SSR_IS_cs=ac,f.SSR_RayTrace_cs=sc,f.Scene3D=Ep,f.ShaderAttributeInfo=_n,f.ShaderBase=Ms,f.ShaderConverter=is,f.ShaderConverterResult=xu,f.ShaderLib=N,f.ShaderReflection=ct,f.ShaderStage=Ut,f.ShaderState=yu,f.ShaderUniformInfo=An,f.ShaderUtil=Ot,f.ShadingInput=Ho,f.ShadowLightsCollect=Ge,f.ShadowMapPassRenderer=Eh,f.ShadowMapping_frag=Xo,f.Skeleton=iu,f.SkeletonAnimationClip=Xa,f.SkeletonAnimationClipState=au,f.SkeletonAnimationComponent=Ai,f.SkeletonAnimationCompute=op,f.SkeletonAnimation_shader=Er,f.SkeletonBlendComputeArgs=lp,f.SkeletonPose=Zr,f.SkeletonTransformComputeArgs=hp,f.SkinnedMeshRenderer=qa,f.SkyGBufferPass=Ef,f.SkyGBuffer_pass=dc,f.SkyMaterial=Tc,f.SkyRenderer=us,f.Sky_glsl_fs=jg,f.Sky_glsl_vs=Wg,f.SolidColorSky=Lm,f.SphereColliderShape=Ip,f.SphereGeometry=na,f.SpotLight=ou,f.StatementNode=ge,f.StaticAudio=Uc,f.StorageGPUBuffer=fe,f.StringUtil=rt,f.Struct=bi,f.StructStorageGPUBuffer=Fp,f.SubGeometry=Kl,f.TAACopyTex_cs=nc,f.TAAPost=qp,f.TAASharpTex_cs=oc,f.TAA_cs=lc,f.TextAnchor=Wc,f.TextFieldLayout=Jc,f.TextFieldLine=Kc,f.Texture=st,f.TextureCube=as,f.TextureCubeFaceData=wn,f.TextureCubeStdCreator=hr,f.TextureCubeUtils=yn,f.TextureMipmapCompute=ga,f.TextureMipmapGenerator=Ht,f.ThirdPersonCameraController=xp,f.TileSet=om,f.TileSetChild=hm,f.TileSetChildContent=um,f.TileSetChildContentMetaData=cm,f.TileSetRoot=lm,f.TilesRenderer=eo,f.Time=he,f.TokenType=x,f.TorusGeometry=Mm,f.TouchData=So,f.Transform=Ue,f.TranslatorContext=mn,f.Triangle=ps,f.UIButton=Yn,f.UIButtonTransition=Zc,f.UIComponentBase=Vn,f.UIEvent=xs,f.UIImage=Xi,f.UIImageGroup=Xn,f.UIInteractive=ms,f.UIInteractiveStyle=Me,f.UIPanel=fa,f.UIRenderAble=ca,f.UIShadow=Wn,f.UITextField=jn,f.UITransform=ni,f.UUID=Mt,f.UV=kf,f.Uint16Texture=Um,f.Uint8ArrayTexture=Qu,f.UnLit=On,f.UnLitMaterial=la,f.UnLitMaterialUniform_frag=Do,f.UnLit_frag=Mo,f.UniformGPUBuffer=Dt,f.UniformNode=ee,f.UniformType=$e,f.ValueSpread=xm,f.Vector2=$,f.Vector3=p,f.Vector3Ex=Qi,f.Vector3Struct=Vm,f.Vector4=q,f.VertexAttribute=Pp,f.VertexAttributeName=X,f.VertexAttributeSize=wi,f.VertexAttributeStride=of,f.VertexAttributes=Po,f.VertexBufferLayout=Mp,f.VertexFormat=ll,f.VertexGPUBuffer=Hs,f.Vertical=jc,f.VideoUniform_frag=Ro,f.View3D=Bp,f.ViewPanel=ds,f.ViewQuad=Na,f.VirtualTexture=ne,f.WGSLTranslator=mu,f.WebGPUDescriptorCreator=Qe,f.WorldMatrixUniform=Es,f.WorldPanel=gs,f.WrapMode=Ar,f.WrapTimeMode=Mc,f.ZCullingCompute=zp,f.ZPassShader_cs=gc,f.ZPassShader_fs=pc,f.ZPassShader_vs=mc,f.ZSorterUtil=Sl,f.append=_l,f.arrayToString=Ru,f.blendComponent=Wf,f.buildCurves=Cm,f.calculateCurveRangesValue=bm,f.calculateMinMax=Aa,f.castPointShadowMap_vert=uc,f.clamp=J,f.clampRepeat=Bd,f.compute_skeleton_blend=up,f.compute_skeleton_transform=cp,f.cos=vd,f.crossProduct=Sd,f.cubicPolynomialRoot=Mf,f.cubicPolynomialRootsGeneric=Pf,f.curvesSupportProcedural=ym,f.deg2Rad=md,f.directionShadowCastMap_frag=fc,f.dot=tt,f.doubleIntegrateSegment=Rf,f.f32=zm,f.fastInvSqrt=ml,f.floorfToIntPos=pl,f.fonts=gr,f.generateRandom=Id,f.generateRandom3=Ed,f.getFloatFromInt=fl,f.getGLTypeFromTypedArray=Rg,f.getGLTypeFromTypedArrayType=Pg,f.getGlobalRandomSeed=xd,f.getTypedArray=Lg,f.getTypedArrayTypeFromGLType=dn,f.grad1=ao,f.grad2=Ss,f.grad3=_a,f.grad4=wr,f.i32=Gm,f.integrateSegment=io,f.irradianceDataReader=kp,f.kPI=mm,f.lerp=Ii,f.lerpByte=ad,f.lerpColor=rd,f.lerpVector3=id,f.magnitude=Us,f.makeAloneSprite=Vg,f.makeGUISprite=Xu,f.makeMatrix44=Ra,f.matrixMultiply=ks,f.matrixRotate=Pd,f.matrixRotateY=Md,f.multiplyMatrices4x4REF=Al,f.normal_distribution=Nf,f.normalizeFast=wd,f.normalizeSafe=cl,f.normalizedToByte=bd,f.normalizedToWord=Cd,f.outlinePostData=kt,f.outlinePostManager=Kp,f.perm=Z,f.quadraticPolynomialRootsGeneric=bs,f.rad2Deg=Ad,f.random01=Ki,f.randomBarycentricCoord=pd,f.randomPointBetweenEllipsoid=gd,f.randomPointBetweenSphere=fd,f.randomPointInsideCube=ud,f.randomPointInsideEllipsoid=cd,f.randomPointInsideUnitCircle=dd,f.randomPointInsideUnitSphere=gl,f.randomQuaternion=ld,f.randomQuaternionUniformDistribution=hd,f.randomUnitVector=Pa,f.randomUnitVector2=dl,f.rangedRandomFloat=qe,f.rangedRandomInt=od,f.readMagicBytes=In,f.registerMaterial=fm,f.repeat=Fs,f.rotMatrix=Dd,f.rotateVectorByQuat=$f,f.roundfToIntPos=Os,f.scale=Ls,f.shadowCastMap_frag=cc,f.shadowCastMap_vert=hc,f.simplex=At,f.sin=_d,f.snoise1=Im,f.snoise2=Em,f.snoise3=Bm,f.snoise4=Tm,f.sqrMagnitude=Ns,f.sqrtImpl=ul,f.stencilStateFace=jf,f.swap=yd,f.toHalfFloat=ur,f.u32=Qm,f.uniform_real_distribution=wm,f.uniform_real_distribution2=Sm,f.webGPUContext=I,f.zSorterUtil=Il,Object.defineProperty(f,Symbol.toStringTag,{value:"Module"})});